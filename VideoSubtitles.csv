Video file name,Extracted text,,,,,,,,,,,,,,,,,,,,,,,,,,,,
2-D Array Operation.mp3,"So we were discussing that how the two, how a two dimensional array is stored in the memory. Now we have already said that that is our two dimensional array is stored in a row wise form. So we have to find out the address of a particular element in the memory, right? So if we have a two dimensional array and the row and the column is specified, all right, so say here there are 12345 rows and three columns. Say a particular element here has got the address. Say the name of this array is a. This particular element has got the address. A zero, one two, a two three. A. 2012. A two two. Right. This element, so it is stored, how it is stored, it is stored in this consecutive way. First this one is stored, then this one is stored. Then this one is stored row wise, right? So if in my, each of them have got a memory location. So if the location of this is thousand and if it be an integer array, then this location will be. Location will be, location will be 1000, 6000 and 8010, right? In that way it will go on. So a little thought will tell you that if the starting address. So what will be the address of this? It will be thousand plus. How many columns have to come for each column shift? For each column, what will be the address of this? 1000 and 10,012 thousand and 14,016. Right? Actually this should be in the location thousand and 16 of the memory. So we start with thousand. And then since each of the elements, each of the elements are taking two bytes, so I'll have to go for each shift two bytes and how many such shifts, what is the distance from here to here? Element wise we have got eight such positions, right? And so with that I can find out the address of this x. So if this was x and this was element was k, then what would be my address? K into the offset is so many columns, sorry. Two means three columns per row and three such rows. So it will be six rows. So in general we can say that if x be the starting address of the array in the memory and c be the number of columns and k be the number of bytes allocated, then the address will be x plus I into c plus j. C is the column number plus j, how many columns are there? So if I go back to this, if I go back to this, I can say that how many columns c is each, it has got three columns. So k into three plus, sorry, three into k plus j, right? Three into k means two plus j. J was two. So that will be my result. Thousand plus six plus two, eight. So that will be the location that I'll be finding out. So here, that is the formulation x plus I into c plus j times k. K is number of bytes allocated per element plus. Please look at this. So the rows are. The matrix is actually stored as a one, a zero, two. So this entire thing is a zero three. So, 1234. So there are four columns in one row. Then the second row, a one, a one column zero, a one column one, a one column two, a one column three. Then I proceed in this way. So this is the arrangement of three rows and each row having four columns. And using this formula, which is intuitive, we can find out the exact location of a particular element. So this part is row one. This part is row. Sorry. This part is row zero. This part is row one. This part is row two. You can see that this is row one, column zero, row one, column one, row one, column two, so on and so forth. Now, given. So that is how it is stored and how we can find out what the address is. But how do we read a particular array, elements into a two dimensional array. We have seen that I can read one dimensional array, the elements of a one dimensional array into the array by repeatedly getting the character from the user and storing it in the proper indexes and proper positions. By varying the index right here. Also, we'll be reading one element at a time and we'll store them. So my array is, say the array that I am storing is aij having some rows and columns. And I is the row index and j is the column index. So initially in this for loop, look here, there is a nested for loop here. So first I am keeping the I fixed for I equal to zero. Now I come here inside this, inside this, there is a nesting of for loop. Say I've got four columns. So for j is equal to zero, two, j less than four. What do I do? I scan f and aig. Now, each element here, each element here is identified by the row number and column number. So this one is and a eleven. This one is and a 13. Okay? In that way you do. So now for j is equal to zero. I read the particular value and store it here. Suppose it is five. Next, what is done? I am still inside this loop. I increment j. So j comes here. Note that I is fixed. Still. How long will a, I remain fixed? As long as I am inside this inner loop. And how long shall I be inside this inner loop? Till j reaches the end of the number of columns. So next, I read the other value. So it is two. Next, I read the other value, it is seven. Next, I read another value. Maybe it's zero. Then it comes to four. Comes to the end of the row because all the columns have been filled up. Then I come out of this loop. And again, go inside this. So I is now incremented. I is now incremented to this one. And I again, do the same thing inside this loop. So this loop is filling up a row. And this one is filling up all the rows. Please take a little time to understand this. This loop. I'm once again explaining. This loop is filling up one row. Keeping I fixed. I is fixed. And in a loop. I am filling up the values here. Here. And then I increment this one. So this part for filling up all the rows one by one. Okay. I come here again. And again, fill this up. Then I increment I. And again, fill this up. Again, I increment this. I come here and fill this up. All right. That's how we read the elements of an array. So that is being what is being shown here. The ampere sand is necessary here, just as in the case of an array, it was necessary. It is necessary here as well. The elements can be entered all in one line or in different lines. It really does not matter whether you type five, blank six, blank seven, blank eight, or you type five, enter six center like that. That really does not matter because we already know that every element will be stored in a row wise fashion. How to print the elements of an array again, suppose I have got an array. Suppose I have got an array. Suppose I have got a two dimensional array. And I'll have to print the elements. I cannot just print the array in one shot. I cannot do that. So again, here, I will be fixed, and then I'll print, say, this is a 0123-0123. So, first, a will be printed. Whatever was the value here, I'm printing it here. Then j will be incremented. So the next one that will be printed will be a zero, one. Next, j will be incremented. So it will be a zero, two, a zero, three, so on and so forth. And then I will be incremented again in this way. So it will be. Next printing will be a one. And j will be reinitialized to zero one, a 10, a eleven, and like that, it will be printed. Okay, now the elements are, since it's a backslash n, you can see the elements are printed one per line. Because every time I am printing, I'm giving a backslash n. So, although my array could be 1235-4679 it will be printed as 1235-4679 because at every point I have given a backslash n. Now here, what are we doing here? In this case, the elements will all be printed in the same line because I have not put the backslash n. So it will be printed. All the elements say, sorry, all the elements say 1234-5678 it will be printed in this way. If that was the matrix, then this part will be printed in one line. And then I go up, there is no backslash n. This one will be followed and the entire thing will be printed in one line. Okay. 1234-5678 but if I had done this that first I had this again 1234-5678 and I want it to be printed in this way because here I have not given any backslash n. It will be printed 1234. And as it comes out of this loop, it goes here and comes to the next row. First thing that it does is printf backslash n. So the control will come here and then 5678 will be printed. Therefore, this is a better way of printing a two dimensional array so that it looks like a two dimensional array, okay? So that this will make the elements. Now the question is you just think, how can we print two matrices side by side? Okay? So suppose there is one matrix 1234. There is a character matrix ABCD. How can you print them side by side? What should you do? Can you think of that? I mean, if I say I have got two matrices, one is 1234-5678 another matrix is say ABCD. So they are of different dimensions. So first of all, first of all, how can you represent such a matrix? Say this matrix. How you declared that simple. This will be a character matrix. Character. Let's call this matrix. Let it be m. M is two by two. That means each element of this matrix will be a character, okay? And this is int, let it be n two by four, right? These are the two matrices. Now you can think of how you can print two matrices side by side. If I do look at this by this row, by this, I'll first print 1234. And then what should I do? I should go to here, I should again, for j is equal to j to m call might be j plus. Plus I'll be printing mij. So this will come immediately side by side if necessary. I could have given another a blank in between and I could have printed this as a complete row. Next I go up and print this and this. So I suggest that you try to write this program and run it and see whether you get a nice output or not. Now we come to a very well known problem that we often encounter, matrix addition. I am going to add two matrices. This is a very simple problem, so all of you know how this can be done. So I have got a matrix of the same size, two matrices. So it is 1234-7692 and there is another matrix, 1012, 1513, 714 30. Now I want to add them and have another matrix. First of all, this is a matrix of two rows and four columns, two rows and four columns. So we can say that this a is a two by four matrix and this one b is also a two by four matrix. Now the sum I'll store in another matrix whose dimension will also be two by four has to be. And how is matrix addition done? I'll first take this element. What is this element? I am saying this element, what is this element? This element means a particular I j value zero, zero element I zero j zero from this array. So I take this element one and then take bij of the same I j value one, add them together, one plus ten. I get eleven. I put that eleven in the I j value, remaining same zero zero of the c matrix. So here it is, eleven. Next I am increasing the index I here j remains, sorry, I am incrementing whatever I do. I keep the I's fixed and increment the j. So I is one, j is I is zero, j is one. So with that I take this value two and take this value with the same I and j value. I is zero and j is one. Add them. So that is 14. And I store this value here. In that way I go on for this entire matrix. That is how I do the matrix addition. So let us see how the code looks like for this and let's try to understand the code. This much is okay, include stdio h. Then my main program is continuing. What is being done here? I am trying to add two. I'm writing the program for adding two matrices of size 100 by 100. Let's look at this 100 by 100. A matrix is of size 100 rows and 100 columns, b of 100 rows and 100 columns, and c of 100 rows and 100 columns. And I have got other integer values. Pqr, pqmn. I'm reading the matrices. I'm reading, sorry, I'm reading m and n. All right, two values. Now what is m and n? M and n, although I have here recall the difference between I mentioned about the size and the dimension. Dimension is the maximum size. The maximum size that it can have 101 hundred are the maximum sizes of the a matrix and b matrix. But actually I may not need so many locations. So what I can do, I've got a has got so much size, but actually I'm filling up only this much. So this is my m. I'm sorry, this is my m. And this is my n. Okay, so my actual matrix is small. Dimension is the largest size that I can accommodate. All right? So I read that actual value m and n, and then for p is an index. P equals zero less than m, p plus plus q. So I am reading the matrix a. And here you see, I am not using the conventional ij indices. I am saying p is keeping account of my row and q is keeping account of my column. So for p zero to m and q zero to n, I am filling up the a matrix. Then I come here, fill up this matrix out of this outer loop, this inner loop. With this inner loop, what am I doing? I'm filling our particular row and the outer loop, I'm going to the next column repeatedly. I'm saying that. So in this way, I read matrix A here. Here I read matrix B. Then I am doing the addition here again. The dimensions of the two matrices will be the same when I add, and the result matrix will also be the same according to matrix algebra, that is, I am adding two matrices. They will result in the same dimension matrix. So again, for p equal to zero to m and q equal to zero to m, I take Cpq. So I have taken two matrices, and now I'm generating c matrix where this value, this particular element, is being computed by the corresponding element from a and the corresponding element from b being added. I am filling it up and this is going on in a loop. All right. And so I fill this entire thing up. What is the last for loop? This last for loop is nothing but printing the same array, printing the array in the proper way. Now, here you please note that it is backslash n. So it will come nicely. After one row, we'll go to the new line and we'll print it this way. So this is a matrix addition, which is a very useful, very common and simple application of our knowledge of two dimensional array to start with. Okay, we'll see other applications of this too in near future. Now, the other thing that we'll be discussing in the consequent lectures are next. So we now have got an idea of one dimensional array. And we have got an idea of two dimensional array. We have also seen strings and character arrays. Next, we'll move to functions in the next lecture. We have already mentioned about the term functions while moving in the course of other discussion, and we have already seen one particular function, that is main function, that is always that's the main body of any c program, and we have also seen some library functions. But next lecture onwards we look at user defined functions. We have seen some stored functions in the earlier lecture, like string copy string length, finding string length. Similarly, a user can himself or herself write a particular function of his or her own need. We'll have to see why we need to write functions and how a function can be written from the next lecture onwards. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"abstract datatypes, classes and objects.mp3","We have seen how to implement data structures such as stacks, queues and heaps using the built in list type of python. It turns out that one can go beyond the built in types in python and create our own data types. So we will look at this in more detail in this week's lecture. So let's revisit what we mean by a data structure. So a data structure is basically an organization of information whose behavior is defined through an interface. So an interface is nothing but the allowed set of operations. For instance, for a stack, the allowed set of operations are pushed and popped. And of course we can also query whether a stack is empty or not. Likewise for a queue, the only way we can modify a queue is to add something to the tail of the queue using the function add queue and remove the element at the head of the queue using the function remove queue. And for a max heap, for instance, we have the function insert to add an element and delete max, which removes the largest element from the heap. Now, just because we implement a heap as a list, it doesn't mean that the functions that are defined for lists are actually legal for the heap. So if we have a heap h, which is implemented as a python list, though the list will allow an append function, the append function on its own does not insert a value and maintain the heap property. So in general, the call such as h append seven would not be legal. So we want to define new abstract data types in terms of the operations allowed. We don't want to look at the implementation and ask whether it's a list or not, because we don't want the implementation to determine what is allowed. We only want the actual operations that we define as the abstract interface to be permitted. So for instance, if we have a stack s and we push a value b, then the property of a stack guarantees that if we immediately apply pop, the value we get back is the last value push, and therefore we should get back b. In other words, if we execute this sequence, we first do s dot push, and then we do a pop. Then the value that we pushed must be the value that we get back. So this is a way of abstractly defining the property of a stack and how push and pop interact, without actually telling us anything about how the internal values are represented. In the same way, if we have an empty queue and we add to it two elements, u and v, and then we remove the head of the queue, then we expect that we started with an empty q, and then we put in from this end a u, and then we put in a b, then the element that comes out should be the first element, namely u. In other words, assuming that this is empty, then if we add u and add b, and then remove the head, we should get back the first element that we put in, namely u. So the important thing is that we would like to define the behavior of a data type without reference to the implementation. Now this can be very tedious because you have to make sure that you capture all the properties between functions. But this can be done, and this is technically how an abstract data type is defined. Now, in our purposes we will normally define it more informally and we will make reference to the implementation, but we definitely do not want the implementation to determine how these functions work. In other words, we should be able to change one implementation to another one, such that the functions behave the same way and the outside user has no idea which implementation is used. Now, this is often the case when we need to optimize the implementation. We might come up with an inefficient implementation and then optimize it. For instance, we saw that for a priority queue we could actually implement it as a sorted list, and then we could implement insert as an insert operation in a sorted list, which would take order n time, but delete max would just remove the head of the list. Now this is not optimal, because over a sequence of n inserts and deletes, this takes time order n squared. So if we replace the internal implementation from a sorted list to a heap, we get better behavior. But in terms of the actual values that the user sees as a sequence of inserts and delete max, the user doesn't see any difference between the sorted list implementation and the heap implementation. Perhaps there is a perception that one is faster than the other, but the actual correctness of the implementation should not be affected by how you choose to represent the data. So this is the essence of defining an abstract data type. So a good way to think of an abstract data type is as a black box, which allows limited interaction. Imagine something like an ATM machine. So we have the data structure as a black box, and we have certain buttons which are the public interface. These are the functions that we are allowed to use. So in this picture, imagine this is a stack, and the buttons we are allowed to push are pop and push. We are allowed to remove the top elements in the stack. We are allowed to put an element into the stack. Now this requires us to also add and view things from the stack. So we also have a slot for input, which is shown as a kind of thing at the bottom here we have a slot for input, and we have a way to receive information about the state of the stat. So we can imagine that we have some kind of a display. So this is typically how we would like to think of a data structure. We don't want to know what's inside the black box, we just want to specify that if we do a sequence of button pushes and we start supplying input through the input box, what do we expect to see in the display? So other than this, no other manipulation should be allowed. So we are not allowed to exploit what's inside the box in order to quickly get access, say, to the middle of a stack or the middle of a queue. So we don't want such operations. We only want those operations which the externally visible interface or the buttons in this case of the black box picture allow us to use. So in a sense, this is already implemented when we use the built in data types of python. If we announce that the name l is of type list by setting l to the empty list, then immediately Python will allow us to use operations like append and extend on this list. But because it is of list type and not dictionary type, we won't be able to execute an operation such as keys, which is defined for dictionaries and not lists. Likewise, if we define d to be an empty dictionary, then we can use a function such as d values to get the list of values currently stored. But we cannot manipulate d as a list, so we can't say d append, it will give us an error. So Python uses the type information that it has about the value assigned to a name to determine what functions are legal, which is exactly what we are trying to do with these abstract data types. We are trying to say that the data type on its own should allow only certain limited types of access whose behavior is specified without telling us anything about the internal implementation. Remember, for instance, we saw that in the dictionary, even if we add a sequence of values in a particular order, we ask for the values after sometime, they may not return in the same order, because internally there is some optimization in order to make it fast to look up a value for a key. So we have no idea actually how a dictionary is implemented inside. But what we do know is that if we provide a key and that key is a valid key, we will get the value associated to that key. We don't ask how this is done, and we don't know whether from one version of Python to the next, the way in which this is implemented changes. So our question is that instead of using the built in list for stacks, queues and heaps and other data structures, can we also define a data type in which certain operations are committed according to the type that we start with? So this is one of the main things which is associated with a style of programming called object oriented programming. In an object oriented programming, we can provide data type definitions for new data types in which we do precisely what we have been talking about. We describe the public interface, that is, the operations that are allowed on the data, and separately we provide an implementation which should be private. We will discuss later that in Python we don't actually have a full notion of privacy because of the nature of the language, but ideally the implementation should not be visible outside only. The interface should allow the user to interact with the implemented data. And of course the implementation must be such that the functions that are visible to the user behave correctly. So here, for instance, if we had a heap, the public interface would say insert and delete map. The private implementation may be a sorted list, or it may be a heap, and then we would then have to ensure that if we are using a sorted list, we implement delete maps and insert in the correct way. And if we switch from that to a heap, the priority queue operations remain the same. So in the terminology of object oriented programming, there are two important concepts, classes and objects. So a class is a template, very much like a function. Definition is a template. When we say def and define a function, the function doesn't execute. It just gives us a blueprint saying that this is what would happen if this function were called with a particular argument, and that argument will be substituted for the formal parameter in the function, and the code in the function will be executed to the corresponding value. In the same way a class sets up a blueprint or a template for a data type. It tells us two things. It tells us what is the internal implementation, how is data stored, and it gives us the functions that are used to implement the actual public interface. So how you manipulate the internal data in order to affect the operations that the public interface allows. And now once we have this template, we can construct many instances of it. So you have a blueprint for a stack, you can construct many independent stacks. Each independent stack has its own data. That stacks don't interfere with each other. Each of them has a copy of the function that you have defined associated with it. So rather than for the kind of, the main difference from classical programming is in classical programming you would have, for instance, a function like say, push defined, and it will have two parameters, typically a stack and a value. So you have one function, and then you provided the stack that you want to manipulate. On the other hand, now we have several stacks, s one, s two, s three, et cetera, which are created as instances, class. And logically, each of them has its own push function. So there is a push associated with s one, there's a push associated s two, there's a push associated with s three, and so on. And each of them is a copy of the same function derived from this template, but this implicitly attached to a single object. So this is just a slight difference in perspective. So, having a function to which you pass the object that you want to manipulate, you have the object and you tell it what function to apply to itself. So let's look at a kind of example. This won't be a detailed example, it will just give you a flavor of what we are talking about. So here is a skeleton of a definition of a class heap. So now we are introducing the built in list. We want to define our own data type heap. So there are some function definitions. So these are these things, these depth statements, and these correspond to definitions of functions. And what we will see is that inside these definitions we will have values which are stored in each copy of the heap. So just to get a little bit of an idea about how this would work, when we create an object of type heap, we call it like a function. So we say h is equal to heap l. So this implicitly says, give me an instance of the class heap with the initial value l passed to it. Now, this calls this function in it, which is why it's called init. So init is what is called a constructor. A constructor is a function that is called when the object is created and sets it up initially. In this particular case, our constructor is presumed to take an arbitrary list of values, say 1430 215, and heapify it. So somewhere inside the code of init, there will be a heapification operation, which we have not actually shown in this slide. So this is how you create objects. You first define a class. We will look at a concrete example soon. You define a class, and then you call the class sort of like a function, and the name that is attached to this function call, or this class call becomes a new object. Now, as we said, we have functions like insert and delete maps defined for heaps. But it's like we have a separate copy of this function for each individual heap. So in this case we have created a heap h. So we want to tell h, insert in yourself the value 17. So we write that as insert with respect to h. So h dot insert 17, as opposed to insert h 17, which would be the normal functional style of writing. We would normally pass it the heap and the value here. Instead we say, given the heap h, apply to the heap h, the function insert with the argument 17. The next line says apply to the heap h in function insert with the value 28. And then, for instance, we can now ask h to return the maximum value by saying h dot delete max and store the return value in the name key. So what we would like to emphasize is that an abstract data type should be seen as a black box. A black box has a public interface, the buttons that you can push to update and query the data type, to add things, delete things, and find out whether the data type is empty, and so on. And inside we have a private implementation. This actually stores data in some particular way to make the public functions work correctly. The important thing is changing the private implementation should not affect how the functions behave in terms of input and output. They may behave differently in terms of efficiency. You might see that one version is faster than another, or one version is slower than another. But this is not the same as saying that the functions change. So we don't want the values to change. If we have a priority queue and we insert a set of values and then delete max, no matter how the priority queue is actually implemented internally, the delete max should give us the same value at the end. So we saw that Python supports object oriented programming. We shall look at it in more detail in the next couple of lectures in this week's course. But the main concepts associated with this object oriented programming are classes and objects. Classes are templates for data types, and objects are instances of these classes. They are the concrete data types which we use in our programming.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Address and Content of Variables and Types.mp3,"So till now we have looked at it. We have looked at how in c language, how in this c language we can write the identifiers. This is becoming a little too thick. Which identifiers are used for writing the variable names and the constant names. So for example PI or some variable names such as sum, all those things. Now we have seen what are the rules that the language c imposes on writing the names of variables or constants. That is how we can write the identifiers. All right. Also we have seen that there are different data types like int, which stands for integer, and float, which represents floating point numbers or real numbers. And care is used to specify some data which is of type character. We will see some more examples of this in the course of these lectures. Now, we also know that int means integer, and whenever a particular variable a is declared to be an integer, then typically it also varies from machine to machine and compiler to compiler. Two bytes or 16 bits are allocated for storing one integer. All right, each of these boxes are that I am showing here are eight bits wide, so there are two such. So 16 bits for float. We will have two more. Real numbers are stored using 32 bits, whereas characters are typically stored in eight bit. Now this is not so sacrosanct as in some machine which is much more powerful and much more accurate. Having high resolution, we can have 32 bits for storing integers, 64 bits for storing floating point numbers and characters can be eight bits or 16 bits. However, depending on what is the type declaration, the amount of storage, the amount of memory that is allocated to a particular variable varies. Okay, just like int float cad, we also have got some more like short int. All right, long int or unsigned int. These are also different data types. We'll come across these in the course of this lecture. Short int means just if an integer takes two bytes, a short int will take one byte. If an int takes 16 bits, that means two bytes. A long int can be made to consume four such bytes or 32 bits, but still that will be an integer. So in these four bytes, an integer that will be stored. That means the integer accuracy will be much larger. So, depending on the number of bits I allocate to a particular variable, depending on the number of bits. Suppose I allocate n bits, the range of values that I can represent. Values. For example, if there be n bits, then I can go from, I can have two to the power n distinct values stored. For example, if there be eight bits, then the maximum value that I can store is when all these eight bits are ones, and that is your knowledge of binary arithmetic will tell you that this will be two to the power eight, right? That is, 256 will be actually 255. All right, so 255. And if I make everything zero, if each of them are made zeros, all zeros will be zero, right? So I can have the range from zero to 255. That means total zero to 255. That means I can store any of distinct 256 values. Out of 256 values. Distinct values, I can store any one of them. Now, if this eight would have become 16, then my maximum range would be two to the power 16 minus one. All right, that's the maximum value that I can store. Okay? Now, signed and unsigned means sometimes in our representation, we keep one bit for the signed part. In that case, of course, the range decreases. But if we go for unsigned, then we remaining within, say, 16 bits or two bytes, I can have a larger representation. We'll encounter these details as and when we need them. Okay, now let us come to some examples of the data types. You can see integer 00:25 minus 156. All these are examples of integers. Now here I am for the first time showing some characters. Now, the character values are. You see, the character values have got something special. Say I am declaring some variable care as typecat my variable. I name that myvad. Myvar is of type character, and I want to assign to myvad. I want to assign that my variable will hold the character a. Now, when I am assigning a character, then I have to put a single quote around this. For example, I had another variable int. Your VAR. Your VAR is another variable which is of type int. So if I assign into that in your VAR, then I can straightway say an integer value ten. But when I write onto a character, a character constant has to be always encapsulated within two single quotes, right? As here. Now, this single quote within this single quote is a character slash. What about this? This is just single quote. Single quote. That means within that there is a blank. So that means I am say, if I say my where is assigned this, that means my where will be assigned a blank character. Now, you should remember that each of these characters that we type in have got an ASCII value. Each of these characters have got an ASCII value. What is ASCII? ASCII stands for american standard code for information interchange. American standard code for information interchange. Now, according to this table, for every English character, ABCD and capital, ABCD and one, two, two, everything up to nine, all of them have got some particular code, American standard code. And that is accepted in all the computers. So whenever I type an a when I strike the key on the keyboard. When I strike the key a. All right, whenever I strike a, then actually as I press a, what goes inside the computer is an ASCII code of a. All right? Now this ASCII code of a will be stored, therefore, and the code for b, the code for capital a, are all distinct. So whenever I type in a character from the keyboard, a particular ASCII code goes in whenever I assign some value to a variable, for example, as I did right now, Myvad assigned a. This means that Myvad will now have the ASCII code of a. All right? It will have the ascii code of a. Now the third variety that these three are very common, float, for example, 23.54 or minus 003452, 5.0. Or I can also write it in this way, 2.5 e twelve. What does this mean? This means it is 2.5 times ten to the power twelve. What does this mean? This means 1.234 times ten to the power minus five, because it is e minus five. Here it is e twelve. I can use capital e or small e. That really doesn't matter. These are the examples of floating point constants. Okay? So if I have a variable like float x and I assign, I can assign x to be, say, x is one, y is one, z is another one. So I can assign x to be 23.54 semicolon. Or I can assign y to be 2.5 e twelve and z to be 1.234 e minus five. All right, that means now z will have the value 1.234 times ten to the power minus five. That's how we represent the floating point numbers given this. So this part is clear. That's how we write the variables now. And these are the examples of the data types now coming to constants. The constants can be integer constants on floating point constants, just the ones that I was showing right now. But there is another type of constant character constant. So we have already seen example of character constants of single character like we had say a. Sorry, what is happening here? We can have a single character like a or say x. All these within single quote are single characters. And there is another type of character constant, which is a string. For example, I can have a string, which is another type of character constant, which is not a single character, but a string of characters. For example, I want to write down my name, the name of a person. So string type variable named name. And I can assign some value to this string, like say G-O-P-A-L. All right, so this is a number of characters taken together is forming a string of characters. It could also be named to be x, one, two, y, double quote. Now note that in this case I am using double quote, whereas for single characters I was using single quote. Now these are some of the rules of defining character constants or numeric constants in C. Next we move to. You have seen the integer constants. Now a couple of things to be just mentioned, that the maximum and minimum number of values that can be stored as an integer constant is dependent on how many bits are allocated for representation. For example, as I said that for 32 bit representation, I can have two to the power 32 different combinations. All right? So if you compute this, you will find that on one side here is zero. When everything, if I take one bit to designate positive or negative, then I'll be left with 31 bits. So the maximum I can have on the positive side is two to the power 31 minus one. The middle one is zero. All right? And I can go up to this, and on the other side I can go up to two to the power minus two to the power 31. Right? So this is the range. There's a maximum integers and the minimum integer that I can represent. But obviously we need not be so concerned about it because that varies with the number of bits representation in the machine. So for a 64 bit representation, obviously this size will be doubled, will be much larger. I'm sorry, it'll be much larger. So we have also seen floating point numbers just now, so I don't need to repeat this. And why are we going for, why are we going for exponential type of representation? Because that enables us to represent much larger numbers and very small numbers. Also using less number of bits, because I can always write 0123 into ten to the power minus whatever, say here minus twelve, I could have written -15 so it has got two num, two parts. One is the mantisa part, that is this part. Okay, I just put the decimal part, one, two, three, I represent in binary somewhere. And on this side I put some bits for the exponents, so it can be -15 plus 15, whatever. So using less number of bits, I can increase the range and can go for a much larger range of representation. This one, we have already explained that single character constants. Now here, of course, you can see that this operator plus also has got an ascii code. Every character has got an ascii representation. Whatever we have, we find on the keyboard has got an ascii representation. Therefore I can also have capital z dot plus as a character. Now here is something that is a little new to you. We have already encountered one of these as our friend earlier. Here you can see that we are using a special character like backslash. This backslash means that whatever is following a backslash is not the normal nature of that. For example, if I write n, it really does not mean a character n. But backslash n has got a different meaning. All right, for example, suppose I was writing something printf. Say I write. You have seen that example earlier, printf. Suppose I am just writing abc, and then I put Backslash n. That means I'll be printing abc, but after that I'll not print n. But since it's backslash n, it's some other information. It is telling us that go to the new line. So immediately we go to the new line. Similarly, we can see that backslash t. Backslash t. This one is the horizontal tab. So if I have backslash t, my cursor will move from here to some fixed tabular distances. Right? Backslash. Now, you know, single quote or double quote? Single quote. If I just want to print the character, single quote, how do I do it? I'll do it because any character I have to do within this quote. Now, if I put single quote here, then it will be confused. It will take these two and will take a blank character in between because a blank character is represented as blank within two single quotes. But I really want that here, not blank, but I want to print the single quote. So in that case, what should I do for this? I should take a single quote and then backslash, single quote back. I mean, single quote. That means this single quote is different from these two single quotes. So these are the boundaries of the character representation. And what is the character that is the single quote. Similarly, for double quote, you can now very easily reason that I must enclose it within single quote, and then backslash, double quote followed by single quote. Similarly, if I want to print backslash, what should I do? Single quote, then backslash. That means it is something different. Backslash, single quote. Similarly, backslash null is backslash zero. All right, so these are some special character constants that we may encounter during our programming practices. The other new thing that we have learned is string constant. Now, string constants are a sequence of characters. It's the sequence of characters, sequence of characters enclosed within double quotes. Just like we wrote that the characters within the double quote may be letters, numbers, special characters, blank spaces, like that, for example. Nice. Good morning. There's a blank here. Now, what will happen with this. When I put this as a string, don't think that it will be computed and printed as a nine. It is just a string that will be printed. So if I write in this way, within double quote, within double quote, if I write three plus six, then just three plus six, that string will be printed. Okay, the difference between, with character constants is that backslash, I mean the single quote c, this is a character, this is a string, and they are not equivalent because their representations, we'll see, will be internally, they'll be represented in a different way. This one has got an equivalent integer value. That's the ASCII code, whereas this does not have an ASCII code. This is something different where there will be c and something more, which we'll see later. Okay, so string constants, the only thing to remember is string constants are a sequence of characters which can be letters, numbers, expressions, whatever this sort of operator, special characters enclosed within double quotes. All right, that's a string character. Now, we already know what variables are, so we don't need to repeat that. And we have seen the variables, we know that the variables are to be declared and the general syntax is a particular data type. Sorry, it will be a particular data type followed by variable list. Right? So like examples, we have already seen int velocity distance, int abcd, abcd, velocity, distance are all integer variables. Temperature is a float, temp is a floating point variable flag option. These are character type of variables. We have already seen them. Right now we come to something that we evaded. Till now. Pointers have got a big role in C programming, but we will just have a very simple look at the pointers here. Pointer means basically address, all right? So you please forget about the title for the time being. A variable is assigned a specific memory location, okay? That we know. And that memory location is assigned by the compiler. So if we have some variable, say, when we find out, int ABC, then as we have discussed earlier, ABC are three memory locations which are assigned by the compiler. Okay? Now, each of these memory locations actually have got an address, right? So the address can be, say, this is 1350 is an address, just like our houses have an address, just like your rooms have got some numbers. Just as your dryers may have some levels, so similarly it might be this is 1400, this is say, 1450 or 1420. Suppose ABC has got these three addresses. All right? Now, when I read, when I try to read something, we know that I read through scanf. Now, in scanf, what I did is percentage d and a. That means I am trying to read a variable a, but I did not explain to you earlier why I put this and this and means that. And you know, what is this? Percentage d. So, I've got some space, some space to hold an integer. And that space is in the variable a. But when you from the keyboard type in, say, the value 25, where will that value go? The value will go to the address of the variable a. What is the address of the variable a? 1350. So it will go to 1350. 25 will come here. Similarly, when we write, say, scanf, percentage d, percentage d, comma and a and b. Then I am going to read two values and two integers and the address of the first one. Suppose I type in 25 and 27. So for the 25 will go to the address of a that is at 1350. And 27 will go to the address of b, that is 1400. Okay, given this, let's now read this. A variable is assigned a specific memory location. We know that, for example, a variable speed is assigned memory location 1350. And assume that the memory location contains the data value 100. So when we use the name speed in an expression, it refers to the value 100. So for example, when we write distance is speed into time, then it will take this speed from this location, 1350. Okay, every variable has an address and its contents. So we have seen a has got an address. A is a variable a has got an address, 1350. And when I write 25 into that, 25 is the content. Okay, so address and content. We had earlier discussed also, but you see here integer speed, I think you can read it. So speed is this particular location that is in 1350. And when I write speed equals speed assigned hundred, then 100 is written over here. All right. When I assign it, okay, so speed is getting the value 100. But when I say what is and speed, then I am asking the question, what is the address of the variable speed? What is the address of the variable speed? And the answer would be 1350. So this and, sorry, this and operation. This and operation is nothing but asking for the pointer to speed or the address to the variable speed. So this would be the answer. So, and of suppose, suppose here time is given here. If I just say and time, what will that be returned? What is and time and time will be 1351. Something of this sort. All right. So that is another thing that we needed to understand. What is the purpose of this? And so here in c terminology, speed refers to the contents of the memory location. And. And speed refers to the address of the memory location corresponding to the variable speed. So let's come to this example. Printf, percentage f. Percentage f. Percentage f. That means I am going to print three floating point numbers. And what are the variables? Three floating point values. Speed, time, and distance. That means what am I going to print? Look here. I am going to print the contents of the memory location, speed, the content of the memory location, time, the content of the memory location, distance, and when I am reading percentage f, percentage f, and speed and time. That means what? That I am reading, where I am reading in the address of the variable speed. I am reading in the address of the variable time. So this is required to be understood. So basically, when I have, say, speed, I once again repeat. Suppose speed is 25 and I print speed. That means I am printing the content of this location speed. But whenever I am reading into speed, where am I reading the value? I am reading into the address of speed. Okay, that is this location. That is the main difference between these two. All right, let's stop here. In the next lecture, we will straightaway move ahead to write some c expressions because till now, whatever we have learned are the bits and pieces, the tools of c. That is just like in a language, how the words are written, what are some of the simple rules? But then we'll have to learn writing the real sentences in a language so that we will start from the next lecture. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
algorithms and programming_ simple gcd.mp3,"Welcome to the first lecture on the course on programming data structures and algorithms in Python. Let's start with the basic definition of what we mean by an algorithm and what programming is. As most of you probably know, an algorithm is a description of how to systematically perform some tasks. It. So an algorithm consists of a sequence of steps which we can think of as a recipe in order to achieve something. So the word recipe, of course, comes from cooking, where we have a list of ingredients and then a sequence of steps to prepare a dish. So in the same way, an algorithm is a way to prepare something or to achieve a given task. So in the context of our thing, a recipe will what we call a program, and we write down a program using a programming language. So the goal of a programming language is to be able to describe the sequence of steps that are required, and to also describe how we might pursue different sequences of steps if different things happen in between. So the notion of a step is something that can be performed by whatever is executing the algorithm. Now, a program need not be executed by a machine, although that will be the typical context of computer programming, where we expect a computer to execute our steps. A program could also be executed by a person. For instance, supposing the task at hand is to prepare a hall for a function. So this will consist of different steps, such as cleaning the room, preparing the stage, making sure the decorations are up, arranging the chairs, and so on. This will be executed by a team of people. Now, depending on the expertise and the experience of this group of people, you can describe this algorithm at different levels of detail. For instance, an inspection such as arrange the chairs would make sense if the people involved know exactly what is expected. On the other hand, if this is a new group of people who have never done this before, you might need to describe the step in more detail. For instance, you might want to say that arrange the chairs in eight rows and put ten chairs in each row. So the notion of a step is subjective. It depends on what we expect of the person or the machine which is executing the algorithm. And in terms of that capability, we describe the algorithm itself. Our focus in this course is going to be on computer algorithms, and typically these algorithms manipulate information. The most basic kind of algorithm that all of us are familiar with from high school is an algorithm that computes numerical functions. For instance, we could have an algorithm which takes two numbers x and y, and computes x to the power of y. So we have seen any number of such functions in school. For example, to compute square root of x. So what we do in school is we have a complicated way to compute square root of x, or we might have x divided by y, where we do this long division, and so on. So, these are all algorithms which compute values given one or more numbers, they compute the output of this function. But all of us who have used computers know that many other things also fall within the realm of computation. For instance, if we use a spreadsheet to arrange information, and then we want to sort a column. So this involves rearranging the items in the column in some order, either an ascending order or a descending order. So, reorganizing information is also a computational task, and we need to know how to do this algorithmically. We also see computations around us in our day to day life. For instance, when we go to a travel booking site and we try to book a flight from one city to another city, it will offer to arrange the flights in terms of the minimum time or the minimum cost. So, these are optimization problems. This involves also arranging information in a particular way and then computing some quantity that we desire. In this case, we want to know a that we can get from a to b, and b. Among all the different ways we can get from a to b, we want the optimum one. And of course, there are very, very many more things that we see day to day, which are executed by computer programs. We can play games. For instance, we can solve Sudoku, or we can play chess against a program. When we use a word processor to type a document, or even when we use our cell phones to type SMS messages, the computer suggests corrections in our spelling. So we will look at some of these things in this course. But the point is to note that a program, in our context is anything that looks at information and manipulates it to a given requirement. So, it's not only a question of taking a number in and putting a number out. It could involve rearranging things. It could involve computing more complicated things. It could involve organizing the information in a particular way, so these computations become more tractable. And that is what we call a data structure. So, to illustrate this, let us look at the function which most of us have seen and try to understand it algorithmically. The property that I want to compute is the greatest common divisor of two positive integers, M and n. So, as we know, a divisor is a number that divides, so k is a divisor of M. If I can divide m by k and get no remainder. So the greatest common divisor of M and M must be something which is a common divisor so common means it must divide both, and it must be the largest of these. So it's the largest k, such that k divides them and k also divides them. For instance, if we look at the numbers eight and twelve, then we can see that four is a factor of eight, four is a divisor of eight, four is also a divisor of twelve. Another divisor of twelve is six, but six is not a divisor of eight. So if we go through the divisors of eight and twelve, it's easy to check that the largest number that divides both eight and twelve is four. So GCD of eight and twelve is four. What about 18 and 25? 25 is five by five. So it has only one divisor other than one and 25, which is five. And five is not a divisor of 18. But fortunately, one is a divisor of 18. So we can say the GCD of 18 and 25 is one. There is no number bigger than one that divides both 18 and 25. Since one divides every number, as we saw in the case of 18 and 25, there will always be at least one common divisor among the two numbers. So the GCD will always be well defined. It will never be that we cannot find a common divisor. And because all the common divisors will be numbers, we can arrange them from smallest to largest and pick the largest one as the greatest common divisor. So given any pair of positive numbers Mn, we can definitely compute the GCD of these two numbers. So how would one go about computing GCD of MNN? So this is where we come to the algorithmic bit. We want to describe a uniform way of systematically computing GCD of MNn for NEM and nE. So here is a very simple procedure. It's not the most efficient. We will see better ones as we go along. But if we just look at the definition of GCD, it says, look at all the factors of n, look at all the factors of n and find the largest one, which is a factor of both. So the naive way to do this would be to first list out all the factors of the first number, n, then list out all the factors of the second number n. And then among these two lists, report the largest number that appears in both lists. This is almost literally the definition of DCD. Now, question is, does this constitute an algorithm? Well, at a high level of detail, if we think of list out factors as a single step, what we want from an algorithm are two things. One is that the description of what to do must be written down in a finite way, in the sense that I should be able to write down the instructions regardless of the values of m and n, in such a way that you can read it and comprehend it once and for all. So here it's very clear. We have exactly three steps. So we have three steps that constitute the algorithm. So it's certainly presented in a finite way. The other requirement of an algorithm is that we must get the answer after a finite number of steps. Now, this finite number of steps may be different for different values of Mn. You can imagine that if you have a very small number for m, there are not many factors. If you have a very large number for m, you might have many factors. So the process of listing out the factors of Mn may take a long time. However, we want to be guaranteed that this process will always end. And then, having done this, we will always be able to find the largest number that appears in both lists. So, to argue that this process is well defined, all we need to realize is that the factors of m must be between one and m. In other words, although there are infinitely many different possibilities as factors, we don't have to look at any number bigger than M because it cannot go into M evenly. So all we need to do to compute the factors of m is to test every number in the range one to m. And if it divides m without a remainder, then we add it to the list of factors. So we start with an empty list of factors, and we consider, in turn 1234 up to m. And for each such number, we check whether if we divide m by this number, we get a remainder of zero. If we get a remainder of zero, we add it to the list. So, let us look at a concrete example. Let us try to compute the GCD of 14 and 63. So, the first step in our algorithm says to compute the factors of 14. So, by our observation above, the factors of 14 must lie between one and 14. Nothing bigger than 14 can be a factor. So we start by listing out all the possible factors between one and 14 and testing them. So we know, of course, that one will always divide. In this case, two divides 14, because 14 divided two is seven with no remainder. Now, three does not divide, four does not divide, five does not divide, six does not divide, but seven does. Because if you divide 14 by seven, we get a remainder of zero. Then again, eight does not divide, nine does not divide, and so on. And finally, we find that the only other factor left is 14 itself. So for every number m, one and m will be factors. And then there may be factors in between. So having done this, we have now identified the factors of 14 and these factors are precisely one, two, seven and 14. So the next step in computing the DCD of 14 and 63 is to compute the factors of 63. So in the same way we write down all the numbers from one to 63 and we check which ones divide. So again we'll find that one divides. Here two does not divide because 63 is not even, three does divide. Then we'll find a bunch of numbers here which don't divide and then we'll find that seven divides. The seven nine plus 63. Then again, eight does not divide, but nine does. Then again there are a large gap of numbers which don't divide and then 21 does divide because 21 threes are 63. And then finally we find that the last factor that we have is 63. So if we go through this systematically from one to 63, crossing out each number which is not a factor, we end up with a list, one, three, 7921 and 63. Having computed the factors of the two numbers 14 and 63, the next step in our algorithm says that we must find the largest factor that appears in both lists. So how do we do this? How do we construct a list of common factors? Now there are more clever ways to do this, but here is a very simple way. We just go through one of the lists, say the list of factors of 14. And for each item in the list we check if it is a factor of 63. So we start with one and we say, does one appear as a factor of 63? It does. So we add it to the list of common factors. Then we look at two and then we ask, does it appear? It does not appear, so we skip it. Then we look at three and look at seven rather, and we find that seven does appear. So we add seven. Then finally we look at 14 and find that 14 does not appear. So we skip it. So in this way we have systematically gone through one, two, seven and 14 and concluded that of these only one and seven appear in both lists. And now having done this, we have a list of all the common factors. We computed them from smallest to biggest because we went through the factors of 14 in ascending order. So this list will also be in ascending order. So returning the largest factor just returns the rightmost factor in this list, namely seven. So this is the output of our function. So we have computed the factors of 14, computed the factors of 63, systematically checked for every factor of 14, whether it's also a factor of 63, and computed this list of common factors here. And then from this list we have extracted the largest one, and this, in fact, is our DCT. So this is an example of how this algorithm would execute. So, if you were to write it down in a little more detail, then we could say that we need to notice that we need to remember these lists and then come back to them. So we need to compute the factors of 14, keep it aside, we need to write it down somewhere. We need to compute the factors of 63, write it down somewhere, and then compare these two lists. So in other words, we need to assign some names to store these. So let us call FM for factors of m, and sn for factors of n as the names of these lists. So what we do is that we run through the numbers one to m, and for each I in this list, one to m, we check whether I divides n, whether m divided by I has remained a zero, and if so, we add it to the list factors of m or sn. Similarly, for each j from one to n, we check whether j divides n, and if so, we add it to the list sn. Now we have two lists, fm and sn, which are the factors of m and the factors of n. Now we want to compute the list of common factors, which we will call cf. So what we do is for every f that is a factor of the first number. Remember, in our case it was 14 for each f. So we ran through one, two, seven and 14 in our case. So for each f in this list, we add f to the list of common factors if it also appears in the other list. So in the other list, if you remember, it was one, three, 7921 and 63. So we compare f with this list, and if we find it, we add it to cf. And having done this, now we want to return the largest value in that list of common factors. Remember that one will always be a common factor. So the list cf will not be empty. So there will be at least one value. But since we add them in ascending order, since the list fm and fn were constructed from one to m and one to n, the largest value will also be the rightmost value. So this gives us a slightly more detailed algorithm for GCD. It's more or less the same as the previous one, except it spells out in little more detail how to compute the list of factors of s, m, how to compute the list of factors of n, and how to compute the largest common factor between these two lists. So, earlier we had three abstract statements. Now we have expanded it out into six slightly more detailed statements. So this already gives us enough information to write our first Python program. Of course, we will need to learn a little more before we know how to write it, but we can certainly figure out how to read it. So what this Python program is doing is exactly what we described informally in the previous step. So the first thing in the Python program is a line which defines the function. So we are defining a function gcd of m comma n. So m and n are the two arguments, which could be any number, like any function. It's like when you write f of x y. In mathematics it means x and y are arbitrary values, and for every x and y do something depending on the values that you call the function with. So this says that this is a definition. So def for definition of a function gcdn. So now the first step is to compute the list of factors of n. In Python, we write a list using square brackets. So list is written as X-Y-Z and so on. So the empty list is just an open bracket and a square closed bracket. So we start off with an empty list of factors. So this equality means assign a value. So we assign fm the list of factors of m to be the empty list. Now we need to test every value in the range one to n. Now, Python has a built in function called range, but because of, we shall see. Because of the peculiarity of Python, this returns not the range you expect, but one less. So if I say give me the numbers in the range one to n plus one, it gives me numbers in the range one, two, n, one up to the upper limit, but not including the upper limit. So this will say that I takes the values one, two, three up to m. For each of these values of I, we check whether this is true. Now, percentage is the remainder operation. So it checks whether remainder of m divided by I is zero. If the remainder of m divided by is zero, then we will append I to the list fn, we will add it to the right append is the english word which just means add to the end of the list. So we append I to n. So in this step we have computed fm. This is exactly what we wrote informally in the previous example. We just said that for each I from one to m, add I to fm if I divide n. And now we have done it in Python syntax. So we have defined an empty list of factors, and for each number in that range we have checked if it is a divisor and then added it. And now here we do exactly the same thing for n, right? So we start with the empty list of factors of n for every j in this range, if it divides, we append it. And now at this point we have two lists, fm and fn. And now we want to compute the list of common factors. So we use cf to denote the list of common factors. Initially there are no common factors. Now for every factor in the first list, if the factor appears in the second list, then we append it to cs. So the same function append is being used throughout. It says take a list and add a value. Which value we add the value that we are looking at now, provided it satisfies a condition. So earlier we were adding it, provided the divisor was zero, the remainder was zero. Now we are adding it, provided appears in both lists. For every f in the first list, if it appears in the second list, add it. So after this we have computed ff and now we want the rightmost element. So this is just some python syntax which you'll see which says that instead of if you start counting from the left, then the numbers, the positions in the list are numbered. 01234 but Python has the shortcut which says if you want to count from the right, then we count the numbers of minus one, minus two, and so on. So it says return the minus one element of Cf, which in Python jargon means return the rightmost element. So this is the rightmost element. So at this point it's enough to understand that we can actually try and decode this code, this program, even though we may not understand exactly why we are using colons in some places and why we are pushing some things. You notice that there are other syntactic things here. So there are, for example, you have these punctuation marks, which are a bit od, like these colons. Then you have the fact that this line is indented with respect to this line. This line is indented with respect to this line. So these are all features that make Python programs a little easier to read and write than programs in other languages. So we will come to these when we learn Python syntax more formally. But at this point you should be able to convince yourself that this set of Python steps is a very faithful rendering of the informal algorithm that we wrote in the previous slide. So let's note some points that we can already deduce from this particular example. So the first important point is that we need a way to keep track of intermediate values. So we have two names to begin with, the names of our arguments m and n. Then we use these three names to compute these lists of factors and common factors. And we use other names like I, j, and f. In order to run through these, we need I to run from one to n. We need j to run from one to n. Of course we could reuse I, but it's okay, we use f to run through all the factors in Cf. So these are all ways of keeping track of intermediate values. The second point to note is that a value can be a single item. For example, mn are numbers. Similarly, IJNF at least step are numbers. So these could be single values, or they could be collections. So there are lists. So fm is a list, fm is a list. So it's a single name denoting a collection of values, in this case a list, a sequence. It has a first position, an exposition, and a last position. So these are lists of numbers. One can imagine other collections and we will see them as we go along. So collections are important because it would be very difficult to write a program if we had to keep producing a name for every factor of m separately. We need a name collectively for all the factors of m, regardless of how big m is. So these names can denote, can denote single values or collections of values. And a collection of values with a particular structure is precisely what we call a data structure. So these are more generally called data structures. So in this case, the data structure that we have is a list. So what can we do with these names and values? Well, one thing is we can assign a value to a name. So for instance, when we write fn is equal to the empty list, we are explicitly setting the value of fn to be the empty list. This tells two things. It says the value is an empty list. It also tells Python that fn denotes a list. So there are two steps going on here, as we see, and the other part is that when we write something like for each f in the list cf, this is implicitly saying that take every value in cs and assign it one by one to the value to the name f. So though we don't have this equality sign explicitly, implicitly, this is assigning a new value for f as we step through the list here. So the main thing that we do in a Python program is to assign values to names, and having assigned a value, we can then modify the value. For instance, every time we find a new factor of n, we don't want to throw away the old factor. We want to take the existing list fn, and we want to add it. So this function append, for instance, modifies the value of the name fn to a new name, which takes the old name and sticks an I at the end of it. So more generally, we could have a number, and we could want to replace it by two times the number. So we might have something like I is equal to two times I. So star stands for multiplication. This does not mean that I is equal to two times I arithmetically, because obviously, unless I is zero, I cannot be equal to two times itself. What this means is take the current value of I, multiply it by two, and assign it to I. So we will see this as we go along. But assignment can either assign a completely new value, or it could update the value using the old value. So here we are taking the old value of the function of the list fn, and we are appending a value to it and getting a new value of fn. The other part that we need to note is how we execute steps. So, as we said at the beginning of today's lecture, a program is a sequence of steps. But we don't just execute a sequence of steps from beginning to end blindly. Sometimes we have to do the same thing again and again. For instance, we have to check for every possible factor from one to m. If it divides m and then put it in the list. So some steps are repeated. We do something, for example here for each item in a list, and some steps are executed only if the value that we're looking at meets a particular condition. So when we say something like if m percent I is zero, if the remainder of M divided by I zero, then append so the steps append I to fm the factors of M. This happens only if I matches the condition that it's a factor of M. So we have repeated steps, same thing done again and again. And we have conditional steps, something which is done only if a particular condition holds. So we'd stop here. So this example should show you that programs are not very different from what we know intuitively. It's only a question of writing them down correctly and making sure that we keep track of all the intermediate values and steps that we need as we go along, so that we don't lose things. We will look at this example in more detail as we go along, and try to find other ways of writing it and examine other features. But essentially, this is a good way of illustrating programs.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Arithmetic Expressions and Relational Expressions.mp3,"In the last lecture we were introduced to the precedents among the operators, and we had seen that pattern. Ss has got the highest precedence, followed by unary minus. Then multiplication, division, and modulus have got the same priority. Addition and subtraction are having the next priority. And for operators of the same priority, if in an expression there are more than one operators which are of the same priority, then evaluation is done from left to right. Only one thing we didn't mention, and that is, if we want to change the precedence of the evaluation, then we can always do it using parentheses. Okay, using parentheses, because we know parenthesis is the highest priority one and it's overriding scenario. All right, so let us look at some examples for this, which will make the idea clear. Here are some example arithmetic expressions. Here you can see a plus b times c minus d divided by e. Now, according to my precedence rule, this is equivalent to a plus, as if I have if I had done it by hand computation. If I had done by hand computation, how would I have done? There is a chance of confusion. Somebody could have done a plus b and the whole thing multiplied by c, et cetera, even in school level. In order to avoid such confusions, we use parenthesis, and this is equivalent to this scenario that a, this b and c are parenthesized and d divided by e are parenthesized. So first this will be done. Then this will be done. Why b into b times c first? Because it is left and this is right. Right. So first this, then this, then addition and sub. So let's see, how will it break it down again, we'll have first b times c will be done, followed by d times e. Then we have got suppose this result is x and this result is y. Then my expression is a plus x minus y. Now out of these again, these two, they are of the same precedence. So first this will be done. Suppose this is z minus y. That's how the computation will go on here. What is the significance of this? The critical point to note here is this part. Here there is an unary operator. Therefore during computation, what it means, the computer will automatically assume that these parenthes are there. All right, if you had not wanted that, then you better write it in some other way. Put it in some other way so that the confusion is not there. The computer will not allow. The compiler will generate the code in a way that it will be treated as this. A times first minus b will be done. Then this one is the highest precedence, next highest precedence. So this will be done. Then multiplication between these two will be done. Now, I'm sorry, here, normally, say, if I had done this, what would have happened? First of all, I'd be doing minus b, and by capital letter I am writing some constant value. All right, say b is right. Now say five. So first, after computing this, it would be a times minus five, because b was five plus. Suppose D was 100 and e was D was 100 and e was nine. So what is my modulus? One. Right. So then, now at this point I've got d modulus e minus f. Now, at this point, which one has got the higher priority? This and this. Now, since I have put a parenthesis here, therefore, if I put a parenthesis here, then this will be done first. Otherwise this would have been done first because this multiplication has got the same priority as this. And pre resolve left to right. Okay, so similarly here, a minus B plus C plus D. Now here, these are having the same priority left to right. Now, I want it to be done in a particular order. Therefore, I have put the parenthesis in such a way that a minus B should be done first. Then a minus B plus C will be done first. Then D will be added to that. That would have been done anyway. Why? Because since these are of the same priority, that would be done left to right. So first this would be done, then this would have been done. Then this would have been done. Okay, either way. Here, also the same. I can write it in this way, but that is, the precedence is being shown in the form of bracket. But here, this is an example where I have used parentheses to override the precedence. The precedence between this multiplication and this modulus was the same, but just by putting this parenthesis there, I have forced this to be computed first. Similarly here. Now, normally, given this, this would be done first, then this would have been done. Then the addition should have been done. But I have overwritten that by saying that, okay, first you do a plus b, then you multiply c and d multiply by e. That is there anyway, and then you do the addition. But this is actually overriding the normal precedence. So with a little bit of practice, initially you will make some mistakes, but then gradually with practice, that will go away and all of you will be able to write it fine. Now we are coming to a very important concept of this arithmetic expression evaluation. Integer arithmetic. What does it mean? It means that when the operands and in arithmetic expression are integers, then the expression is called an integer expression, and the operation is called the integer arithmetic. Integer arithmetic always yields integer values. It will always yield, I'm sorry, it will always yield integer values. Okay, so it will be clearer when we take some examples. On the other hand, real arithmetic is arithmetic operations involving only real or floating point values. For example, here you can see this expression 1.0 divided by 3.0 multiplied by 3.0. Now all these are operands. Now here is I'd like to introduce a term. When I say a plus b, then this plus I call it as an operator, and these I call as operand, on which the operation is being done. Now in real arithmetic, all the operands are floating point numbers. Right? Now sometimes the floating point values are rounded to the number of significant digits, because it may be 7.59, seven, six, like that. You can go on. It's often rounded to the number of significant digits permissible in a particular machine. We get an approximation of the results. Now one thing that we have to remember is that the modulus operation is not defined over real operands, so I am not allowed to do 3.5 modulus 2.1. That is not allowed. Okay, the modulus operation is allowed only for integer arithmetic. It now we can also have mixed mode arithmetic where some of the operands are integers and some are float okay? Or real. In that case we call it a mixed mode arithmetic expression. If any of the operand is of real type, then only real arithmetic is performed and the result is a real number. This example will make it clear. Now you see here, look at the first 125 divided by ten. Both the operands, this operand and this operand, both these operands are integers. Therefore when I divide them, I get an integer quotient or integer result. Whereas if one of the operands was integer and one was real, if at least if even one is real, then the result will be real. So what is happening here? This is becoming like 25.0 divided by 10.0, so that will become 2.5. All right, now here on the other hand, since both are integers, the result will be integer. So let me just put in one twist on this. Suppose now here 25 divided by ten is actually what if I divide, it is also 2.5, right? 2.5, but since this operator is nothing but an integer division, so it will find out the quotient, and the quotient is an integer. The quotient is two. If I had done 25 modulus ten, what would my result be? The result would be five as the integer. All right, so we could understand what is meant by mixed mode, real mode, and integer mode of arithmetic. We'll see some more things later. Now there are some problems for value assignment. For example, in assignment operation, we actually take the expression value and assign it to a variable. Or we assign a particular variable to another variable. For example, we could have, as we have done, say something. V is u plus f times t. This is an expression value is going first, it will be computed and the value will go to v. So the value is going there, right? On the other hand, I could have done v assigned u. That means the value of u is going to this variable here. Also, the value is going here, the value of an expression here, just a value of a variable. But the most important point is that the data type of the right hand side should be compatible with that of the left hand side. Okay? Now if, for example, I say v assigned u and u is a float and v is an int, then may, I may have problem. What type of problem can I have? Suppose u is 25.7. I assign this to v. So v can only take an integer value. So in most of the cases you will get an error. Why? Because you know that depending on the computers, depending on the different architectures, integers are often given two bytes and floats are given four bytes. So you are trying to pack in a large number, I mean a four byte number, into a two byte space. The space is not there, so the errors can come. In some cases, maybe they will cut it out and represent it as ignored. This part, and you will not understand it, will just assign 25 to v. That's also an error that is creeping in. Now, this error will go unnoticed if the compiler catches it, which is mostly the case. In that case, the compilation error will occur and we'll understand that it is not working. All right. For example, as I said, the four byte floating point number is not allowed to be assigned to a two byte integer variable. So sometimes what we do, there's a new concept called typecasting. Look at this example here. We have defined x to be integer. So x has got two bytes. Suppose I show two bytes for x, and r is a floating point number which has been represented through four bytes. Now, sometimes what we do, we typecast this thing. Two times r will be what? Two times r will be a float because r is real. And so if one of the operators are real, then this part will be a real arithmetic. But then that result, I'm casting back to int. So this operation is called the typecasting operation. That means whatever I have, I've casting that to fit in in a way so that it can fit in as an integer. Okay, here is another example. Say perimeter has been defined as Double. That means it can have twice the floating point space. PI is a float. 3.15. Now, here you see this PI. We had encountered PI earlier, but here, this PI is not the constant which has been defined as defined, but PI is a variable which has been initialized at the time of declaration, and r is an integer. Therefore, when I'm computing, perimeter is twice PI r. So what am I actually doing? I am trying to compute two PI r, right, the circumference of a circle. So twice two is real. Now PI. Now, r perimeter is double. So I want to have perimeter with a larger accuracy. Therefore, I first make r to be double. I typecast this integer to a double type. I typecast this float to a double type. Then I multiply and get the perimeter. Okay, so this is another very powerful operation which we often need for scientific computation. So, typecasting of a floating point expression to an integer variable, as is shown here, and the typecasting to double has been shown here. We have already explained that. Now we have till now looked at arithmetic expressions, how to form arithmetic expressions, and arithmetic expressions are formed using arithmetic operators. Besides arithmetic operators, there is another very important type of operator called the relational operator. A relational operator is used to compare two quantities. Okay, let us see. For example, this symbol, very familiar, denotes is less than this symbol, which is also familiar, shows is greater than this symbol is less than or equal to this. Sometimes in our normal course, we write it in this way, but in a computer we cannot write it in this way. We have to write it less than equal to. All right, similarly greater than equal to, unlike the greater than equal to that we used to write in this way, we have to write here greater than or equal to. Now, this means greater than or equal to that is well known to us. Next, here is another operator. This requires some discussion. Is equal to now, earlier, this is very important to note, and this is a very source of a very common error and common mistake. Typically, when we say in our normal arithmetic, x equals y, we meant that the value of x and the value of y are the same, right? But we have seen that in c language, this actually means the variable x is being assigned the value of y. Right? So how do I compare whether these two variables are equal or not? For that, c provides this technique of using two consecutive equality sign to show x whether x is equal to y. All right, we'll come to this in a moment. There is another operator that is not equal to. Again, let's compare to what we had in school. We used to write something like this in C. We have to write it with this exclamation mark followed by equality. This means it's not equal to. All right, now, a very important thing comes into the play whenever I am using these relational operators. What do I get if I write x less than y? Now, we know that. What are these? X and y? These are two operands. And what is this? This is an operator. So when I carry out some operation, I'll be getting some result. So if I had done x plus y, and suppose x was five and y was seven, then x plus y would have given me what twelve would have resulted into. Twelve, five plus seven. Now, if I do this, x less than y, that means five less than seven. What will this give me? Any relational operator gives me only true or false, one or zero. So when I say x less than y and x is five, y is seven, it is true. Therefore, x less than y, in this case, will return one. Okay? If I write y less than x, if I write y less than x, it will return me false. Because y is seven and x is five, then this would be false. This would return zero. Okay, similarly, for greater than y greater than x will return me. In this case. For this particular value set, y greater than x will give me true one. Or in conceptually, we can say true, but this true cannot be represented as tr ue in a computer. It is written in C, it is represented as one less than equal to. In this case, what would have happened? Y less than equal to x. Is it true or false? Is it true or false? Less than or equal to in this case, is y less than x? No. Is y equal to x? No. Therefore, it will be false. Y greater than or equal to x. What would have happened? Y is not greater than is greater than x not equal to x. Therefore, it immediately becomes true. Y is y equal to x. In this case, no. So it will return false. Y is not equal to x. Is it true or false? It is true, therefore it will be one. Okay, so what we could observe is we can form expressions using relational operators, but these expressions only return the values true and false. Okay, we'll see that these relational operators, if you recall, in our flowchart discussions, we often had some decision boxes shown as diamonds. And in that decision box, we used to say x greater than ten. Or say we used to write something like n equal to three, right? Yes or no? Right. We had taken one path for yes, one for for no. And that can be captured very easily using such relational operators as we'll see, now here are some other examples. I have already given you enough examples. Ten greater than 20, true or false? It is false. Okay, 25 less than 35.5. Yes, it is true. Twelve greater than seven plus five. Now here, if one of the operands is an expression that will first be evaluated, so the arithmetic operators and the expression have higher priority over relational operators. All right? So here what will happen? Seven plus five will be first computed. So that is twelve. Is twelve greater than twelve? No. So it is false. Okay, so when arithmetic expressions are used on either side of a relational operator, the arithmetic expressions will be evaluated first, and the arithmetic expressions will be evaluated in accordance with the precedents that we have already defined. So if there be something like this, a plus b greater than c minus D, that is equivalent to, first I'll compute a plus b, then I'll compute C plus D. And then suppose a plus b is ten and c plus d is 17, then this will lead to false. Okay, first these will be computed, then the relational operator will be computed. So here is a quick look at an application of this. Suppose I want to implement the flowchart, something like this. I have read x and y, and I want to do x greater than y. If so, yes, I'll be say, I'll print x is larger. Otherwise I'll print, y is, sorry. Otherwise I'll print y is larger, right? So that sort of situation, how will that translate into C language? Here you see this part we have not discussed, but it's very intuitive. You can understand. If x is greater than y, I print what is larger, dash is larger. Then what will come here? The value of x. So I'll print, say x is ten and y is 15. This is x and this is y. Then what will be printed here? Ten is not greater than 15. So this part will not be executed, will come to here, because x is not greater than y. So we are taking this no path, and we'll print dash is larger. And in dash what will come, the value of y. That is 15. So what will be printed is 15 is larger. So that is how we can implement this sort of decision box. And when I have got a choice between paths based on the decision, that is being, that condition is being computed using relational operators, which these conditions are telling me which path I'll take. Is the situation true? If so, I'll take this path. Otherwise, I'll take this path. This is known as. This is the purpose of the relational operators. Okay, so next class will start with logical operators. Today we have discussed about arithmetic expressions how arithmetic expressions are formed using arithmetic operators and what are. The very important thing that we have discussed today is in the earlier lecture lecture that what is the precedence? Till now, what we have discussed is that what is the precedence of the operators in an arithmetic expression and what is a relational operator? And we have seen that relational operators have got lower priority than arithmetic expressions. So if on either side of the relational operator there are arithmetic expressions, those will be evaluated first in accordance to the arithmetic operation priority. Okay, next we'll come to another very important concept that is logical operators. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Array Problem.mp3,"We were discussing about arrays and we have seen how we can read an array. We have seen how we can print an array. We have also seen how we access the different elements of an array using for loops and while loops. Now, a couple of things that we cannot do using an array are, as you can see here, we cannot use this equalities, this assignment for assigning one array variable to another. For example, if I have, suppose I have one array e. Suppose I have one array e, which is this array having some elements. Suppose it's an integer array and the elements here are 1567 910 now. And there is another array, b, like this. I want that this data be transferred to one, to this array b, as 1567 910 now, that I cannot do. Using a assigned b, I cannot do this. Or b assigned a. I'm sorry, this is wrong. Using b assigned day, I cannot do that. However, it's true that a is also a variable of type array and b is also a variable of type array, but for other variable types. For example, if a, let's say a is an integer variable and b is another integer variable, okay. And a was 15 and then I could have assigned b assigned a. So b will become 15. But this sort of straightforward assignment cannot be done in the case of an array. What we have to do in order to do such assignments in an array is that we'll have to do it component by component, element by element. For example, I can do this. Let me again take another array a. Now this time I take an array a to be a little smaller of, say, four elements. 1327. And there is another element, b. And I actually intend. My intention is that the data in a goes to the array b. Now, as I said, for an array, I have to do it element by element. So suppose there are four elements in the array and I write a for loop. For I equals zero, I less than equal to three. I plus plus bi is assigned AI. What will happen through this? AI is zero. So AI, that means a zero. This element will be taken and that will be copied to the zero th element of b. Here, both of them are I, so that's zero. So this will become one. Next, I is incremented. So I becomes one. So this element is being pointed at and I transfer this element to the corresponding element. This will also be incremented I. This is also I, so I is one. So this will be copied here. Similarly for this element. Next in this loop, I will be incremented and this will be loaded here. Similarly for the last element. Okay, it will go on. Therefore, ultimately I'll get the same thing. 1327, as was my intention, but I cannot do it directly. But I have to do it in the form of a loop, element by element. I have to transfer them. All right, so we cannot use this assignment directly. What else am I prohibited to do? So a and b are two arrays. I cannot do this. Also, I cannot compare two arrays using this sort of equality checker. Earlier we have seen that I can check whether two elements are equal. Logical operation. I could do it using normal a equals b. I'm sorry, a is b. If a was a variable 15 and b was another variable 15. In that case, a equality checker b will lead to a value one or true. Okay, but if a is an array and b is another array, I cannot do it directly in that way. There also I can write a piece of program in which I can check them element by element. So please note, suppose I have got an array, a, which is 2457, another array, b is 2457. Then these two arrays are equal. However, if I have an array with the same elements, but in a different arrangement, say for example, 2547, this a and c are not the same. Therefore, how can I compare? How can I compare these two arrays? How can I compare them? In order to compare these two arrays a and b, what I need to do is I have to again write a small loop like for. Let me do it clearly. Say I've got an array 2574, another array, 2574, a and b, are they equal? I can compare them. I want to compare them. Compare a and b. Now what can I do? I can do it in this way. For I zero, I less than equal to three, because there are four elements in the array. I plus plus. Suppose I put a flag here, a variable, flag equals one. Suppose I keep a flag variable. I've initialized it to one. All right, now for I equal to one to zero. Or let me make it simpler. I keep it zero. Initially, this is zero. Okay? So now I do. If AI is equal to bi, flag is assigned one and flag is assigned one. Else flag assigned zero. And I come out of this. So what I am trying to do is here, let me avoid this part for the time being. Let's see, we'll develop it gradually. What will happen here if this is done? Let's see. If I run this piece of code, then what will happen for I equal to zero, that means I'll be comparing with this. And if AI is equal to bi, that means I am comparing these two. If these two are equal, then flag is one. That means till now it is one. But this will go on here. So here, one. Now five and five is one. Fine, seven and seven is compared. Again it is written one, four and four. Again it is written one. So it has been done and ultimately I come out with the value of flag. Ultimately I come out. When I come out of this, the value of flag is one. And so I can say if flag is one, then they are equal. But there is some problem with this program. What is that? First of all, every time I was assigning flag to be one, that is one problem. Now suppose another problem is. Suppose this value is six, then what will happen? Let us trace this once again. Two and two will match. So the value of flag will be one. Fine. Five and five will be matched again. I am not bothering about how many times unnecessarily I'm writing into flag. That apart, flag will be one. Now, seven and six, they're not equal to one. So I'll come out of this if statement, but we'll go again in the loop. So what should I do here? If this is not equal, not equal, then I'll have to set flag to zero. If there is a mismatch. So if I do it like this, then what will happen? It is this part. If AI is equal to bi, then flag will be one. And else that means with this, else flag will be zero. So ultimately, now suppose. But here again there is a problem. What will happen? So seven and six are not matching. So this is not true. So flag will be zero and then I'll again go into the loop because the loop has not yet ended. And here I'll find that these two elements are equal, four and four. So it will come at this point and flag will be one. And then I come out of the loop, I'll come out with flag equal to one. But these two arrays are not equal because I can see that the elements are different. So this problem, this program will not solve my purpose. I leave it to you for a while to see how to think how you can solve this problem. You need to apply your mind a little bit to write this piece of program which will simply check whether two arrays are equal or not. If they're equal, that means if the elements are the same at every position, corresponding position, the elements are same. In that case it will come out with a flag value of one. Otherwise it will come out with a flag value of zero. Okay, that is the task. I hope you understand where the problem is. In this problem, in this program. You see here had the mismatch been at the last point, last moment, at the last element, 76, then it would have worked fine. So that's why at the beginning we said, this is not just c programming, it is learning to write programs using logic. Suppose this was seven and this was three. Then the arrays are not equal. Arrays are not equal. Here flag would be one. Here flag would be one. Here flag would be one. Here flag would be zero. And I would come out and my answer would be correct by chance. The answer is correct by chance, because as we have seen, that here, if I have an error, if I have a mismatch here, and suppose here the things are all right, then I would once get the flag is zero. But next time that flag will be made to one. And ultimately when I come out, I'll have the flag value to be one. So the correct answer has eluded me. So you just think of how I can modify this program such that I get the correct result as I intended. Okay, so we cannot use these directly, directly to compare the array variables. I cannot compare what else? So if a assigned b, this sort of thing I cannot do. Also, the other thing that I cannot do is scanf and printf statements. I cannot read the array in one shot. That is not allowed. Scanf and printf. Normally, what could I do? I it normally, if I have a variable, a some variable value, five, I could have simply done printf percentage d, a so this could be printed similarly. I could have done scan f, percentage d, and a, I could have read a value here. But if it is an array, I cannot do it in this way. We already know how we can do that. We know that in order to read an array, what we need to do is read it again in a loop, in a for loop, element by element. So it can be four. I assign zero, I less than equal to whatever, three, I plus plus scan f, percentage d and AI. So this array a will be read element by element, I equal to zero. So first this element will be red, might be five, whatever element is five, then might be seven, et cetera. In that way, I can read them element by element. Similarly, for printing an array, six, four. For printing an array, I can simply, again, do that for, say, j assign zero, j. Let me change a little bit. Is there any trouble here? J less than three, j plus plus printf percentage d, AI here. Of course I don't give the scan f again. Now, is there any problem with this? Here I made I less than equal to three. Here I am making j less than three for the same size of array you can think of. You can look at it. This is also correct. Because here I am starting with one. So one I'm looking at. Now there's a mistake here. I've done a couple of mistakes. What will happen here? J. First of all, this was an unintentional mistake. So this is j. Now how will the array be printed here? If I do it in this way, what will be printed here? First thing that will be printed is J-A-J. What is the value of j? One. So what is a one? That is this element. So seven will be printed. Suppose I have got a backslash n here. So seven will be printed. Then six will be printed. Because I is now two, I is now three. Then four will be printed. But till less than three. So therefore one, two, three, this will not be printed. And also again I am missing this one. So what should I do? What should I do? I can make it j minus one. What will happen in that case? I am printing j is one and I am printing a j minus one. That means I am printing a zero. Five. Next j becomes two. So I'll be printing j minus one. That means two minus one. A one seven, then six. So seven. Then j becomes two. Then j becomes three. So three minus one. Two have printed a two I have printed. Now j will be incremented, will be three. The last one will not be printed. Okay, so here also I have to make it less than equal to three. Was this one. All right, just quickly check. This is a common source of error. I am reading this array. Let me do it again. I'm reading this array. A zero. Then I've read a zero. Then I is incremented. So the four elements. So I'll come up to a three. So the second one. I'm reading the second one. A I is one. So a one. I is next two, a two and then a three. So this is okay. So you have to be a little careful about all this. Okay. So reading and printing. Reading and printing. We cannot directly do. We have also to do it through a loop. So I cannot do like this. How to copy elements of one array to another by copying individual elements. I've already shown that. So that is what we have to say about arrays right now. Now we'll come to some examples. Say, I want to. This is an example of copying an array. There are two arrays, a 25 and B 25. So I'm trying to copy them. So you know that I can do it by copying it in this way. Now some problems. We'll like to try out. Now, one is finding the mean and standard deviation of a set of n numbers. I leave this standard deviation part. We can try to do that. Mean, you know, mean is the arithmetic average. So I'll first try to find write a program where all of you will be able to write find the mean and standard deviation of a set of n numbers. So what are you going to do? Mean means the average, right? So I add the numbers, all the numbers. Suppose my array is a. So each element I designate as AI is an element. So I'll have sigma AI, I, varying from one to n. Whatever this size is divided by n, that is the average. I add all the numbers. So it's simple to write the program. Suppose I have read the array. First of all, I have to read the elements in an array. So, summarizing all what we have learned, what should be my first statement? First statement is declaring the array. So, let me declare an array int a. Suppose the size of the array is five, maximum size possible. And I also have sum. And I have got another variable, avg. All are integers. Again, avg may not be integer. Mean may not be integer. And then I have got another float avg. Right. Now, first, I have to read the array. So read the numbers. I am making a shortcut. I am leaving out the printf statement. Please enter the array. That part I am living out. Then what I am doing here. Here, of course, for I assigned zero, I less than. Suppose there are five elements. I less than five. I plus plus. If it was some other value, then I would have put it n here, and I had to read the n before I read the array. All right? So I do this, and then initially I can make it the sum here to be sum is initialized to zero. All right? Now for I equal to zero, I less than m I plus plus. I read that. I'm just reading the array. So what I do scanf percentage, d amperesand AI. I am reading that. And then here in this for loop, I can repeatedly compute the sum. Sum equals sum plus AI. So I'll get the sum here. Ultimately, at the end of the loop, at the end of the loop, I'll get the sum. So now here I can write average is sum divided by whatever the value was. I've taken five to be a fixed value. So I divide with five, and that is the average. So in that way, I can find out the mean. Okay, this value. The next task is computing the standard deviation so that I leave to you for the time being, we'll take it up later.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Arrays (Contd.).mp3,"So we were looking at arrays and we have seen that all the data items constituting the array shared the same name. So we can call an array to be a, an array a or an array num. If the array be a, then the elements are a one, a two, like that up to an, where n is the size of the array and each individual elements are being accessed by this indices. These are the different indices. Okay, so, so for example here, when we declare, here comes a new thing. Suppose we have an array where the size is ten. So there will be ten elements of the array, ten elements of the array. Just like variables, array as a whole is also a variable. So suppose I name this array to be x. These are x one, x two, x three, x four, x five, like that up to x ten. Now, just like we had to declare the variables like int float here, here. Also we need to declare the array. And the way we declare the array is shown here, int x ten. What does it mean? That means x is an array of, now I'm introducing a term of dimension ten. Earlier I was talking calling it size, and here I am calling it dimension. For the time being, assume that both these, both of these are the same thing, but actually there is a difference. We'll explain that in the course of discussion. So we declare it, first of all, the type of the array. As I had said, that an element, all the elements of an array has to be of the same type. So either all of them will be integers or all of them will be floats. Therefore, this entire array is of a type int, which says that all the elements of this array are integers and extend. So let's quickly have a look at the memory scenario. Okay, say in the memory, this is my memory and this is the memory. And in the memory some locations are kept for the array x. That may start from here and maybe up to this. Now how much space will be given to the array must be known to the compiler, because the compiler, just like the compiler, allocates variables to different memory locations. The compiler will also have to allocate locations, memory locations for the array elements. Now when I said int x ten, that means the compiler will store space equivalent to ten integers, ten integers in the memory, ten consecutive places for ten consecutive one after another, no gap elements, ten consecutive integer places in the memory. Therefore, how many, can you tell me how many bytes are required for that? Integers? And I have assumed that any, every integer is taking two bytes. Okay, integer is taking two bytes. If I assume that, then I'll require 20 bytes here. So there will be 20 locations. Each location consisting of two bytes in this way will go on, right. So you must understand, when I declared this, what is the meaning of this dimension of the array means that I am storing, I am reserving. The compiler reserves the space for ten integers and that has to be done before the array is used, before the array is used. Therefore it must be declared before so that the compiler, while it is compiling the program, can allocate enough space. Okay, and now individual elements are accessed by specifying the index. So here, x, this x is a ten element one dimensional array, linear. Okay, now comes a peculiar thing. If you look at this, we are saying that each of these elements are stored in these locations and which are identifiable and accessible by the indices. Now in C language, each index, the index value starts from zero. So the first element, although while discussing, we are saying x one, say, I was drawing an array like this, where I was saying that these elements are the first element, x one, x two, that's true, x three, x four, x five. But in c these elements are counted, the counting is started from zero. There's a reason for that which will also be evident soon. Just remember for the time being that the first element, therefore x one, is actually represented in C as x. Then the square bracket followed by the index, and the first one will be x zero. Second one will be x one. Therefore, can you tell me what will be the last element of this array? How do I represent that? Yes, you are right. X five will be nothing but x four. Since I am starting with zero, I can go up to four here. In this example, as you can see that I have got ten elements in the array. Therefore I start from zero and go up to nine, okay, that is what is followed in C language. There is a reason for that. Let me just briefly mention the reason. The reason would be this. As I said that in the memory the array is stored in a particular region. When I declared it as int x ten, then 20 bytes have been given to me. And the array starts from this point, which has got some address, maybe thousand. And this address is starting is thousand two now, and I know that each one is of size two. So when I say what is the address of x one, what is x one? X one means here, and I know the starting of this array. So start address plus index times number of bytes for integer will give me the actual address. So for the first address, what will be the index? X zero. So my start address is thousand for the first 1000 plus zero times two. So that will be thousand. Okay, for x 1000 plus one times two. So that will be thousand, two for x five. X five in this way is which element? 6th element. So that one will be here, one 2345-612-3456 this element. And what would be its address? Address will be thousand plus five times two. That means thousand and ten. It starts from 1010, so 1002. Here it will start. So this is basically the offset, how much I shift from the top. That is the reason the ease of computation of the address of any of the index, any index, any element with a particular index can be done using this method, this formula, and therefore we start with zero. That is a specific reason for starting with zero. All right, so these are ten element one dimensional array that we have seen. Let's move ahead. So like variables, the arrays that are used in a program must be declared before they are used. The general syntax, just like in integer or float, we had declared them as int float before they are used. Why do I need to declare them before they are used? Because the compiler needs to allocate space for that. Otherwise the compiler does not know what type of variable it is. Therefore, therefore we also have to do the same for the narrative. And the general syntax will be type array name size. Now again, here, the size, I mean the dimension type specifies the type of the element that will be contained in the array. It can be int, float, cat or whatever. Okay, so I have got fields like say here, I can have an array, I can declare it as float. The array name can be my array, and size may be 20. Now this one specifies that this array can hold only floating point numbers. And suppose floating point numbers are four bytes each. Then for how much memory will be reserved for this, 80 bytes will be reserved for this. Because 20 is the size, that means the maximum size that the array can take. And what is my array? Everything, just like every variable must have a name. This array, this array also has got a name called my array. And so what will be the indices? I am repeating the thing, my array zero. So I am writing ma for short, zero. And what would be the last element here? Ma for size 20, it will be 19, is it? All right, so this is the general syntax which I must put. And also there should be a semicolon at the end, just like other declaration. There is no other major difference here. Size is an integer constant. Here I am calling it dimension. That is a maximum number of elements that can be stored inside the array. Suppose I have got so much space kept for storing an array. All right, so much space, many elements can be stored. I have reserved so much space. But in my actual working, I am using only some spaces. And these are not touched. That is allowed. That means, but the reverse is not allowed. Unless I have got the space. Unless I have got space, I cannot store them. So I must reserve the space beforehand. So that's why I was mentioning this maximum space as dimension. And the actual number of spaces which you are using to be size of the array. All right, the reverse is not true. Because suppose I have reserved so much space for an array. And I go beyond that. Then these are the spaces for other variables like ABC. Their data will be destroyed by my data, which I am taking as an array. Therefore, we must restrict to this. But suppose out of this I am using only this much. In my perlance, I am calling it size. And this to be the dimension. You can call it. In this example in the slide, we are calling this to be the size of the array. There's a maximum size of the array. So what is dimension? Dimension is the maximum size that the array can be of. But in practice, in actual running, it can be less than that, but not more than that. So I hope that part is clear to you. So here, what did I write? Int marks five. What does it mean? It means I am storing marks. And the marks are all integers, right? 50, 55, 6100. I am storing integer marks. And how many marks can I store? Five. So what will be the indices? Zero. Marks. Zero to marks. Four. That's the index limit. Because I am starting from zero, I can have only five positions. So marks is an array containing maximum of five integers. If a teacher decides that you will give fractional marks. That somebody can get 62.5, somebody can get 70.2, somebody can get 59.7. Then what change should we do? The change that we should do is this will be replaced with float. And if I say in my class there can be maximum 20 students, then what else should I change? I should change this and make it 20. That's how I should declare. All right, here are a few examples. Int x, ten. That means x is an integer. How do we read it? X is an integer. X is an array of integers of size or dimension. Ten, care line. 80. That means what? That means line is a variable array of type character. So what will it be? There will be 80 such positions. Usually when we take a print out. Usually when we take a printout of characters. The lines were conventionally 80 characters in a line. So there will be positions like this all through. Maximum 80. All right, so the size will be 80. And this variable is known as a line. And what can it hold? It can hold characters like a. Sorry. A. There can be space. Space is also a character. I denote space as a blank like this. Then maybe x is a character. Then there's a blank. Blank is also a varied character. Then c, then d. All those things can be there. So it is an array of. Say, ultimately, say p is the last character. Something like this. Altogether, 80 spaces for character I keep in my variable line. And what is the type of the variable? The type of the variable is an array. Array of character. Right. Similarly, I'm saying that there are 150 points. There can be 150 points. And each of those points are floating point numbers. Okay. Say name. I just store a name. I want to store the name of a person. Say name. S Ravi Kumar is the name of a student. And I want to store it in a computer. How do I store it? I can store it in the form of an array where each of the elements is a character. First one is s, then dot, then r, then Avikuma. And I need one more space, r. So you see, I needed one more space here. Why? Because I had taken. I did not have enough space here. Now, each of them is a character. By the way, you know that a character is denoted like this, so on and so forth. Now, what this line says is that name is a variable which has got the capability of holding 35 such characters. It has got the ability of storing 35 such characters at the most. Now, how much space should we keep? How much should I keep here? Here. If we are not sure of the exact size of the array, we can define an array of large size. Say, if I think. If I have got no idea of what are the typical indian names, for example, or american names, for example, I can keep name hundred. But is it advisable? Not always. When I really do not have any idea, I've got no other way but to do it. But if I have an idea of how much the name length can be at the most, I should keep so much size. Because if I keep an arbitrarily large size, then what am I wasting? I am wasting my memory space. Because each of these are a memory location. Okay, suppose beyond this, never a name can extend to. Then I should not keep this part in the name. But when I have got no idea, of course I have to keep a bigger large size. So that is the difference between the actual dimension of the array. How much reserve we do. And for S. Kumar. S. Ravi Kumar, for example, my actual size is 1234-5678. 910. Eleven. All right. Out of 35, 35 was the available number of spaces. So when I say it, say int marks 50. Suppose in my class I have got, say, ten students and I am going to store the marks of only one subject. In that case, there is no point storing so much space, reserving so much space for the variable marks. If I know, since I know only ten students are there, if I know beforehand, then I could have written int marks ten. Or if I had known that sometimes the number of students in a class are ten, sometimes 15, but never more than 20, then I could have kept marks 20, but I should not keep marks 50. I hope the point is clear now. I have already described this, how an array is stored in a memory starting from a given memory. Just let's have a revision of this. Starting from a given memory location. The successive array locations. This is very important. The successive array elements are allocated spaces in consecutive memory locations, one after another. So array a will have memory locations one after another like this. Let now the same computation. Let's do it again. Let x be the starting address of the array. Sorry. Let x be the starting address of the array. Address this address. And k is the number of bytes allocated per array element. I had shown it for an integer. Now I'm showing it in a generalized form. X was the first starting location, say thousand or whatever, and k is the number of bytes allocated. Okay, now then, the next one will be x plus k, because it started with x and needed k locations. The next one will start from x plus k. The next one will start from x plus two k, like that. The ith element, therefore will be as we had computed earlier, will be x plus ik. And since we started with zero, that will be perfectly okay. All right. Element AI will be located. Sum AI will be located. The address, say AI here, will be located starting at x plus I times K. Just a little bit of puzzle here. I have written it here like this. A common mistake. Could be that. What would have happened if I had written it like this? What is the problem of writing in this way? The problem is, what is Ik? Ik is not I times k, not I multiplied by K. But Ik is another variable name. All right, so these two are not the same thing. Whenever we go for programming, we should be very careful. Okay, now, so first, array index is assumed to start at zero in c. We are doing that. So a particular element of an array can be accessed by specifying two things. What are the two things? Name of the array index. This index is nothing but the relative position of the array. Okay, we'll continue with this discussion further.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Arrays (Contd1.).mp3,"So we now know that an array is identified by a name of the array, okay? Some name it like x num, whatever. And there is an index, num I or say num four, num five, et cetera. So by this index, by this index, we identify which particular element of the array I am referring to. Now in C. Also, we have said that the array starts from zero. The index of the value of the index starts from zero. Okay, next, so when we have an array defined as int x ten, the index are from zero x zero to x nine. All right, the first element can be accessed as x zero. First element can be accessed as x zero and the fourth element as x three. The 10th element as x nine. I hope this is clear to you by now that this one is array is x. So this is x zero. This is x one. The fourth element will be x three and the last element will be x nine. Okay? So that is how the array elements are addressed, how they're referred to by the indices. Now these indices must be integers. Now these indices must be integers. That is very important. So if I have got an array defined as int x n where n is the size of the array, then the value of this n, this index value of this index must lie between zero to n minus one. So if it were 20, then the value must lie between zero to 19 where n is the number of elements in the array. Now you can see here in this example that it's not the case that always I have to put a fixed integer as the index. Of course, I can write for an array, say an array is a. I can always refer to some element of the array as say a four for the fifth element. Or I can have some other integer value, x. And suppose x is two. Now, and if I refer, I can refer to the same thing as ax plus two. That means this will also evaluate to four. And this will also point to the fifth element of the array. Now one thing that we have to be careful about, that this value that's computed lies between, in this range between zero to n minus one. So here is another example where the array index value has been computed through an expression. Three times x minus y is assigned. So suppose here you can see that we are talking of two variables, two array variables. So let's draw a picture. A picture always clarifies the things much better. So let's have an array a and array b. A and b are two arrays, right? So suppose x is two and y is three. Then this statement, what does it do? A assigned x plus a x plus two. X is two plus two. That means a four, right? So a four. The fifth element is being assigned the value 25. And what is being done here? X is two. A ten minus x. So that is a eight. That means the 9th element. Let's have the fifth. Let me make it a little bigger. Suppose this is the. Suppose this is the 9th element. A nine. A eight, sorry, a eight. This is a eight. So that was suppose 30 that is being taken. Plus five is being added to that. So 30 plus five, that's 35. Now, note this. This part is being evaluated. What is being done? In evaluating this part? I have got x to be two. So I'm computing ten minus x. I get that to be eight. That means I want a particular variable which is stored in, stored as a eight. That means in the 9th location of the array a. And that is 30. I take that value 30 and add five to that. So I get 35. And then what do I do? I store it in the array b. And where in the array b. Now, I'll compute this part. Three times x was two. So three times two is six minus y. Y was three, so it will be three. So in b, three. So b zero, b one. B two. B three. That means again, in the fourth element of this array b, three, I'll be storing the value 35. So now the array b will have the value 35 here. I hope this is clear. So you have to be very clear about the distinction between the array index and the value of the array. Say this 30 that I got after computing the index a eight, that was telling me where in the array I should look at to get that value. And then that was just a value. And with that value, I had another value, five. I added them together. I added them together and got the value 35. Now I see where I am going to store that. For that, again, I compute the index here. And I compute the index. The index must be within the range zero to n minus one. I compute that, and I find that the index is three. That means in b three, I have to store the value. I go to b three and store the value. I hope this is clear. Right now, in C, there is a word of caution here that in the language c, the array bounds are not checked. For example, int, I have got declared int marks five. That means I have got an array marks whose size is five or dimension is five. That means at best, I can have five elements in that. All right, now, here, what I am trying to do here, what I am trying to do is I am trying to write 75 in marks eight, but there is no space for marks eight. It was 5678. This is the place where I am going to trying to write 75. Now it would be good if the compiler could give me an error that, hey, you had declared it that size to be five and you are going beyond the border. All right, you are crossing the border, so be careful. Warning, syntax error or whatever syntax error and you are not allowed to do that. But unfortunately array bounds are often not checked. So what can happen if you are not careful, then it will not necessarily cause an error, but will be writing something here. All right, it will be writing something at this point, which might be when I allocated, the compiler allocated the memory. This part was for the marks and this part were for other variables, X-Y-P and whatever value of p was there that is overwritten with 75. So one must be very careful about this when writing the programs and running it. Suppose it's a very common thing that often you will find that there are some funny errors occurring. And the reason for that maybe you have crossed the array boundary, so it can result in unpredictable results. So general form of initialization of arrays is the array name size with some list of values. So recall that we had done, we can do initialization. Slide int x equal to 25 semicolon where I declare x to be an integer and also initialize it to a particular value. The same thing can be done for arrays. For example, I can write int marks 572 8016. Note that this initialization is within this two curly braces. That means here I am creating an array whose name is marks and the values are 72 for marks zero, 80 for marks, 165 for marks 280 for marks three, and 76 for marks 401-2345 elements. Okay, I can declare in this way, this is one form of initialization. Remember that here we are putting square brackets for declaring the dimension, but here we are putting curly braces. Similarly, this one care name four. I have just typed in an array, so the array has got four elements. And what is stored here? Am I t? Okay, Amit. So basically the name is Amit. So that is coming as a string of four characters, although I use the word string. Be careful about that because string has got a little more thing to it, which I'll describe later. But right now it's an array of characters. Characters, array of characters of size four. Now there are some special cases. If the number of values in the list is less than the number of elements, the remaining elements are automatically set to zero. Are automatically set to zero. For example, in this case I have got a variable. What is the name of the array here? The name of the array is total. And what type of array is it? It's an array of floating point numbers. And so there are five elements. One, two, I've got five spaces to three, four and five. There are five spaces here and I have loaded initialized it to this value. So here it is 24.2. The next one is -12.5 the next one is 35.1. The remaining elements which are not filled up are filled up with zeros automatically by the compiler. Okay, if it is less. Now be careful that sometimes some compilers behave in a are implemented without doing this bit and therefore you must check whether your compiler, usually the standard compilers do that, but you should be careful about it. So total will be this. As I've said here, the size may be omitted. In such cases, the compiler automatically allocates enough space for the initialized variable. So when I am initializing it, then it's possible that I can leave out this size because I am already writing it here in this form. Therefore in this case what will happen? Flag an array will be created just for the initialized values. So a four element space will be given to you, which will be one, one and zero. Because I have not mentioned anything here, but I must give this symbol because just to distinguish it between int flag and int flag this because this is just a variable integer variable. This is an integer array. So you must be careful about this too. So similarly, I could have done care name. I did not put anything here and just write amit. Now let's come to this example, finding the minimum of ten numbers. Now we are doing our first programming with arrays. Okay, we are doing the first programming using the arrays. Now here what we are doing is first we are reading the numbers. I'm reading the numbers, right, I'm reading the numbers and then I'm storing them in an array. So let's look at this line by line. Let's look at the declarations. Int a ten, what does it mean that I have got an array of size ten and the name of the array is a. All right, there is space for ten elements, a zero to a nine. Next I have got another variable. I one variable, another variable min. So that is my declaration part. Now I am printing here, give ten values. So on the screen I'll find that give ten values and then backslash n. So now the user is entering ten values. And what am I doing? I am reading those ten values. Now compare till now when we read the different integers. What did we do? We wrote it like this, right? Scanf percentage d, meaning that's an integer. Ampere sand num. Something like that. We did to read an integer called num. Compare that with what we have done here. Here. What we have done is scanf percentage d remains the same because whatever I am reading is nothing but an integer. And amperes and AI, that means this array is ith element I am reading. This means AI means I am reading the ith element of this array. A. What is the value of I? I is zero initially, so first time, whenever I have asked, ten values. So I is zero. So first I is pointing here. So I is zero. So that means this is pointing here. I read a particular value, 25. I store it here. All right? Then I go in the loop. What happens? I plus, plus I is incremented to one. Please observe this carefully. This variable is incremented to one. That means now the index shifts from here to here, a one. And I read. And that is less than ten. Typical for loop. So I come here, read the second value, say three, go back increment I, it becomes two, less than ten. I come here, this beings two means again, this is changed to the next element, all right? And I read the next value, which may be 37. In that way, I go on and read ten values every time I am reading one particular integer. And that is being where am I storing it? That is the importance of this ampere sand, that means that I am reading this at the address of AI. So at this location. So this is the first part, first part of the program that has read the array. Now I want to find out the minimum of the array. Okay, now let's see. Let me. Now, so is this part clear, how we read the array in this way? Suppose I have read the array, some array, like say five, 3275, one. Now, in this part of the program I am trying to find the minimum. And that is typically what we did last time done here in a little bit different way. I am starting with a min mean, which is very large. So I am assuming that there will be no data given at this point. At this point, no data will be given, which is as large as nine. Nine. Nine. Okay, I'm assuming that. So again in a for loop here, I is starting from zero. That is I is pointing here. I am comparing AI. That means a zero, a zero. With min. A zero is less than min. Therefore I can assign a zero to mean. So my mean becomes five. I go back to the loop. I is incremented so I is incremented. And I comes here, less than ten. So I come here and again compare AI. What is AI? AI is this value. Three is three less than min. Yes. So then min becomes three. I again go back, increment the index. So you see in this for loop, I am incrementing the index. We will see how we can write it in different ways. Now, this is a very important exercise and you will have to program it yourself, meet with errors at several times, but then ultimately you will find it that it's not that difficult. So I is now three. I again compare 200 with mean. No, 200 is not less than the mean. I go back to the loop. I is incremented. 75 is not less than the mean. I come here, one is less than the mean. So this will be like this. In this way it goes on. So here we could find two distinct application of this for loop. One for reading the array and storing it in a set of locations. And the other one is looking through that array for every element. I am looking through this array and I'm finding the minimum. Now let's do a little bit of exercise before we conclude this lecture today. Say I want to read an array of integers and I want to print the array. Okay, so what should I do? I'm leaving out the standard include stdio h declarations. Let me do int, let me call it an array. M, underscore a meaning my array, and let the size be ten. All right. Also, and an index. I index need not be I, but it must be an integer variable. And then I am starting to read the array. I am trying to read the array. So my program started here. For reading the array. I am doing for I assign zero, I less than, less than ten, I plus plus scanf percentage d. And what am I reading? Mai. So in a loop, I'll be reading ma zero, ma one, ma two, like that. And then I want to print the array. So suppose I have read an array which is something like 32451. Now I want to print the array. So what shall I do? I'll just simply, again, I'll take one elements one by one, and we'll be printing them so I can write for I assign zero, I less than ten, I plus plus. That means I'll be doing this. So I is starting with zero, and we'll go up to this here. I am assuming that there are ten elements here, although I've shown only five, then printf. I can say that. Say I'm printing the value of ma this percentage d. So these things will be as it is printed. Except for this is percentage d, backslash n, and, sorry, backslash n, and then discontinuing m underscore a I. Let's see what will happen. And then I conclude this. So I have stored this. Now I am printing this. What will be printed? The printing will be something like this. Let me use another color for this. What will be printed is the value, first iteration. First iteration. What will be printed? The value of ma. What is the value of I? I'm sorry. Here there should be another one. I've written wrong. There are two percentage ds. So here should be I comma, this. All right, so I'll repeat again the value of ma. Then this. Then this part will come. And this will correspond to the first variable, that is I. What is the value of I? Value of I is zero. Is then the second placeholder. That is ma, zero's value. That means is three backslash n. Again, it will go in the loop. And what will it again print? The value of m underscore a will be printed as it is percentage d. The value of the index of ma one is then the value ma one is two. Is two. Like that, it will be printed. So these are two fundamental operations of reading an array and printing an array. We'll continue further with the array.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Arrays at Strings.mp3,"Today we'll be having a look at how the techniques that we have learned can be applied to different problem solving, and this we'll continue from this lecture onwards for a few more lectures. We have learned quite a few things. We have seen the overall structure of the c language. We have seen the if then else if else structure, the iteration structure. Like the loops, we also know how the variables are defined. We have seen arrays, how data can be stored in one dimensional array and two dimensional arrays. We have also seen functions. And the most important thing about functions is that it enables us to take a complex problem and divide it into different parts and solve each of the parts separately using functions. A very important thing about functions is passing of the parameters and how the function returns a value, returns a value to the calling function. We have also seen that there are two ways in which parameters can be passed from the calling function to a called function. One is call by value, another one is call by reference. In c language in general, always call by value is adopted. However, in call by value we have to copy the value of the data, the parameter value, the parameter value to the argument value. However, for the case of arrays, whenever I want to pass a particular array, at that point an array can be 100 by 100 array or ten by ten array. If it be a ten by ten array, then I'll have to copy 100 values. So that is not advisable. For that, we just pass the array name, and let's quickly have a look that the array name is essentially an address. Right? An array. Whenever we pass, suppose there is an array, a two dimensional ten by ten array. All right, two dimensional array like this. Now all the elements I am not passing. So it's essentially, it happened to be a four by four array. So that's all the 16 elements I'll not be passing. So here is my called function, the function called function, and on this side is the calling function, the calling function, and the array name is say a. So the calling function refers to suppose let this function be called f. So from the body of the calling function, whenever I am calling f, I am passing the array. Say if it be an integer array, int a, and here I just pass the array a. And here in this function body we have got say int a and just saying that the size of the or it may not be a, it can be x. Also int x something and the size of the array. And here int a and maybe n. So here I'm actually passing the name of the array. And the name of the array is nothing but the beginning of the address of the first element of the array. So here I am actually copying the address. So it is a call by reference in the case of an array. And in the last lecture, we have also seen that we can also use pointers to sort of establish call by reference. Another major thing that you have to keep in mind is that suppose this array is 1234-5678 910, 11, 12, 13, 14, 15, 16. Now, these are organized in c in a row major form. So it is stored in the memory like one. So the rows first, two, three, four, then five, six, like that. So when I refer to the array a, I actually pass on the address of the first location of the array, okay? So a zero, zero in the case of a two dimensional array, points to this element. And that is this element, okay? That's how we pass on arrays for functions. And we have also seen some applications of all these techniques that we have learned. In particular, we have seen how we can carry out search. And we have seen two search techniques. One is linear search. Another is binary search. Now, in linear search, the complexity, the time is proportional to the number of elements. Whereas in binary search, it is reduced, it's faster, it's log of the number of elements to the base two. And search is a very fundamental problem solving technique in technique. Because suppose you have got the names of students in the class. All right, here are the names. Atul, sham, gargi. In that way, the names are there. And each of them have got a role number, 1234, like that. Now you want to find out how many shams are there in the class. So you have to search this array and find out where sham is. Okay? Maybe here. And there is another sham here. So that is searching and counting both the things. But you cannot avoid searching this array. All right? It may be that along with that, there is an array of marks obtained by role number one, roll number two, et cetera. So maybe this is 50, this is 70, this is 30. All right. Now, here, tell me. I want to say. Now, they are in two arrays. This is one array called name. And this is another array called marks of the corresponding students. Now, I want to know what is the marks that Gargi has obtained. How do you go about it? What would be the first step in solving this problem? What is the marks that Gargi has obtained? In order to do that, I have to. First, I do not know what is Gargi's role number. If I had known, what is Gargi's role number. Suppose Gargi's role number is three. Then I could have gone in the marks array. And I could have taken marks roll number. What if I knew the role number? Role number minus one that marks I could have taken as a result. All right, but I don't know the rule number. If I had known the role number three, then I would have gone to the second element. So its marks two would have given me the rule number. But suppose I do not know the rule number, then what should I do? First, I'll have to search this array. And what would be my key? What is my key? Key will be the string Gargi. Because I want to know the marks obtained by Gargi. And what should I do with this key? I should carry out a search. It can be a linear search or it can be a binary search. Let's, for the time being, assume that it's a linear search. So we'll be searching and I'll be finding Gargi. Here I am assuming for simplicity, that there is only one Gargi in the class. So I'll take this and I find what will the search, if you recall, what will the search algorithm return me? The search algorithm will return me the index or the position where Gargi is located. And that position will be. Actually, it will automatically come since this positions will be marked as zero, one, two. I'll get this two returned. So I'll get. So I get the key. I search the array name. This is a character array, a care name, size, whatever size is, say, n and the key. And this search will return me the value position two pause, equal to two. Then I'll simply take the value of marks. I'll go to the array marks pause, which will be my result, right? So you see, we needed the searching. Now, while I was talking of searching this array, I said that the searching. I am assuming they're searching to be a linear search. Would it be possible to search this array using binary search? If you just think it over, would it be possible to search it using binary search? What does binary search require? Binary search requires that the array be sorted. Right? Array be sorted. So an array like this, atul, amal, gargi and joy. There's an array of four elements. Can I sort it? The type of sort. If I want to sort it, I'll have to organize it in increasing or decreasing order. Let's assume that I am trying to do it in an increasing order. Now, this sort will be. This character array can be sorted in a way which is called the lexicographics sort. That means I go, I sort the character array according to the alphabets or the words as they're written. Obviously, a comes first. So therefore, a character a is smaller than character b. All right? So here, between these two elements, both of them has got a. But similarly, t is greater than m. So in this sorting, I'll first check between these, say aa. They are same. Think of bubble sort. I am trying to compare them. In normally what we did, we found that say array xj is less than xj plus one. And then we did something. If it is the case, no issue. If it was the other way around, I wanted to do a swap. But in this case, it will not be so simple. I can take a string and compare these two strings as to which one is whether they are same or not or whichever is greater. But another way, you can write a small function to compare. I leave it to you. I leave it to you that you now know sorting techniques. So you should try to write a function that will sort a string of characters. All right? So a and a are same. If they are same, the function, what will do it will now look at t and m. Now, m is smaller than t. Therefore, amal is smaller than atul. So amal will come here. And atul will come here. Now, between Atul and Gargi, you can see a is greater than smaller than g. So gargi is in a proper space. Now, if, say, for example, I don't have joy here, I am having another name, gautam. Here. Now, when I'm comparing between gargi and gautam, g and g are the same. So they're equal, no change. Next, a and a are also same, no issue. So there is no change. But r. R is smaller than u because r appears earlier than u. But in terms of our computer code technology, the ASCII code of r is less than the ASCII code of u. So in both the ways it is meaningful, so r is less than u. Therefore, gargi is smaller than gautam. So in that way, I can carry out with another small function. Compare string is greater. Say is, you can write a function is greater. Two strings. Okay, care s one, comma, care, s two. Two strings will be passed on this function. And this function will find out which character. If s one is greater than s two, it will just return. If s one is greater than s two, it will return a one. If s one is greater than s two, try to write such a function. Okay, now that I am giving you as a home assignment, all of you should try to do that. And with a little effort, I'm sure you'll be able to do that. So I could have, just as I had done in the earlier one here in this thing, I said that I'll be doing linear search. I could have done binary search also, provided. Provided I had sorted them. Okay. Provided I had sorted them in the proper way, and then with the sorted array, I could have done binary search. Now, we'll be also doing some problem solving in this course. We'll be doing some problem solving in the field of numbers or equations, mathematical problem solving. But before that, in order to do this today, let's have a relook at the strings. We had looked at strings earlier as an array of characters. So let us have a relook at the whole thing today. How can I represent an array of strings like the one that I was showing here? An array of strings. All these names, Atul, Amal, Gargi and Gautam. All these are nothing. But this is a string. This is a string. All these are different strings. So how can I represent them? Let's have a look at that. Say I can. I have got three strings. One is Spike. Other is Tom, other is Jerry. Now, these three strings I have to store. And I am saying that each string can be, at best ten characters, at most ten characters. And I am looking at three such names. So it is an array, three rows, and each row having ten characters. Right? So the definition would be. I named them as Chr. I could have done character array. And it is three rows and ten columns. Now, I can initialize that as Spike, as character s. Character p. So s comes here. P comes here. I comes here. K comes here. E comes here. And that's the end. So it's backslash zero. I also put that. And so 123-4564 places are still vacant. Okay, four places are still vacant. Similarly for the next one is Tom. So to m, backslash zero, and the rest are rest. Six are all free. All right. But my string has ended here. So one way is that I can represent them in this way where I specifically talk about the characters in the array and terminate them with backslash zero. The other way I can do it is simply, I initialize them as 310, the same array with three strings, spike, comma, tom, comma, jerry. Now, internally, even if I do that, it is essentially becoming the same thing. Internally, it is being stored in the same way with three rows and each row having these characters S-P-I-K-E backslash zero, and so on and so forth. There can be more T-O-M backslash zero, and so on and so forth here also, jerry and so, and, sorry, backslash zero and so on and so forth. It's being stored. So both of them are equivalent. I can do it in either of these ways. All right, so a string can be represented in any of these ways. So we already know this. Again, the name of the array is a pointer to the zero 8th element of the array. So if I have this array, S-P-I-K-E backslash zero. T-O-M backslash zero. J-E-R-R-Y backslash zero. When I am calling that chair, the name itself is pointing to the first element of this array. So chr, it's pointing to that. So this and chr zero are the same. They mean the same thing. Okay, so this, you just like an array. This is also true here. Therefore, if char points to the address thousand, char plus one will point to address thousand and ten. Why? The reason is, again, I have got this array and ch a r is pointing. Ch A-R-A-R is pointing to the zero th element of the first row. If this is thousand, then thousand to 1009. This at this location is 1009 because the size is ten. Okay, size is ten. So although spi k e backslash zero, et cetera, is there, then when I go to the next one, ch underscore air plus one, that means wherever this pointer is, this entire thing is taken zero to ten. So I am taking, here it is taking all these ten elements as one array. It will be pointing to the next one. That means it will be 1010. Okay? Again, if I make it ch air plus two, it will come to this one. All right, that's how the pointer works. But how can I get this character? This will be ch at one that is pointing to this element. Okay, now this thing must be clearly understood. So ch a r points to a zero 8th string or the zero th one dimensional array. Ch one points to the first string or the first one dimensional array, or number 10 8th 1st chr two points, the second one dimensional lady. So each of them are one dimensional ladders. And char is pointing to each of these one dimensional ladders. Chr is pointing to one one dimensional array. And as I increment the pointer, this pointer is going on increasing. All right, in general, chari points to the ith string or the ith one dimensional array. Clear the following program. Let's look at the program. And the following program demonstrates how to print an array of strings. Please take 1 minute to read this program yourself and try to understand it. You can see here that I am starting with the main function, and although it's written in a very cryptic way. So my program starts from this point and ends at this point. I is an integer. ChR is again an array of three strings, and each can be of maximum length ten. So Spike, Tom and Jerry are there. So I can print. I just print first way. Next line I go to, next line, and two next lines I just put first way. And then what do I do? So I'll print first way, and then two lines have been given blank. Then for I zero, two less than three, I plus plus printf string. I am printing the string. So what will be printed? String equals a placeholder for the string. And then there'll be some tab, one space, and then, so the first will be string here, some space, and then tab. This is tab. So I give some space and write address, and then, sorry, string equal to string equal to address equal to. And there will be some space for the address. And that format is unsigned integer, so it will become longer. All right? Because unsigned and signed integer, whenever I am putting, suppose I have got 16 bits for representing an integer. If it be assigned. If I distinguish between plus five and minus five and keep one bit kept for the plus or minus, then for the 16 bit, I'll be actually having 15 bits for this size. But if I make it unsigned, then I can have all these 16 bits so I can represent more numbers. Okay, all right, more numbers. So that apart. So string and address. And then what am I printing here? Care, I care. Plus I, that means zero. Care, zero the first string. And then I am again putting the cad this. Now, what is the difference between this cAd, this and this? This is being printed in percentage s. That means the string will be printed. And here in an unsigned integer, what I am printing here is the address of that string. So this string spike was here. When I print this, just the name of the array. That means I am in this format. If I do, I am printing the address of it. Therefore, the output will be somehow like this. Okay, so this is something to be understood very clearly that this array, when I'm actually looking at this, I am taking the content of the array. Otherwise, I am taking the array itself. So here is a program. This program asks the user to enter a username. If the username entered is one of the names in the master list, then the user is allowed to calculate the factorial of a number. Otherwise an error message is displayed. So we have got a master list of names. Now, if you are a valid user. Your name is there in the list. So first what is doing is including stdio h. It's including string h. That means some string functions are also included. I am defining the factorial prototype. The factorial function has been written later. Suppose this part, this part is later than the main function. Okay, now the main is here. And what is the main doing? It has got some integer I and found is zero. Initially, the name is not found here and some n number for which I have to compute the factorial master list five by 20. That means each of these, each of these can be 20 character long, and there are five such. And I have put the valid names as admin, tom, bob, Tim, and Jim. Now I am asking. And name is? I am asking from the user, enter username. Now the user gives the name. So get s. Here you are getting a new function being introduced here. That is get s. What is get s? Get carry getch, you know, and here get s means get the string. So in one shot it is getting the string as the name. So name I am getting from the user some name. Say it is Jim. Suppose the user enters Jim. Now for I equals to zero to five. Why five? There are, all the five names are here. If string compare name and master list I. If this character, this string, and this string matches, then found is one. Otherwise, I am again going in the for loop. So at every stage of the loop, I am trying to compare this name with this string here. There is no match. So I come here, no match. No match. In that way, I come and find Jim. So here, ultimately I'll get found and then I'll break. Now, when I come out, suppose it was not Jim, it was say, jimmy. All right, then I do not get a match here. So I can come out with found equal to zero or found equal to one. If found equal to one, then welcome, then welcome exclamation. And then the name. It's printing. Welcome Jim, and asking. Please enter the number. Is entering the number for the factorial. And then here you see in this printf, I have called the factorial. That factorial of the number is this n is this. So I call factorial. And this part, you know now that this n and this n may not be the same. I mean, there are two different locations, but this n, it could have been x. Also. In that case, internally it had to be x here. So this is being passed over here and the factorial is being computed. All right, once the factorial is computed, now how the factorial is computed, I'll be discussing that later because here there is some trick, forget about that trick now. I'll be discussing that later. That's recursion which we have not yet discussed and after this I am coming back here and I am printing. So the purpose of this program was to show how we can handle strings. So these are very common, very common thing. I mean you try to log in in a machine, right? And you type in your login name and your password. If they do not match the system says login failure. Now how does it do it internally? Internally it has got a list of, just like this. It has got a list of all the users and it takes your username and checks it with all these. That's a problem that's being solved, a sub problem that's being solved in the operating system and that is the basic principle is depicted in this program. All right, we'll continue with other problem solving approaches in the future. Lectures.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"arrays vs lists, binary search.mp3","You. We have seen several situations where we want to store a sequence of values. Now, it turns out that in a program or in a programming language implementation, there are two basic ways in which we can store such a sequence. These are normally called arrays and lists. So let's look at the difference between arrays and lists. So an array is usually a sequence which is stored code as a single block in memory. So you can imagine, if you wish, that your memory is arranged in a certain way, and then you have an array. So usually memory is arranged in what are called words. So a word is one unit of what you can store or retrieve from memory. And an array will usually be one continuous block without any gaps. And in particular, this would reply when an array has only a single type of value. So all the elements in the sequence are either integers or floats or something where the length of each element of the array is of a uniform size. And we would also typically in an array, know in advance how big this block is. So we might know that it has, say, 100 entries. So we have a sequence of size 100. Now, when this happens, what happens is that if you want to look at the jth element of a sequence or the ith element of a sequence, then what you want to think of is this block of memory, starting with one, two, three, up to I, and you want to get to the ith element quickly. But since everything is of a uniform size and you know where this starts, you know where the sequence starts, you can just compute I times this size of one unit and quickly go in one shot to the location in the memory where the ith element is saved. So, accessing the ith element of an array just requires an arithmetic computation of the address by starting with the initial point of the array and then walking forward I units to the ith position. And this can be done in what we could call constant time. By constant time, what we mean is it doesn't really depend on I. So it is no easier or no difficult to get to the last element of an array as it is to get to the second element of an array. It is independent of I. It takes a fixed amount of time to get to sequence of I for any I. Now, one consequence of this is inserting or contracting arrays is expensive, because now if I have an array with zero to 99 and I want to add a new value here, say at position I, then first of all, this array now becomes from zero to 10, and now everything which is after I has to be shifted to accommodate space. If we want to keep the same representation where the entire array is stored as a single block. So when we have a single block of memory, though it is efficient to get to any part of it quickly, it is not very efficient to expand it, because we have to then shift everything. The worst case, for example, if this green block comes at the zero th position, then the entire array has to be shifted down by one position. In the same way, contraction is also expensive because we have to make a hole in some sense. So if we remove this element out, then we have a hole here, and then we have to push everything up to block this hole. Because remember, the array must have all elements contiguous, that is, without any gaps starting from the initial position. So the other way of storing a sequence is to store it one element at a time and not bother about how these elements are with respect to each other in the memory. So I can think of this memory as a large space. And now I might have one element here. So this is my first element, and then I will have a way of saying that from here the next element is somewhere else. So this is what we call a link. So very often in the implementation these are called linked lists. So I have the first element here. Now because of various reasons, I might end up putting the second element here and so on. So this, you can imagine that if you have some, say, a space in your cupboard, and then you take out things and then you put things back, but you put things back in the first place where you have an empty slot, then the sequence in which you put things back may not respect the sequence in which they appear finally in the shelf. So here, in the same way, we don't have any physical assumption about how these elements are stored. We just have a logical link from the first element to the next element and so on. So the other part of this is that we don't have to worry about the overall length of the list, because we know we start at the zero th position and we keep walking down and the last position. So say, suppose the last position is in fact two, then there would be some indication here saying that there is no next element. So two is the last element. So a list can have a flexible size. And obviously because we are just pointing one element to another, we can also accommodate what we see in python, where each element of the list may be of a different type and hence each value might have a different size. In itself, it's not important, unlike an array, that all the values have exactly the same size, because we want to compute how many values to skip to get to the ith element. Here we are not skipping, we are just walking down these links. So since we have to follow these links, the only way to find out where the ith element is, is to start from the zero th element, then go to the first element, then go to the second element, and so on. Because a priority, we have no idea where the ith element is. So after I steps, we will reach the ith element. And if we have a larger value of I, it takes longer to get there. So, accessing the ith position in a sequence, when the sequence is stored as a list, takes time proportional to I. We can't assume that we can reach any position in the list in constant time, unlike in an array. On the other hand, it is relatively easy to either insert or delete an element in a list like this. So supposing we have a list like this. So supposing we start at the zero th position, we come to the ith position. And currently, if we say that the ith position points to the I plus one th position, which points to the rest. And suppose we want to insert something here, then it's quite simple. We just say that this is the new I plus one position. So we create a new block in memory to store this value, and then we'll make this point here. So it's like plumbing. We remove one pipe and we attach a pipe from the ith element to the new element, and we attach another pipe from the new element to what was beyond the ith element previously. So we just have to shift these three links around and this doesn't matter wherever we have to do it, any place in the list, if we have, we just have to make this local change in these links. And so this insertion becomes now a constant time operation. If we already are at the position where we want to make the change. In the same way, if we want to delete something, that's also easy. In fact, it's even easier. So I have say I pointing to I plus one pointing to I plus two, and I want to remove this element. Well, then I just make this link directly point to the next one. Remember, all these links are available to us. We know this link, we know this link, so we know where the I plus second element is. Similarly, here, when we want to create a new element, we get a link for it, because we create it. And we know what link to copy there because we already have it here. So we can copy it from the ith element to the new element. So therefore, in a list it is expensive to get to the ith element, it takes time proportional to the position we are trying to get to. However, having got to a position, inserting or deleting an element at that position is of constant time. Unlike in an array, where if we insert or delete at some position, we have to shift a lot of values forwards or backwards, and that takes time. So let's look at typical operations that we perform on sequences. So one typical operation. Now, if I just represent a sequence more abstractly as a sequence, as we have been drawing it. So supposing I want to exchange the values at inj. So this would take constant time in an array, because we know that we can get the value at the 8th position, get the value at the j position in constant time independent of inj, and then we exchange them. It just involves copying this there and the other one back. On the other hand, in a list, I have to first walk down to the ith position and then walk down to the j position to get the two positions. So I will have in a list I would have a sequence of links, and then I would have another sequence of links. And then having now identified the block where the ith value is and the block where the jth value is, then I can of course exchange them without actually changing the structure. I just copy the values back and forth. But to find the ith and jth values, it takes time proportional to inj, so it takes linear time. On the other hand, as we have already seen, if we want to delete the value at I position I or insert a value after position I, this we can do efficiently in a list, because we just have to shift some links around. Whereas in an array we have to do some shifting of a large bunch of values before or after the thing. And that requires us to take time proportional to I. So, the consequence of these differences between the two representations of a sequence as an array and a list is that we have to be careful to think about how algorithms that we want to design for sequences apply depending on how the sequence is actually represented. An algorithm which works efficiently for a list may or may not work efficiently for an array, and vice versa. So, to illustrate this, let us look at something which you are probably familiar with, at least informally called binary search. So, the problem we are interested in is to find out whether a value v is present in a collection, or we can even call it a sequence. To be more precise, in a sequence which we call scq. So we have a sequence of values. We want to check whether a given value is there or not. For instance, we might be looking at the list of role numbers of people who have been selected for a program. We want to check whether our role number is there or not. So there are two questions that we want to ask. One is, is it important whether the sequence is maintained as an array or as a list? And is it also important, given that it is maintained as an array or a list, whether or not there's some other additional information we know. For example, is it useful for the array to be sorted in ascending order? That is, all the elements go in strictly one sequence, from beginning to end, lowest to highest, or highest to lowest. Or does it matter? Does it not matter at all? So here is a very simple python program to search for a value in an unsorted sequence. So this is similar to what we saw before, where we were looking for the position. We were looking for the position of the first position of a value in a sequence. But since we don't even need the position, we only need true or false. Is it there or is it not? It's a very simple thing. What we do is we loop through all the elements in the sequence and check whether any element is the value that we are looking for. Once we have found it, we can exit. So this exits the function with a value true. And if we have succeeded in going through the entire list but we have not exited with true, that means we haven't found the thing. So we can unambiguously say after the four, that if we have reached this point, we haven't found the value v that we are looking for, and so we should return false. So since we are not looking for the position, we are a much simpler code. If you go back and see the code we wrote for find pause. So there we had to first of all keep track of the position and check the value at position I rather than the value itself. And secondly, when we finished the loop, we had to determine whether or not we had found it, or we had not found it. Whether we had. We remember we used a break to get out of the loop the first time we found it. So we used to detect whether we broke or not. If we did have a break, then we had found it. If we did not have a break, we didn't find it. So accordingly, either the value of pause was set or it was not set, and if it is not set, we should make it minus one. So that was more complicated. This is very simple, but the main point of this function is that we have no solution to search, other than to scan from beginning to end. The only systematic way to find out if v occurs in the sequence or not is to start at the beginning and go till the end and check every value, because we don't have any idea where this value might be. So this will take time in general proportion to the length of the sequence. So we are typically interested in how long this function would take in the worst case. So what is the worst case? Well, of course, one worst case is if we find the value at the end of the list, so v is the last value, then we have to look at all. But more generally, v is not in the list. If v is not in the list, the only way we can determine that v is not in the list is to check every value and determine that that value is not v. And this property that we have to scan the entire sequence, and therefore we have to take time proportional to the sequence to determine whether v is in the sequence or not. It does not matter if the sequence is an array or a list, whether it's an array or a list, we have to systematically go through every value. The organization of the information doesn't matter. What matters is the fact that there is no additional structure to the information. The information is not sorted in any way. At no point can we give up and say that since we have not seen it so far, we are not going to see it later. On the other hand, if we have a sorted sequence, we have a procedure which would be at least informally familiar to you. So, when we search for a word in a dictionary, for example, the dictionary is sorted by alphabetical order of words. So if we are looking for a word, and if we open a page at random, supposing we are looking for the word monkey, and we open the dictionary at a page where the values or the words start with I, then we know that m comes after I in the dictionary order of the english Alphabet. So we need to only search in the second half of the dictionary after I. We don't have to look at any words before I. So in general, if we have a sequence, the efficient way to search for this value is to first look at the middle value. So we are looking for b. So we check what happens here. So there are three cases. Either we have found it, in which case we are good. If we have not found it, we compare the value we are looking for with what we see over there. If the value we are looking for is smaller than the value we see over there, it must be in this half. On the other hand, if the value we are looking for is bigger, it must be in this half so we can halve the amount of space to search and we can be sure that the half we are not going to look at positively doesn't have the value because we are assuming that this sequence is sorted. This is called binary search. This is also, for example, what you do when you play a game like 20 questions. If you played that when somebody asks you to guess the name of a person they are thinking of, then you might first ask the question whether the person is female. The person is female, then the person, and the answer is yes, then you only need to think about women. If the person says no, then you only need to think about m. So you have men, so you have half the number of people in your imagination whom you have to think about at each point. Each question then further splits into two groups depending on whether the answer is yes or no. So here is some python code for binary search. So binary search in general will start with the entire list and then as we said, it will look at the midpoint and decide on the left. So we'll have to again perform binary search on this. How would we do that? Again, we look at the midpoint of this part and then we'd again look at, say the midpoint of the next part that we look at and so on. So in general, binary search is trying to do a binary search for a value in some segment of the list. So we will demarcate that segment using lNr. So we are looking for the slice sequence starting with l and going to r minus one. We are assuming that sequence is sorted and we are looking for v there. So first of all, if the slice is empty, so this says the slice is empty. That is, we have gone halving the thing and we have eventually run out of values to look at. The last thing we looked at was a slice of length one and we divided into two and we got a slice of length zero. So then we can say that we haven't found it yet, so we are not going to ever find it and we return false. On the other hand, if the slice is not empty, then what we do is we first compute the midpoint. So an easy way to compute the midpoint is to use this integer division operation. So supposing we have currently the slice from four to seven, then at the next point we will take eleven by two integer wise and we will go to five, right? So remember 4567. So we could either choose six or seven next to split it into two parts, because we are going to examine six and then look at four, five and seven, or look at five and then four and six. So if you do integer division, then we will pick the smaller of the two. So we find the midpoint. Now we check whether the value is the value at that midpoint. If so, we return true. If it is not, then we check whether it is smaller. If so, we continue our search from the existing left point till the left of the midpoint. Now we are using this python thing that this actually means there's a slice up to mid, and therefore it stops at mid minus one. So it will not again look at the value we just examined. It will look at everything strictly to its left. So if the value that we are looking for is not the value of the midpoint, and it is smaller than the midpoint, you look to the left. Otherwise you look strictly to the right. You start at mid plus one and go up to the current right value. This is a recursive function. It'll keep doing this. At each point the interval will have. So eventually, supposing we have a slice of the form just one value, so five to six for example. Then at the next point we will end up having to look at just a slice from five to five or six to six. And this will give us a slice which is empty because we'll find that the right point and the left point are the same. So how long does the binary search algorithm take? The key point is that each step halves the interval that we are searching, and if we have an empty interval, we get an immediate answer. So the usual way we do this is to record the time taken, depending on the size of the sequence or the array or the list. So we've written array here, but it could be sequence in general. So if the sequence has length zero, then it takes only one step, because we just report that it is false, we can't find it if there are no elements left. Otherwise we have to examine the midpoint. So that takes one abstract step. Computing the midpoint and checking whether the value is v will collapse at all into one abstract step, and then depending on the answer, remember, we're computing worst case. The answer in the worst case is when it is not going to be found in the sequence. So the worst case it will not be the midpoint. We will have to look at half the sequence. So we will have to again solve the binary search for a new list which is half the length of the old list. So the time taken for n elements is one, plus the time taken for n by two elements. So we want an expression for t of n, which satisfies this. So this is what is called a recurrence normally. So what function t of n would satisfy this? One way to do that is to just keep substituting and see what happens. So we start unwinding, as it said. So we have this by the same recurrence should be one plus t of n by four, right? Because I take this and have it. So t of n is one plus one plus t of n by four. So if we start with one plus t of n by two, and I expand this, then I get one plus one plus t of n by two squared. And in this case, I'll again get one plus one plus one by t of n by two cubed. So in general, after k steps, we will have one plus one plus one, k plus one times, or k times, and t of n by two to the k. Now, when do we stop? Right? We stop when we actually get t of zero. Or we can also say that for t of one, it takes one step, just if you want to be careful. So when this expression becomes one, so when n is equal to two to the k, so when is n equal to two to the k, this is precisely the definition of log. How many times do I have to multiply two by itself in order to get n? And that's the value of k that we want. So after log n steps, this term will turn out to be one. So we will end up with roughly log n times one added up. And so we'll get log n steps. So what we are saying is really, if we start with 1000 values in the next step, we'll end up searching 500, next step, 250, next step, 125, next step, 62 and so on. And if we keep doing this, when will we get to a trivial sequence of length, zero or one? Well, we keep dividing thousand by two. How many times can we divide thousand by two? That's precisely the log of thousand to the base two. That's an equivalent definition of log. So this comes back to another point. Now, we have said that if we add a sorted sequence of values, we can do this clever binary search. But remember that it requires us to jump in and compute mid, which is fine. And we need to then look at the value at the midpoint. And we are assuming that this computation of mid and comparing the value with the midpoint took a constant amount of time. That's why we said that it is one plus t, n by two. This one involves computing mid and looking up the sequence at the midpoint. But this can only be done for arrays, because only for arrays can we take a position and jump in and get the value at that position in constant time. It will not work for lists because we need to look up the sequence at the ith position in constant time. Of course, one important and probably not so obvious thing if you think about binary search is that by only looking at a very small number of values, say so, for example, we give you a sorted list of thousand entries. As I said, if a value is not there, we only have to search ten possible entries because we keep halving after log n, which is about to remember the two to the ten is one, zero, twenty four, two times two times 210 times is 100:24 so after ten halvings of 1000 we would have come down to zero or one. So we would definitely be able to tell quickly whether it's there or not. So we only look at ten values out of 1990, values we don't look at at all, unlike the unsorted case where we have to look at every possible value before we solve. So it's very efficient binary search, but it requires us to be able to jump into the ith position in constant time. And therefore, if I actually did a binary search on a list, even if it is sorted, and not on an array, where I have to start at the zero th position and walk to the ith position by following links, unfortunately, binary search will not give me the expected bonus that I get when I use an array. So having discussed this abstractly, we are of course working in the context of Python. So the question is, are built in lists in Python, are they lists as we have talked about them, or are they arrays? So actually the documentation would suggest, if you look at the Python documentation, that they are lists, because you do have these expansion and contraction functions. So we saw we can do an append or we can do a remove of a value and so on. So they do support these flexible things which are typical of lists. However, Python supports this indexed position, right? So it allows us to look for a to the I, and if you try it out on a large list, you will find that it actually doesn't take that much more time to go. To say you construct a list of 100,000 elements, you will find it takes no more time to go to the last position. As to the first position as you would normally expect in a list, we said that it should take longer to go to the last position. So although they are lists, as far as we are concerned, we will treat them as arrays when we want to, and just to emphasize how lists work. When we go further in this course, we will actually look at how to implement some data structures, and we will see how to explicitly implement a list with these pointers which point from one element to the other. So for the rest of this course, whenever we look at a Python list, we will kind of implicitly use it as an array. So when we discuss further sorting algorithms and all that, we will do the analysis for the algorithms, assuming they are arrays. We will give Python implementations using Python's built in list. But as far as we are concerned, these lists are equivalent to arrays for the purpose of this course. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Assignment Statement and Operators in C.mp3,"In the last lecture, we encountered a special notation like this where we, we can put in ampere sand and a variable name to denote the address of that particular variable. Right? So that is what we encountered in the earlier class. Next, now we'll be moving ahead towards some statements which are absolutely essential for writing any c program. Just as in English, we write different types of sentences. Similarly, in the language C, just as it is a language, there are again different types of statements that we can write and through which we can express what we want to do. The simplest type of statement that we have already encountered about is assignment statement. Assignment statement means I have got some contents in some register, some register say x, some memory location, say variable x, and has got some value. 50. Now, how does this value come over here? Initially it was not there. So suppose I have got memory location, variable, say speed, and I want to put in some value into this location. All right, say 500. So what we do, we write speed assigned 500. Semicolon. So the general syntax for that is a variable name followed by the expression, okay, the variable name followed by the expression. As you have written here, speed is the variable name, and the expression here is nothing but a constant. All right, it could be something else. For example, I could have written speed assigned two times 500 or maybe v times q. Whatever speed is assigned v times q. Here are some examples of such assignments. As you can see here, velocity is a variable, right? On the left hand side, the variable name is there. On this side is an expression. Now, what type of expression is this? 20 is nothing but a constant value. Please note that all the statements must be ended with a semicolon. Look at the second one. B assigned 15. Again, a constant. Look at the third one. Temp assigned 12.5. So what type of variable is temp? You will immediately answer, temp must be a floating point variable or real number. Here you see a different type of expression. A variable a is being assigned the variable a plus ten. What does it mean? So, a assigned a plus ten. So a being a variable a is a memory location. And suppose it has got some value, 25.7. If a is a floating point variable. Now, if I do a assigned a plus ten, that means whatever is there as the value of the variable a is taken out. So we take out, we read 25.7, add ten with that, and we get 35.7. And then this 35.7 comes in here and I get a new look of a. The same location will now hold 35.7. So you see, the left hand side is the destination, where the new value, after computation of the expression will go. And the left side, sorry, the right side can have the same variable as a source or might be the. Some other variable, could be some other variable also, like here, this expression. You see, I am using three variables here. V is one variable, u is one variable. I'm sorry, I'm using four variables here. F is another variable and t is another variable. Now, suppose u has got some value 20. F has got some value zero five, and t has got some value two. Then v is being computed as u is being taken, 20 plus the product of these two, two and five. So two and zero five will be one. And one is being added to 20. So these two being added is becoming 21, and this 21 is filling up this variable, v. All right, so here you can see, I can use more number of variables. I'm sorry, this is, let's be a little nice. So it should be 21.0. Similarly, here you see, it's a mix of variables. How many variables are here? S is a variable. U is a variable. T is a variable. Ftt. Ft. So one, two, three variables are there again, U-F-T and s. All right? And there is a constant zero five. So this side entirely, this side is the expression. Similarly, this is again an expression. This is an expression. This is also an expression. We'll see more of these expressions in a moment. All right, so, a value can be assigned to a variable when the variable is declared. For example, when I am declaring a variable, just starting, I want to declare a particular variable. And so I want to declare a variable, maybe acceleration. Acceleration. All right, now. And I say that acceleration is a real number. So when I declare it, I'll write float acceleration. And then at some point later on, I can say acceleration assigned, say 2.5. This is one way. The other way is that I could have written it when I declared it as float acceleration assigned or initialized to 2.5. This is also allowed in c. Okay, so a value can be assigned when it is declared. For example, here, speed is an integer, which is being declared as an integer. And along with that, it is being assigned the value 30. Here you see the care is a type of another variable flag. And when I am saying that it is, a flag is a character. Along with that, I am also assigning it to value y. Now, you understand, you remember that within the single quote means it is the integer. It's a character string. So I could have done it also like this. Care flag. And then later on, flag assigned y. And this is equivalent to what I did here. Okay, several values can be assigned the same value using multiple assignment operators. What does it mean? As soon as we see the example, it will be clear. For example, A-B-C all these are being assigned the value five. Flag one and flag two. Both are being assigned the value y. Speed and flow both are being assigned the value 0.0. So here, say, for example, the correct thing would be to say float, speed, flow assigned 0.0. Okay? So that is the simplest possible way we go about it. Now, when we write an expression, first thing we have seen now is the assignment statement. Now, in the assignment statement, if you have seen in the earlier slide, we are using some operators. For example, u assigned, say v minus f times t. This is an assignment statement. Here is the assignment. Okay, but on this side, I have written an expression. So how can we write an expression in c? We have seen quite a few examples of such expressions in the earlier slides, right? We have seen different types of expressions like s assigned u times t plus zero, five times f times t times t. So you will immediately recall that this is our standard school formula. S is equal to ut plus half f t square. Right? Now, this expression has got two components. This well known expression in school has got two components. One side is the expression here which has to be computed and then that has to be assigned to another result or another variable. So that is being written here. Now, this is the way an expression is written in C. You cannot just write it in this way as we are doing in our school. This is not possible. We have to write it in this way. Okay? Now here when we write this expression, you please observe a couple of things. Look at these. This, these are known as the operators. You know that this is meaning multiplication. This is meaning addition. These are again multiplication symbols. Now, there are sets of allowed operators in C. Just as every language allows some constructs to form sentence and some other constructs are not valid in a sentence formation similar to that in the programming language c. Or for that matter for any programming language, there are some allowed operators by which we can form expressions. Okay, so we have got three types of operators. The type of operators that we have encountered till now, we have seen till now are arithmetic operators. But besides arithmetic operators, there are two other types of operators called relational operators and logical operators. Okay, so let us see a little more of this. Arithmetic operators. These are some of the very familiar arithmetic operators, right? You know that this means addition, normal subtraction. This is division. Remember, unlike this sort of division that we use in school, we use here this symbol for division, unlike this symbol that we use for multiplication here, we use this symbol and new symbol that we are introducing here, is this symbol like the percentage sign. Now, this does not mean percent computing percentage. It means modulus. What does modulus mean? Say the modulus means finding the remainder. For example, if I compute 15 modulus three, that means I am dividing 15 by three, and whatever is the remainder is my result. So what is my remainder here? Remainder is zero. Okay, so modulus is basically the remainder operator. So another example, let's look at, say I have got 27 modulus two. What would the result be? 27 divided by two. The quotient is 13, right? Quotient is 13, and the remainder is one. So this modulus will be one. Whereas if I had done 26 modulus two, that would be zero. Now again, observe, if I, instead of modulus operator, if I had done 26 divided by two, the result would be 13. So this gives you the quotient, whereas this gives you the remainder. All right, so this is a new operator that we are coming across, and you should keep that in mind. Next, let's proceed. Now here are some examples. Distance is rate, or velocity, or speed multiplied by time. Please note again, as I have told earlier, also, that any expression must end with a semicolon, as is being done here. What does this mean? Can you read this variable? Can you read this variable? Is it meaningful? Net income is income minus tax. So operator is minus, and this is the arithmetic expression. And this is the arithmetic operator. Speed is distance divided by time. Again, ended with a semicolon. Speed is distance divided by time. How do we find the area of a circle? PI. You remember PI. We can define PI. We had seen this example earlier. Hash defined PI 3.15, et cetera, et cetera. We could have done that. So PI is a constant. Times radius. Times radius. Here, basically, what I am computing is area is being assigned. Here is the assignment operator, and the expression is PI, r square. Now this expression, I am writing in this way, PI times r radius, times radius. Okay, here is another expression. Y assigned ax square. What does it, how do we write it? Typically in school, this is expression, which is ax squared plus bx plus c. All right, this is a very familiar expression of a quadratic expression. Now, when we write it again, here, you see how many operators I have. I have got two multiplication operations, three multiplication operations, and two addition operations, right? And one assignment operation. So here again, quotient is dividend divided by divisor. Now, this is exactly what I was telling a couple of moments back that this operator is actually returning you the quotient, all right, of a division operation. And this is actually giving you the remainder of a division operation. So here are some examples of arithmetic expressions. You suppose X and Y are two integer variables and whose values are, we know, 13 and 15. Then x added to y, x plus y, arithmetic operator plus will give me 18 x minus y, 13 minus five will give me eight. Now, the point to note here is that here again, always try to think in terms of our memory location diagram. X and Y are two variables. X is 13 and y is five. So x plus y means the content of the location x plus the content of the location y. X minus y is the content of the location x minus the content of the location y. Similarly, when we multiply, it is 65. Now, if I add an assignment with this operation, with this operation, I just add an assignment. For example, I write, I am giving two variations, z assigned x times y. That means what? There is another location z where the content of X and the content of Y are taken and multiplied. And 13 times five is 65 that is stored there. And that is possible because I have assigned it here. Again, I could have, as an alternative, could have done x assigned x times Y. What would have happened? In this case, the content of X would have been taken, 13 multiplied with the content of Y, that is 513. And five would be 65. And this product, 65, where would that be written? It would be written in X Y because it is being assigned to X. So then this would be overwritten with 65. Okay, similarly, you will recall now, X divided by two. This is a division. So I'm expecting the quotient 13 divided by five. What will be the quotient? Two. But x modulus Y would be the remainder of when I divide 13 by five, so that modulus is three. Okay, now, in an expression, we can have different operators. If more than one different operator occurs in a particular expression, how will that expression be evaluated? So now we are concerned about how we'll evaluate or find the result of computing an expression. Okay, now here is a list in decreasing order of priority. So if I have something like this, say x assigned p plus q times z minus x divided by L plus m. Now, here you can see that I have got different operators. What are those? Our well known operators are plus multiplication, minus division, plus. Again, here is another operator that is parenthesis. Now, as we learned in school algebra that the parenthesis has got the highest priority. All right, so I will first compute the elements which are within the parenthesis. So first p plus Q will be computed. Then L plus and L plus M will be computed. Now out of this p plus Q and L plus M, which one will be computed first? Whenever these two, these are of the same priority, these parentheses. Now, if there be more than one operator of the same priority, they will be computed left to right. So first we'll have p plus Q computed. All right, suppose that is something, say, let's call it a some value a times z minus x. Suppose this is computed to be some constant b. So in that way it will be computed. So the parentheses has got the highest priority. Next, after parenthesis it is unary minus. Unary minus means usually when we write something like x minus y, then I have got two variables on which I am carrying out this subtraction. This is a binary operator in the sense that I am needing two variables or two constants, two elements on which I am carrying out this computation. Unary minus means that particular variable is being operated on. For example, if I had something like this minus x plus 7.5 semicolon, and suppose x was 2.5, so what will be the value? X is 2.5, so first this will be done, so it will be -2.5 plus 7.5. So the result will be then five. It's not that. I'll first compute this 2.5 plus 7.5 and then do the negation. All right, so the unary minus. So here I had shown a variable. It could be something constant, also minus two plus six. That means you all know that six subtracted by two, although it is plus, because this has got the higher precedence. Okay, the next one is multiplication, division, and modulus. These three will have the same priority. Multiplication, division, and modulus. These three operators will have same priority. Therefore, if I have an expression like say x division y multiplied by z modulus q, how will that be? Which one will be done first? This and this have got the same priority. Therefore we'll be carrying it out left to right. All right, but if the expression was something like this minus x divided by y multiplied by z modulus cube, then which one would be done first? This unary minus would be done first, followed by these three candidates, which will be done left to right, left to right. Okay, next comes addition and subtraction. So if I have got an expression again like say x times y, even before that, let me put it p plus x times y divided by z minus q, then in which order would it be computed? First plus will not be computed. Multiplication has gotten higher priority. This also has got a higher priority. So out of these two, which one will be done first? Left to right. So first I'll do this. Suppose this is yielding a result, a. So it will be p plus a, then divided by z minus q. And then this one will be done because left to right of the same precedence. Suppose it is b. Then it turns out to be p. It turns out to be p plus b minus q. All right, now out of this, plus and minus have got the same priority. Then which one will be done first? This part will be done first. Suppose that is c, c minus q. This is how this entire operation will be done. For operators of the same priority, they valuation is from left to right. Okay, in the next class we'll see some more examples of this and we'll proceed further. Bye.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"assignment statement, basic types - int, float, bool.mp3","Last week we were introduced to the notation of algorithms. Using the DCD example. We also saw informally some Python code which we could understand, but we have not actually been introduced to formal Python syntax. So let's start with some real Python. This time, a typical Python program would be written like this. We have a bunch of function definitions followed by a bunch of statements to executed. So remember that we said Python is typically interpreted. So an interpreter is a program which will read Python code and execute it from top to bottom. So the interpreter always starts at the beginning of your Python code and reads from top to bottom. Now, a function definition is a kind of statement, but it doesn't actually result in anything happening. The Python interpreter merely digests the function. It kind of remembers the function definition, so that later on, if an actual statement refers to this function, it knows what to do. So in this kind of organization, the execution, which actually would actually start with the statement, which is called statement one. So first you will digest k functions, and then start executing 1234 up to statement n. Now, there's no reason to do this, so Python actually allows you to freely mix function definitions and statements. And in fact, function definitions are also statements of a kind. It's just they don't result in something immediately happening, but rather in the function being remembered. But one of the things that Python would insist is that if a function is used in a statement that has to be executed, that function should have been defined already. Either it must be a built in function, or its definition must be provided. So if we use this kind of jumbled up order, we have to be careful that functions are defined before they are used. Also, jumbling up the order of statements and function definitions in this way makes it much harder to read the program and understand what it's doing. So though it's not required by Python as such, it is strongly recommended that all function definitions should be put at the top of the program, and all the statements that form the main part of the code should follow later. So what is a statement? Well, the most basic statement in Python is to assign a value to a name. So we see examples, and we have seen examples, and here are some examples. So in the first statement, I is a name, and it's assigned a value five. In the second statement, j is a different name, and it's assigned an expression two times I. So in this expression, the value of I will be substituted for the expression I here. So if I has not already been assigned a value before, Python would not know what to substitute for I, and it would be flagged as an error. So when you use a name on the right hand side as part of an expression, you must make sure that it already has a valid value. And as we saw, you can also have statements which merely update a value. So when we say j equal to j plus five, it's not a mathematical statement that the value of j is equal to the value of j plus five, but rather that the old value of j, which is on the right hand side, is updated by adding five to it, and then it gets replaced as a new value of j. So this is an assignment statement. This equality assigns the value computed from the right hand side, given the current values of all the names to the name given on the left hand side, and the same name can appear on both sides. So the left hand side is a name. The right hand side in general is an expression. And in the expression you can do things which are legal given the types of values in the expression. So values have types. If you have numbers, you can perform arithmetic operations, if you have some other things, you can perform other operations. So what operations are allowed depend on the values. And this is given technically the name type. So when we say type of value, it's really specifying what kinds of operations are legally available on that class of values. So the most basic type of value that one can think of are numbers. Now, in Python and in most programming languages, numbers come in two distinct flavors, as you could call them, integers and numbers which have fractional parts. So in Python, these two types are called int and float. So int refers to numbers which have no decimal part, which have no fractional part. So these are whole numbers. They could be negative. So these are some examples of values of type int. On the other hand, if we have fractional parts, then these are values of type float. So normally in mathematics, we can think of integers as being a special class of, say, real numbers. So real numbers are arbitrary numbers with fractional parts. Integers are those real numbers which have no fractional part. But in a programming language, there is a real distinction between these two, and that is because of the way that these numbers are stored. So when Python has to remember values, it has to represent this value in some internal form, and this has to take a finite amount of space. So if you're writing down, say, a manual addition sum, you will write them down on a sheet of paper. And depending on the sheet of paper and the size of your handwriting, there is a physical limit to how large a number you can add on that given sheet of paper. So in the same way, any programming language will fix in advance some size of how many digits it uses to store numbers. And in particular, as you know, almost all programming languages will internally use a binary representation. So we can assume that every number, whether an integer or a real number, is stored as a finite sequence of zeros and ones which represents its value. Now, if this happens to be an integer, you can just treat that binary sequence as a binary number, as you would have learned in school. So the digits represent powers of two. Usually there will be one extra binary digit zero or one to indicate whether it's plus or minus. And there may be other more efficient ways of representing negative numbers. But in particular, you can assume that integers are basically binary numbers, so they're just written as integers in binary notation. Now, when we come to non integers, then we have two issues. One is we have to remember the value, which is the number of digits which make up the fractional part, and then we have to remember the scale. So think of a number in scientific notation, right? So you normally have two parts. When we use things in physics and chemistry, for instance, we have the value itself, that is, what are the components of the value. And we have how we must shift it with respect to the decimal point. So this says move the decimal point 24 digits to the right. So this first part is called the mantisa, and this is called the exponent. So when we have a number in memory, if it is an int, then the entire string is just considered to be one value. Whereas if we have block of digits which represents a float, then we have some part of it, which is the mantisa, and the other part which is the exponent. So the same sequence of binary digits, if we think of it as an int, has a different value, and if we think of it as a float, has a different value. So why float, you might ask? So, float is an old term from computer science called floating point. It refers to the fact that this decimal point is not fixed. So an integer can be thought of as a fixed decimal point at the end of the integer. A floating point number is really a number where the decimal point can vary, and how much it varies depends on the exponent. So there are basically fundamental differences in the way you represent integers and floating point numbers inside a computer. And therefore one has to be careful to distinguish between the two. So what can we do with numbers? Well, we have the normal arithmetic operations, plus minus multiplication, which has a symbol star, not an x, and division, which has a symbol slash. Now, notice that for the first three operations, very clear. If I have two ints and I multiply them or add them or subtract them, I get an int. If I have two floats, I will get a float. Division, on the other hand, will always produce a float. So if I say seven and divided by two, for instance, where both are ints, I will get an answer 3.5. Now in general, Python will allow you to mix ints and floats so I can write eight plus 2.6 even though the left is an int and the right is a float, and it'll correctly give me 10.6. So in that sense, Python respects the fact that floats are a generalized form of int. So we can always think of an int as being a float with a zero at the end. So we can sort of upgrade an int to a float, if you want to think of it that way, and incorporate it in an expression. But division always produces floats. So seven divided by 3.5 is an example of a mixed expression where I have an int and a float, and this division results in 2.0, and seven by two results in 3.5. Now there are some operations where we want to preserve the integer nature of the operands. We have seen one repeatedly in GCD, which is the modulus operator, the remainder operator, but the corresponding operator that goes with the remainder is a quotient operator. So if I use a double slash, it gives me the quotient. So nine double slash five says, how many times does five go into nine exactly without a fraction? And that is one, because five times one is five and five times two is ten, which is bigger than nine, and the remainder is four. So 9% five will be four. Another operation which is quite natural and common is to raise one number to another number, and this is denoted by double star. So three double star four is what we would write normally as three to the power four is three times three times three times three four times, and this is 81. Now there are more advanced functions like log, square, root, sine, and all, which are also built into Python, but these are not loaded by default. If you start the Python interpreter, you have to include these explicitly. So remember we said that we can include functions from a file that we write using this import statement. So there is a built in set of functions for mathematical things, which is called math. So we must add from math import star. This can be done even within a Python program. It doesn't have to be done only as the interpreter. So when we write a python program where we would like to use log, square root and sine and such like, then we should add the line from math import star. Before we use these functions. So we have seen three concepts, names which are what we used to remember, values, values which are the actual quantities which we assign to names. And we said that there's a notion of a type, right? So a type determines what operations are legal given the values that we have. So the main difference between Python and other languages is that names themselves don't have any inherent type. I don't say in advance that the name I is an integer or the name x is a float. Names have only the type that they are currently assigned to by a value that they have. So the type of a name is not fixed. In a language like c or c plus plus, or java, we announce our names in advance. We declare them and say in advance what type they have. So if we see an I in an expression, we know in advance that this I was declared to be of type int and this x was declared to be of type float, and so on. Now, in Python this is not the case. So let us illustrate this with an example. So the main feature of Python is that a name can be assigned values of different types as the program evolves. So if we start with an assignment I equal to five, since five is an int, I has the type int. Now, if we take an expression which produces an int such as seven times one, I remains an int. Now, if we divide the value of I by three, so at this point, if we had followed the sequence I is seven, so seven by three would be 2.33, and this would be a float. So therefore, because the operation results in the float, at this point, j is assigned a value of type float. Now, if we continue, and at some later stage, we take I and assign it the value two times j, since j was a float, I now becomes a float. In the interpreter, there's a useful function called type. So if you type the word type and put an expression and either a name or an expression in the bracket, it will tell you actually the type of the expression. Now, although Python allows this feature of changing the type of value assigned to a name as the program evolves, this is not something that is recommended, because if you see an I and sometimes it's a float and sometimes it's an int, it is only confusing for you as a programmer and for the person trying to understand your code. So in the same way that we said before that we would like to organize our python code so that we define all functions before we execute statements, it is a good idea to fix in advance. In your mind at least, what different names stand for and stick to a consistent way of using these either as ints or as floats. So let's execute some code and check that what we have been saying actually happens. So supposing we start the python interpreter and we say I is equal to five. Then if we use this command type I, it tells us the type of I. So it returns it in a form which is not exactly transparent, but it says that I is of class int. So you see the word int. If I say j is equal to 7.5 and I ask for the type of j, then it will say that j is of class float. So the names int and float are used internally to signify the types of these expressions. Now, if I say I is equal to two times j, as we suggested, I has a value 15.0 because j was a float, and therefore the multiplication resulted in a float. And indeed, if we ask for the type of I at this point, it says that I is now a float. So the point to keep in mind is that the names themselves don't have fixed types. They are not assigned types in advance. It depends on the value that is currently stored in that name, according to the last expression that was assigned. Another important class of values that we use implicitly in all our functions are boolean values which designate truth or falseness. So there are two constants or two basic values of this type, which in Python are called true with a capital t and false with a capital f. So true is a value which something is true. So when we remember we wrote conditions like if something happens, if x is equal to y, do something, or if x mod seven is equal to something, do something. In our DCD function. So the output of such an expression, where we compare something to another expression, compare an expression on the left to an expression on the right, is to determine whether this comparison succeeds or fails. When it succeeds, it is true, when it fails, it is false. So these are implicitly used to control the execution of our program. So we need to have a way of recording these values and manipulating them. So the basic values are true and false. And typically there are three functions which operate on these values, so not negates the value. So true is the opposite of false, so not applied to true will give us false not applied to false will give us true and follows the usual english meaning of and so when we say that something is true and something else is true, we mean that exactly both of them are true. So x and y, two values of Boolean type will. The expression x and y will be true, provided at the moment, x has a value true and y also has a value true. If either of them is not true, then the output x and y is false, or again, has an english meaning. But the meaning in computer science and logic is slightly different from what we mean. So normally when we say or, we mean one or the other. So you might say either I will wake up in time or I will miss my bus. So what you mean is that one of these two will happen. It's unlikely that you mean that you will wake up in time and you will miss your bus. So when we use, or in English, we usually mean either the first thing will happen or the second thing will happen, but not both. But in computer science and logic, or is the so called inclusive or not exclusive? It's not exclusively one will happen or the other, but inclusive, both may happen. So x or y is true. If at least one is true, so one of them must be true. But it's also possible that both of them are true. So the most frequent way in which we generate Boolean values is through comparisons. So we have ALreadY SEen two of these. So we have seen equal to equal to. So this is the actual equality of mathematics, not the single equal to, which is assignment. So x equal to equal to y checks whether the value x is actually the same as the value y, and if so, it returns the value true, otherwise it returns false. And the corresponding inequality operator is an exclamation MarK FOLlowed. So this is not equal to exclamation. Equal to is a symbol for not equal to and this is the usual mathematical equal to and then of course, you have for values which can be compared as smaller or larger, you have less than, greater than, this is less than equal to and this is greater than equal to. So we have these six logical comparison operators, arithmetic comparison operators, which yield a logical value true or false. And the usual thing we will do is combine these. So we might want to say that. Check if the remainder m divided by n is zero, provided n is zero, not zero. So if you say n is greater than zero and this, it will require n to be number bigger than zero and the remainder m divided by n to be equal to zero. So this says m is a multiple of n and n is not zero. And we can take an expression of this kind, a kind of comparison, which yields, as we said, a Boolean value, and take this boolean value and assign it to a name. So we can say that n is a divisor of n. If the remainder of M divided by n is zero, and we can say that the fact that it's a divisor is true, provided this happens. So, divisor is now of type bool, and it has a value of true or false, depending on whether or not n divides m evenly. So let's look at an example of how we would use Boolean values. So let's get back to the divides example. So, in mathematics, we write m divides n to say that m is a divisor of n. So this means that m times k is equal to n for some k. So m divides n if the remainder of n divided by m is zero. So if so, you return true, else you return false. So this is a very simple function. It takes two arguments and checks if the first argument divides the second argument. Now what we can do is define another function, called even, whose value is derived from here. So we check whether two is a divisor of this number. So we check whether two divides n. If two divides n, then n is even. We return true. If two does not divide n, n is od, we return false. So similarly, we could say define odd n as the negation of the previous case. So if two divides n, then n is not od. So you take the answer about whether two divides n or not, and reverse it to get the answer od. So if two divides n, you negate it and say od is false. If two does not divide n, you get false back, you negate it and say od is true. So we just wanted to emphasize that BooleAn values can be computed, assigned, passed around, just like numerical values are. So, to summarize, what we have seen is that the basic type of statement is to assign a name to a value. Values have types, and these determine what operations are allowed. So we can use, for instance, arithmetic operations. On numeric types, we can use logical operations like and or, and not on BooleAn types. But the important difference between Python and traditional languages, where we declare names in advance, is that Python does not fix types for names. So we can't say that I has a type int forever. I will have a type depending on what it's assigned. So a name inherits the type from its currently assigned value, and its type can change as the program evolves depending on what values have been assigned. So what we have seen in this particular lecture are three basic types, int, float, and bool. As we go ALong this week, we will see more types with interesting structures and interesting operations defined on them.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"backtracking, n queens.mp3","It. For many problems, we have to search through a set of possibilities in order to find the solution. So there is no clear solution that we can directly reach. So we have to systematically search for it. So we keep building candidate solutions one step at a time. Now, it might be that the solution that we are trying to get doesn't work. So we hit a dead end, and then we undo the last and try the next option. Imagine, for instance, if you're solving a sudoku, so you have a grid, and then you start filling up things. And then at some point, you realize that there's nothing you can put here. So then you go back and you have to change something you did before. So we have to backtrack. We have to go forwards trying to solve the problem. And at some point, when we realize that we are stuck, we cannot solve the problem again. We have to go back and change something we have done before and try something else. So, one of the classic problems of this coin is called the eight queens problem. So the problem is to place eight queens on a chessboard so that none of them attack each other. Now, if you have ever played chess, you would know that a queen is a very special piece. It can move any number of squares along a row, column, or diagonal. So, for instance, if you place a queen here in the third row and the third column, then it could move anywhere, up or down the third column, anywhere left or right on the third row and along the two diagonals on which the square three, comma, three lies. Now, since it can move along these columns, it can also capture any piece that lies along these rows. So the queen is set to attack all these squares. So the squares to which the queen can move are set to be attacked by the queen. So our goal is to place queens so that they don't attack each other. So if we have a queen here, then we can't put another queen in any of the red squares. We have to put it somewhere else. So, for instance, we could put a new queen, say, for instance, here, this would be okay, or here. And then if I put a queen here, in turn, it'll attack more pieces, like it will attack these squares, and it'll rule out some more options. I will not be able to place queens there and so on. So we want to see if we can place eight queens. Now, we can't place more than eight queens because there are only eight rows. If you place nine queens, two will be on the same row or the same column, so they will have to attack each other. So eight is clearly the limit, the question is whether we can actually put eight. So we can generalize this question and ask not for eight, but n. Supposing I have a chessboard in which there are n rows and n columns. Can I place n queens on such a chessboard? Now, for n equal to one, the question is trivial because you only have to put one queen on one square. Now, it's easy to see that n equal to two is impossible, because if I have two squares and wherever I put a queen, say here, it will attack all the remaining squares. So no matter where I put the queen, every other square will be on the row, column or diagonal of that queen. And so there's no possibility of putting a second queen. It turns out that three is also impossible. So supposing we start by putting a queen on the top left corner. Then you'll see that it blocks out the first column, the first row and the main diagonal. This leaves two slots open for the second queen. But wherever we put whichever of the two we put, it will block the other one, right? So once we put a queen in one of those slots, the other one is on the same diagonal, and there is no free slot for the third queen. So just by exhaustive analysis, we can show that n equal to three is actually impossible for n equal to four. For a four x four board, it does turn out to be possible. We should not start at the corner, but one off the corner. So supposing we put it in the second column. Then we get this pattern of blocked squares. Then we can find an empty slot on the second row right at the end. So we put a queen there. It blocks off certain or some more squares in the last column and in that diagonal. But this still leaves one slot on the third row. Unfortunately, the third queen doesn't block the last slot on the fourth row. And we have this kind of symmetric pattern where everything is one off the corner in which none of the queens attack each other. Now, it turns out that once we cross n equal to four for 5678, you can show that there is always a solution possible. Our task is to find such a solution. How do we find a solution for n greater than or equal to four? So, as we observed, the first thing we know is that there can be exactly one queen in each row and in each column, because queens attack the column and row on which they lie. So if we have two queens in the same row or the same column, they will necessarily attack each other. Since eight is the classical size of a chessboard, let us do specifically an example for eight queens. So we want to place the queens now row by row. We know that there are exactly one queen in each row. So let's first put a queen in the first row. Then based on that, put a queen in the second row and so on, exactly as we did for the four x four case that we saw in the previous slide. So, in each row, we would place a queen in the first available column, given the queens that have already been placed so far. By available, we mean a square which is not attacked so far. So we start with an eight by eight board and in the first row now everything is available. So by our analysis, we are going to put a queen in the first available column, maybe in the top left. Once we do this, it blocks out the first row and column and the main diagonal. So all the shaded squares are now under attack. We move to the second row and we try to put a queen in the first available column. This is the third one. And this in turn will attack another set of rows, columns and diagonal squares. Now we move to the third row, and in the fifth column we can place a queen. And this one again attacks some squares. So we have added some colors to indicate, as each new queen is placed, which squares are newly under attack by the new queen. Some of them are attacked by multiple queens. For instance, the yellow queen attacks the blue square on the diagonal, which was already attacked by the first queen. So we leave it blue for now. In this way, we can proceed. So we put a fourth queen on the fourth row, and then. This is a mistake. This should be already attacked by this queen. And then we place a fifth queen, and then a 6th one, and then a 7th one. And now we find that all the squares in the 8th row are actually blocked. So there is no way to extend the solution to put the 8th queen. So we have to do something about this. We can't place a queen in the 8th row. So since we can't replace the queen in the 8th row, we have to go back and change something we did before. Now, the last thing we did was to put a 7th queen. So we do that and we find that unfortunately for the 7th queen, we had only one choice, so we have no other choice for the 7th queen. So though the 7th queen could not lead to a solution, it was not the choice of the 7th queen, which actually made a problem, but it was something earlier. So then we go back and try to move the 6th queen. So once again, if we remove the 6th queen, then this unblocks a few squares, but at the same time, there was no other place to place the 6th queen on the 6th row. So again, this was a unique choice that we had made. Now, if we go back to the fifth queen, then we find that there is a way to place the fifth queen in a different place, namely to move it to this slot so we can move this fifth queen to one slot to the right and try again. So, having gone back from the 8th square, which 8th row, which is completely blocked, to the 7th row, which had only one choice, to the 6th row, which had only one choice, we come back to the fifth row and now we try the next choice for the fifth row. So we try the next choice for the fifth row, then we get this pattern of squares. And now we see, for example, that we can't put a 6th thing. So both the choices for the fifth row actually turn out to be bad. So we would now have to go back and try a different choice for the fourth row and so on. So this is what backtracking is all about. We keep trying to extend the solution to the next step. If we cannot, we undo the previous move and try again. And in this way, we exhaustively search through all the possible solutions. But we do it in a systematic way. We don't go back and randomly reshuffle some of the choices we made before we go back precisely one step and undo the previous step. So at each step we have a number of choices. We go through them systematically. For each choice, we try to extend the solution. If the solution does not get extended, we come back, we try the next choice, and when we exhaust all choices, this level, we report back to the previous level that we have failed. Then they will try their next choice, and so on. So the key to backtracking is to do a systematic search through all the possibilities by going forwards and backwards, one level at a time. So how would we actually encode this kind of an approach specifically for the eight queens problem? So our first question is how to represent the board. Because the board is what keeps changing as we make moves and undo them. So the most obvious way for an n queen solution is to represent the board literally as an n by n grid. And since Python numbers list position from zero onwards, we have an n by n grid, and we number the columns not one to n, but zero to n minus one. So we'll have rows zero to n minus one and columns zero to n minus one. And we can now put a value one or zero or true or false, to indicate whether or not there is a queen at the Square. I comma j, I is the row, j is the column. So, we can have a two dimensional list, bold a list of lists which has n minus one by n minus 10 to n minus one and zero to n minus one as a valid indices. And we say that bold I, j is one to indicate that the queen is at I comma J. And therefore if it is zero, it indicates there is no queen. So there are two possible values for every square. Of course, we also know that there is only one queen per row. So this particular thing, though it has n minus n into n n squared entries, it will only have actually n ones at any given time. So we can optimize this slightly by just having a single list with entries zero to n minus one, where we say that the ith entry corresponds to the ith row and we record the column number. So if board of I is equal to j, it means that in row I the queen is at column j, so the queen is at position I, comma j. So with such a data structure, this is the outline of how our strategy works. So what we have to do is place each queen one at a time. So we are just writing a function which tries to place a queen in row I given the current state of the board. So we pass it the current state of the board as one argument, and we pass it the row number I that we are going to do. So we would initially start it with an empty board and with row zero. Now we run through each column and check whether the column position that is the square I comma c is available. If it is available, we then put a queen there and we of course have to update the board. So we will come back in a minute. But in our case, updating board just means setting board I equal to c if we have the one dimensional representation. Now, if we have actually put the last queen, if I was n minus one, then this is the last queen. So if it is an eight queen problem, then when we have put queen number seven starting from zero, then we are done, so we can return true. However, if this is not the last queen, then we have to continue. So what we need to do is now with the new board, we have to place one more queen. So we recursively call this function incrementing the row to I plus one with the updated board which we have just put. And this will return true or false depending on whether it succeeds or not. So we record its return value in the name extend solution. So depending on whether the succeeds or not, we check if extend solution is true, that is the current position reached the end now? When would it be true if it succeeded in going all the way to level n minus one and n minus one returns true. So when n minus one returns true, then n minus two will return true, and so on, and then our level I will also get the value true. So then we can also return true. So if extend solution returns true, we also return true, saying that so far I'm good. On the other hand, if extend solution returns false, it means that given the current position that I chose for row I, nothing more could be done to extend this to a full solution. So this position must be undone. So we have to undo this move. So we have to, whatever we did earlier to update the board, so this update has to be reversed at this point. So we have to reverse the effect of putting it at iC. Okay? And then when we do this, it will go back and it'll try the next c. And now if we have actually run through all the c's and we have not returned true at any point, then Python has this else, which says that the for loop terminated without coming out in between. So the for loop terminates normally. It means we have run through every possible c that was available, and for none of them did we return true. That means that there is no way to currently put a queen on row I, given the board that we have. So we should return false, saying that the board that we got is not a good one. Then the previous row will now get a false and retry the next position, and so on. So this is the recursive solution that we get. We will see an actual Python implementation, but we have to do a little bit more work to figure out how to actually implement this. So the crucial thing in the implementation that we saw the previous one is that we have to update the board when we place the queen and update the board when we undo it, and we also have to check whether IC is available. So, we had two representations, a two dimensional representation with zeros and ones, and a one dimensional representation, which gives us the column position for each row to keep track of the queens on the board. But in order to determine whether a square is free or not, we need to have a better way to compute how the squares are attacked by queens. So a simple way would be to just say that along with a two dimensional representation of the board, we denote, like we had done pictorially in the example we worked out, we denote by what we had called a kind of colored square, whether or not an attack, a square is attacked. So we say attack ij is one if it is attacked by a queen. Otherwise it is zero. Now, the problem with this is that a given square ij could be attacked by more than one queen, right? So when we undo a queen, it will obviously attack many squares, but not all those squares become free by removing that queen, because some of those squares are also attacked by other queens, which we had placed earlier. So we need to be careful when we remove a queen in order to mark squares which were attacked as being free. Well, one way to do this is to actually number the queens and record the earliest queen that attacks each square. So we say attack ij is k if I, j was first attacked by queen k and attack I, j is minus one if I, j is free. So when we remove queen k, we reset attack ij with value k to minus one, and all other squares are still attacked by earlier queens. So we can explain this very easily with the picture that we had before. So, here is how we had represented our board. When we put the blue queen, we marked all squares that the blue queen attacked with blue as blue solid squares. Then, when we put the red queen, we only attacked when we marked with red those squares, new squares which attacked. For example, this particular square, which is attacked by both red and blue, was already attacked by blue. So we didn't mark it. So, in this way, with each new queen, queen I, that we put, we only mark the squares which are attacked by queen I. So the colors here represent the queen queen numbers. So the blue squares are queen zero, the red squares are queen one, the yellow squares are queen two, and so on. So, when it comes to undoing, for instance, now we want to undo this particular thing. Now, this, when we put it, had only one white square. There was no free squares other than this. So we didn't add any new attack. So, removing it doesn't actually change anything regarding the attack position, only makes that particular square itself free, doesn't unattack any of the other squares. Now, when we remove this orange queen, then we have to remove all the orange squares which were placed under attack only after adding this queen. And that turns out to be these two on the bottom row. So when we undo this one, we will find those two get under. Similarly, when we undo the purple. Okay, so what we had done, actually was precisely this more efficient implementation of how to keep things, how to record what is under attack. Right? So we are going to now keep an attack array which says that attack ij is k if it is first attacked by queen k. And when we remove queen k, we reset to minus one, saying that black square is free precisely if the value is currently k. Now, this would work. The only difficulty is that it requires n squared space. We saw that we could replace the board by a linear thing from n by n array with zeros and ones. We could replace it by a single array which had board I equal to j. So the question is, can we replace attack by a linear array? Now one thing to remember is that though attack itself is an n squared array, undoing the attack doesn't require us to actually look at all the n squared entries. Once we fix the queen to undo, we only have to look along its row, column and diagonal, and remove all entries with the value equal to that queen on that row, column and diagonal. So the updates are not a problem. The updates are linear. Adding and removing a queen only requires us to look at a linear number of cells in this array. But the array itself is quadratic. So can we improve our representation to use only order n space? So, to do this, we just have to look a little closer at the problem. So how many queens attack row I? Now, if you look at the row as a whole, remember we place only one queen in each row and in each column. So only the queen on row I actually attacks row I. Similarly, only one queen is in column j. So therefore there's only the queen in column j, which attacks that column. So if you look at an individual square, then if we are in the center of this, for instance, then this particular square can be attacked from four directions. It can be attacked from the column in which it is, or the row in which it is. Or it can be attacked from this main diagonal or the off diagonal right. So the main diagonal is the one from top left, which I could call northwest. And the one off diagonal is the one from the southwest. So there are four possible queens that could be attacking the square. So there are four directions in which a square could be under attack. So it might be better to represent these four directions rather than the squares itself. The representation we have now is to say that this particular square is attacked by Queen K. But it doesn't tell us from which direction queen k is attacking it. It doesn't tell us whether queen k is attacking it from the row or the column or the diagonal. So rows and columns are naturally numbered from zero to seven. But how about diagonals? Now, if you look at a diagonal from the northwest, so let us call these directions northwest, southwest, northeast, and southeast. If you look at a decreasing diagonal, a diagonal that goes from top to bottom, like this, then what we find is that this difference, the column minus the row, is something that will be the same along every square on that diagonal. For instance, look at this diagonal which starts here. Here the column number is two and the row is zero. So two minus zero is two. If you go to the next item on the diagonal, it's three minus one, which is again two. Then four minus two is again two, and so on. So, if we go along this diagonal for all these squares, c minus r, where c is the column number and r is the row number, the difference is exactly two. And you can check that nowhere else on this square on this grid is this true. As another example, if we look at this particular thing, we have zero minus four, so the difference is minus four. And similarly, three minus seven is also minus four. So everything along this particular diagonal has a difference minus four. Now, if you look at the diagonals going the other way, then we'll find that the sum is an invariant. Here, for instance, we have either six plus zero, or five plus one, or four plus two, or two plus three plus three, and so on. So along this purple diagonal, c plus r is equal to six everywhere. And along this green diagonal, we have seven plus five, six plus six, and five plus seven. So c plus r is equal to twelve. So we can now conclude that a square at position I, j, is attacked if it is attacked by queen in row I, or in column j, or if it is along the diagonal, whose difference is j minus I, or if it's along the diagonal, whose difference is j plus I, whose sum is j plus I. So we can now come up with a representation to only keep track of rows, columns and diagonals which are under attack. And from that we can deduce whether a square is under attack. So we say that rho I is one. If rho I is under attack, where I ranges from zero to n minus one. Similarly, we can have an array which says column I is attacked, and then column I is set to one, provided column I is attacked for, again, I between zero and n minus one. Now, when we look at the diagonals, we have these two types of diagonals. So the northwest to southeast diagonal is the one where the difference is the same. And if you look at the differences, if you go back, then you see the differences at this diagonal. Here, the difference is seven. Minus zero is seven. And here the difference is zero. Minus seven is minus seven. So it goes from plus n minus one to minus n minus one. On the other hand, if you go the other way, then the sum at this point is zero, plus zero is zero, and the sum over here is seven plus seven is 14. So the sums along these diagonals are 01234 and so on. So this is one, this is two, this is three, and so on, right? So we have these northwest to southeast diagonals running from minus n minus one to n minus one. This gives me the number. So this is the difference. If the difference is, say, six, I know which squares are there. If the difference is minus three, I know which squares are there. And the possible range of values is from minus seven plus seven minus n minus one to plus n minus one. And for the other direction it is from zero to two times n minus one. In our case, two times n minus one is two times seven, which is 14. So zero to 14. But if we have an n by n thing, we have two times n minus one. So this gives us an order n representation of the squares under attack. So therefore we look for. If we want to see if an I j square is under attack, we check whether it is row I is one or column j is one or j minus one. Diagonal is one or I plus j diagonal is one. If any of these is one, then it's under attack. If all of these are zero, then it's not under attack. So I j is free, provided row I, column j, the northwest to southeast diagonal j minus I, and the southwest to northeast diagonal j plus I are all equal to zero. When we add a queen at ij, first we update the board representation to tell us that there is. Now the ith row is set to the jth column, and for the appropriate row, column and diagonal corresponding to this square, we have to set all of them to be under attack. So row I becomes under attack, column j becomes under attack, the j minus one diagonal on the decreasing diagonal, and j plus I diagonal on the increasing diagonal all get set to one. An undo is similarly easy. We have to first reset the board value to say that the ith queen is not placed. So we could use, say, minus one. This is not a valid value because the values are zero to n minus one. So minus one indicates that the 8th queen is not placed at this moment. And we reset this row and this column to be equal to zero, because this row and this column are attacked only by this queen. Remember, we cannot have two queens on the same diagonal because they would attack each other. So at any given point, each one of these rows, columns and diagonals is attacked by a single queen, and it must be attacked by the queen at I comma, j so only the queen at I comma j can attack all of these, because if it were under attack by another queen, we could not have placed a queen at I comma j. So the fact that it was free before case that all of these got attacked only by the current queen. So when we remove the current queen, we must reset them back to zero. So one implementation detail for Python is that instead of keeping these five different data structures, we have a board and a row and a column and all that. We can keep it as a single nested dictionary, so it's convenient to call it board. And we'll have at the top five key values indicating the five sub dictionaries. So the queen position we will call the key queen. So instead of saying board I is j, we will say board with queen as the key at position is j. Then we will say instead of row I is one or minus one, we will say that the board at key row is one. Similarly, board at key column, board at northwest to southeast and board at southwest to northeast. Right. So we have just converted it. So we don't have to pass around five different parts to each function. We just have to pass a single board, which is a dictionary which contains everything of interest. So remember that this is how we tried to give our solution. So we wanted to place a queen in Row I, and for each column that is available, we would try to update the bold and so on. So now we have now better ways to do these things. So we have shown that using this dictionary or these five different representations, we can check whether a row and column is available, how to update the board when we place a queen, and we undo the queen. So here we have an actual Python implementation of what we discussed. So we have this function here, which is called place queen. So place queen, we said, takes the row I and the board, and the first thing it does is it has to determine what is the value of n. So we just take. So remember, that board is now dictionary. So board of queen will tell us how many rows there are in the thing. So if we take the length of the keys of board of queen, we get n. So this is just a way of recovering n without passing it around. So now what we do is for every possible value from zero to n minus one, that is for j. For all column values, we check if I, j is free in the current port. If it is free, then we add a queen. This is exactly the code that pseudocode we had. If I is n minus one, we return true. Otherwise we try to extend the solution by placing a queen at the I plus one throw. If the solution does extend, we return true. Otherwise we undo the queen. So undoing the queen will remove this queen and also update the board. And finally, if this loop goes all the way through for every possible column and does not return true, then it means we cannot place a queen on the ith rows. We'll return false. Now, the main function that we have, the main code, will start off by initializing board to be an empty dictionary. It'll ask the user how many queens, what kind of board we have. N by n. So remember, we take the input, it will be a string. We convert it using int, and we record this as n. So it asks for a number, converts it to an int, and passes it as n. Then we will initialize the board with the number n. We need n because we need to know how to set up that. Remember that the indices run from zero to n minus one, or from n minus n minus one plus n minus. So n is required in order to initialize the dictionary. And finally, we try to place the queen. So initialization will set up an empty board where nothing is under attack. Then we try to place the queen in the zero throw on this board. If it succeeds, then we have a function which prints the board. So let's see how these other Functions work. So let us first look at the function which initializes the Board. So initializing the board says that first of all, for every key for each of these subdictionaries, Queen, row, column, northwest, southeast, southwest, or northeast, we first set up a dictionary with that key. So this does create an empty Dictionary. Now, for three of these things, for queen, row and column, the indices are zero to n minus one. So for I in range, we just set up the key value I to point to minus one. In case of queen. That says that the queen and row I has not been placed. And for row and column, these are the attack ones, which says they are zero if they're not under attack, and one if they're under attack. So the initial thing is to say zero. Now similarly, for the northwest to southeast, the range goes from minus n minus minus n minus one to plus n minus one. So if in the range function, since we give the upper bound as n, we set every key in this to zero. Similarly, for zero to two, n two into n minus one, we want to set the southwest and northeast diagonals to be zero. This is one reason here why we are using a dictionary, because for the other things, of course, we could use a list zero to n minus one is the natural list index. But here we have these strange indices which go from minus n minus one to plus n minus one or so on. So that's why we use a two level nested dictionary. So this initializes the Board. How do we print a board? Well, for every row, we sort the rows. So we take Board, queen keys will give us zero, one up to n minus one. In some random order we sort them, and for each such row, we print the row and the column number for that row. So this happens when we have a successful solution. When is a position free? Well, we check whether the row entry is zero. The column entry is zero, the diagonal entry j minus I is zero, and the diagonal entry j plus I is zero. This is exactly as you said before. And finally, what happens when we add a queen? Right, when we add a queen, we have to place it. So we set the queen entry for row I to j, and then we mark the corresponding row, column and diagonal to be one. And when we undo a queen, we set the queen entry to be minus one and the row, column and diagonal entries to be zero. These are all exactly what we wrote in the pseudocode. They've just been formalized in Python code. Now we can run this code and verify that it works. So here we have this code, eight queens py, which is the code that we just saw in the editor. So now if I run this code as Python 3.58 queens PI. So this is, by the way, if you have a Python program, you can run it directly without first invoking it and then importing it. If you do this, it'll ask us how many queens you want. So for instance, if we give it the number four, then we will get the solution that we saw in the earlier example. It's not very printed out very neatly. So if we give the number eight, then we'll get one solution like this. It turns out that you can actually change that print board function. I won't show you the code, but to print it out in a more user friendly way. So I have another function which is called pretty. So if I do this, then it shows me the four queen solution in a more readable form. So you see exactly the kind of off diagonal positions. And if I do for eight queens, then you see there is an extra column. So there is some mistake in that, but there is an extra column. But basically you can see that if you ignore the last column, this is showing you the position of the queens in the first eight queen solution. So it's fairly straightforward. Once we have got the representation worked out and the structure of the code worked out, it's very easy to transform it into actual Python code. So as a final step, suppose we want not one solution, but all solutions, so we don't want the previous thing. The moment it finds a solution, then it turns true, and then every previous level also returns true. And eventually we print out the board. So supposing we don't want to stop at the first solution but keep printing out. It's actually much easier. Then wh",,,,,,,,,,,,,,,,,,,,,,,,,,,,
t we do is we just keep going through all possible positions, and whenever we reach the final step,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Binary Search (Contd.).mp3,"We were discussing about the binary search function or binary search procedure. So here we can see that binary search is of type integer is a function of type integer that will be returning an integer. And it has got the parameters, the list, or the array, which is being designated as x here, the size of the array and the key. Now, if the key appears, say the array is here, the array is this, or the list is this. This is called x and it starts with zero. And the last one is therefore whatever is the size minus one. So if the key, there is a key. And if the key appears anywhere here, it will return the position of the point where the key is. If this be the position that will be returned. Okay? And if not found, it will return minus one. So either it will find the send the position. So that's also an integer or minus one. Hence the type is integer. All right? Now we have got two pointers. One is l, the left pointer, I mean left index, and the right index of this. And from there we are finding out the middle. So we are finding out the midpoint by this line. Now, if the key is smaller than the middle element, if the key is smaller than this middle element, then obviously our search will be on this side. Therefore, this r will be moved to this point. L will remain here and my search will be restricted in this zone. Otherwise, l will be moved here, r will not be disturbed, and the search will be restricted to this zone. This much has been achieved by this piece of code. What else do we need? What else do we need to do now? How long will this go on? How long will this go on? So in this way, what will happen is I'll move either l or r. Either this or this. And when will this be completed? How long will this loop go on? If you think a little bit, you'll find that it will go on as long as l and r are not crossing over. So if I shift and search this part, r is here. Suppose I initially start with l to be minus one and r to be the size. So I'm shifting from. So here is my array and l value of l is minus one. So it is here. And r is equal to size. That means pointing here. Size plus one. That means, sorry, this point is size minus one. So that is actually here. And while as I shift, I shift l and I shift between this part, et cetera, then I shift l. R is here. But as soon as l and R crosses over, if r moves on this side, then also l and R can cross over. If they cross over, then that is my point where I should stop. So I initialize this and I go on shifting this depending on either l or r. That's exactly what we are doing. When we took the say 1257, 913, like that, 15. So I started with the middle number. And when the key was. Suppose my key is 16, all right? Or say, okay, let me erase this. My key is say 812, suppose my key is twelve, what will happen? My l is here, this l, this is r, I start with mid. Mid is seven, so key is greater than this. So I'll have to restrict my search in this zone. I take the middle of this, so r becomes this, this becomes the r. And I'm sorry, r remains the same. I have to search between this zone. So what I do, I shift l, I have to search between this zone. So I shift l to this. So this is my new l and this is r. I have to search in between this. I find this to be the mid. Fine. And I find that the key is less than the mid. So I'll restrict my search within this zone. This zone. Within this zone. Right. Since it's less. So then what should I do? Since I am moving on this zone, I'll shift r, keeping l fixed. I'll shift r here. So this will be r now. Now between this l and R I find mid. This is my mid. Okay. I find nine to be less than twelve. That means it should be on this side. So I move l. As I move l, l is crossing r. That means now I have come to a position where I've exhausted everything and I could not find the key. All right, so if l is greater than zero and xl is equal to key, l is greater than equal to zero and xl is the, is the key, then I return the pointer, otherwise return minus one. So that is the binary search algorithm, okay, this is how I am carrying out the algorithm, through a c code. So here is an example. I'm writing down an array, suppose, sorry, I'm writing down a sorted array. Suppose it is -17 minus five, 3612, 21, 45, 63 and 50. 63. It cannot be 50. Say this one is, say this up to 63, that's my array. Now if I carry out, so the size is 1234-5678 I must have another one. So let me have 75. And if three be my key, this is the key. So what will happen? I'll start l here, r here and I'll find the midpoint here. So the midpoint will be here twelve, and twelve is greater than the key. So my search will be within this zone. So this r will be shifted here. So this is now my r and this is l. I'll find out the midpoint three here. Now, as soon as I come to this mid and I find that this mid is matching the key, my search is found. All right, I get my key in a particular position, so you can write it in different ways. So, so in this way, if I do that, then I'll get different results. So, -17 I just missed out minus five. 3612, 21, 45, 63 and 75. So if for this, my l was at minus one, r was at nine, and my mead was this x 412. Okay, so then x one is minus five. I carry on doing this. L is still one, r is four, r has been shifted to here and x two is three. I found it. So that is my result. In that way, I'll carry out and you can find out that L and R. And then I return L, I go on shifting. So that's what it has happened. I have got the mid value and I've got the value, but then still I am going on shifting. What I was suggesting is it's also possible to check the equality with the x mid. As soon as I find that the element has matched with the mid, then it is found. I think you have understood it. You can try writing out the algorithm yourself. There is a binary search. We'll see later that it can be also done through recursion. Now, why are you doing so much earlier? Linear search was very much simple. Right here. Suppose we had thousand elements. If we had thousand elements, then an ordinary search, if a key is a member of x, it would, on an average, required. On an average, it would have required 500 comparisons on an average. But what will happen in the case of binary search? After the first compare, thousand elements. So we are left with only 500 elements because I started with an array. And then based on that, I have either gone on this half of the array or this half of the array, depending on whether the key is less than or greater than the midpoint. This is the mid. So on an average, first compare, I am left with 500 elements. Next compare, this part is again divided. If it's on this side, I'm left with 250 elements. Right after at most ten steps, we are done. In that way, I go on dividing it, and after at most ten steps, I am done. So I had thousand elements. Okay, so in that way I get 250 elements, then 125, 125, then half of that, 60, 65 or something like that. In that way, number of steps that I'll be following will be around ten. In general, if there are n elements in the array, the number of searches required is two to the power k should be n, where k is the number of steps, okay, for n, if there be 64, initially the list is 60, the size is 64. After first comparison, the list is 32, after second it is 16, then eight, then four, then two and then one. So six steps. So basically at every step I am breaking it down into half. Therefore, if I need the k steps, then if I need k steps, then two to the power k should be equal to n. That means how many steps are there? What is k? If I take log, then k, log k, log two is equal to n. Therefore k will be log two, n to the base of log two. Okay, so log two, log 64 to the base two is six. So we'll be completing in six steps, whereas in the worst case I would have needed 64 comparisons in the case of linear search. Now, given this idea of binary search, so what have you seen? We have seen binary search is a search algorithm that enables us to search for an element much faster than linear search. The approach being that we divide the array to be searched in half, okay, every time. So we divide it into half and restrict our search in half. And in the next step I further divide it to half and restrict it to even a smaller step. So every time I am halfing whatever array I'm checking. So two raised to the power k times I halved it, where k times I have halved it, two raised to the power k should cover the entire n. And so from there we get the complexity to be of log of log two, log n to the base two, log n to the base two. In general, it will be log. If 64 is replaced with n, it should be log n to the base two. That is my time complexity compared to, so I can say this order of log n to the base two compared to order of n. That was the case of a, in the case of linear search. Okay, now we'll move to another very fundamental problem in programming. We often need that. See for example, here we have done one thing. That is I had an array like say 237619. Now this was an array on which I cannot run binary search. Why I cannot run binary search? Because binary search can be done only on sorted array. So if I sort it either in increasing or decreasing order, say for example, it becomes 123679. This is a sorted array. Or the other thing could be 976321. This is also a sorted array. In the other direction it is descending order, this ascending order. Okay, so now another problem is to arrange the things, arrange the objects. Suppose there are a number of numbers like this. You have to arrange them sorted or arranged in a particular way. The question is how to do sorting, how to sort. So suppose I have given this array to my program. This is the input. Then if I want to apply binary search, then I cannot directly apply it. Apply binary search on this. So what I can do, I can first take the array, say I read the array, let me write, then sort the array and then read key apply binary search. Now, binary search takes for n number of elements. It will be faster. But how do we sort the array? So it's faster than linear search. But is it advisable to approach in this way? If the array is not sorted, is it advisable to sort the array and then apply binary search? In order to understand this, we have to first see how an array can be sorted. How an array can be arranged in either increasing or decreasing order. That is also a very important problem. That is called the sorting problem. And this has got a very important application in many objects. Whenever I, for example, for example, you have got the marks of the students, all right, you have got a marks array. Say you have got two dimensional matrix, maybe where, all right, let's take one dimensional array where the role numbers are here. Every row is corresponding to a role number. And here I think I'll just do it again. I've got the marks here, 56, 55, 70, et cetera, et cetera, et cetera. Now I want to find what is the highest marks. One thing is that I can find that out, or I want to attribute ranks 1st, 2nd, 3rd, like that. In that case I can sort this array. And from here I want to have an array like this where the first element will be 72nd, element will be 65, then 56, then 50. This is also sorting the marks in a decreasing order. And along with that I can also sort the role numbers and can publish which role number got what marks. Right. So what we want to see next is sorting. Let us define the basic problem. First, sorting means given an array like zero to some size minus one, reorder the entries so that they are in this way that x one is greater than equal to x zero. X two is greater than equal to x one. So if it be this, sorry, why is this greater than equal to coming up, say for example, 255-6679 there is also a sorted array. So both these elements could have taken any order. But since they are same, they can be assumed to be sorted. That's why this greater than equal to thing that's coming up. Okay, the list. Here it is. It's in non decreasing order. Nondecreasing. I cannot say increasing order because it's not increasing. 255667. So here, of course there was an increase, but here there is no increase. So this is rather, instead of calling it increasing order, we can call it non decreasing order. We can also sort a list of elements in non increasing order. It's non decreasing order. So I can also sort it in the other way as we had shown earlier. Okay, so here is an example. This is sorted in non decreasing order. You can see this array, 1030. Now this is the original list. Now if I sort them in non decreasing order, it will be ten minus 1010, 2030, 40, 62. If I do it in a non increasing order then -80. 70. In this way, this is not increasing. In this way. Here it's not increasing. All right. Here it is not decreasing. If I go in this direction. So these are the two possibilities. So the sorting problem is if we have an array from zero to size minus one, I want to sort it and get a sorted list. All right, that is what I want to have. So the first algorithm that we'll be talking about is selection sort. Selection sort is something like this. That suppose we have got a list here and this part of the array is already sorted. This part of the array is sorted in a nondecreasing order. The smallest element is here. The smallest element may be minus ten, then ten, then 20. This part is somehow has been sorted. Now I am left with sorting this part only. This remainder, what should I do? I am going to select the candidate for this position, right? I am going to select the candidate for this position. For that, what shall I do? I'll start. Since this part is sorted, all the elements on this side are either equal to this or less than this. So I'll have to look at this part and find out the minimum element that is here. This element that is minimum. Since this part is sorted, this element, this element must be greater than these elements. So among these only for these people, this one is the smallest. So I select that, I select that and put it in this position. I swap. How do I do that? Suppose here it was minus 1010, 2030 and here it was 50. This point, this part is sorted 5032-7231 remember this position and search from here and find out the minimum. The minimum is 31. So this 31 comes, I swap it here. So what happens to my array? This part. Let's see what it will happen. It will now become. From here it was 30, it will be 313-2725 so up to this part it is sorted now. Now from here I'll try to find out the minimum element. I find this is a minimum element and I sort out the minimum element. I swap this minimum element with itself. So up to this is sorted. Now out of these. Now I have to find out the candidate for this position. So I find out the minimum. I come here and swap this. So it becomes 50, 72. So here in this selection sort, the approach is that we are going position by position and I am selecting the element that belongs to that particular position. So whenever I'm starting with the search, then at the beginning I'm starting with the. If this be my array, then I am first searching for this position and this position will have, will be the minimum of all these. I search all through here and find the minimum. Suppose the minimum minus ten was here. So I take and bring this minus ten here. So it becomes minus ten. I know this is the minimum. Now I am sorting. I am now looking for this position. I select the element minimum element. In this zone. I find here something ten. So this part is done. So now ten is swapped here. So 1010. And then this part is unsorted. This part I'll sort in. This way we go on. This is one of the sorting approaches. We will deal with it further in the next lecture.", if we actually a solution reaches the final step, then we record it. In our case, you might print it, otherwise we extend it and go to the next one. So actually, it's much simpler to print all solutions than it is to print a single solution, because we don't have to remember whether our solution extends or not. It's really running through every possible solution. The only thing is that it will not run through every solution till the very end and then decide it doesn't work. It's not like we are putting all possible queen positions and then trying it out. We are trying it out for smaller things, because once we get stuck at, say, position five, then it won't try to extend this, it'll come back and so on. But this is just a much simpler loop which just prints all solutions. So here is the code. It's exactly the same code. Otherwise the only thing is the place queen function is much simpler. Now we just try for every j in range, one to zero, to n minus one. If it is free, we add the queen. If we have reached the last row, we print the board. Otherwise we extend the solution and then we undo the queen and try the next one, right? So for every j. So for every j, we are going to first add the queen. If it managed to place it, extend the solution, and finally we are going to undo it and try the next j. So we are just going to blindly try every possible j and we're not going to ever come out complaining that we have not succeeded. The rest is pretty much the same. The print board has been changed slightly, and slight change in the print board is just that. We have changed it so that we'll print the entire thing on a single row. So we have added this thing which says end equal to space. So we print the positions in a single row rather than row by row, so that we can see them all. So now if we look at the function now and we try to print it for say, for four queens, then it prints two solutions. These are essentially two rotated solutions of the same thing. If we do it for eight queens, for instance, then it'll actually produce a lavast number of solutions. It turns out there are actually 92 solutions. But even these 92 solutions, if you look at rotations and reflections, they come out to be much less. But if you just look at the position of the square as it is given to you," then there are 92 different solutions that it prints out. So this concludes our discussion of backtracking with respect to the eight queens problem. Bye."""
Binary Search.mp3,"In the earlier lecture, we have seen how we can search in a list of items, maybe list of of integers, or maybe list of names or list of real numbers in a linear way. That means we start from one end of the list and we have got a key, and we check for every element, whether the element in the list matches the key or not. In that way, we go on from top to bottom. And ultimately, if we get the match of the key to an element of the list, we declare it is found and we also say where it is found. Otherwise, if we exhaust the list and still do not find the element, then we say that the list is not found, and the way in which we are searching from the top to bottom. That process is known as linear search. We have also seen that the time, that time that is required to search for an element, in the best case it would be of order one. That means at the very beginning we can find the element. Otherwise, how many comparisons we have to do? The minimum is one if we get a match at the beginning of the top of the list. Otherwise, we may have to exhaust all the elements. And whether it is found or not found, we can say only after we have compared all the elements. So if there is a list of n elements, then the maximum number of comparisons that I may have to do will be n. Therefore, on an average, it will be n plus one by two. That we say in complexity of algorithms parlance, in that parlance, in that terminology, we call it order of n. Okay, that is not the main issue with us, but we can say therefore, that in a list of elements, if I have got n elements and the list is not sorted, so maybe five, two, 7911, one, say this is a list and I want to search for a key. So in this case it is six. But in general I can say that there are n elements, right? In general I can say number of elements is n. So the best case, I can get a match here, the number of comparisons I require is one. In the worst case, I have to come up to this and compare all these n elements. So the number of comparisons on an average will be n plus one by two. All right, that's the average number of comparisons that we denote in computer palace, as of the order of n. This o has got a name called bego. I'm sorry, let me write it in this way. This called bigo notation. Bigo notation. So where it just denotes how much time a computer can a program will take to run in terms of the input size. What is this n? This is the size of the input data. We call it input size. So obviously you can see that as this list increases, if it becomes 100, then the time, average, time that will be taken, average. This is the average complexity. All right, will be more than this. If it be thousand, it will be even more. And as increases, the time will increase in a linear fashion. As n increases, the time will increase in a linear fashion. However, the way we are searching is known as linear search. One thing to note is that in this case we are not making any assumption. This is time. We are not making any assumption about the way in which the data items are organized. Okay, now, in an endeavor to see if we can make it better, we today discuss another very important type of search algorithm, which is known as binary search. Why the name binary is coming? You will be very clear in a moment. But the important thing to note is that in this case, the list or the array must be sorted. That means it is organized in some particular way, either in an ascending order or in the descending order. Okay, so why is it called binary? Let me just try to explain it with an example. Say I have got the array, but in a sorted way. So I have got one. Two. The elements were there in the earlier case, 1257 911. Right? 1257 911. So 1257 911. Now suppose my key is, well, let the key be two. Now we will start at the middle of this array. First we'll look at the middle. Now, since this is an even number, even sized array, six elements, the middle can be somewhere here. Say, let me take this. This is the midpoint. Now I compare the key with the middle element. Two and seven are being compared. Two things can happen either to the key. I'll rather say either the key is less than the mid element, or the key is equal to the mid element, or the key is greater than the mid element. Three things can happen. Now, if the key is equal to the middle element, then my search immediately stops. Yes, I have found it. And where did I find it? The index is mid. If the key is less than the mid element, as is the case here, then what can I say? I can immediately say that I still do not know whether the key is there in this array or not. Whether the key is here or not, I do not know as here. But the thing that I can say is that the key, since it is less than the mid, it cannot be on this side. It cannot be on this side. Not possible. It must be, if at all, on this side, because the key is less than the mid. Therefore, I can restrict my search within this period, suppose within this zone. Now what I'll do, I'll again take the middle point of this array, right? So between here, it is becoming very simple. So the middle point of this part is, suppose five. I could have had it from one to five. But I am just taking from one to seven. I come at this point. And again, now I compare this element with the key and still it is less. Therefore, I am sure that it is not in this area. It must be in this zone. Now I again, only for this part, I apply again, I find the media element and this is here. And I find that the key and the element are matching. So it is found. So how many comparisons I needed here? In this case, I needed one, two, three comparisons. In the case of linear search, of course, you could have got it. Luckily here in two comparisons. All right. But what would have happened if my key was nine? In the case of linear search, suppose the key was nine. In that case. In the case of linear search, what would have happened? I would have started from here. One comparison, two comparison, three comparison, four comparison. On the fifth comparison, I would have got it, right. On the fifth comparison, I would have got it. But let's see what would have happened in the case of the new search technique that we are looking at one. So again I have 1257, 911 and my key is nine. I know that in case of linear search, I needed five comparisons. What will happen here? I'll come to the middle point. Here I find that the key is greater than mid. This is mid. The key is greater than mid. Therefore, I know that the key, if at all, cannot remain in this zone. This part is ruled out. This part is ruled out. It must be in this zone. So again within this I find the new mid. So the new mid comes here. And I find this new mid. New. And I check this. Now I find that the key is equal to mid. Therefore I find my search completes here with this index as the output. Now how many comparisons I needed here? One, two, one. Only. Only two comparisons. So two comparisons versus 12345 comparisons. In the case of linear search. Now why was it reduced? The same thing would have happened with if my key was eleven. Let's have a look. If the key was eleven. In that case, suppose the key was eleven. In the case of linear search, I would have required six comparisons here to reach at eleven. However, in this case, I'd be sure if key is greater than this, then my next iteration will be between these two and would have found the mid, new mid. And I would have got it within three comparisons. Now, why is it becoming so? Why is the number of comparisons being reduced? The reason is we have got this array. And at every stage what I am doing is I am looking at the key. And depending on whether the key is greater than the mid. I am concentrating on only one half of the array. Either this array or this array. And then depending on the key value I take, suppose it is greater. Then I'll concentrate on this zone. If it is less, I'll concentrate on this zone. And iteratively I'll be reducing my search to a smaller array. Let's have another example. Let's have another example. Let's have it a little bigger. All right, let's have 1719, 212-53-2384. So now I have got again even number. Let me have 42, say od number. That is 1234. Now I have got nine elements. Right now I'll start with the mid element. What is the mid element here? Between this, the mid element is this. And suppose my key is 19. Then I know that my key cannot lie. Since it is less than 19. It cannot lie in this part of the array. If at all, it will lie on this part of the array. Why do I say that? I can say that because this array is sorted. Otherwise I could not have said. Since it is in an increasing order. I can say that since the key is less than the media element. Therefore it must be in this zone. And so I come to this zone and find out the mid element again. Maybe in this zone or up to this, say I come here and find out the mid element to be this again. So I am immediately reduced my list to half. Right, this half it could have been. If my key was, say, 38. Then I would have restricted to this half. Not this half. But for 19, I am restricting to this half. Now, again, 19 is less than 20. So immediately I'll restrict myself to this half. And I'll not consider this part. So gradually I am going to the lower half or the higher half at every stage. So what is happening is something like this. I'm starting with a whole array. Then I am concentrating either on the left half or on the right half. Then again, depending on that, either on the left half or on the right half. If it is in the right half, then among this I am coming to left half and right half. So at every stage I am dividing the array to half. That's why this is called binary search. Either it is here or it is not here, not in this zone. So in that way I carry on. So consequently, the number of elements that I restrict my search to gets reduced at every iteration. Let's look at this in a little more detail. So, in every step, we reduce the number of elements by half. I think this is clear now that this statement, now, if you don't find it, you can ignore the half of the array and repeat the process. So now let's look at this basic strategy. What do you want? The array is from zero to n minus one n elements. Here I was showing mid only. So this is the mid m, and this is the left end. This is the right end. So there are two index indices. All right, now I am taking the key and I'm checking this part. M the element m, this element that is xm. And depending on whether, if it is greater than the key, if Xm, if the key is greater than Xm, key is greater than xm is less, then I'd be concentrating here. If xm is greater than the key, then I'll be concentrating on this half. On this half or on this half. That's what I was explaining till now. Okay, so here, if it is no, then if it is xm is less than the key, then I'll come to this half. Otherwise, if it is es, I'll come to this half greater than the key. All right, so we'll first, given this l and r, what is my media element? How will I compute my media element or m, that is l plus r divided by two. And then depending on whether it is less or greater, we will move the left or l or r to the middle, depending on the test. So again, let me show it with that example that we are showing. So something like this. 1257. 911 what is being, it is 911. So l is l equals zero and r is equal to one. 2345-601-2345 so r is equal to five. So mid is l plus r divided by two. So that is five divided by two. So we can take two or we can take three depending on. So I come to, if I take two, if I take three, then I'm coming to mid. So what I'll do is f. Three is my midpoint. If I take five by two is three, then that means it will be, in case of od, I'll add one to that so I can move. Now, if the key is suppose key is nine, suppose the key is nine. So my mead was the third. 0123. Or let me. 0123. This is my mid. Now, since the key is key is greater than the element xm, x mid. Since it is x, mid is less, I'll be restricting my search in this area. Therefore what I'll do, I'll move this l to mid. So this will be my new l and I'll find the mid with now next mid will be this new l plus r by two. So that will be this element. If my search was on the other side, that means if the key was not nine but the key was two or one, let's make it one. Then at this point I find that the key is less than x mid, then I'll be restricting my search in this area. In that case, I'll move this r, I'll shift this r over here and the mid will be, r will be the mid. So next, I'll be restricting mid search in this half and forget about this half. So that is how we, at every iteration we break down the entire array into halves. So if you have understood this, let's proceed, repeat the search operation in the reduced interval. So what we are doing is we are looking at this binary search algorithm and we are trying to design a function. And binary search is a function whose name I am just keeping as bin search. All right, this is the name of the algorithm. And what are the parameters? Let's see, the parameters are, one is the array that's being passed the list that I have to search. I also need the size of the array and I need the key. So these are the three things. So binary search is a function. What are its inputs? The list or the array, which is x, the size or what we are calling about right now, n and the key. And what will the output be? Bin search will tell us whether it has been found or not. Okay, but so it will be a zero or one, found or not zero or one, or it can return us an index also. Okay, so now if we proceed with this idea, then let's develop the algorithm step by step. Inside this function, I have got the search, I've got the list, the list is given to me, this array is known to me. I declare internally lr and I have to use another index called min. Now this has got no meaning outside this function. Next step, what should I do? Next step would be while some condition mid, I'll have to find out l plus r by two. As you know, if this is the array, x, if the mid element is greater than the key, so the key, say this mid element is seven and my key is nine, so this element is greater. Then I know that this element is greater. So this is 17, this is greater than the key. Then I'll have to keep my search within this zone. So this R will be updated and the R will come here. Otherwise L will be moved here. This much is clear. You think over this and build upon this algorithm. We'll take it up in next step. Again, you have to decide on how to build these things up.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bisection Method.mp3,"We were talking about errors and round of errors and percentage errors. Now, I'll briefly show you that if we commit an error, how that error continuously gets accumulated and ultimately has a much larger effect. For example, suppose the exact value, suppose the exact value of some variable at the first instance is ten. All right? And suppose, no, sorry. Suppose the exact value is 9.98 and we compute ten. All right, so the inherent error first, the error actually is 0.2. Right. Now, as we go on iterating, suppose x one is ten times x zero. Then the exact value should be 99.8. But here we'll get 100. Okay, suppose it is 100. So you can see that the error has increased to how much? Zero two. Now, if the next iteration x two is again ten times x one, then it will be 998, whereas the computed value will be thousand. So the error is becoming two. So you see how if we start with an inherent error, how that error accumulates over time? Okay, so we can say a very important term is relative accumulation of error, which is accumulated error, accumulated error divided by exact value for that iteration. For example, in the first iteration it was, the accumulated error was zero two divided by the exact value, which was 9.98, but later on it became zero two divided by 99.8. So this was zero zero four. But whatever that is, that is not that important. I don't want to confuse with this. Now, there are some cases where this accumulation of error actually goes on increasing. Okay? If the rate of accumulation error decreases, if the rate of accumulation of error decreases, or if the rate of accumulated error increases, but the rate of relative error decreases, then we call it a stable algorithm. However, I am not going into the details and the intricacies of this, but this is just to give you an idea how the error propagates through iterations. And so we must be very conscious about the rate of increase of this error. All right, with these words, we move to the algorithm which we are planning to discuss in this lecture. That is a bisection method. I've already told you that the bisection method is given a particular function, sum function on this x and y axis. If I have some function that moves in this way, then we start with any two points, any two points, arbitrary points here and maybe here. No, these two points will not do, because if I select these two points, then both of them are positive. So that if I had selected this point, for example, these two points, x zero and x one, that would not have served my purpose because I do not know whether the root is there or not. So I would rather select two points which are of opposite signs. And therefore I know that somewhere in between the root lies. So now I'll take the midpoint of this somehow here. If this point is negative, then I'll keep the positive fixed and I'll find out the value of y. So these two are opposite signs. So the root must be somewhere here. So in that way I come to this one and find out the value of the root here. In that way I go on dividing it till I come very close to the root, as is being shown here, very close to the root. Now how close? That will depend on my decision. Okay, that is the basic approach of bisection method. So with that, let us try to have a look at the algorithm. Therefore, first we start, we define the function. We define the function f x and get the value of the interval ab. That is, there's a function. So here there is a function, and the function can be long enough. So I take the limits that I have to find out the root within this interval a and b, and I find out how much error is required. So how much error is acceptable. So this error is, the allowed error is the epsilon that I was talking of, and also the number of iterations, the number of iterations, because it may be that in some case I'm not finding the root, because I'm going on looking at say for example, this sort of scenario, and my a is here, my b is here. Then obviously the root does not lie between this. So I'll go on doing this bisection, and again doing this bisection. How long will I go on? But still it may be that I'll not find the root. Therefore, there is a maximum limit that is kept number of iterations. Now I initialize I to be one, some index to be one, and then I call a subroutine or a function. Bisect the midpoint, that means. So here is a subroutine. Bisect. What it does here is a subroutine. You see what it does? Or a function, what does it do? Here it finds out between a and b the midpoint and increments the iteration, and prints the value of x one. X one is the middle point. So if my function was like this and this was a, this was b, then the root must lie somewhere. Here I find out the midpoint of this. So this becomes x one. Okay, there's the next one. And what is the iteration? Next is f, that means f mid, less than zero. So there can be two things. All right, here I select this to be my b and this to be my a. Now, obviously, if I take the midpoint, then the midpoint will be somewhere here. A and b were of different signs. If f mid is not less than zero, then a should be x. That means I'll now move it on this side and try to find out. This should be the next a, and between these two I'll have to find out. And every time I am trying to find out whatever value of f x that I compute, is it less than the absolute error? If yes, then x, that is, I am getting my solution, otherwise I am going on doing this. So, this is a flowchart of the whole thing. But I think you'll be more interested in looking at the algorithm. And let's look at the algorithm for a second. And the program here is the algorithm. You see, this is much more understandable to you. I start, I read x one, x two, and the error here, x one and x two are the initial guesses. All right, here is my thing I have taken. This is x two, this is x one. E is the absolute error. That means how much error is permissible. Compute f one. That is f x one. Compute for this function, this value, and f two. Compute this value. All right, if f one and f two, the product of these two is greater than zero, greater than zero, that means my initial guesses are wrong, because both of them are positive. Then I can do many things. Instead of going to eleven, my initial guesses are wrong. I'll again ask for new guess. All right, so I take a new guess and I find that that is less than zero. Then I take in this tape x one plus x two, mid of that. So suppose mid of that is this one, and that is becoming x. If x one minus x two by x, actually, here it should be if I think it's wrong here it should be if f x one minus f x two. Please read this as f x one. No, the error f x one minus f x two divided by x is less than e. Then display x. That means if my error between these two, between these two points, the valve difference is less, is zero, zero two, and that is, I just, that I can assume as zero. Then I'll display this particular value of x. So right now it is not the case. Otherwise, I'll make this f to be F-X-I take this. All right, now, between these two, I again divide. I come here, and in this way I go on. All right, so you will be able to write the program as the program runs. So, just to show you I'm sure, you can write the program yourself. How can we translate this in the form of a code? So here you see, let's try to understand this code. It's a c program. For the bisection method, I have included stdio h math h, and there's some function, because I have to find the root of a particular polynomial. So for example, here it is given this is the polynomial. So what is this polynomial? It is x cube minus four, x minus nine. So that value of f x has to be computed. So the function is the fun, fun is the name of the function. Then there is another function, bisection. This function performs and prints the result of one iteration. So it is a plus b by two. Now, in an earlier lecture, we had talked about this. What is this? Because here when I'm calling this function, I am calling by reference how I am just passing the address x. And whatever I do here, once again, as a part of revision, you can see if I come here, float star x. That means what? X is there, some variable, and I've just passed the address of that. So star x is the content of this, say 50. All right, so I passed it on, and in the main function, I am passing on the address of x. Okay, this we have seen earlier. So I am taking the meet point and incrementing the iteration. Iteration is also a call by reference, and float a, float b are two points in between which have been passed on. Now, what is being done in the main function? In the main function, I am setting the iteration to be zero. And here I am saying how many iterations are permitted, maximum number of iterations x ab allowed error. How much error is allowed and some x, one value is given. Enter the values of ab allowed error and maximum iterations. So all these I read the range a and b between which points I have to do a and b, and how much is the allowed error and what is the maximum number of iteration. Then with this I call bisection. What do I do? Bisection index. That means this will be, give me the meetpoint. I'll call bisection here, ab iteration. So a is being passed here, b is being passed here, and the number of iterations is being passed here. Now here I am finding the meetpoint, and that meetpoint is being returned here, this common, right? And then here at this point, I find out, I call the function that is, I am computing the polynomial. If the polynomial at a, value of the polynomial at a, and the value of the polynomial at x, that is the midpoint, is less than zero. So what happened? This was my scenario here was a and here was b. No, let me draw it in it. So here was b and here was a. So now what I do, I got the midpoint somewhere here. Then the value of the function at this point and the value of the function at this point are negative. Therefore, I move this b to x. All right, x is becoming b and I do the same thing. Otherwise, if it was on other side, I would have made x to be a. All right, this clear. And then again I call bisection. After calling bisection, I find if the absolute error of x one minus x is less than the allowed error, then I'll print the root. So this will go on while this is under this do, while this will go on until I exceed the maximum iteration. So this is how I code. And all of you should be able to practice this yourself. Okay, next we will move to another, ah, another algorithm, another algorithm, which is another method, which is known as the Newton Rapsen method. This method adopts a different approach to find the root of the function. Let us try to understand this briefly. So I've got a function like this. Now, Newton repsend method. What it does, it starts at some x zero, and the corresponding value of the function at x zero is f x zero. Now, what it does, it finds out the tangent at this point. Tangent to this point. So what would that tangent be? That tangent is nothing but f prime x zero. Okay, because we know that is f prime means dfx dy dx. So I draw the tangent here. The tangent intersects the x axis at some point. Now I take the x one. Let this be the value x one. I drew the tangent and got the value x one. Okay, I come here, and from here. Since the value here f x one, at every stage I have to check whether the value is close to zero or not. Obviously this is not the case. Therefore, I draw another tangent from here. And what is this tangent? This tangent is f dashed x one derivative at this point. So this becomes x two. Now I find out f x two. Now I again compare whether f x two is very close to zero or not. Still it is not the case. So I draw a tangent from here to this. I'm sorry, I should have made it dotted as I was doing at all. I draw a tangent at this point. So this is x three. And I find out f x three. Suppose this value f x three is very close to zero. Suppose this is within my allowed error. Then x three is the root. Otherwise, if it was not there from here again, I would have to draw a tangent in this way it goes. All right, so this is the essence of Newton Rapson's method. So what are you doing here? We are taking a function starting with a point and finding a tangent to that curve, to the function at that point, and see where that tangent intersects the x axis. From there, I find out f x two, and then I go on doing this. So I think this geometrical exposition will be very helpful to you. So next, let us try to see how Newton Rupson method works. So, at every stage, x n plus one is x n minus F-X-N by f, dashed x n. Why? Because of the simple reason that I had this curve. I had this curve and this was my x n. All right? From there, I drew the tangent. So this was F-X-N and I drew the tangent here. Then if I divide this and subtract it from here, I'll get this x n plus one here. So you see, it's coming in the other way, all right? Because at every stage I am computing this next here, x n is the current known value of X-F-X-N represents the value of the function f. Dashed x n is the derivative of the slope at that point. X n plus one represents the next x value that you are trying to find. So this expression is coming from the fact that f x by dx, where dx is delta minus x. Therefore, the term f x by f dashed x, is actually the value of dx. How much the dx value, sorry, dx value. That means how much I should come down. So you can see from this expression, f x by f prime x is f x by f x. By delta x. That means the delta x. Actually, this is the delta x part, and that means how I am shifting this x. So the x was here and I'm shifting it by delta x and coming here again, shifting it by delta x. Coming here like that, I am going. All right, so suppose f x. Let's take an example here. Suppose f x was x square minus four. Then f prime x is obviously two I six, okay? And x zero was six. Suppose I assumed x zero to be six. So here is how it goes. First iteration, x zero is six. F x zero. Here f x zero is, suppose 32. 32, because six squared, 36 minus four, f prime x is what f prime x is two x. That is twelve. F prime x is twelve. Then x plus one x n. Sorry, I'm sorry. This x n. And the next value will be. Next value will be x n. That means six -32 by twelve. So whatever that is, I subtract and I get the x 33.33. Next iteration I come to 3.33. So it was something like this that I started with six and then I moved to 3.33. So you see it is converging very fast. 3.33. Then at 3.33 the value of f x one is 7.9. Here, if you compute this, the derivative will be twice of this, that is 6.66. Derivative is two x 6.66. If I subtract this 6.66, divided by 7.9, subtract it from 3.33, it is 2.27. So my dx is 1.6. I go on like this and ultimately I come to a dx of zero. One, I assume. So next time it is 2.27, I start with that again, find the next value to be. Instead of 2.27 it will be 2.1. And with 2.1 I compute. And gradually you see the dx is coming down. As the dx is coming down, that means I'm approaching the actual root. So this is Newton Rapson's method, and we can very easily code it. So here is an example. Now you can see this. It starts with six, goes to 3.33. Then from the three here is a little animation. 3.33 I'm coming to 2.2.7. Then from 2.2.7 I am coming here, and gradually the error is there. It's not increasing, so it's very much converging. So I get the solution with 2.1 and I get the solution so quickly the algorithm will look like this again. I'll read x, the maximum error allowed number of iterations, and d is the checking. Checking for checking the slope. Here are the comments. X is the initial guess, absolute error is e. N is the number of iterations. So do in a loop I to n in steps of two F-X-F is equal to f x and then f one is f prime x. Now these are two functions which you have to write. And if the now why am I keeping this check? Why am I keeping this check? F one which is a slope. If f dashed x is too small, that means what? That the slope is nearly horizontal. That means I am not going to get any. Suppose, suppose something is something like this. If I come to this point and try to find a slope of this, the slope will be very horizontal. So this is not a good choice. In that case, I have to reduce it and come to a point where I can find a slope. All right. Now in that way I go on and find whether it's coming to the close to the root and. Go on. Now, if it goes on, the iteration goes on. Say, for example, it's possible that I am missing the loop coming close to that. Say a curve like this. The slope of the curve was such that I was trying to come here, and somehow I missed the root. I go to another point. So that is another special case. I need not bother you with that right now. So let's have a quick look at the program. The program will be again. So here we are trying to find out the root of a function. X log x. The function is x log x to the base ten. -1.2 so that is the function. That function is embodied in another c function. Now, df is returning. Df is nothing but f dash text. So if this function is given, I also keep f dash text written. So this is f x. This is f dash text. Now, I know I have already pre coded them, and that will return me the value for different values of x. So now again, I read as can f. I read the initial x zero, the allowed error, the maximum iteration. Now then, in this loop, what I do, I find f x by f dashed x. And that is h how much I should reduce, how much I should change the initial value. The initial value was x zero with which I started. I subtract that and come to the next point. And if the absolute error is less than absolute value at that point, f absolute at that point is less than error, then that is a solution. Otherwise, I'll go up and repeat this. Now, if I go on, and ultimately, if I overshoot the maximum iteration, then I can say that the required solution does not converge or the iterations are inefficient. So Newton Rapson usually gives us a very fast way of finding the root, but sometimes it does not converge, and that's one problem of that. However, there are many other sophisticated ways of finding roots. Just to summarize, I would like to say that what we have learned in the past couple of lectures is that one of the major technological requirements, or computational requirements, are finding roots of polynomials for many solutions. For many engineering solutions, I have to solve equations for that. There are many methods. We have just gone through two simpler methods. One is the bisection method, and the other one that we saw just now is the Newton Rapsen method. Next, we look at something else called interpolation and other things. Thank you. Thank.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Branching  IF - ELSE Statement.mp3,"We are looking at the if selection structure, where the structure was something like if some condition, if and then there were some statements. And here is an example of what we are looking at. So here you can see that if a is greater than b and also greater than c, here is the logical connective. So then this statement will be executed. So in English we can just call it like if the condition is true, then if the condition is true, then execute a set of statements. So in this case, the set of statements is just only this printf. Otherwise, if this condition is true, then this statement will be printed. So this is what we discussed in the last class. Now, one thing for those who will be writing programs in C, you should remember that this condition is always within a parenthesis. And within that parenthesis there can be a composite expression, which is here you can see there is a logical expression, here is another logical expression. And here is a composite logical expression joining them by and or it could be by or et cetera. So in that way we can form the condition statement. And if the condition statement is true, then these things will be executed. We will see more examples as we go ahead. So let us look at a little more different, a little more extension of the structure here. Here we are going to see the if else structure. What we actually want to mean is if a condition is true, then we'll be doing these things. And if the condition is false, then I'll do these things. Let me clarify it a little bit more. Suppose I write if x is greater than five, increment x by one, and printfalue of x is percentage d backslash n x. All right? That means if x is greater than five, suppose x is an integer. I am assuming that x is an integer here. So somehow, somewhere up here, I have written intex equal to or intex, just intex. And later on I have assigned x to be seven. All right? Now when I encounter this condition, this condition evaluates to true. Then I come to this set of statements, because this condition is true. So what will be the value of x? Now, x was seven, it is greater than five. Therefore x will be eight. And what will be printed? New value of x is eight. That's what will be printed. Now suppose I write printf x not greater than five. What I intend to do is if this condition is true, then this will be printed. Otherwise, this will be printed. That's what my intention is, that's what I want to do. But the way I have written it will actually do something different. You see, when the execution will be done. You know, the execution is normally done in a sequential manner. So, here we will come. X is greater than five. X is seven. So x is greater than five. This thing will be printed and we'll come out and come to this next statement. Let me number these statements. Say this statement was one, this was two, this was three. Now see, I am calling this entire if statement to be a single statement. So three and then four. So, normally one will be executed, then two, then three. Now, three will be executed because x is greater than five. So this condition is true. And then what will be executed? Four. So what will be the output? What will be written here, new value of x is eight will be printed. And here, when four is executed again to be printed, x is not. X not greater than five. But that was not my intention. So, in order to avoid that, I can write a new statement. Here. There was an if I write here, else this. That means what? If this condition is true, then print this. Otherwise, that means if this condition is false, then do this and then number five can be something else. And that will be executed. So what will be the execution? Suppose x is equal to four. Let's try to write down what is the execution sequence. Then one, then two. Now x is equal to four. Therefore, this condition will be false. This condition will be false. Therefore, this statement three will not be executed. This part of three will not be executed. Then we'll come to this else statement. That means if the condition is false, then I am coming over here. And so, four will be executed. Four will be executed. Three will not be executed completely and then five will be executed. But if I had not put this else, then what would have happened? In this case, if x is four, in that case, this will not be true. Only this statement will be printed. Fine, there won't be much problem. But suppose x is equal to seven. And if this else is not there, then what will be printed? X is eight, x not greater than five. But if I put the else here. If I put the else here, I am probably repeating a little bit more because a lot of students face difficulty in this structure. So if I put else here, in that case, this will be x is seven. So this will be printed. And at this else, this condition was true. So this part will not be executed. This part will be executed only if the condition was false. So this contradictory situation would not occur. All right, so let us look at some examples of this. If statement, if else. It's also a single entry, single exit structure. It allows us to specify two alternate blocks. Of statement, one of which, one of which is executed, any one of them, depending on the outcome of the condition. Essentially what we are trying to say is that I'll have a single entry point to a decision box and I'll check for some condition. I'll test that particular condition. If that condition is true, then true, then I'll do some state set of statements. Let's call that s one. Otherwise, if it is false, then I'll carry out some s two. All right? And then I'll be meeting maybe at some other point, which is s three. So this structure, I can write as if condition, then I'm not writing the statements, I'm just writing s one, else s two, and then s three. So my flow will be either this way way an s three, or this way an s three. Okay? If I had not put this else, how would this diagram look like? You have seen this diagram. Now, if I had not put this else, how would the diagram look like? The diagram would look like f. Here I have got the condition block decision box, True. Then I do s one, and then I do s two and s three. So we'll come at this point. If it is false, then I'll also come at this point. If it is true, then also I'll join at this point. If this else was not there. But since this else is there, then I just separate out their point of joining. All right, we'll see more examples of this. So the general syntax of this is if condition, then block one, block one is what I was calling s one, the set of statements. Else, block two, the other statements. All right, if a block contains a single statement, then the braces can be deleted. I'm sorry. If the block contains a single statement, then these, it's not essential that I put them, but just for the sake of generality, in most of the cases, I'll have more than one statement. Therefore, I am putting that in place. All right, so the diagram that I was looking at, I was explaining that sort of diagram. Suppose the grade is 60. If the grade is greater than equal to 60, suppose somebody's grade is or marks is 50. Then at this point, the condition is false. This part will be executed. If the grade is 70, that is, this condition is true, this part will be executed. Then I'll come to this common point. This is a common point which will come now. So this, I can write as if grade is 60. See here, there was only one statement, so I have not put the braces here. Print. Sorry. Printf passed. Else, printf failed. And then whatever I had to do, I'll do it here. Okay? And then whatever was following that will follow here. Okay, so let's come to. So, I hope this is clear. So the syntax of efels, let's look at little bit more here. I have said block one, block one means or s one, whatever you name it. This is block one, or I had named it as s one. The same set of statements where there are a number of statements, each separated by a semicolon. Please note, suppose there are n statements, they are separated by a semicolon. Okay, now next I come to this if I want to do else. Also, if expression statements one to n else, state these statements, one to m. So this is my block two, and this is block one. Okay, so here we can see that based on this expression, which is a condition evaluation. If this condition is true, I'll carry out these statements. Else, I'll carry out these statements. Note that these individual statements have got semicolon. And this is a whole body of the else statement. This is the whole body of the if statement. So composite. If this entire thing we call an if else structure. So if grade is 60, printf passed, else print failed. Now this next we are coming to a little more complication of the same thing. It's a nesting of efelt structure. Now by this efels, what are we trying to achieve? We are achieving branching. That means we are carrying out a sequential flow. We are carrying out a sequential flow. And from there we made a decision box and then we branched either in this direction or in this direction. Now suppose here in this direction. This is true and this is false. Again, I come and make a decision. It can be, if x is greater than five, then I come here and y is greater than seven. Then I do something here. It can be x is greater than five. I follow this path, but y is not greater than seven, so I follow. This is true, this is false. I follow this false path. Okay. If x is not greater than five, I come here and suppose I check z less than two. True or false. There can be two outcomes. So suppose x is four, so not greater than five. I'll come through this path. Now, z is three, so z is not greater than two, less than two. Therefore I'll follow this path. So you see, the path that we follow, that is a branching that we do, can have the path that we follow can have more than one decision box, say x is greater than x is seven. So here I was coming in this path, then I follow this path, because x is seven. This condition is true, and I find that y is eight. So I follow this path. All right. If y was six, then I would have followed this path. So in the path that the program follows, there can be more than one decision box. So that is what we mean by nesting of e fail structures. Okay, that means nest one if else statement within another. Now, all statements may not have the else part. Now, rule to be remembered is an else clause is associated with the closest preceding, unmatched, if really confusing. What do I mean by this? Let's look at this. How will this be executed? Here? E one means some expression. If e one is true, then s one else. If e two, then s two. Now, with whom does this else go? This else certainly goes with this preceding. If I just quickly draw this, the flowchart corresponding to this, how does it look like? I come here and evaluate the expression e one on true, I do s one on true, I do s one on false. Here is false. All right. I come here and there is another if here. So I again check e two. If e two is true, then I do s two. This statement actually means this graph. If e one is true, then I'll carry out s one. Otherwise, else is there. So this else is linked to this. If then I do this one. Okay, what about this? Let's erase this for a while. And how would we interpret this one? Here you can see there are two else's. With whom is this else paired? This else is paired with. I have written it in a bad way. This else is paired with this. If so, this means, again, I check e one. E one is true, so I carry out s one else false. That means this else is for this decision box, I check here e two. E two is true. So I carry out s two, and else I'll carry out s three. This is what I am trying to do now here. I would have preferred to write it in a better way. That's why, if you recall in an earlier lecture, we had talked about a good program writing practice, that is, through indentation. I would have liked to write it in this way. F e one, then s one else. F e two, then s two else s three. Which makes it very clear that this else is corresponding to this f and this. If this else is corresponding to this if. Right. Let's look at the third scenario. What does it mean if e one? If e two s one, how do I draw that? I draw that like that. I take e one. If e one, that means if e one is true, I immediately come here and the statement starts with another if a nested. If this is known as a nested, if one, if within another, there is one if statement, there is another if statement within this, this is known as nesting. All right, so here, sorry, we are here. If e two, s one. So immediately there is no else here, by the way. So if e one, then I come here. Then if statement is again there. Therefore, there is another decision box where I am checking the condition e two. And if e two is true, then I'll follow. Then I'll carry out s one, else, s two. Which else should it be? Here or there? Now this is something. This else is pairing with the preceding f. So it should be false, will be s two. Now, this else is therefore covered. This path is covered. So this else can only mean this one and s three will be because this is already covered, right? So this is the nearest one to this clear. So if we go to the earlier slide, let me go back to the presentation. So here, this one, how this one actually look like. How will this one look like? There's something still there. So how will this one look like? Coming straight here. If e one, if the condition is met, then true. I again test here. If e two, this is true, this is true, then I come and do it here. S one and else, this else is, again with this. If so, it will be here s two. And I have not specified this one here. All right, so if you put a little bit of mind here, so you can see many different other scenarios that can come and we can proceed accordingly. Let us see here this one. As I was saying, it would be nicer to write it in this way because here you may feel, okay, there are two elsees, two, if who goes with whom. Now here, if I write it in this way, if e one, s one, else, that means this. If cells, else. If e two, s two. Here, if e one, s one, else. If e two, s two, else s three. So this else is, therefore, I'm sorry, I think I'll have to go back to a couple of slides. You see an else clause. I'd like to be corrected a little bit. An else clause is associated with the closest preceding, unmatched, if any. If that is not there, that should be. It should match with that. So that is what I explained in these examples. Okay, so it's a much better. For example, let's look at this. How do I like to write this? E one. I would not prefer this. Also, I would prefer that I write it in this way. If e one, then if e two s one, else s two. Okay. Then it becomes very clear, this if else and else are very clear. Say for example here also this is better. But still I would prefer to write this one as this one as this is one way I can write if e one if, then. I mean this is the part of if e two s one, else s two. And under this if that is what has been done here, else s three. Okay, so what we have learned today is a nesting of another structure. What we are discussing now is how we can have a better or more versatile flow. Normally it is a sequential flow, but based on the decision condition points, I may have to take different paths, which is known as branching. Right. And for branching or selecting the proper path, the structure is if and along with that, we have learned today if else structure. And we have seen how if else structure can be nested to give rise to some better, more versatile scenarios. We'll continue with this in the next lecture. Thank you. Thank.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
breaking out of a loop.mp3,"So let us revisit loops. So we sort that we have two types of loops in Python. The first is a for loop where the value ranges over a list in general, or say the output of a range sequence. So for in L we'll repeat the body for each item in the list L. Sometimes we don't know how many times we need to repeat in advance, so then we use the while form. So the while takes a condition, and it keeps repeating the body until the condition becomes false. But the main thing to notice in both these cases is that how long the loop takes is determined in advance. Either we have a fixed number of iterations depending on the number of values in l for a for loop, or we keep going until the condition becomes false. We cannot stop before that. Now it does turn out that sometimes we have natural situations where we want to cut short the loop and not proceed till the very end. Suppose we want to write a function find pause, which finds the first position of a value v in a list L. So we had seen that there is a built in function called index, which pretty much does this. So l dot index v will report the first position where v occurs in the list L. However, the index function will report an error if there is no occurrence of v in l, so we want to change that slightly. And what we want to say is that if there is no v in l, report minus one. So either we get a value between zero to n minus one where n is the length of the list, or we get the value minus one saying that v is not in the list. So here is a while loop implementation. We use a name found, as the name suggests, to indicate whether the value has been found or not as we been seen so far. Initially we have not seen any values in L, so the found is false and we use I as a name to go through the positions. So I is initially zero and we will increment I until we hit the length of l, so so long as while I is less than the length of l. If we see the value we are looking for, then we update found to be true and we mark the position that we have found it to be pause at the end of this if we have not found the value, so the value found has not been set to true. That means there was no v in the list. Then we will set pause to minus one, which is the default value we indicated beginning, and then we return the current value of pause, which is either the value of pause we found, or the value is set to minus one because we didn't find it. So there are two points to observe about this. The first point, which is the main issue at hand, is that we are going to necessarily go through every position I from zero to the length of l minus one, regardless of where we find it. So supposing we had several hundreds of thousands of elements in our list and we found the value at the very second position. We are still going to scan the remaining hundreds of thousands of positions before we return the position two. Now this seems very unnecessary. The other point, which is an issue of correctness, so this is an issue of efficiency that we are running this loop too many times unnecessarily in case we are actually able to report the first value quite early. The other problem, which is correctness, is that we want to report the first position, but the way we have written it, every time we continue past the first position and we find another copy of v, we are updating the position to be the new thing. So we are actually finding not the first position but the last position. So this is not a very good way to do this. So we first change that. So we say that we want the first position, so we want the first position. We want this update to happen only if we have not found the value so far. So we add this extra condition which says that if li is v and we have not found it so far, then we update found to true and we set pause to I. So this ensures that pause is updated to I only the very first time we see v. After that the value found prevents us from doing this update again. So at least we are correctly finding the first value of the position. And finally, as before, if we never find it, then the value found is never set to true and so we report minus one. So the issue is why do we have to wastefully go through the entire list, even though after we find the very first position of VNl, we can safely return and report that position. So a more natural strategy suggests the following we scan the list and we stop the scan as soon as we find the value. So wherever we find the value for the first time, we report that position and we get out. Of course the scan may not find the value. So if the scan completes without succeeding, then we will report minus one. So we could think of doing this using a for loop. So we go through every value in l using a variable x. So x is a name which goes through the first element. Second element. These are not positions now these are the actual values. So we check whether the value x that we currently pick up from the list is indeed the value v we are looking for. If so, we exit and we report the position of this x. If we come to the end of the loop and we have not seen x so far like before, we want to report minus one. So here is the first attempt at doing it. So let's go through it systematically. So first of all, we have this loop. So for each x in the list, if x is v, then we report the position. Now we have to find the position because we are going through the values. So this has forced us to use a name iter, record the position, and we have to manually do this. So like in the while loop we start with the position zero, and in every iteration we increment the position. So this is only the first version of this. We will see how to fix this. So we have to separately keep track while we are doing this, for separately keep track of the positions and report it. But what is new, and this is the main issue to be highlighted here, is this statement called break. So what break does is it exits the loop. So this is precisely what we wanted to do. If x is v, we have found the first position. We don't want to continue, we just want to break. If not, we will go increment the position and go back. Now, how do we record at the end? We don't have this found variable anymore. How do we know at the end whether or not we actually saw it? So the question is, was pause set to I or was it not set to I? Well, the default value is minus one. So supposing pause is not reset, we want to report minus one. So this is why in our function, we have actually initially set pause to be minus one. So the default value is that we don't expect to find it. So it's like saying found is false. So by default, the position is minus one. At the end of this loop. If we have not found it, pause has not been reset, so it remains minus one. On the other hand, if we have found it without looking at all the remaining elements, we have set it to the first position. We found it and we have taken a break statement to get out of the loop so we don't unnecessarily scan. So when we come here, either way, we have either reported the first position we found it, or in the worst case, we have scanned through the entire list and we have not found it, in which case the initial value minus one is there. So in any case we can return pause and we have no problem. So this is just to illustrate the use of the word break, which allows us in certain situations to get out. Now, remember, in the worst case, we don't find x in it. So the worst case behavior of this loop is no different from the situation without the break. We have to go through the entire list, and we have to come out only when we have scanned everything. But if we do find it, we can avoid some unnecessary computations. So we can simplify this a little bit by first removing this I. Instead of scanning x, actually, it is better to scan the positions. So it's better to say pause is minus one. But instead of going through x and l, it's better to go through I in the range zero. Remember, now, this is implicitly zero to the length of l minus one. So we go for I in the range zero to length of l. So if we don't give a zero, if we give only one argument, this is taken as the upper bound. So this will go through all the positions. And instead of checking x, we check l at position I. So if l at position I is v, then we set the position to this current value and we break. So by changing the variable that we put in the for, we have got a slightly more natural function. And again, we have this clever trick which says that since we set pause initially to minus one, if we did not reset it here, if no value in the range zero to n minus one produced a list value which is equal to the value we're looking for, we will return minus one as before. So this requires this clever trick. So the question is, what if we don't have a situation where such a clever trick is possible, or if we don't think of this clever trick, how would we know at this point? So, remember, now, there are two situations. Either we break, so if we break, that means that the value is formed, or if we know, don't break. If we terminate normally, if the loop ends by going through all the things, then v is not found. Remember, if even if v is found at the very last position, we will first break. We will not go back and say that the loop ended. So if we see v at any position from beginning to end, we will execute the break statement. If not, we will not. So the question is, can we detect whether or not we broke out of this loop, or whether we terminated separately? So, Python is one of the few languages which actually provides a way to do this. So it allows something that looks a bit od because of the name. It allows something called else, which we saw with. If it allows an else for a loop, as well, the idea is that this part will be executed if there is no break if the loop terminated normally. So don't worry about the fact that else doesn't mean this in English. Okay, so it's just a way of economizing on the number of new words you need to use. So if you see an else attached to a four, it could also be attached to a while. It means that the while or the for terminated in the natural way. Either the for iterated through every value that it was supposed to iterate through, or the while condition became false. If it was, on the other hand, aborted by a break statement, then the else will not be executed. So here, for instance, now we don't initialize, so we no longer have this clever trick. We don't have this anymore. So what we say is that for I in this range, we check, and if it is there, we set the position to be the current I and then we break. Now, if we have actually gone through this entire list and not found it, pause is undefined. So if pause is undefined, we need to define it before we return the value. So we have this l statement. So now we say, okay, we have come through this whole thing and there has been no break. So there is no v in L because otherwise we would have done a break. And otherwise pause will be set to a valid value in the range zero to n minus one. So there has been no break, there is no b in L. So let us set pause to minus one and then return. So, to summarize, it is very often useful to be able to break out of a loop prematurely. We can do this for both for and while. We can execute the break statement and get out of a loop before its natural termination. And sometimes it is important to know why we terminated. Did we terminate because the loop ended naturally or because we used a break statement. And this can be done by applying the optional else. So both for and while also allow an else at the end and the statement within else is executed only when the loop terminates normally. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bubble Sort (Contd.).mp3,"So we were discussing about the bubble sort algorithm. And the approach, as was discussed in the last class us, was that every element, every iteration, pushes the heavier element at the bottom. And that's what we had. And the lighter elements therefore goes up, go up. So we had shown an example, a couple of examples by which we can show that the heavier elements go down and the other lighter elements go up. For we had given a number of examples to that effect. So if there be 50 here, I don't know if it's visible. Let me write it here. 50 here and six here then, and say twelve here and seven here. Then what will happen is 50 will be swapped with six, because 50 is heavier than six or larger than six. So first it will be six and 50, and then 50 will be compared with twelve. Again, there will be a swap, so there will be 12. 50, 50 will be compared with seven, so it will be 750. In that way. Ultimately, the 50, if it is the heaviest, will come at the bottom. So we swap only if the element at the top is heavier, okay? Thereby the heaviest element is coming to the top, and the others, which are less than this, I mean, less than this heaviest element, will be going at the top. The bottom moves upward. Now we are going to write the algorithm for this, or the program for this. Now, before writing the program, we need to understand a very interesting and fundamental concept of c programming. That is pointers. We'll not formally introduce pointers here, but we'll be talking about pointers in a different way in the context of this bubble sort. Now, what is a pointer? Pointer is something that points right. Now, suppose there is a variable here. Suppose the variable is named V. Until now we have seen that we can write declare the variable as int v. Okay? Now suppose I do not. So V has got a particular address. Maybe that address is thousand, is the address of V. Okay? Yeah. Now if instead, so if I say int v equals 50, that means in the address thousand, 50 is written. But now suppose we have got this address v and which is an integer, but I am not declaring v as such. But there is another variable, p, which will always point to some integer. So p will point to this v. Right. P is pointing to this v. In that case I can say p is a pointer to v. Now, so therefore, what did I say? I said that v is stored in the location thousand. Now, pointer p, this variable p, therefore stores the value thousand. Okay? Now, this v is of type integer, so v is of type integer. So p is a pointer to an integer v that we know because v, I have earlier said that v is an integer, so I can very well say int v. But what is the type of p? P is a pointer to v, which is an integer. So we write that as int star p. What does it mean? It means that p is a pointer to an integer. If I write it, it's not concerned with v only it says that p is a pointer to an integer. Okay, so what is the value of p? Now, value of p is thousand. We need to say what is the address of p? The address of p. Now this, where is this p? This is in location thousand. And where is this? This might be in location 2000. Therefore, what is the address of p? And of p is 2000. We know that this and operator gives us the address. We have encountered this during scanf when we are discussing about scanf. Right? So let us have these diagrams to understand the concept of a pointer. Suppose there are different things written in different pages of the book. All right, there's one page. This is another page. This is another page. And this is another page. Each of these pages have got a page number. Now, what I have, I have got a table where suppose this has got some content a. This has got some other story, b. This has got some other story. C. This has got some other story d. Therefore, the content of each of these pages are the stories A-B-C or d. But which page I am looking at. Suppose here is a page number, table, table of page numbers. So I have got, there are four pages. So the pages are 1234. Now suppose I just want to come to this page number. So this page number does not tell me what story is there. But this page number tells me that I have to go to this page. This entry is telling me, this particular page number is telling me that I have to go to this page. This is telling me that I have to go to this page. And this is telling me that I have to go to this page. So what are these? What are these things? What are these? What are these? These are nothing but pointers to pages. And what is a? A is a content of the page. So a or c or d, say, is content of page four. Okay? And these are pointers to the pages. That means if I want to go to page four, where should I go? Because this page may be located at some other table. Maybe. Suppose these pages of a book are torn out and have been kept on different tables. Okay? So page number one is giving me the table address so that it is on this particular table. So it can be on table t. One this can be on table t two. Maybe the third page is on table. The third page is on table t four. And this is on table t five. It's possible. So the first table. If I want to read the first page, I have to go. I'll come here. Okay. The first entry, this is pointing to table t one. And I go to table t one and find this particular page and read the content of that. All right? So these are pointers to pages. But these pointers also have to be in some memory location. Let me draw the diagram in a different way. Now suppose this is my memory and I have got four variables. Suppose I have got four integer variables and each integer variable takes two bytes. I am showing two bytes here, one after another. All right. This is the variable v one. This is the variable v two. This is the variable v three. And this is the variable v four. Right? And similarly, let me just change the color. So these are suppose in locations, sorry, let this be in locations. V one is in location thousand. Assuming that an integer takes two bytes. This one is in location thousand and two. This one is location thousand 4000 and 2004. And this is in location thousand and six. And let me extend my table a bit. Now suppose I have got, here again, four integers. This is, say, this is, sorry, things are mixed up a little bit. M. I want to come to this. So here I have got p one is a pointer variable with, again, since it's an integer, let me say p two, p three, and p four if they're integer pointers. I am not bothering about that. I'm not bothering about how many locations it's taking. Now this p one is actually. I'm not bothering about this division here. Two bytes. I'm just showing those two bytes together. That will be easier for me to write. All right? So here the p one is storing the value thousand. Why p one is appointed to this variable. So this p one tells me not the value of v one, but it tells me where is v one located. So thousand is the position where v one is located. So p one is storing that pointer. And p two is, say, thousand and two. P three is 1004 and p four is 1006. Now these locations also have got address. Suppose these addresses are 50 00, 50 02, 50 04 and 5006. There's 5006. Okay? So please try to understand, when I say p one, what is p one? P one is a pointer to an integer, okay? So int star p one, that means that p one is an integer, all right? And p one is an integer. Sorry. P one is a pointer to an integer variable. Okay, it could be a floating point variable also, had it been a floating point number. Then suppose. Suppose this v one, v two, v three, v four. For the sake of clarity, I'm just not bothered about how many locations variable is taking. I'm just erasing this. Okay? Whatever it requires depending on the machine that is taken. Now suppose each of them is a float. So float v one. So v one is a floating point number, right? V one is a floating point number. And if p one points to v one, then I should write float star p one. That means p one is pointing to a floating point number. Okay, so since it's a floating point number, so if I say now and p one, what will I get? What is the address of p one? If I try to get. There's not an assignment. What is and p one? What is the address of p one? Address of p one is 5000. All right, and what is star p one? What is the meaning of this? Please don't be confused. This star and this star has got two different meanings. This star means, it is just saying that p one is a pointer to. Pointer to what? Type of variable. Pointer to a floating point type of variable. So for v one, I am just writing float v one. So that means that v one is purely a floating point number, not a pointer. But when I say float star p one, then p one is a pointer to some floating point number. Now if I just. What is star p one in this case, what is the content of p one? Content of p one. Content of p one is thousand. All right. Content of p one is thousand. So let me just repeat it once again. So we have seen in declaration something like int star p one. Int v one. All right. Now that means p one is a pointer. P one is a pointer. Suppose located at location 5000 and p one is a pointer to a variable v one, which is also an integer, v one located at location thousand. All right. These two lines are just meaning these two things, these two pictures, this 5000 or 1000, this part is not known to us because that is known by the compiler, not by us, but logically to us. This is the picture. Leave aside this 5001 thousand. Only these two parts are declared by this. Now if I say star p one, that means the content of p one, what is the content of. Sorry? Yeah, content of p one. Whatever is the content of p one. Now, if I make p one to point to v one. In that case, if I make p one point to v one, so what will that be? Content of p one. Should be assigned to end of v one. End of v one will give me the address of this and the content of p one will get that. So therefore, this thousand will be written over here. That means this pointer is pointing to this v one. Okay, I'll not go into further details of this right now. We will come to this as and when the context comes later. Right now, with this in mind, let's go back to the algorithm of bubble sort. What is being done in the algorithm of Bubble sort? Let's try to understand each of the functions. First thing is we have got the standard declaration find no issue. Now, first, let's start with this function. Void bubble sort. Bubble sort is void because it is not returning any value, any type, any value. It is just sorting some array. What array? X array. And the size of the array is n int I j. There are two local variables because they are used as indexes of these two loops in this loop. What is happening? For I assigned n minus one, 20 I minus minus. That means what? That means if I have an array here, this is my array, I have got I pointing here because that's the size of the array, minus one. So I is pointing here and it will go up to zero. So gradually it will go in this direction. Up. That's what the first for loop is saying. Okay. First for loop is saying that I is starting from the bottom and going up, up to zero, as long as it is greater than zero. And then for j equal to zero, j minus j equal to zero to j less than I, j plus plus. If x, j is greater than x, j plus one, that means what if x, j is greater than xj plus one. So let's again go back, do this. J is starting from zero and I am comparing this value 50 with the value two with j plus one. This j plus one. If xj is greater than xj plus one, what would I do? I'd swap. Let's go to here. If xj is greater than xj plus one, I am swapping xj and xj plus one. I'll come to the swap function later. I'm assuming that the swap is working correctly. That means it is swapping them. So what is happening? So this loop will go on, j equal to zero. Then j will be one. In that way it will go on. So let's see again. So next, when I swap it, it becomes two and 50. Right now I have got other values. Now j is being incremented. So now this is becoming j and this is becoming j plus one. In that way, this swapping will be done. Suppose this is 70, so there'll be no swap. No swap. So let's see here. If this condition does not hold, swap is not taking place. I'm going back to this loop. All right, sorry. So now 70 remains here. And then suppose the next one. So now j changes. And j plus one is pointing here. Now there will be a swap here. So this is twelve. Say twelve and 70 will be swapped. So 250, 1270. In this way, I'll go on up to this point. And next. So ultimately, in this iteration, ultimately, I'll have this heaviest element, say 70 is the heaviest element coming over here. Then I will be decremented. And I will come here. And then for this zone again, I'll do the same thing as I did till now. Right, exactly. That is being done here. So I'll be doing this. And then I'll increment, I'll decrement n a little bit. And I'll go on doing this. I'll be then looping, doing the same loop again for one level less. I mean, the last element is already having the heaviest element. So I'll do it among the remaining part. So this part, this part is already covered. So I have decremented it. So I'll be now playing in this zone. And once that is done, this part will also be covered. I'll be playing in this zone. I'll be playing in this zone. Right. And in every zone. So once every time, I'm deciding on the zone, n n minus one, n minus two, like that, it is going on. And every time I am doing this loop for each of the pairwise element comparison, and thereby I am pushing the heaviest element at the bottom. That is the code for bubble sort. However, this swap keeps. I have not yet explained this swap. Earlier. We have seen that if we do swap in any arbitrary way, for example, if I want to swap two variables, say I write swap int a and b. Let me do it here, let me do it here. If I do it like this, int. Sorry. If I just do swap int a, int b, and inside, I use another variable, temp. Temp gets a, b gets a. Sorry. B gets a, and a gets. Sorry. A is stored here. A gets b. And then temp has been remembered there. So b gets temp. This was my function. Return. So here, suppose a was when it came, it was called with x and y. So, main program called swap with x and y. And x was five, y was seven. Right? So x was a location here, five and y was a location. Seven. Now, when it came here, a was a local location, and I know that the functions are called by value. So five was copied in a and seven was copied in b. Seven was copied in b and then by this temp became five, b became five and a became. Where is seven? B was stored in a. Sorry, this was towed. This. This became seven. And this became. Became five. All right, that's how it was done. So seven a was five. So stemp was five. Seven went over here to a and here, five was copied again here. This was fine. So the swapping was done by a, by b. And then when I returned, no change is reflected in x and y. That was the problem. So we will now see how the swap function can be implemented. And again, another point is here. I have just done return I and a function can return only one value. I could not return a and b to the main function. Right. So how can the thing be managed so that after the swapping, the result is reflected back in the main function? We'll see that in the next lecture.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Character Array and Strings.mp3,"We were discussing about strings. And in today's discussion, let me recapitulate what we the last part of what we discussed in the earlier lecture. How can we read words from an input? So there we had introduced this percentage s format with that, with percentage, as if we read a name, then it has to be noted that the ampere sand is not needed in this case. Right. The ampere sand is not needed. When I am reading a string. When I'm reading a string, I don't need that ampere sand. Now, the point to remember is that whenever I am reading this in this way, the string will be read, the string will be read until there is some blank white space. This is also called as white space or a tab sign or a carriage written or enter is pressed. So if I type on ABC and then I type blank, then this ABC will be taken as the word. So when I perform scanf in this form in name, then abc will go in the name. All right, so this is what we had seen last time. So that's why this example was given. If we type rupak Biswas, since after rupak there is a blank, we will stop at that point of time. The name will be assigned to rupac. Name will be assigned to the string rupac. Name will be assigned the string rupac. Okay. On the other hand, when we read a line of text, if I suppose I want to read, say this rupak Biswas, I want to read this blank. Also this entire thing, the entire sentence. I want to read a quick brown fox. I want to read. So I want to read these characters as well as this blank spaces, everything. Then what will be my delimiter? My delimiter will be the carriage return. Okay? The return. Carriage return, or that is often designated as backslash n. So till I get a backslash n, I'll go on reading this. That is how I can read a line. Okay? So in order to do that, we can use the gate care function for the purpose. By gate care function, we'll be getting the characters one after another. And I'll go on getting the functions till the character. I'll be going on getting the characters till I come to a character that is carriage return designating. That's an end of the line. Okay? So for example, here, a line has been defined to be of maximum length, 81. Typically, as I said, a line consists of 80 characters. And you must be understanding now, realizing now that why I put 81, the reason is here. I need a space for backslash zero. Okay? And I put C to be zero. C is the number of characters. C is here, designating the number of characters. Number of characters. Read. All right, now here we are doing it through a do while statement. You can see that we are doing it through a do while. So I'm reading one character here, say x. And that I'm reading it through getcad. And that character that has been read is coming to the variable array line. All right, line c. C was initially zero. So here I put x, then I go up, then character. I go on, I read it and then found that the character is not amperesm. I go back again, read another character, say x, y, increase c. So C is now pointing here. C is now pointing here. And I again go back. Now suppose a blank has been typed in. So I come here, get carries blank. So that comes here. And then C is pointing to the next position here. And then I go again here. And suppose I type in p. So the c is now pointing here. And then after that I read the character, and the character was ampere. I mean, character was backslash n. That means the end of the character. So I put Backslash n here, whatever it was there. And C is pointing here. Right. C is now pointing here. Now I have after insertion of backslash n, I come and find here that, well, what I have entered is backslash n. Now, Backslash n should not be there. Instead of that, we should have backslash zero. Therefore, I'll come back, I'll decrement c by one's position. So it will come here. And I'll replace this with backslash zero right here. I'll bring in backslash zero will come here. So the pattern that will be stored will be x, y blank p, backslash zero. So that's what the string will look like in that way. I'm reading a line. Okay, that's how we are reading a line. So we have seen that we can read characters as a character array. Care some line in this way, line 81. Now this line, I can read character by character, or I can type in line to be x, y blank p. That's also will do the same thing. Otherwise I could have copied it character by character. Both of them are equivalent, right? So here we have read the character until the carriage return or backslash n is encountered. And then we make it a valid string by replacing backslash n by backslash zero. Okay, an alternative approach of reading a line can be this, that I just specify the format here. Till now what we have seen is that our formats could be percentage s, percentage d percentage f, like that. I can also specify my format in this way. As you can see here, what it means is anything, I'm sorry, what happened? Anything that is ABCD or whatever, that this entire thing. Um, and here there is a blank here, there is a blank. I don't know what's happening here. Here you can see there is a blank here. So that means what is allowed? Anything, including blank capital a to z. Everything is allowed as members of the variable line. Okay. Similarly here the specification is that it can be carrot. This is a wild card. It's called, that means we can put in anything preceding backslash n. So this means it's a wild card. That means anything can come here as a character that can be a member of the variable line. So that's also another way of specifying it. Now these are specifics to the language c, of course. Now it's easier, relatively simpler to display strings on the screen. We can simply do a string. We can display the string with percentage x, s and followed by the string name. That's simpler. Now we come to a very important aspect. How do we process character strings? Now for that we have got several c library functions. We'll soon come to functions, and we have already seen different types of functions like square root maybe, did we see, and we have seen the standard functions like scanf, printf, all those things. Similarly, we have got c library, built in library functions for character string manipulation. How are they looking? Like they are, we have to, in order to do that, say one is strcpy, that means string copy. That means if I have a string here, say string. Here is my, sorry, let me put a blank here, my space job. Suppose this is a string a, and I want to copy it to another string b. So b will also therefore have my blank job. So that can be done by string copy function strcpy. Strcpy, how can that be done? We also have a similar thing like string length strlen, which means that I have got a string, say my job again, blank job. And automatically there is a backslash zero at the end. So when I copy it, then this will also be with strcpy will have my blank job. Backslash n will come here. Sorry, backslash zero will come here. But str len means string length. I'll count how many elements are there in the string. Can you tell me how many elements are there in the string? One, two, three. Blank is a valid character 123456. So the string length will be returned. That will be returned as six. Okay, similarly, we have another function very popular function, string comparison, strcmp. That means I have got two strings, my job and here my job and I compared them. If they are the same, then I'll have a one. Okay, so that is another function. The fourth function is strcat. What is meant by concatenation? Concatenation strcat is actually really S-T-R-C-A-T means string con. That means if I have a string here, say abc ended with this, and there is another string, say pqr ended with this. When I concatenate that these two strings, what I get is a joining of these two strings one after another. When I say that string b is concatenated with a, then my pattern will be abc. Note that this backslash zero will not come pqr and backslash zero. This is known as concatenation, all right, of two strings. So that is being given by a function strcat. Now, these are the very common functions for string operations for our job. If we need some other functions, we can always write functions which we'll learn in a couple of lectures from now. But these are already available in the c library. All right? And therefore, in order to do that, we have to include include string dot h. If you recall, we had said that if you recall, we can include always you do that hash, include stdio h. And also when we use that square root function earlier we had included math h. That means all the mathematic library of all the mathematical functions math h when we use for example, sqr square root. So this is a function that is already inbuilt, inbuilt in this math library. Similarly for strings, if I use this strcpy, strcat strp compare, then I have to include strings age in my function. All right, so, so here are some examples. Very much like a string assignment operator string copy. Just like an assignment. For example, we are saying string copy string one, string two. So both string two will be copied in string one. So assigns the content of string two to string one. Assigns the content. So this is the source, this is the destination. So it is copied from here to here. Okay, say string copy Ct Calcutta. What will happen here? That means I am trying to copy city is a string that is already defined. All right, I have defined city and I am copying this string. Now, this is a string constant. This part is a string constant. This is a string constant. Okay, so what I am doing is I have got a variable city variable of type string. Now this, how did you define it to be a type of type string? It was care ct say something like this care ct 20. So 20 characters can come there. Now when I write CT, strc copy CT to Calcutta. Or right now we should say kolkata. Say we do kolkata. Then in this variable, Kolkata will be loaded, all right? A followed by a backstab zero. Right? On the other hand, suppose city is here and suppose another city, another string variable is there, which is maybe Mumbai. And I copy string copy city, my city. That means, what will happen? This string, this string, my city will come into this variable city. So this kolkata will be overwritten and will be replaced by mumbai. Now, Kolkata is of length 123-4567 and mumbai is 123456. In that case, what will happen as I copy this whole string over here. Then here, mumbai m will come, u will come mbai. And this backslash zero will come here. And so the entire string will be kept here up to this. And with a backslash zero here and the remaining part of unused part of kolkata will be lost. Now, warning. There is a warning here. That is assignment operator does not work for string. So I could not have done string one assigned string two. Or as we are doing here, city assigned my city that won't do that. Assignment operator will not work in the case of strings. So ct assigned calcutta is invalid. String length. Strlen. This is. I will ask you when we teach you function to write a function for finding the string length, although it is available in the standard c library, counts and returns the number of characters in a string. So, Len, suppose Lane is a variable of type integer. Lane is of type integer. Okay. Lane is of type integer. And we say str. Alien string. So string is some string. All right. Some variable. Name. Street is a variable. And whatever is the. And suppose city is Mumbai. It will find out the length of the characters in this string. And that will come into Len. So Len here will get the value six. When I do this function on this, on the string, the null character at the end, as I said, is not counted because that tells you that you need not count any further. Okay. Counting ends with the first null character. So if I do calcutta, if I copy calcutta, this string constant, calcutta to city, and I find out the length of city, it will be 1234-5678 and backslash zero will be left out. So n is assigned eight, writing the string length. So one problem that can be given to you that I am not talking about this function part right now. Suppose I am trying to find out the string length of a character. String. I'm trying to find. How do you find out string length? I mean, it's writing a program that's finding the string length. You need not bother about the structure of this as yet, but let's look at the algorithm. Purely what is being done. Len, some variable has been put to zero. And then, while I am not encountering now, STr is an array, of course, array of characters. As you can see, it's an array of characters. As long as that is not equal to backslash zero, that means not the end of the string. I am going on incrementing this Len. Len was zero. Len becomes one like that. And then we return Len. Okay, after I complete it, then I return Len. Now, this is provided in the, of course I have to include the string h. But this thing, this is what I am writing. If, but actually this is already available, so I need not write it. I need to simply include hash. Include, I call it hash, include strings h. That library there, similar program is already written. And when I write str, alien, that is the program that is activated. String compare is comparing two strings. So we are comparing two strings and returns zero. If they are identical, what I just now said was just the opposite. If they are matching, then it returns zero. And if they do not match, a little non intuitive. So keep it in mind that if the two strings match, then we'll return a zero. Otherwise we'll return a non zero. Okay, so example is here. If I compare city with the string Delhi is zero, then I do something. What does it mean? City is a string already. Suppose that is again Chennai. Suppose that is Chennai, and I'm comparing. So city is a variable which has got this value and I'm comparing with Delhi. Of course, now they are not matching, so it will return non zero. But if this city was Delhi, then these two have matched and I would have got a one here. Right? Now, obviously, you can also just think and decide how this algorithm can be written. That's so simple. Now we have learned all the tidbits of writing such a program. So if this is not equal to zero, then we do this. So similarly, I can do ct one, ct two. So before that, you can simply think of how the algorithm will look like. In case of this, suppose I have got two strings. One is, say, chennai, and the other string is of course, backslash zero here instead of n. There is a name here. So how will you do that? So you will compare these two character by character. So this is, suppose ct one and this is ct two. So you can very easily compare while ct one. I, of course, I has been assigned to zero here. Is same as ct two, I. What shall we do? We'll go on incrementing I plus plus. And if it is not equal, we'll come out. So here I compare, here I compare, I come here, and here I find that city three and ct one three and city two three are not the same. So I'll come out. But what happens if they are same? So I need to put in if they are same, how long shall I go on? No mismatches there. Suppose this is also n, while city one is not equal to city two, while city one is equal to city two. Do I need another condition here? Yes, and CTi is not equal to backslash zero. So are you understanding this? While this condition which I have already written there, that should be true. In order to proceed, in order to proceed further for further checking, they are matching, so I should proceed. And also, the fact should be that none of this. Ah, two cities two strings have reached the end is not equal to this. And city two I. If any one of them has matched has reached the end, then my while condition will be violated. So I'll not continue any further. So I can keep a flag here that, what should I say? Match is one. So if I go on doing this match will be remaining one. Whenever I come out of this loop, I'll make match zero. That means there has been a match, because the convention is that if they are matching, then it should be zero. So you please also try to write this function. Write this program right now. We'll ask you to make it a function a couple of lectures later. I hope this is clear. This part. Please try to understand this condition. Try to understand this condition. All right, next we have got the last one. That is a strcat. That is rather simple. And you will also be able to write the program for that. It is two strings are just being concatenated. But one thing that you must remember, appending. Concatenating means joining, while appending means adding one at the end of the other. So when I write this ABC Pqr, then PQR has been appended to ABC. So string two is appended to string one. That means it is joined at the end of string one. Okay, so the null character at the end of string one is removed and string two is joined from that point. As we said that there can be ABC backslash zero. And then when I append PQR to that, then PQR will, P will replace this and backslash zero will come here. So ultimately we'll have ABC pqr backslash zero. All right, so string copy. Suppose I have name one a string assigned by string copy. Amit Amit. So it looks like this Amit backslash here. There's a backslash zero and there's a blank here. You see the string is not mit Amit blank. And another string is name two, which is RoI. Then when I append them, concatenate them, it will be a mit blank, this blank and then roi. And this blank has been replaced by r. So R has gone here and we'll get this. So this is string concatenation. This will often come handy when you type in some character strings or type in some lines or compute using some text strings. Text english sentence has been given and you are trying to find out where the verb is and all those. Then you need a lot of string operations like this. So here is an example. Here we are reading a line of text and counting the number of uppercase letters. How many uppercase letters are there? So what are the things we are including here? Stdio H, our old friend is here. String h is also there. Then look at this function. I have defined a line to be of length 81 big 181. Now I have got the variables I and car and count is equal to zero. I am asking the user to input the line. I am reading the line using this format which we just discussed. That means anything can come here. Anything can come here like ABC. All right. Percentage p, whatever is coming except backslash n, it's coming here. And then I'm finding the length of the line. Suppose the line that was actually typed in in this way through this scanf is say apple blank is red. All right. And then there's backslash here. Now this string length str alien will find out the length of the string. 1234-5678 910 1112. So twelve is n is becoming twelve. So for I equal to one to n. Now here is another new function that we are finding is upper if the character is uppercase letter is upper if the character that is being read that is being passed here, I put in some character and if the character is an uppercase letter then I'll count that. So suppose here I make a little change. I say this is I. I say that this is capital and I say that this is capital. So what is happening is it is reading character by character. From here I zero onwards and checking whether this character is an upper character. If that is so, count is becoming one. So count becomes one as a is uppercase letter. Then we go on in this loop I is being incremented until it comes to twelve less than twelve. So here is another one. So I'll get the count to be two. It goes on. And here I'll get another one. So three printf the number of uppercase letters is percentage d. Now look at this. The number of uppercase letters in string, percentage s, is percentage d. So line will be printed as a line. Apple is red. The number of uppercase letters in apple is red is three. So here this program demonstrates a couple of things. One is first of all, this is a new thing that you have learned. Es upper I'm just writing it separately so that it is clear. But in actual C library, the function is written without this gap or without any special character in between. This is the first thing that we have learned and how we can we have already seen. It's an application of what we learned, how we can read a line using this wildcard format. And then we found out what is the length of the line by our newly learned function strlen and using that we have this is this looping. We already know we have practiced it so often. So we now, using this value, using this for loop, for so many it iterations, so many repetitions that is determined by the value of n, will check the entire string. So this is an example of applying the string function in string operations. We'll go further with some more examples later.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
classes and objects in python.mp3,"You. So, in the last lecture we saw that in object oriented programming we define a data type through a template called a class, which defines the internal data implementation and the functions that we use to manipulate the data type. And then we create instances of this data type as objects. So we saw a skeleton implement of a heap. So this had a special function called init, which was used to create the heap. And then we had functions insert and delete. Now, one thing which we did not explain is this argument self that runs through this. So this is a convention which we have in python that every function defined inside a class should have as its first parameter the name self. Now, it need not be called self, but it's less confusing to always call itself. So let's just assume that this parameter is always there and it's called self. Now, what is self? Self is a name that is used inside the class to refer to the object that we are currently looking at. So for instance, if we are dealing with this heap h, when we say h dot insert, then this insert is using the value 17. So 17 is the value x which is being passed to insert, and h is the value on which the 17 should be added. And that is a name for self. So self, in other words, tells the function which object it is operating on itself. So it's a name to itself, because you're telling an object a heap h, insert 17 into yourself. So in that sense, mine values are denoted by self. And inside a heap we can maybe refer to other heaps. We will see a little later that we can take one value and refer to another value. So there will be my values and there'll be other values. So my values are always implicitly called self, because that's the one that is typically manipulated by a function. So, to make this a little clearer, let's look at a slightly simpler example than heaps to get all the notation and the terminology correct for us. So our first example is just a representation of a point xy. So we're just thinking about a normal coordinate system where we have the x axis, the y axis, and therefore a given point is given some coordinate, like a comma p. So this is a point whose x coordinate is a and y coordinate b. This is a familiar concept that all of you must have seen in mathematics at some point. So we want to associate with such an object two quantities, the x coordinate and the y coordinate. And this is set up by the init function by passing the values a and b that you want the point to have. And now we have within the point we have these two attributes, x and y. So every point looks like this. It has an x value and a y value, and this x value is something, and the y value is something. And if we change this x and y value, then the point shifts around from one place to another. Now, in order to designate that the x and y belong to this point and no other, we prefix it by self. So self dot x refers to the x value within this point myself. Self dot y is y value within myself. If we have a generic point p, then we'd have p dot x p dot y. These will refer to the values x and y, the names x and y associated with the point p. So inside the class definition, self refers to the value of the attribute or the name within this particular object. Now, this particular object changes as we move from one object to another. But for every object, self is itself. So for p one, if I tell something about p one in the context of p one, self is p one. If I have a different point p two, in the context of p two, self is p two. So this is an important thing. So just remember that every function inside a class definition should always have the first argument as self and then the actual arguments. So in it, in this case takes two arguments, but we always insert a third argument. So let's look at how this works. For instance, if we say p is equal to 00:32 then three will be passed as a and two will be passed as b. And this will set up a point that we have drawn here, which internally is represented as self dot x is three and self dot y is two. Now here is a slightly different function. It takes a point and shifts it. So we want to say shift this to three plus delta x and four plus delta y. So this function we call translate. So it takes the amount of shift as the argument delta x and delta Y. And as usual, we are always providing self as the default first argument. So just keep this in mind. Every Python function, every Python class, if you want to use a function in the object oriented style, the first argument must necessarily be self, and then the real arguments. So what do we want to do when we want to translate a point, we want to take self dot x and move it to self dot x plus the value delta x. So we want self dot x plus delta x. Now this is a very common paradigm in Python and other programming languages, where you want to take a name, say z, and then you want to shift it by some amount, say z plus six, or z is equal to z minus six so whenever we have this kind of a thing where the same name is being updated, there is a short form where we can combine the operation with the assignment. So self dot x plus equal to delta x is just a shortcut in Python for self dot x equal to self dot x plus delta x. It means that implicitly the name on the left is the first argument to the operation mentioned along with the assignment operation. So this is a very convenient shortcut. It allows us to save some typing. So instead of writing self dot x equal to self dot x with delta x, we just write self dot x plus equal to delta x. So this shifts the x coordinate of the current point by the argument provided to translate. Similarly, self dot Y plus equal to delta Y will shift the argument by the amount provided by delta Y. So for instance, now if we say p dot translate to one, then we get a new point which is three plus two five for the x coordinate, and two plus one three, right? So this three plus two gives us five, and two plus one gives us three. So this shifts the point from three two to five three. So this is how we define these internal so the internal implementation is defined inside the init function. This is the function that is called when the point is set up, and this associates these internal names x and y with the object. So this is where the implementation really gets set up. And then the functions that we define externally translate manipulate this internal representation in an appropriate way so that it changes consistently with what you expect the functions to do. So let's look at a different function. So supposing we want to compute the distance of a point from the origin. So we want to know what is this distance. So this distance by Pythagoras's theorem is nothing but the square root of x squared plus y squared, right? So remember, this is like the hypotenuse of a right angle triangle. So you take x squared plus y squared square root, and you get d. So if we want the distance of a point, we don't give it any arguments, but we always have this default argument, self. So we want to know what is the distance from zero zero to the current point. So we would say something like in our earlier case, p is equal to zero, say three comma four, and then we would say p dot o distance to get its distance. So maybe we would assign this to a name, let us not call it, say we might assign this to a name like n. So when we do this, it will look at the current value of self dot x. The current value of self dot y, square them, add them and take the square root. Now one thing to remember is that actually square root is not a function available by default in Python. So you actually have to import the math library. So at the top of your class definition, you should have remembered to write from math import star. So assuming that we have done that, then square root is defined. So this is a typical function which returns some information about the point. The earlier function just translated the point, didn't tell us anything. This is a function that returns some information about the point. Now if o distance is something that we need to do often, then maybe it's useful to just keep the point in a different representation. So you may remember, or you may have seen somewhere in high school mathematics, that if you take a point x y, then an alternative way of representing where this point is is to actually use polar coordinates. So you can keep this distance and you can keep this angle. So if I have r and theta, it's the same information as keeping x and y. So the connection between the two is that x is r cos theta, where cos is a trigonometric cosine function. Y is equal to r sin theta. And on the other hand, if I have x and y, then I can recover r as we just did for o distance. It's the square root of x squared plus y squared and theta. So y by x is actually, if you divide y by x, you get tan of theta just because it's sine divided by cos and the r cancels. So y by x is tan theta. So theta is the tan inverse of y by x. So now, speaking of changing implementation, we could change our implementation so that we don't keep the internal representation in terms of x and y. We actually keep it in terms of r and theta, but the functions remain the same. So for instance, we could take the earlier definition and change it. So we again pass it x and y. So from the user's perspective, the user believes that the point is defined in terms of the x and y coordinate. But instead of using a and b as the argument directly, to set up the point, we first set up the r the radius by taking the square root of a squared plus b squared and then depending. So we want to divide b by a. But if a is zero, then we have a special case. B by a will give us an error. So if a is zero, we set the angle to be zero. Otherwise, this is the python function in the math library for tan inverse arc tan. We set theta to be the arc tan of b minus a b divided by a. So we internally manipulate the x y version to r theta using the same formula that we had shown before, which is that r is square root of x squared plus y squared and theta is tan inverse of y by x. The only thing we have to take care is when x is equal to zero, we have to manually set theta to zero. So now internally we are now keeping self dot r and self dot theta. We are not keeping self dot x and self dot y. So this is useful because if we want the o distance, the origin distance, we just have to return the r value. We don't do any computation. So in other words, if we are going to use o distance very often, then it is better to use the calculation square root a squared plus b squared once at the beginning when we set up the point and just return the r value without any calculation, whenever you want the distance from the origin. So this might be a requirement depending on how you're using it. And one implementation may be better than the other. But from the user's perspective the same function is there, there is self, there is o distance. So if I take a point and I ask o distance, I get the distance from the origin, whether or not the point is represented using x y or r theta. Now of course using o distance is r theta is good for o distance. It's not very good for translate. If I want to translate a point by delta x delta y, I have to convert the point back from r theta to x y using x equal to r cos theta and y equal to r sin theta. Then do x plus delta x y plus delta y and convert it back to r theta. So you pay a price in one function or the other with the x y representation, translate is better with the r theta representation, o distance is better. And this is a very typical case of the kind of compromise that you have to deal with. You have to decide which of these operations is likely to be more common and more useful for you to implement directly. So if you think translate happens more often, it's probably better to use x and y. If you think the origins in the distance is more important, it's probably better to use r and theta. So often there is no one good answer. It's not like saying that a heap implementation is always better than a sorted list implementation for a priority queue. There may be trade offs which depend on the type of use you are going to put a data structure to as to which internal implementation works best. But what you have to always keep in mind is that the implementation should not change the way the functions behave to the external user. The function must behave exactly the same way. So in this particular example, just to illustrate what we have said, again we have changed the private implementation. Namely we have moved from x y to r theta, but the functionality of the public interface, the functions o distance, translate, et cetera, remain exactly the same. Now, we have seen earlier that in Python functions we can provide default arguments, which make sometimes the arguments optional. So for instance, if we want to say that if we don't specify the x and y coordinates over a point, then by default the point will be created at the origin. So then we can use a equal to zero and b equal to zero as default arguments, so that if the user does not provide values for a and b, then x will be set to zero and y will be set to zero. So for instance, if we want a point at a specific place three comma, four, we would invoke this class. We'll create an object by passing the arguments three comma four. But if we don't pass any arguments like p two, then we get a point at the origin. So the function in it clearly looks like a special function because of these underscore, underscore neither side which we normally don't see when we, or normally don't think of using. When we write a Python function, as we said before, Python interprets in it as a constructor. So when we call an object like p equal to 00:54 then this implicitly calls in it, and in it is used to set up self dot x, self dot y. So the internal representation of the point is set up in the correct way by init. So init is a special function. Now Python has other special functions. So for instance, one of the common things that we might want to do is to print out the value of an object. What does an object contain? And for this, the most convenient way is to convert the object to a string. So the function str normally converts an object to a string. But how do we describe how str should behave on an object? Well, there is a special function that we can write called underscore, underscore str. So underscore underscore str is implicitly invoked when we write str of o. So str of an object, o is nothing but o. Underscore underscore str. And for instance, print the function print implicitly takes any name you pass to print and converts it to its print representative. When I say print x and x is an integer, implicitly str of x is what is displayed. So str is invoked and str, in turn, internally invokes a special function, underscore and underscore str. So let's see how this would work. For instance, for our point thing. So if we want to represent a point, so internally we have self dot x and self dot y. We want to print this out in this form, the value x and the value y. So what we do is we set up str. So remember that self is always a parameter. So what it does is it first creates a string with the open bracket and the closed bracket at either end and a comma in the middle. And in between the open bracket and the comma, it puts the string representation of self dot x, and in between the comma and the closed bracket, it produces a string representation of self dot y. So this creates a string from the value. It internally invokes str on the values themselves, self dot x and self dot y, and then constructs these extra things, the open close bracket and the comma, to make it look like a point. As we would expect. Another interesting function that Python has as a special function is add. So when we write plus, the function, add is invoked. So in other words, p one plus p two, if these are two points, would invoke p one, underscore, underscore add p two. So what we would expect is that if I had p one, and if I had p two, then I would get something, which gives me a point where I combine these two. So I get the x coordinate as x coordinate p one plus p two, and y coordinate p one plus p two. It's up to us. I mean, it doesn't mean it has to be this way. But if I say p one plus p two, the function that is invoked is add, and it's up to us to define what add means. So let us assume that we want to construct a new point whose x coordinate and y coordinate the sum of the two points given to us. So here is the way we would do it. We would create a new point whose x coordinate is self dot x plus p dot x. Now notice that self is the function associated with p one. In this case, add. So self refers to p one. When I say p one plus p two, and the other argument, p two, is the point p. So I can look at the values of p and say p dot x, p dot y, I can look at my values and say self dot x, self dot y. And now I can combine these by creating a new point, self dot x plus p dot x and self dot x plus p dot y. So for instance, if we have two points at one two and two five, then this will return a point at three seven, and I must store it in new point. So p three now becomes a new point whose x coordinate is three and y coordinate is seven. So in the same way, we could have a special way of defining multiplication. And in Python, the underscore underscore mult function is the one that is implicitly called by multiply. Similarly, we can define comparisons. We might say what is to be done when we compare whether p one is less than p two. Do we check both coordinates are less? Do we check the distance from the origin is less? We have complete freedom how to define this, but we just write p one less than p two for ewtn in our program and internally it will call the function less than lt, similarly greater than will call the function gt. And there is something for less than equal to, greater than equal to, and so on. So these are all very convenient functions that Python allows us to call implicitly, and allows us to use conventional operators and conventional functions in our code. We don't really have to think of these objects in a different way when we are coding our programs. So there are several other such functions. It's impossible to list all of them, and it's not useful to list all of them at this introductory stage when you are learning Python, but you can always look up the python documentation and see all the special functions that are defined for objects and classes.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
control flow.mp3,"In the past few lectures, we have looked at values of different types in Python, starting with the numbers, then moving on to the booleans, and then sequences such as strings and lists. Now let's go back to the order in which statements are executed. Remember, we said that a typical Python program will have a collection of function definitions followed by a bunch of statements. So in general general, the Python interpreter will read whatever we give it from top to bottom. So when it sees a definition of a function, it will digest it, but not execute it. We will look at function definitions in more detail very soon, and when we now come to something which is not a definition, then Python will try to execute it. This in turn could involve invoking a function, in which case the statements which define the function will be executed, and so on. However, if we have this kind of a rigid, straight line execution of our program, then we can only do limited things. This means we have an inflexible sequence of steps that we always follow, regardless of what we want to do. Now, in many situations, in many realistic situations, we need to vary the next step according to what has happened so far and according to the current values that we see. Let us look at a real life example. So supposing you are packing your things to leave for the bus stop in the morning. Now, whether or not you take an umbrella with you will depend on whether you think it is going to rain that day. If you carry the umbrella all the time, then your bag becomes heavy. If you don't carry the umbrella ever, then you risk the chance of being wet. So you would stop at this point and see, in whatever way, by reading the weather forecast or looking out of the window. Is it likely to rain today? If it is likely to rain, ensure that the umbrella is in your bag. Put it in if it's not there, or leave it in if it's already there. If it is not likely to rain, ensure the umbrella is not in the bag. If it's not there, it's fine. Otherwise, take it out. So this kind of execution, which varies the order in which statements are executed, is referred to in programming languages as control flow. So there are three fundamental things, all of which we have seen informally in the GCD case. One is what we just described, the conditional Execution. The other is when we want to repeat something a fixed number of times, and this number of times is known in advance. We want to carry ten boxes from this room to that room. So of ten times, we carry one box at a time from here to there. On the other hand, sometime we may want to repeat something where the number of repetitions is not known in advance. Suppose we put sugar in our teacup, and we want to stir it till the sugar dissolves. So what we will do is stir it once, check if there is still sugar, stir it again, check if there is still sugar, and so on. And as the sugar dissolves. Finally, after one round, we will find there is no sugar at the bottom of the cup, and we will stop stirring. So here we will repeat the stirring action a number of times, but we will not know in advance whether we have to stir it twice or five times. We will stir until the sugar dissolves. So let's begin with conditional execution. So, conditional execution in Python is written, as we saw, using the if statement. So we have if. Then we have a conditional expression which returns a value, true or false, typically a comparison. But it could also be invoking a function which returns true or false, for example, and we have this colon which indicates the end of the condition. And then the statement to be executed conditionally is indented, so it is set off from the left, so that Python knows that this statement is governed by this condition. So we make this simultaneous assignment of m taking the old value of n, and n taking the value of m divided by n only if m divided by n currently is not zero. So the second statement is executed conditionally only if the condition evaluates to true. And indentation demarcates the body of the if the body refers to those statements which are governed by the condition that we have just checked. So let us look at a small kind of illustration of this. Suppose we have code which looks as follows. We have if condition. Then we have two indented statements, statement one and statement two, and then we have a third statement which is not indented. So the indentation tells Python that these two statements are conditionally executed, depending on the value of this condition. However, statement three is not governed by this condition because it is pushed out to the same level as the if. So, by describing where your text lies, you can decide the beginning and the end of what is governed by this condition. In a conventional programming language, you would have some kind of punctuation, typically something like a brace, to indicate the beginning and the end of the block, which is governed by the condition. So one of the nice things about Python which makes it easier to learn and to use and read is the dispensation with many of these punctuations and syntactic things which make programming languages difficult to understand. So when you're trying to learn a programming language you would like to start programming and not spend a lot of time understanding where to put colons, semicolons, open braces and closed braces, and so on. So Python tries to minimize this, and that makes it an attractive language both to learn and to write code in if you're doing certain kinds of things. So Python will not have this, and then we will see a much cleaner program as a result. One thing we have emphasized before, and I'll say it again, is that this indentation has to be uniform. In other words, it must be the same number of spaces. And the most dangerous thing you can do is to use a mixture of tabs and spaces. When you press the tab on your keyboard, it inserts some number of spaces which might look equal to you when you see it on the screen. But Python does not confuse tabs and spaces. So one tab is not going to be equal to three spaces or four spaces, or whatever you see on the screen. And the more worrying thing is that Python will give you some kind of error message, which is not very easy to understand. So it's quite useful to not get into the situation by remembering to always use exactly some uniform strategy. For example, two spaces to indent whenever you have such a nested block. So quite often we have two alternatives, one to be taken if the condition is true, and the other to be taken if the condition is not true. So if it is likely to rain, ensure the umbrella is in the bag. Else ensure the umbrella is not in the bag. So in this case, for example, if the remainder is not zero, continue with new values for m and n. The remainder is zero. Then we have found the gcD, namely the smaller of the two values. So this is indicated using the special word else, which is like the English else, again with a colon. And again, we have nesting to indicate what goes into the else, and the if and the else should be nested at the same level. The else is optional, so we could have the if without the else. Technically speaking, the condition that we put into an if statement must be an expression that explicitly returns a boolean value, true or false. But like many other programming languages, Python relaxes this a little bit and allows different types of expressions which have different values, like the types we have seen so far, like numbers and lists, to also be interpreted as true or false. In particular, any number, any expression which returns a number zero, any numeric expression of value zero is treated as false. Similarly, any empty sequence such as the empty string or the empty list is also treated as false. And anything which is not this case. So if I have a non zero value as a number, or if I have a non empty string, a string with seven characters, or a non empty list, a list with three values, then all of these would be interpreted as true if I just stick them into a condition. So this can simplify our expressions and our code. So instead of saying m percent n, as we said before, m percent n not equal to zero. So remember, if it is not equal to zero, then it is true. So when it is not equal to zero, it is true. So if this condition holds the same as asking whether m percent n is a non zero value, and if it is non zero value, we want to replace m and n. So we can just write if m percent n. So this is a shortcut. Now, use it with care. Sometimes, if you are used to it, and if you are familiar with what's going on, this can simplify the way you write things. But if you are not familiar with what you are going on, you can make mistakes. So if you're in doubt, write the full comparison. If you are not in doubt, or if it's very obvious, then go with the shortcut. Here is a very common situation that occurs sometimes. We don't want to check between one of two conditions, but one of many conditions. So supposing we have a value x, name x, which can take a value one, two, three or four. And depending on whether it's one, two, three or four, we want to do four different things, which we called f one, f two, f three, and f four. So if we simulate this four way choice using if and else, then we have to make some comparison first. So supposing we first check if x is equal to one, then we invoke f one. If x is not one, then it's one of the others. So all of this goes into an else, and everything gets nested. Then we check in this case, if x is equal to two, then we do f two. Otherwise we have three or four. So now all of this is nested once again. And finally, we have x is equal to three or not three. So this is x is equal to four, and then we are done. But the main problem with this is that, first of all, this code is getting indented. So, as you go into this nested if structure, to simulate this multi way branch, we have essentially a four way branch. X could take one of four values. For each of these four values, you want to do four different things. So if we simulate it by taking three two way decisions, we check one or not one, then we check two or not two, and then we check three or not three. Then we have this ugly nesting, and secondly, we have this else, followed immediately by an if. So Python has a shortcut for this, which is to combine the else and the if into a second check l. If. So, this on the right is exactly the same as the left as far as Python is concerned. It checks the condition x equal to one. If x is equal to one, then it will invoke f one. Otherwise it will invoke the rest. Now the rest we have just collapsed the else and the if to directly check a new condition. If this condition holds, then this works. Otherwise it will check the rest and so on. So we can replace nested else if by l if in this way, and it makes the code more readable, because it tells us that we are actually doing a multi way check. And notice that the last word in L if is again an else. So if you have, say, seven different options and you're only doing special things for one, two, three, and 4567 are all the same, then we can use else. We don't have to explicitly enumerate all the other options. So we have a number of explicit conditions that we check. So by the way, this I noticed the typo there should not be. So we have a number of explicit conditions. We check with if and a sequence of ellipse. And finally we have an else. The else again is optional, like it is with a normal if. But the main thing is it avoids this long indentation sequence, which makes the code very difficult to read later on. So the first type of control flow which we have seen is conditional execution, and the other type is loops. So in a loop we want to do something repeated number of times. So the most basic requirement is do something a fixed number of times. So here, for instance, we have the statement for, which is the keyword in Python. So what Python says is take a new name and let it run through a sequence of values. And for each value in the sequence, execute this once. So this is in sequence, it's multiplying y by one, then the result by two, then the result by three, and so on. So at the end of this we'll have y times one times two times three times four, and we'll have z plus one plus one plus one plus one four times, because each time we're adding one to z. So this will be the outcome of this loop. So the main thing is exactly like if we have Indentation to mark the body of a loop. So the most common case for repeating things is to do something exactly n times. So InStEad of writing out a list one to n, what we saw is that we can generate something equivalent to this list by using this built in function range. So range zero one, we said, starts at zero and generates a sequence of the form zero one two stopping at n minus one. So this is similar to the positional convention in Python, which says that the positions in a list go from zero to the length of the list minus one. So range also doesn't go from zero to n, but zero to n minus one. So instead of writing for I in a list, we can write for I in a range. And this is, from the point of view of Python, the same thing. Either we can let this new name range over an explicit list, or an implicit sequence given by the range function. So in general, range I j, like a slice I to j starts at I and goes up to j minus one. So we can also have range functions which count down, and we can have range functions which skip a value, we can do every alternate value, and so on. We will see These variations on range a LittLE later, but for now just note that we can either have a for statement which explicitly goes through a list of values, so we can give a list and ask for to go through each value in that list, or we can generate a sequence of n values by using the range function. So let's look at a simple example of this. SUppose we want to find all the factors of a number n, all numbers that divide n without a remainder. So, as we recalled when we did GCD, all the divisors or factors of a number must lie between one and n. We cannot have any number bigger than n which is a factor of n. So one simple way to check the list of factors is to try every number from one to n and see if it divides. So here is a very simple function for it. So, we define a function called factors of n, which is going to give back a list of all the factors. So internally we use a name f list to record this list. So the list of factors is initially empty. And now, keeping in mind that all the factors lie between one and n, we generate in sequence all the numbers from one to n. And remember, this requires the upper bound of the range to be n plus one, because the range function stops one below the number which is the right hand side. So this will generate a sequence, one, two, three, up to n. And what we check is if there is no remainder when n is divided by I. Then we add I to this list and remember, that plus for a list and for a sequence is concatenation, it actually adds a value to a list. And this allows us to return a new list. So at the end of this, we have computed all the factors of n and returned them as a list. But as we said at the beginning of today's lecture, sometimes we want to do something some number of times without knowing the number of times in advance, like stirring the sugar in the cup. So we saw an example of this with the GCD. So what we did was we have another statement like for called while. So while executes something, so long as a condition holds. So we execute this body so long as this condition evaluates to true. And then when we have finished executing this, we come back and check again whether this condition is true or not. So the danger is that every time we come back, the condition will be true and this thing will never end. In the for case, we know in advance that it will execute exactly as many times as the length of the sequence that we started with. So when we start a for loop, we give a fixed sequence. That fixed sequence has a fixed length, and so we must terminate the loop in that many executions in a while. We come back, we check the condition again, but there is every possibility that the condition will never become true. So we have to ensure, when we write a While loop, that somehow this sequence of statements to execute inside the while must eventually make this thing to be false. Because if this thing never becomes false, condition will never, the loop will never terminate. So the example we saw with Gcd was a variation of what we wrote so far. So we first, of course, check and swap so that the bigger number is first. And now we check whether the bigger number is divisible by the smaller number. So, so long as this is not the case, we exchange values for m and n, we make m point to the smaller number n, and we make n point to the remainder, which will be still smaller, and eventually this thing will become false. We will get the situation where n divides m and the remainder is zero. And at that point we have found the Gc. So this is a simple example, of course, remember that by our earlier convention, we could also write this as while m percent n make this thing so we don't need this explicit, not equal to zero, because the value m percent n, if it is not zero, is treated as true, and their loop will go one more time. But now, in some situations, it may or may not be so easy to read this. So it might be useful to just say explicitly not equal to zero, just to illustrate to yourself and to the person reading your code what's going on. So, to summarize, a Python interpreter normally executes code from top to bottom in sequence, so we can alter the control flow in three ways. We have seen one is using the if statement, which conditionally executes, and this extends to the l if, which allows us to do a multi way branch. Then there is the for statement, which allows us to repeat something a fixed number of times by providing a list or a sequence of values from range. And then we have a repetition which is based on a condition using a while statement, where we put a condition and then the body is executed each time the condition is checked again, so long as it's true, the body keeps repeating. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Data Representation.mp3,"Today, we'll be looking at some real applications, engineering applications of programming, and we'll see how whatever we have learned till now can be applied to solve some interesting problems like solving equations. One very common thing that we need in any engineering or science is to represent data, right? One way of representing data is by, in the form of a table, right? So I can always represent some data as a table where there can be, say, on one column, it may be height or depth. And maybe as we go down, we bore through some point and at different depths, different depths, we find, we put some sensor and get the temperature so that I can represent in the form of whatever is the depth, 50 meters, some temperature, 100 meters, some temperature, et cetera. So if we need to represent any data in this form, we know how to do it. We know that we can, as it looks here, we can immediately say, okay, we'll be representing it as array. Whether I'll be using it, represent them using as one array, one two dimensional array, or two different array will depend on the format of the data, the type of the data. For example, if the depth is integer and the temperature is real, then up to the knowledge that we have acquired till now, we'll be representing them in the form of two arrays. One is an integer array. Another is a separate floating point array. All right? So that is one way, one aspect, one way of representing data, as we have done also in the case of students toll number and marks earlier. Another very interesting thing and important thing is representing graphs. For example, I want to represent a graph like this. Say, maybe this is, say again, some pressure and this is depth. And as this graph shows that it is not increasing in a uniform way with depth, right, there could be some graph which would be just linear. This is, we call it linear, where along with depth, this increases in a linear fashion. Here it is nonlinear. Okay? So the question is, how do we represent this sort of graph? Now, you know that this graph, I can also state, if I say this is the x axis and my independent variable is x and the dependent variable is y, then this graph essentially represents a function which is y is a function of x. Now, depending on the nature of variation of the dependent variable with the independent variable, the nature of the function will vary. This one will be a linear function, right? For example, it can be here, y equals to some kx. All right, this one is more complex. I could have had a quadratic function. Also, this is a linear function. Now, the question that we would like to first address is, it is so very nice to draw a picture on a piece of paper. However, a computer will not be able to just interpret this picture as we do. Then, in that case, how would we represent this graph in a computer? So let's do it again. So, I have got a graph, let's say a linear graph. And I can say that for different values of x, what is the corresponding value of y? All right. Now, this is a linear one, so I can represent them. If x and y are of the same type, I can also represent them in the form of a table. That means a two dimensional array where one side, one dimension is the variation of x. On one column, we have got the x and the corresponding y. All right, and what will be the number of rows, the number of data points of x that we take will be the size of this array, not the size of this array, the number of rows, how many n? And this one is fixed to be two. I can suppose at this is 5.0 and this is 25. So I have five here. I have 25 here. This array is of type float. Now, here it is ten, so it is 50. It may be 15. So this one will be 30. Because I'm talking of a linear curve, it need not be linear all the time. So I can also have a curve like this. I can also have a curve like this, say something like this. And here again, I have got the y. And here I have got the x. So with a particular value of x, say five, maybe this one is initially, let's say it has risen a little sharp. So maybe it is seven. And if I go here. Now, please note that we usually take the samples at equal distances. So I take it as ten, but here it will not be double. It is becoming a little more than that. So seven, it may be 16. I go here. Now, you see, the slope of this curve has reduced, right? The gradient has reduced. So at 15 it will not increase that much. It will be 18. Say this is 18 because it is flattening out, still flattening out. And here there is a sharp change, et cetera. Right? So this one also I can represent in the form of a table. Like, say I have a two dimensional table where I have got five. This is my x and this is my y. So five corresponding to that seven, first row, that's the first point I could have taken. Zero, zero, also, that would be another one. So ten corresponding to that 16, then 15 corresponding to that 18. So in that way, it could go on. That means whatever is this function F-X-A function can be represented as an array, two dimensional array. Okay. Or as a table. So this we have to remember either as one array or as two arrays, because if this was integer, this was float, then I would have needed two different arrays. Right? It can be. So here is a function. Now let's look at another aspect. Sometimes some data, I don't have the function, but I have got some data. Right? So here x, and here is y. And I have got some data points for x equal to this. This is the y point. All right, so if I call it x zero, this is y zero. Next one could be here. That x one, it is y one here. Maybe it has come down, sorry, x two. It is y two. This will be y two. So I don't have a function right now, but I have got different data points and I have to find out the function. So that is also another very interesting thing. Finding out the function that can represent this distribution of data points might be here again, there is x three, and it has again gone up here. So it is not a straight line. If I want to fit a curve to meet that, how would that curve look like? The curve will be something like this. Right? And I have to find out, what function is this, this curve, what is a function? I do not know as yet. That's another challenging point. All right, so first of all, graphs, or data points, graphs can be represented as table, and the distribution of data points can also be represented as table, because here in this scenario, I don't have a function, but certainly I've got the x and y values known to me. Therefore I can represent that as a table. Another point to note here is that usually this independent variable, the sampling points that I am taking are usually equidistant. So I can say x one minus x zero is some value h x two minus x one will be the same h. Usually we represent that in order to see, for an incremental, fixed incremental increase of the independent variable, how much does the dependent variable vary? Okay, so I can say in general, x I plus one minus xi is equal to h, right? So this is typically how we write. Now, we have got a number of problems to solve using data. So, for example, let's start with one problem, finding the root of a function. Finding the root of a function, some function f x. Now, finding the root means essentially it is solving the equation. So if I have got a function f x, then my equation is f x equals zero. And I want to solve this, right? And I want to find out the root, at least one root. Now, what do I mean by the root. The root is that if there is a function like this, say there is a function like this. So for what value of X-F-X equal to zero is the equation. So this one is F-X-Y or f x. So we have to find out for what value of x, for which value of X-F-X is zero. So that is the root. Now, this particular function, if this be an f x, then it has got two distinct roots, right? Another function could be something like this, could be just like this, where I have got one root. This is the point where f x equal to zero. All right? So one of the major problems is finding out the root of a function, or we'll say, in general, the root of a polynomial. Why are we saying a polynomial? Because you know that any function, say f x is equal to three x square plus two x plus three is a polynomial of degree two, right? Or this f one x, I could have another f two x as four x. This is a polynomial of four x plus three, maybe. All right, now, anybody who remembers school coordinate geometry, this is a linear equation because it's a polynomial of degree one. That means if we say this to be y, then this is y equals mx plus c. So m, this four is nothing but the slope of this straight line. So there will be some slope of this straight line. This is linear. All right? This one is not linear, this quadratic, okay? So I can have, the different functions can be written as a polynomial. And when the polynomial is equated to zero, it becomes an equation. And we want to solve that equation. Problem number two is interpolating a function. I'll describe what interpolation is a little later, okay? But before that, before that, let us try to see a very simple way of finding the root of a function. Say I have got a function, x and y, all right? And a function is something like this. Now, I want to find out this point. What is the value of x? This value, okay, for which this y is zero. Now, the method that we will be talking about is known as the bisection method. This is a very common and interesting approach you have seen in binary search. Also, we have partitioned the array into two halves and then went to one half very similar to that. Let's see how the bisection method tries to find out the root. First, we start finding two arbitrary points, say x zero and x one, such that f x zero and f x one are of different signs. So here you can see this is plus, this is minus, right. F x one is the y value corresponding to x one. So if the y value of x zero and x one are opposite, then it is immediately understood that the root must lie somewhere in between. Okay? So we will then try to find out the midpoint of x zero and x one. Suppose the midpoint of x zero and x one is x two. So if x two, f x two and f x zero are of opposite sign, then I'll again find the. Then the root must be. I have reduced my space, right? So it is between x two and x zero. So I again find out the value, the midpoint of x two and x zero. Suppose that midpoint is here. Suppose this x three and these two, f x three and f x two are of opposite signs. Therefore, I will find the midpoint of these two. So suppose the midpoint of these two is this x four here. Now still this one and this one are of opposite sides. Therefore, I'll try to find out the midpoint of these two. So I'll come somewhere here. All right. In that way, we approach. Till what? Till we find that the value of y is very close to zero. The value of y is very close to zero. Very close to zero. Why am I saying very close to zero? Not exactly zero? There are reasons for that. Reasons we are coming to that. A computer works with finite representation of numbers. So we may not get exact zero. But suppose I get this, and then I can assume that to be zero because it's very small. And often we call it that. The difference that the value of f x at that point is less than equal to some very small value, epsilon, that will decide f priority. Okay? So, however, so you have seen this approach. Now, one thing that you can quickly think of, that how would I know that these two are of opposite signs? F x one and f x zero are of opposite signs. If I take the product of this, if I take the product of this, then obviously, if they are of opposite signs, the product will be negative, that is, less than zero. So at every point we check whether they are less than zero. If there is no root, suppose it goes like this. Then I'll not find any point where they are of opposite signs. Okay? So that is the basic idea of bisection method. Now, when I carry it out through a computer, such attempts to solve such problems are known as programming numerical methods. And we'll start with some representative, relatively easy one, examples of those, some numerical methods. One of them is finding the root of a function. Root of a polynomial. Root of a polynomial. Okay? Now, while doing this, numerical methods, we always encounter errors, okay? And our algorithm will be better if the error is less. Now, what do I mean by error? Say I am computing four by three. All right, what is the result? Result is one point correct result. Most accurate. Absolutely correct result. Do you know that? No. 1.33. It goes on. Now, how much my computer, you know, our computers have got some storage locations of some eight by eight bits or 16 bits like that. So depending on that, I have got a finite capacity to store the data. Therefore, I may represent this as say, 1.33. I just start with, say six, six digits. All right, six, seven, eight. I can store eight digits maximum six after decimal one, decimal. And this. So six places. Therefore I am actual thing was much more. So I am encountering, I am actually committing some error. So what is the error? Error in computation is the exact value, the difference of the exact value. By this and the computed value, it can be positive or negative. All right, suppose the result is actually 1.523. That's the exact value. Suppose and during my computation I got 1.52,823. Okay, then the error is the difference between these two, and the error is. Therefore, if I subtract this, it will be zero 0.7. That is the error. Now, the smaller this error is, more accurate. My result is. I think it's very clear. Now, there are two types of errors. Also. One is a round of error. For example, here I could have rounded it off as 1.523. So actual, suppose the actual thing was this, and I rounded it to 1.52 by approximating. If I go by two bits, that's one type of error. Other type of error is truncation error. This was there. I have just dropped this 1.52 because I could not store more. So there are two types of errors, right? So truncation error and round of error. Another term that you need to know is the absolute error. Absolute error is nothing but the absolute value of the error. Okay? And relative error is absolute error divided by exact value, the absolute of the exact value. All right. Absolute error is the errors absolute part and by the exact value. And percentage error will be letive error times thousand. Okay, letive error times thousand. So we can say that percentage error is letive error into, sorry, into 100. What am I saying? Now, just look at this. Have a quick look at these definitions. Absolute error means the absolute value of the error. Relative error is absolute error divided by the exact value. And then we come to the percentage error, which is relative error times 100. Okay? Now another important thing that we have to consider is accumulated error, but that we'll consider later. Next in the next lecture we'll move. So whatever we do, the way we do the computation, we must be very careful about the algorithm, be such that it does not accommodate too much error. However, discussing about error analysis in general is beyond the scope of this course right now. So we will in the next lecture start with the bisection method as I have explained, and then move to some other methods.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
downloading and installing python.mp3,"For our final lecture of this first week, we will see how to actually use Python on our system. So Python is a programming language which is available on all platforms. So whether you're working on Linux or on a Mac or on Windows, you'll be able to find a version of Python that works on your system. One of the small with Python is that there are two flavors or two versions of Python which are commonly found. So there is an older version called Python 2.7 and there is a newer version called Python three, and Python three is the one that is being actively developed. Python 2.7 is more or less a static version and currently Python three has the version 3.5.2 or something like that. So there's not much difference whether you're using 3.5 or 3.4, but there are differences between 2.7 and three. And for the purpose of this course, we will work with Python three. So what is the difference between these two versions? Well, Python began with a few features and it kept developing into a more versatile programming language. So Python went through many iterations and Python 2.7 was a version that was reached when the developers of Python decided that they should kind of make a clean start. And some of the new features which had been added in an ad hoc way onto the language should be integrated in a better way which makes it a more robust programming language. So Python three essentially is a modern version of Python which incorporates features that were added onto Python as it grew in a way that makes it more consistent and more easy to use. But as often happens, a lot of people had already been using Python, and Python 2.7 has a lot of software written using that version. In particular a lot of software that people find convenient to use, such as scientific and statistical libraries of functions where they don't have to use it themselves, but just invoke these libraries are still written using Python 2.7. And if you run it from Python three, sometimes these functions don't work as they are expected. So this has forced Python 2.7 to live on. Eventually we hope that somebody will take the effort to move Python 2.7 libraries to Python three. And of course newer code is largely being developed in Python three. But you should remember that when somebody says they are using Python, they could be talking about 2.7 and not three. And you have to make adjustments. For the purpose of the introductory material that we will be doing in the course, there is almost no change between Python three and Python 2.7. However, there are some features that we will see which are slightly different in 2.7 and we will explore them in three and I will try to highlight these differences as we go along. But going forward, since Python three is the current version and it has been the current version for some years now, at least for four or five years, it's definitely the language which is going to dominate in the future. So it's better that you start with the new version than go back to the old version. So as far as this course is concerned, any version of Python three should be fine. The latest version, as I said, is some 3.5 point x where I think X is two. But if you don't have 3.5 but you have 3.4 or 3.3, don't bother. Everything should work fine. But if you are interested you can install the latest latest version. If you are using Linux it should normally be there by default because many Linux utilities require Python and so Python should be on your system. But it could be that the utilities use Python 2.7. So make sure that you install Python three. You can use the package manager to do this. Now if you are using a Mac or you're using Windows, then Python may or may not be installed. Especially Python 3 may not be installed on your system. So there is the URL given here. If you search on Google you'll find it. Just search for Python 3.5 install or download and you will get to this URL. So www.python.org downloads release Python 350. So 350 is really referring to 3.5.0. So actually the current version, as I said, is not 3.5.0 but 3.5.2. So you will find instructions there. Please download the version that is appropriate for your system and install it. These are designed to be fairly self explanatory install files. If you have a problem, please search online for help with the problem you are facing or ask someone around you. It is not the purpose of this course to spend a lot of time telling you how to install software. So I hope you are able to do this so that we can get ahead with the actual programming part. So one more thing to keep in mind if you are familiar with other programming languages is the distinction between interpreters and compilers. So the main difficulty is that programming languages like Python or C or C plus plus or Java are written for us to understand and write instructions in. So these are somewhat high level instructions. On the other hand, computers need low level instructions. So when we talk about names and values like IEJ, or we talk about lists, the underlying computer may not be able to directly analyze these things, so we need a translation. If you remember the very first lecture, we talked about arranging chairs. So we said arrange the chairs as a high level thing. And we said put 80 chairs in eight rows, ten each, right? So we said that there could be a difference in the level of detail in which you give instructions. And this is precisely what happens in order to execute something. A so called executable file that we come across is something which is written at a level that the machine can understand, whereas the programs that we are going to explore in this course, and which all programmers normally work with are at a higher level which cannot be directly understood by the computer. So we have to bridge this gap somehow. So a compiler is a program which takes a high level programming language and translates programs in that language to a machine level programming language. So it takes a high level program in Python, not in Python, in C or C plus plus or Java or something, and produces something that directly a machine can execute. On the other hand, the other way of dealing with a high level language is to interpret it. So an interpreter in normal English is somebody who stands between people talking different languages and translates back and forth. So an interpreter is a program which you interact with and you feed the interpreter instructions in your language, in this case Python. And the interpreter internally figures out how to run them on the underlying machine. So whether you're running it on Windows or Mac or Linux, the interpreter guarantees that the answer that you see at the high level looks approximately the same independent of the actual platform on which you're running it. So Python is by and large an interpreted language, and we should be aware of this fact. So we use Python typically in the following way. We first run the interpreter. So remember, the interpreter is a program. So we first invoke the interpreter, and when the interpreter is running, we pass Python commands to the interpreter to be executed. The nice thing about dealing with an interpreter is that you can play with it like you play with a calculator. You can feed it commands and see what it does. So it's very interactive. Of course it is tedious if you have to type in large programs. So there is a way to load a program which has been written already using a standard text editor and loading it from a file. So what I've shown below in green is, so this is what we will see in a minute is the prompt that the interpreter shows you. So when you enter the interpreter, it asks you to execute a command, and this is a command that you provide the interpreter. It says, so I have stored. So I have a file called say filename py, typically to indicate it's a Python program. From that file, import all the definitions and functions and code that is written there. So this will tell the interpreter to take everything that's written in that code and put it into its current environment so that those functions can be used. So these things will become a little Clear in the demo that I'm just going to show you. And then you can play around with this. And in the next week we will get into the real details about exactly what goes into a Python program. So here is a window showing a terminal which on windows would be like a command prompt. I am using a Unix like shell. So if I say ls, it shows me the list of files in my current area. And all these files with extension py are actually Python programs. In this I invoke the Python interpreter by saying Python 3.5 because that's the version which I'm using. If I invoke it, it will produce some messages telling me what type of function system I'm on. So it tells me that I'm using, for instance, 3.5.2, and it tells me that it's a fairly recent version. It tells me it's on an apple and blah blah blah. But what is important is it then produces a prompt, a place where I can enter commands, and this is signified by these three greater thans. So now at the Python interpreter prompt you can directly start writing things. So for example, you can say I is equal to five. What this says is take a name, I assign the value of five. Now, if I type I, it tells me that the value is five. If I type an expression like I plus one, it tells me that six. So you can use it as a calculator. So you can do simple arithmetic if you want, so you can keep interacting with it. Now, you can also define functions. Remember how we defined a function? We use def, use a function name and so on. So we can say, for example, def twice x. So this is a function twice which takes a single argument x. And as you might expect, I would like to return two times x. Now, Python uses, as we mentioned in one of the earlier lectures, indentation in order to specify that something is a part of something else. So the definition consists of a bunch of steps. So I must tell it that these bunch of steps belong to this definition by indenting it. It doesn't matter how you indent it, as long as you use the same indentation uniformly. So if you're using two spaces, use two spaces. If you're using a tab, use a tab, but don't mix up the number of spaces. And don't mix up tabs and spaces because this gets you confused. The LMS, which is from Python. So let's use two spaces. So let us just for the sake of illustration, create a new name y and say y is two times x. Now it's still continuing to ask me for the definition. So the prompt has changed to dot, dot, dot. Now I must index it the same way and say return y. So what I've done is this function takes an value x, computes two times x and stores it in the name y and returns the value of the name y. Right? So now when I'm done with this, I give a blank line and this function is now defined. So now twice seven makes sense, or twice 932 will also make sense. So Python is very convenient in that you can actually define functions as you go along on the fly. Now we could also define our GcD right here. But as you might expect, sometimes a function is too complicated to type in without making a mistake. And secondly, you might want to play around with the function and change it and not have to keep typing it again and again. So for this, what we need to do is first type the function into a file and then load the file here. So let us get out of this. So one way to get out of this is to type quit brackets, and then you get back to this prompt, which is dollar, which is the outside terminal, or the command prompt. So I have actually already created something. So let us start with. So I use an editor called emacs. You can use any text editor. If you're using Windows, you can use notepad. If you're using Linux you can use emacs or vi, or you can use some simpler editor like G edit or kate, anything that is comfortable. But it should just be a text editor. It should not do any formatting. Don't use word processors like office or something like that. Use something which just manipulates text files. So if I look at gcd one PI. So one nice thing about emacs is it shows me colors to indicate certain things. So def this is the very first gcd program we wrote, which takes computes, the list fm, then the list fn, then the list cf, and then it returns the last element at cf. So this is the first version of GcD. So this is exactly the code we wrote before. The point to remember is that I have made sure that all these indentations are at the same number of spaces in. Okay, so this is something to remember. So now you type in something like this, then you save it and exit. Now you go back to your python and you save from that file gcd one import star. What this means is take the file gcd one py and load all the functions which are defined there and make them available to me here. So now if I say gcd of seven, comma, let us, for example, 14 and 63, for instance, it tells me that gcd is seven. Now, if you take some large number like 9999 and 10, zero, then it takes. Okay, so maybe one more digit. Let us see. You will notice that it's not giving me an answer, and then it gives me an answer. So this is just to illustrate that this was a slow GCD. So remember, see how much time it took. Right. There's a visible gap of a few seconds before it produces the answer. And this is illustration that this is not a very efficient GCD. So one of the problems with this Python interpreter, which I will see if we can solve, is that if I have already loaded one file, then it's safer to exit and then reload another file rather than to update the file. So let me reload, for instance, the last version of Euclid's thing, which we wrote, which is the remainder version. It says that if m is less than n, exchange the values. If, then the second line here says that if the remainder of m divided by n is zero, that is n is a divisor of m, then return n. Otherwise, replace the gcd call by the call to n and its remainder. So this, we also had a version of this where we did it with a while loop. So let's use the while version. So the while version says that so long as the remainder is not zero, we keep updating m and n to n and the remainder, and then finally we return the value of n. So I'm going to take this particular thing and load it into Python. So again, I first invoke the interpreter python, and then I say from GCD Euclid to a import star. Now I'm going to give that same large value that we saw before, which I think was say, seven, nine, and this. And now you see, you get an instant answer. Okay? So in fact, you will see that even if I give it several more digits, it should hopefully work fast. So there is a dramatic improvement in speed, which is even visible in this simple example, if we replace a naive idea by a clever idea. So the power of algorithms is to actually make a program which would otherwise be hopelessly slow work at a speed which is acceptable to you. So do load python on your system. Invoke the Python interpreter and play around with the code that we have seen in this particular week's thing. Make errors. See what Python tells you when you import a file which has errors. For instance, now, if I try to invoke a function which doesn't exit lake, if I use a function which I have not defined and which Python doesn't understand, then it'll give me a mistake like this. It will say bloop is not defined. If I write something strange like seven, less than, greater than five, then it'll say that this is invalid syntax. So the interpreter will look for expressions. If the expressions don't make sense, then it's going to complain. And sometimes the error messages are easy to understand, sometimes they're less easy to understand. As we go along, we will look into this, but the purpose of the interpreter is to either execute what you have given it, or tell you that what you have written is somehow not executable, and explain why. So do play around with it and get some familiarity, because this is going to be our bread and butter as we go along. So we are going to be looking at some specific features of Python in this course. But you may find as we go along that there's something that you don't understand or something new that you would like to try out on your own. So it's always a good idea to have access to other resources. The Python online documentation is actually an excellent place to look for details about Python, and in particular, there's a very readable tutorial, especially if you already have some familiarity with programming. The Python Tutorial is probably the best place to start learning Python for yourself. So here is a URL Docs python.org three this is for Python three tutorialindex HTML if you just go to docs python.org three, you will find there are also more detailed reference manuals and so on, which you might need at a later stage. So do keep this as one of the places that you look when you have difficulties. And there are two books which are probably useful to understand Python beyond what is covered in the lectures if you feel that something is not clear. So there's this book called Dive into Python, which is adapted for Python three. And there is a book called Think Python, which is generally about computational thinking in the context of Python. Both of these have the nice advantage that they are available online, so you don't have to buy anything you can just browse them through your browser on the net. So before we leave you for this week, remember that learning programming is an activity. You cannot learn programming theoretically, you have to write and execute code to appreciate the subject. You have to make mistakes, learn from your mistakes, figure out what works, what doesn't work, and only then will you get a true appreciation for programming. The reason we are going with Python is because Python has a very simple syntax compared to other programming languages. We have already, without formally learning Python, seen some fairly sophisticated programs for GCD, and hopefully you have understood them even if you cannot generate them. So it is not very difficult to explain what a Python program is doing with a little bit of understanding. So do take the time to practice the examples that we have seen. This time we will be giving programming exercises as we go along, and unless you do these exercises and become somewhat handy at manipulating Python yourself, you will never truly learn both programming and Python. The other thing to remember is that once you have learned one language, even though the features and the syntax vary from language to language, it is very easy to pick up another language, because all of programming has at its base very similar principles. So although the syntax may vary, the ideas don't, and the ideas are eventually what drive the program. But to be a fluent speaker of a programming language, you must practice it. So do try.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Dynamic Allocation and File.mp3,"We have looked at pointers and structures in detail, and we have also seen how structures can also utilize pointers you, or in other words, how pointers can be used in conjunction with structures. Now we look at another very interesting use of pointers. But in general, let me say that it is a very fundamental concept from the memory allocation point of view. Dynamic memory allocation is what we'll be discussing now. Now when we say that is dynamic memory allocation, then obviously there must be something called the static memory allocation. Now what is static memory allocation? When we declare an array, say Int a 20, you know that the compiler will allocate 20 locations, 20 locations locations to house 20 integers to you, and that will be named as a. Or you can also consider that there is a pointer a, which is pointing to the first element of the array, but you have got space for 20 locations, 20 integers allocated to you. So now you know size of, so how many bytes will be required. You can say 20 times size of int. So size of Int will return you how many bytes your particular system allocates for an integer. And 20 such allocations, so many bytes will be allocated to you. Now, when that is statically allocated, that is allocated at compile compile time. So when we say static allocation, that means allocation at compile time. Right? Now, if for some reason you need more than 20 integers to be stored in this array a, that you will need to redefine this whole thing. Or in some cases we do not know. We do not have an idea of how many data items will come. For example, you are actually storing student data, student records in an array class, and you do not know how many students will join that class beforehand. If you know that beforehand, it's fine. Or if you have an idea that what is the maximum number of students that can come, then it's fine. You can allocate it in the form of static allocation as we do in an array. However, when we do not know and the information comes at runtime, that means when it's being executed, that will lead to what we call dynamic allocation of memory. That is dynamic allocation. Okay, so let us look at how we can handle it. So the basic idea is, I have already explained that the amount of data we cannot predict beforehand. So we will use, effectively use dynamic memory management, memory allocation technique to do that. Now, c language requires the number of elements to be specified in compile time. When we define in an array, we need to specify that in compile time. Now, often that leads to wastage of memory or program failure. Okay, why program failure? Program failure, because if we exceed the amount of space that has been allocated, there will be a failure. The program will give an error or it will exit abnormally. However, if we take recourse to dynamic memory allocation, we can solve this problem. How? Memory space required can be specified at the time of execution. How can we do that? How can you specify the amount of memory required at the time of execution if, while running the program, just like the instructions and operators, if we had some special means, some special command, some special operator by which we can grab memory. Now, here you should understand that who allocates memory to us? It is the operating system who allocates the memory to us. So this, like the printf, scanf, all those things are system calls. We are making calls to the operating system, which is doing the required thing for us. Similarly, there is a function called, called Malloc memory allocator malloc, using which we can grab memory from the operating system. How? Let's look at this. Say in memory in c, I have got different types of variables that is not so much relevant right now. What is needed is part this. Global variables and instructions are there, always stored, but the local variables are kept. The local variables are there, and there is some free memory we can take from this free memory and put it, use them as our local variables. Okay, well, free region has got a name heap. Now, the most important thing is that we need some functions which will give the memory gave my program some memory addresses or memory blocks from the operating system storage of memory, which is known as heap. From there, it will be allocated to my program. All right? So for that, we have got four different functions. One is Malloc. What does Malloc do? Malloc allocates the requested number of bytes and returns a pointer to the first byte of the allocated space. So let us try to explain this. So when I do Malloc, Malloc is just like a function will return me some memory bytes, all right? Some memory bytes. How many memory bytes will depend on what I'm requesting for it is a requested number of bytes. So Malloc will have some parameters which will show later. So it will give me some amount of memory. And how do I know? Now the operating system has got some free memory spread here and there. So from there it is giving me some piece of memory. But how do I know where is that piece of memory? For that, it is returning me a pointer, say pointer p, which is telling me that, okay, if you follow this pointer, you will get this piece of memory location. All right, so let's proceed a little bit now, similarly, now when this is given, that memory block is given in response to malloc request, the actual memory is not initialized to some value. It can have any garbage value. But if I apply calloc clock, then it allocates space for the array of elements, array of elements, and initializes them to zero and returns a pointer. So in this case, if I want to have a chunk of memory where everything has been initialized to zero, then I should use calloc. On the other hand, this free, what it does, the free function call, will return this amount of memory that was given to me in request to Malloc. It will be returned back to the heap, returned back to the operating system, so that it can be utilized by somebody else in future. All right? And realloc modifies the size of the previously allocated space. So I've got some allocation. And then I think that allocation is not enough. I want to change it. I can use realloc. However, we will be mostly concerned with Malloc and free in our discussion. So, a block of memory can be allocated using the function malloc, and it reserves a block of memory and returns a pointer of type void. You know, every pointer has got some type. But in this case, when Malloc returns some memory block, the pointer that it's returned is of type void. But then we have to do something. What do we need to do? I know why I needed this memory. So accordingly, I'll have to do that typecasting. All right, now, the return, once it returns me of type void, but that return pointer can be assigned to any pointer type. So here you see? So here, please note, Malloc has got a parameter byte size, how much memory I want, how many bytes I want. Now, this Malloc has returned me up to this. It has returned me a pointer, and pointer is of type void, but I type. Suppose if this amount of memory I want for the purpose of storing integer array, then this type will be int star. That means I am casting this. What is Malloc returning? Malloc is returning a pointer, some pointer, but that pointer was of type void. Okay, of type void. Now, when I am typecasting it to instar, then this void is no longer, it is of type, is becoming of type int. And then I'm assigning it to another variable, ptr. So think of two things. First of all, you have to decide on how many bytes you want. Accordingly, you do Malloc, and then what type of data you want to store there. So accordingly, you do this typecasting like in star float, star cat, star, whatever you do, and then you assign it to a particular pointer. Let's see how it will work. So let's look at an example here. How do I know how many bytes I need? Suppose I need to store an element, an array of hundred integers, integers. So what I do here is I ask for Malloc 100 times size of int, size of int, if it is four. If int is four, then I am getting 400 bytes. Now, these 400 bytes that have been given to me is being pointed by some pointer of type void. So next I make it instar and put it to p. So p is now an integer pointer that is pointing to this entire block of 400 integers. Okay, so a memory space equivalent to 100 times the size we have got. So here 400 bytes of space and p is a pointer pointing to the beginning of this. So I have got this just using malloc. It was not declared beforehand. Now, so this hundred can also be a variable n. If I read a particular variable n. Now, how many students are there? Scan f and n. So I read the number of students. Then I can multiply that with n as well. Okay, next, you see here I am initializing two. I am seeking memory for 20 characters. I do malloc 20 because I know a character takes one byte and then the pointer is of type void. I am typecasting it to type character cad star and assigning it to cptr. Now, it is actually wrong. It is allocating 20 bytes of space for the pointer. Okay, so structure stud. Now, for example, I now need. So integer character was simple. Now I want to have space for the entire structure students. Now that size is larger. So I do not know. So I just employ this function size of structured. So I gets how many bytes it requires, say 40 bytes and the tens for ten such students or n such students. I multiply with that. I get so much memory. Now I have to typecast that to struct star. And that goes to as a structure pointer. Okay, now malloc always allocates a block of contiguous bytes. Now it may be that sufficient. Suppose you are asking for 100 bytes and 100 bytes are not available. Then malloc will not be able to allocate you the space. In that case, malloc will return null. That is a null pointer. That's a special character, special value it will return. That shows that I could not allocate a space, so I could not allocate to you a valid pointer. So it is a null pointer, meaning thereby that I failed in allocating you memory. So here is an example. Here you can see, let's look at from one side in. Float is a pointer. Height is a pointer of type. Float sum is zero and average. So what I am trying to do, probably I am trying to find the average height of the class. So input the number of students. And I'm reading Ampere sand. So this one is Ampere sand, n. So this is n number of students. Now, see, I did not know how many students are there. So I am getting this number of students here. I am getting n number of students here. Now I want to have so many spaces for the height. So what I am doing, I am allocating n number of spaces. N is a variable here. And size of float, whatever size of float is four bytes. So n times four bytes, so much space is being allocated. And the pointer is height. Height is a pointer of type, float. So this pointer is being typecasted to float. All right, then I get the input scanf in a loop. I am getting the heights one after another in an array. And I am finding the sum of the heights, finding the average of the heights, where I am dividing sum, which is a floating point number with float n. Here is another example of typecasting. So you see, I am dividing by n, but this is a floating point real number. N was an integer. So I convert it to float, and convert it, divide it. Right. So this is how Malloc works. Now. So we have explained that. Now how do we are allocating space? Similarly, the general format for freeing space is by using the free function. Now, suppose I have got a space allocated to me. Some space is allocated to me, and that space, the only handle to that space is to the pointer p. So I free that pointer. I free p. So that pointer is freed. That means this pointer is freed, means this location, this amount of memory goes back to the storage of the operating system, and that is the heap. Okay? So whatever we got in Malloc. So that gives us some idea about how we can gate space and reallocate space. Now, briefly, I'll be talking for the next five or ten minutes on file handling. There is not much to understand about file handling. This you will learn as you do. Now, what is a file? That is something you have to understand. File is something wherever I want to write something, write or read from. So I want to store something. I'll take a particular file, all right, I'll take a particular file, and I'll open that file. And then I'll write into that file, then close that file. And then whenever I need in that way, I may have ten files. Now, at a particular point of time, I want to read a particular thing. So I choose the particular file. What do I do next? Open the file and read the file. Now, some files may be allowed to be read by others. Some files can only be written into and not read from. Some files can have the option of read or write both. So file is some space where I'll be writing or reading from some storage. So this is there in the secondary memory. And till now, whatever variables we are talking about, those were all in the primary memory. So if I store it in a file, it goes into the secondary memory. So let us have a little idea of how files are handled. So now, again, now we have learned pointers. So any file can be accessed using a pointer, just as if I have the file of income tax. All right, so I'll have a pointer that, okay, there is the file of income tax here, there is some file of road tax, it will be here. Some file of your salary, it will be somewhere here, some file of your expenses, it will be somewhere else. So there will be pointers. So we use in c the, sorry, we use file star. We use file star to represent pointer to a file. And if open is the command for opening a file. If a file cannot be opened, then it will return a null. Just as in the case of Malloc, we saw if nothing could be returned, it was returning a null. So here, for example, you see fptr is a pointer of type file. That means fPTR will be pointing to file. Now, I have got a character file name is an array file, two dat, it's a data file. So fptr is f open file name. And here, when I do f open, I give the file name as well as the mode in which it can be opened, the mode in which it can be opened, and this w means it's in the right mode. So what have I done here? I have called f open. So I am trying to open the file. So this f open will return a file pointer. Now, if this file pointer is null, that means there was some error in file creation. Otherwise it will go on doing something. Okay, so quickly, let's look at this. When I do f open, it will open a file, and you'll open it in a particular mode, read or write whatever I specify, and it will return me a pointer. If a file is created successfully, it will return me a non null pointer. All right, the second argument of f open is the mode. And there are three modes. Okay, there are three modes. R is the file is open for reading, w means it creates a file for writing, and writes over all the previous content. So if I open it in the write mode, whatever content was in that file is erased and a opens the file for appending. That means whatever is there after that it will be added. Okay, so if you have got something already stored and you don't want to destroy that, and you want to add something more to that, you will open it in the form in the mode a. All right, and rb reads a binary file, raw bytes. We need not bother about that. And there is a function called exit which you have seen that exit for. Sometimes in the emergency we can put exit minus one. That means it tells that I have exited the function without success. Now here you see use of exit file. F pointer. Character file name is an array file. Two d. I tried to do something, so the file pointer was null. So if it be null, then what can I do? I'll have to exit because of some reason the file could not be created. So that apart. So f open. We have seen f print is a very important command. F print works just like printf and s printf, okay, except that the first argument is a file pointer. So we'll see how it works. So fptr is again the file pointer. And I have opened a file file dat in the write mode. Now f printf means now I am printing. Where am I printing? A file called file dat has been opened. The name of the file is file dat. And how do I identify it? I identify it with the fptr, the file pointer. Okay, so I am writing, it's open in the write mode. So everything, whatever was there has been erased. So I am writing just as you have done printf. Then automatically, by default, it goes to the screen here. It is not default. Here I have said fptr. So whatever I write, hello world, it will be written in this file, not in the screen. All right, screen is another file, but that's a default file reading a data. Similarly, we printed using f printf. Reading we can do using f scanf. Forget about that part. Look at this fptr. I'm reading from, not from the keyboard. Now I'm now not reading from the keyboard. I am reading x and y, two integers from a file which is pointed out by fptr. All right, and what is that file? Fptr. I've opened a file input dat. So you see in that file input dat, 20 and 30 was written. And so f scanf, I have read that, that was input dat. I have opened that in the read mode, okay, in the read mode. And I'm reading from there. So I'm getting x to be 20 and y to be 30, not from the keyboard, but from the file. Okay, so in that way we can, now here are some powerful commands just to know. We can read a string using f gets from a file. I can read a string. So here you see a file is fptr and a line is of size thousand, while f gets line is not null. That means I am getting from fptr, I am getting a value. And if it is not null, that means it's not the end of the line. I mean, I have got the file as open. I am reading the line using f gets. All right, I'm getting the line. F gets takes three arguments. What are the three arguments? It's taking a string, a maximum number of characters, thousand, and a pointer from where it returns if there is an error, such as end of file. Uf is end of file. Okay, now this I think you can understand much better when you use, now when we open a file. After that, we must close that file. We can simply use the command f close and the file pointer. So here you see fptr. I opened the file in the right mode. I have written hello world over here. F printf means I'm printing in the file and then I am f close. I'm doing f closing the file by f close fptr. All right, so here it is opening and here is access, and here is closing. Okay, you have seen that std in std out were two special cases of files, which were default files, and std error was the printing of the error. So here is an example program. You can see that main f printf, std out, give value of I. That means where am I printing this? I am printing it to the standard output. I am reading I from the standard input. Now, f printf, I am writing that the value of I is I is whatever value of I read and there is no error. Okay, so give value of I. It will first print give value of I. You give 15, then f printf that I. Then it will say value of I is equal to 15 and there no error, but an example to show error message. So if you do this std error, then if there is an error. So for example, I am being returned a null pointer. In that case, I can use some output std error and say the file failed to open the file. That sort of message. Okay, now another thing I'll just talk about here that will come in very handy to you. That is, say for example, you must be running the programs. And after you compile the program and link them, you are creating an executable file which is a out right, a dot out. Now usually what you do, you have got the dollar. Those of you using Linux shell a dot out, right and return. Now this a dot out. In that case a dot out. What it is expecting the input from the keyboard std in and the output is going to std out. But I don't want that. I want that. I have got a file, I have got a file where my input data is there and I call that in dat. And I have got another file which is known as out dat. I want that the input be taken from this. So I want a dot out to read the data from here and the result should be written here. I can do that in the Unix environment. Very simply by this redirection operation you see a dot out will run taking data from in dat and sending the output data to out dat. So say for example in Dat has got 15. So I do that and the program runs and says give the value of. I think of the earlier example, earlier program that we are thinking of. Give the value of I and it reads from here and it prints the value of I is 15. So that is coming, this whole thing is coming in out I. So let us once again look at this thing here. Instead of std out here I am asking them to give the value of I. The value of I is being given and that is being scanned from the input file. And this is being written on the output file. So in the output file both these things are being written. Consequently, you see what am I getting is I'll be getting this output. Okay, this is my output out dat and in dat there are two files. So in this way you can use files for storing data. You have to open the file. Let me summarize a little bit. You'll have to open the file. If you want to read in the read mode, read the file from there, read the data from that file, do the operation, open another file in the write mode and write the data into that file. Thereby whenever you require some file operations you can easily do that. And this is one example that we have shown which is very common during running your programs. If you store some data in a particular file and read from there and write into another file, you can utilize this sort of structures, this sort of commands. So thank you very much. I think you have got an overall idea of how to write C programs and programs and solve problems using programs. Because the essence of our course you was to solve problems through C programming. So you should choose different problems and you should try to write commands. Sorry, try to write programs for solving those problems. So first you have to find out the proper algorithm and then write the C code. For that you have learned everything about basic things about the thank C programming. I have not touched upon some special features which you can also learn from the book, like static variables and all those I have left out intentionally so that you are not overloaded. You can solve it the more you run the programs using the basic concepts that has been taught. You'll be a good programmer, and most importantly, you'll be able to think logically like a programmer. You'll be able to think of algorithm, and you'll be able to translate that into a program. Thank you very much.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
efficiency.mp3,"You, when we looked at binary search, we talked about how efficient it was. So let's just spend a little bit of time informally understanding how we look at efficiency of algorithms. So in general, an algorithm will work on many different sizes of inputs. So it makes sense to talk about the efficiency as a function of the input size. So if the input size is n, we will use a function such as t of n to talk about the time taken on an input of size n. Now, of course, different inputs will take even of the same size. Different inputs will take different time for an algorithm to execute. So which of these should we take as our measure of efficiency? The convention is to use the worst case behavior. So, among all the inputs of size n, which one will force our algorithm to take the longest time? And this is what we call usually the worst case efficiency. Now, in the case of searching, for instance, binary search, or even a linear scan, we said that the worst case would occur typically when the value that we are trying to find is not found in the sequence. So we actually have to scan through the entire sequence or array or list before we find it. In case of a linear scan and in terms of a binary search, we have to reduce the search interval to a trivial interval before we can declare that the value is not there. So that's the worst case. Now, it may turn out that in many algorithms, the worst case is rare. So it may not be a representative idea about how bad or good the algorithm is. And maybe it would be better to give something like the average case behavior. Now, unfortunately, in order to determine something like an average case in a mathematically precise way is not very easy. We have to have a probability distribution, overall inputs, and then measure different inputs and different outputs, and then compute a probabilistic mean for this. So in most cases, this is not possible, which is why we settle for the worst case efficiency. Now, when we talk about efficiency, as we said, we are broadly interested in the connection between input size and output size. So we express this up to proportionality. So we are not really interested in exact constants. We want to know. For instance, is t of n proportional to log of n? For example, in the case of binary search, or n in the case of linear scan, or larger values like n log n n squared n cubed? Or is it even exponentially dependent on the input? Is it two to the n? So we write this using this, what is called the big o notation. So we say t of n is big o of n. What we mean is that t of n is some constant times n same way t of n is big o n log n means t of n is some constant times n log n. In other words, it's proportional by some constant to that value. So we are not going to go into much detail in this course about how big o is defined and calculated, but it's Useful shorthand to describe the efficiency of algorithms. So we will use it informally and you can go and read an algorithms textbook to find out how it is more formally defined. So in terms of this notation, when we say that linear scan is proportional to the length of an array or a list, we can say that linear scan takes time big o of n in the same way for a sorted array, binary search will take time big o log of n. So here is a table which tabulates for different values of input n. What would be the corresponding values of log n, n, log n squared, and so on. And what we want to probably estimate is given these values, these absolute numbers, what would be reasonable inputs that we can expect to compute within a few seconds? Now if we type something on our computer and we don't get a response very soon these days we realize that something may be wrong. So let us say that we want to see the input in one or 2 seconds, otherwise we will deem it to be inefficient. So if we look at this, we have to now figure out how fast our computers are. So by some simple Hand experiments you can validate that Python can do about ten to the seven basic steps in a second. So what we can do is try and execute a large loop and see how much time it takes. So here we have a bunch of programs which we've already written, and here is a template. So if I say look at speed four PI, it basically executes a loop ten to the four times, hence the name four. So for m in range zero to 10,000 minus one, it just assigns m to be the value I. And finally there's a statement we haven't seen so far, but which should be quite intuitive. It says print the value of m. So in the same way, speed five does this for ten to the five times, speed six does this ten to the six times speed seven does this ten to the seven times, and so on. So these are a bunch of scripts we have written for Python from speed four to speed nine. Now if you are working in Unix or in Linux, there is a nice command called time. So first of all I can take Python and I can directly use the name of the Python program like this. So I can say Python 3.5 and give the name of the script, and it'll execute it and give me the answer. But now, in addition, there is also a useful command called time. So, time tells us how much time this thing takes to execute, and it typically reports this in three quantities, real time, user time and system time. So what we really need to look at is the so called user time. So it says that if I do this loop ten to the four times, it takes a fraction of a second .3 seconds. If I do this, on the other hand, five times, then it goes from zero zero three to zero five. So it's roughly a factor of ten, as you would imagine, which is reasonable. If I do this zero six times, then again it goes up, not quite by a factor of ten, but it's gone up to about 0.2 seconds, almost. Now we come to the limit that we claim ten to the seven. So if we run speed seven PI, which is a loop ten to the seven, it takes about 1 second. It I mean, this is not a precise calculation, but if you run it repeatedly, you say that each time, because there are some other factors, like how long it takes for the system to load the Python interpreter and all that. But if you just do it repeatedly, you see that ten to the seven takes about a second or more. So this is the basis for my saying that python can do about ten to the seven operations in a second. And just to illustrate, if you actually do it for ten to the eight, you can see it takes a very long time. And in fact it takes roughly ten to 12 seconds to execute. So soon, we will hopefully see the output. So, as you can see, 10 seconds doesn't seem to us like a very long time, but it is an enormously long time when you're sitting in front of a screen waiting for a response. So what we claim now is that something that takes a couple of seconds is what we will deem as an effective input that we can solve on our computer. So coming back to our table, assuming that ten to the seven is the limit that we are looking at, let us see what happens when we mark off ten to the seven on these different columns. So it turns out as if something takes login of time, then even for ten to the ten, it takes only 33 steps, and we are fine. Of course, if line, the input is linear when we're ignoring the constant, then input of size ten to the seven will take time to. So this line comes here. On the other hand, if we have n log n now, it turns out that n log n. So it's useful to know that two to the ten, as we mentioned before, is 10,024. Right? So therefore two to the 20 will be ten to the power six and two to the 30 will be ten to the power nine. So really the log grows linearly as this thing grows in terms of powers of ten. So when we have ten to the seven, the log is going to be something like 20 something, so it's going to be of the order of ten. So it's going to drop 10. So that's why we say that for input of size ten to the six, the log is going to contribute a factor of ten. So that's going to take time, ten to the seven. Now notice that when you do square, then ten to the three is already going to take ten to the six. So somewhere between 1010 thousand, say around 5000 maybe if you're lucky, will be the feasible limit for something which takes n squared. And as we go to nq, the limit drops from a few thousand to a few hundred. So here we have between ten to the six and ten to the nine. So somewhere between 100,000, the scaling goes from ten to the six to ten to the nine. So we ten to the seven will be somewhere around 200 or 300. And when you get to exponentials like two to the n and n factorial, then unless you have an input that is really small like ten or something like that, you're going to hit problems, because if you have a few tens, you already get to enormous numbers like ten to the 30. So this gives us an idea that given that our system that we are working with, Python, can do about ten to seven steps in a second, we need to really examine this table to understand what kind of inputs will be realistic to process, given the type of algorithm that we are executing. Now, Python is ten to the seven. Python is a bit slower than other languages, but even if you're using a very fast language like c or c plus plus, you cannot really realistically expect to go beyond ten to the eight or ten to the nine. So this table is more or less valid up to a scaling of a few tens k in different languages. So you can take this as a reasonable estimate across languages. So theoretically, if you look at algorithms, books or complexity theoretic books, any polynomial, any dependence on n, which is of the form n to the k for a constant k, is considered efficient. So these are the so called polynomial time algorithms. So n cubed, n to the five, n to the seven. All of these are considered to be theoretically efficient. Algorithms as compared to two to the n and so on. So you have n to the seven versus two to the n. So n to the seven is considered efficient, two to the n is not. But what the table tells us, if you look at the previous table, is that even n square has a very severe limit. Right? We can only do about 4000 things. So if we are doing something in n squared time, we can't process something larger than a few thousand. Now, many of the things that we see in real life, like if we have a large spreadsheet, or if we have anything like that and we want to sort it, then it's very likely to have a few thousand entries. So supposing, even if you want to just look at all the employees in the medium sized company, or all those children in a class in a school or something like that, a few thousand is not at all a large number. So therefore, what we see is that if you go beyond that and n squared algorithm would take enormously long time to compute. So really we have to think very hard about what are the limits of what we can hope to do. And that's why it's very important to use the best possible algorithm, because by using something which is better, you can dramatically improve the range of inputs on which your algorithm works. And.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
euclid's algorithm for gcd.mp3,"Let us continue with our running example of GCD to explore more issues involved with programming. We started with the basic definition of GCD, which said that we should first compute all the factors of M, store it in a list, compute all the factors of N, store it in another list. From these two lists, extract the list of common factors and report the largest one in this common factor list. Our first implication was to observe that we can actually do a single pass from one to the minimum of Mn and directly compute the list of common factors without first separately computing the factors of M and the factors of M. We then observe that we don't even need this list of common factors, since our interest is only in the greatest common factor or the greatest common divisor. So we may as well just keep track of the largest common factor we have seen so far in a single name and report it at the end. Our final simplification was to observe that if we are interested in the largest common factor, we should start at the end and not the beginning. So instead of starting from one and working upwards to the minimum of Mn, it's better to start with minimum of mnn and work backwards to one. And as soon as we find a common factor, we report it and exit. Remember always that one is guaranteed to be a common factor. So when we start from minimum of MNN and go backwards, if we don't see any other common factor, we are still guaranteed that we will exit correctly when we hit one. So what we noticed that was that though these different versions are simpler than the earlier versions, they all have the same efficiency in terms of computation, which is that they will force us, in the worst case, to run through all the numbers between one and the minimum of MNM before we find the greatest common factor, whether we work forwards or backwards. So at the time of the ancient Greeks, what was possibly the first algorithm in modern terminology was discovered by Euclid, and that was for this problem, GCD. So what Euclid said was the following. Suppose we have a divisor d, which divides both m and n. So this is a common divisor and we are looking for the largest such d. Let us assume also for the sake of argument, that m is greater than n. So if d divides both m and n, we can write m as a times d and n as b times d for some values a and b. So m is a multiple of d and so is n. So if we subtract the left hand side the equations, then the left hand side is m minus n. So we take m and subtract it n from m. So correspondingly, we subtract bd from ad. So m minus n is equal to ad minus bd. But since d is a common term, this means m minus n is a minus b times d. So this is where we are using the assumption that m is greater than n. So a minus b will be a positive number. But the important thing to note is that m minus n is also a multiple of d. So in other words, if d divides both m and n, it also divides m minus n. And since d is the largest divisor of m and n, it will turn out that d is also the largest divisor, which is common to m n and n minus n. In other words, the gcd of mn is the same as the gcd of the smaller of the two, namely n, and the difference of the two m and n m minus n. So we can use this to drastically simplify the process of finding the gcd. So here is the first version of Euclidist algorithm. So consider the value GCd of Mn, assuming that m is greater than n. So if n is already a divisor of m, then we are done and we return n. Otherwise we transform the problem into a new one. And instead of computing the gcd of m and n that we started with, we compute the gcd of n and m minus n and return that value instead. So here is a Python implementation of this idea. So there are a couple of new features that are introduced here. So let us look at them. The first is this special statement which starts with the symbol hash. So in Python, this kind of a statement is called a comment. So a comment is a statement that you put into a program to explain what is going on to a person reading the program, but it is ignored by the computer executing the program. So this statement says that we are assuming that m is bigger than or equal to n. So this tells us that when the program continues, this is the assumption. Of course, it is possible that the person who invokes Gcd does not realize this, so they might invoke it with m smaller than n, and so we fix it. So this is a special kind of assignment which is peculiar to Python. It is not present in most other programming languages. So what we want to do is basically we want to take the values m and n and we want to exchange them. So we want to make the new value of m, the old value of n, and the new value of n, the old value of m. So that in case m and n were in the wrong order, we reverse them. So what this Python Statement does is it takes a pair of values and it does a simultaneous assignment. So it says that the value of n goes into the value of m and the value of m goes into the value of n. Now, it is important that it is simultaneous, because if you do it in either order, if you first copy the value of n into m, then the old value of m is lost. So you cannot copy the old value of m into the new value of n because you have lost it. So imagine that you have two mugs of water, right? And now you want to exchange their contents. Now you have to make space. You cannot pour this into that without getting rid of that. And once you've got rid of that, you can't pour that into that. So you need a third mug normally. So you need to first transfer this here and keep it safe. Then you need to transfer this there, and then you need to copy it back. So this is the normal way that most programming languages would ask you to exchange two values. But Python has this nifty feature by which you can take a pair of values and simultaneously update them. And in particular, this simultaneous update allows us to exchange the values without worrying about having this extra temporary place to park one value. So anyway, all that this first part is doing is to ensure that this condition that we have assumed is satisfied. So now we come to the crux of the algorithm. So if n divides m, that is, the remainder of m divided by n is zero, then we have found n to be the gcd, and we return n. If this is not the case, then we go back to what we discovered in the last slide, and we now are going to compute the gcd of n and the difference m minus n. So we would ideally like to compute gcd of n and m minus n. So we compute the differences m minus n, and we could just invoke this, but it is possible. For example, if m is, say, 97 and n is two, then the difference will be 95. So the difference could very well be larger than n. And we would ideally like to call this function with the first number bigger than the larger number. So we will just ensure this. Even though our function does take care of this. What we want to do is we want to call gcd with n and m minus n. Instead. We will call gcd with the maximum value of n and the difference as the first argument, and the minimum value of n and the difference. So it will make sure that the bigger of the two values goes first and the smaller of the two values goes. And whatever this GCt, the new GCT returns is what this function will return. So this is an example of what we will see later, which is quite natural, which is called recursion. Recursion means that we are going to solve this problem by solving a smaller problem and using that answer, in this case directly, to report the answer for our current problem. So we want to solve the gcd of m and n, but the gcd of m and n. Instead, we solve the gcd of n and m minus n. And whatever answer that gives us, we directly report it back as the Gcd for this number. So we just invoke the function with the smaller values, and then we return it. Now, whenever you do a recursive call like this, it's like a while loop, it will invoke the function again. That in turn will invoke a smaller function, and so on. And you have to make sure that this sequence in which GCT keeps calling gcd with different values, doesn't get into an infinite progression without a stopping point. So, formally, what we have to ensure is that this guarantee of finding an n which divides n. So this is where gcd actually exits without calling itself. So we have to make sure that eventually we will reach this point. Now, what is happening, if you see here, is that the values that are passed to gcd are getting smaller and smaller. Now, what can we have for m minus n? What can be the value? Can it be zero? Well, if m minus n is zero, that means m is equal to m. If m is equal to n, then certainly m is divisible by n. So if m minus n is zero, then it would have exited, so it cannot be zero. So it must be at least one. So whenever we call this function, m minus n is at least one. On the other hand, each time we are reaching smaller values. So we start with some value, and m minus n keeps decreasing. What happens when it actually reaches one? Well, when it reaches one, then one divides every other number. So m percent n, or m divided by m, the remainder will be one will be zero. Right? So we will return gcd of zero. In other words, we are guaranteed that this function, because it keeps reducing the number that we invoke the function with, will eventually produce a call where gcd terminates. So this is important, and we will come back to this later. But whenever you write a function like this, you must make sure that there is a base case which will be reached in a finite number of steps, no matter where you start with. So, this is Euclid's algorithm, the first version where we observe that the gcd of m and n can be replaced by the gcd of n and m minus n. And what we have seen in this particular implementation are two things, one, three things. Rather. We have seen how to put a comment in our code. We have seen that Python allows this kind of simultaneous updation of two variables at the same time. So m comma n equal to m comma n. And we have also seen that we can use the same function with new arguments in order to compute the current function. So there's no problem with saying that in order to compute gcd of m and n, I will instead compute gcd of some other value and use that answer to return my answer. So let us look at a different version of this algorithm where we replace the recursive call by a while loop. So we saw while in our last version of the standard algorithm, when we were counting down from the minimum of m comma n to one, so we kept checking whether I was greater than zero, and we kept decrementing. Well, here we are doing the recursion using a while. So the first thing to notice here is that I have moved this Comment, which used to be in a separate line, to the end of a line. So what Python says is that if there is a hash, then the rest of the line can be ignored. So it reads this line, it sees a valid conditional, and then it sees a hash. So it's as though this statement was not part of the Python program when it is executing. So a command can either be in a separate line, or it can be an end of a line. Of course, remember that you cannot put anything after this which you want Python to execute, because once it sees a hash, the rest of the line is going to peak node. So it can't be in the middle of a line. You can't put a comment in the middle of a line, but you can put it on a separate line, or you can put it at the end of a line. So anyway, so this is our Comment as before. So up here there's no change except that I've shifted the comment position. So now we reach this point where we actually have to do some computation. So at this point if we have found n such that n divides m, we are done and we can directly return n. So this is what our recursive code would do. If we have not found such an n, we have to do some work. So the condition is to check whether m divided by n actually produces a remainder. So this not Equal to symbol is written with this exclamation Mark. So this is the same as the Mathematical Not Equal to remember that this Double Equal to was what we use for the mathematical symbol of equality. So this is our symbol for not equal to. So so long as there is a remainder, that is the remainder. M divided by n is not zero. We do what we did before. We compute the difference, and we replace m by the maximum of the two values and n by the smaller of the two values. So we have a pair mn, whose gcd we are trying to find with the assumption that m is bigger than n. At each step we replace m by the larger of n and the difference, and n by the smaller of n and the difference. So this is exactly what we are doing in this recursive call. We are saying pretend we are computing the AGCD of that. So here in this While loop, effectively we are saying replace the computation of Mn by the replace the Gcd of mn by the computation of maximum n diff and minimum n diff. And we keep doing this until we hit a condition where n actually divides n. And exactly like we said in the recursive case, that there will be a boundary case where at worst case n will become one and one will divide everything in the same way. Here the difference will keep reducing. The difference cannot be zero, because if difference is zero, it would have divided. So difference can at most go down to one, and when it hits one, we are done. So this is a while version of the same recursive function we wrote earlier. So if it helps, you can look at these side by side and try to understand what the recursive thing is doing and what the while is doing, and see that they are basically doing the same thing. And the idea that the recursion must terminate is exactly analogous to the claim that we said earlier, that when you write a while, you must make sure that you make progress towards making the while condition false, so that the while exits. So just like the recursion can go on forever if you are not careful and you don't invoke it with arguments which guarantee termination, the While can also go on forever if you don't make progress within the while in order to make sure that the while condition eventually becomes false. So we can actually do a little better than this. So let us see one problem with this by doing a hand Execution. So supposing we start with some number like GCD of 101 and two, then our algorithm will say that this should now become GCD of the difference and n the difference is 99. So we'll have 99 and two, and then this will become GCD of 97 and two and so on. So we'll keep doing this about 50 steps, and then eventually we will come down to GCD of five and two, and then GCd of three and two. And now when we compute the difference, we'll get GCD of two and one. So now the difference will become smaller. And then at this point we will report that the answer is one. So it actually takes us about 50 steps in order to do GCD of 101 and two. So one of our criticisms of the naive approach is that it takes time proportional to the numbers themselves. If we had numbers m and n, we would take, in general, number of steps equal to minimum of m and n. Now here, in fact, we are taking steps even larger than the minimum, because the minimum is two. If we were just computing factors, we'll say that there's only factor of two is two, and it's not a factor of 101, and you would have stopped right at the beginning. So this actually seems to be doing worse than our earlier algorithm in certain cases. So here is a better observation. So suppose n does not divide m. In other words, if I divide n m by n, I will get a quotient and a remainder, so I can write m as q times n plus r, where q is the quotient and r is the remainder. So you may remember these terms from high school arithmetic. So this goes, n goes into m q times and leaves a remainder r. And we are guaranteed that r is smaller than n. Otherwise it would go one more time, it will become q plus one, right? So we have a remainder r, which is smaller than n. So, for example, if I say seven and I want to divide it by three, for example, this will be two times three plus one. So this will be my quotient and this will be my remainder. And the important thing is the remainder is always smaller than what I'm dividing by. So now let's assume as before, that we have a common divisor for both m and n. In other words, like before, we can write M itself as a times d and n as b times d for some numbers a and b, because m is a multiple of d and so is m. So if we'll plug this into the equation above here, then we see that M, which is a times D, is equal to q times n, which is b times d plus r. So D divides the left and D divides one part of the right. So you can easily convince yourself that D must also divide r. So the way to think about it, if you want pictorially, is that I have this number m, and I can break it up into units of n. And then there is a small bit here. On the other hand, if I look at d, D evenly divides everything. So it divides each of these blocks. It also divides the whole thing. But, okay, now, if I continue with d, it is going to stop exactly at this boundary, because D also divides n. Therefore, D must also divide this last bit, which is r. Exactly. So, in other words, we can argue very easily that R must also be a multiple of D. So D must divide r as well. So if D divides m and d divides n, then D must divide the remainder of M divided by n. And as we saw before with the difference. So last time we said we would look at the difference m divided by n. Now we are saying we look at the remainder of M divided by n, and D must divide that, and d will be, in fact, the GCD of n and this remainder. So this is an improved, and this is the actual version of the algorithm that duclet proposed. Not the difference one, but the remainder one. It says, consider the GCD of M and n, assuming that m is bigger than m. Now, if n divides m, we are done. We just return n. This is the same as before. Otherwise, let R be the remainder is a value of M divided by n. Get the remainder and return the GCD of n and r. And at this .1 important thing to remember is that R is definitely less than n. So we don't have to worry about this condition here. We don't have to take the max and the min, as we did for the difference, because the remainder is guaranteed to be less than n. Otherwise N would go one more time. So, as before, we have a very simple recursive implementation of this. And this is even simpler, because we don't have to do this max min business. So, like the previous time, we first flip m and n in case they are not in the right order. Then if n divides m, if m, the remainder of m divided by n is zero, we return n and we are done. Otherwise, we return the GCD of n and the remainder. So this is the remainder. And remember that the remainder is always less than n. So we don't have to worry about flipping it and taking Max and min at this point. And analogous to the previous case, we can do this whole thing using a while, instead of doing it with the recursive thing. So we first exchange m and n. If they are in the wrong order, then so long as the remainder is not zero, we replace m by the smaller of the two numbers, and we replace n by the remainder, and we proceed. Now, we are guaranteed that this remainder will either go to zero, but if it goes to zero, it means it divides, or if it's not zero, in the worst case, the remainder keeps decreasing because it's always smaller than the number that we started with. So it keeps decreasing and it reaches one. Then in the next step it will divide. So finally we will return at least one. So if we go back to the example that we were looking at, so if we saw that Gcd 101, two, two, when we did it using the difference, we said we took about 50 steps. Now, here, if we do the remainder, I'm going to directly find that the r is equal to one, right? If I divide 101 by two, it goes 50 times the remainder, one. So in one step, I'll go to GCD of two, comma, one, and I'll get one. So, in fact, what you can show is that this version with the remainder actually takes time proportional to the number of digits. So if I have, say, 100 digit number, it'll take about 100 steps. So, for instance, if we have a billion as our number, so a billion will have about ten to the nine will have about ten digits. Then if I do the naive algorithm, then it could take some constant times a billion number of steps. So say a billion steps. But this algorithm, because of the claim that it takes time proportional to the number of digits, since the ten to the nine has approximately ten digits, it will only take about ten steps. So there's a dramatic improvement in efficiency in this version. So this is something that we will touch upon while we are doing this course. So this course is about programming data structures and algorithms. So the programming part talks about what is the best way to express a given idea in a program, in a way that it is easy to make sure that it is correct and easy to read and maintain. So that is the programming part. So how do you write, how do you express your ideas in the most clear fashion, but the idea itself has to be clear, and that is where data structures and algorithms come in. So you might write beautiful prose, but you may have no ideas, or you may have very brilliant ideas, but you may express yourself clumsily. Neither of them is optimal. So this is like writing in any other language, brilliant ideas to express. But if you cannot convey them to the person you're talking to, the ideas lose their impact. So you need ideas and you need a language to express them. So programming is about expressing these ideas, but the ideas themselves come from algorithms and data structures.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Example of If-Else.mp3,"Till now, we have learnt about some constructs of programming to implement some very generalized structures. The programming structures, right? What are they? First we have seen how we can do branching, right? And branching means that whenever there is a sequential flow, we take decision pop, we come to a decision box, and depending on whether the result is true or false, we take different paths, right? That's what we have seen. And that is implemented by if else statement, right? We have seen that the other thing that we have learned is repetition or looping. All right? That means we have come to a particular point, we take a decision, and based on the decision, we decide whether we'll go back to an earlier point or we will continue forward. Okay, so this is this repetition we could achieve by while statement do while statement or while do statement or for statement. So if else and do while do for all these are constructs in the C language. Whereas the concept of branching and repetition or looping is general for most of the programming languages. So this is a general concept, while this is a specific construct corresponding to the C language. Now, to start our journey into the world of real examples, let us first start with the school level equation solving. When we try to solve quadratic equation of the form ax square plus bx plus c equals zero, we try to solve. It means we wanted to find the roots of the equation, roots of the equation of this form. And what are the roots? The roots are the values of x that will satisfy this equation. For example, I can have three x squared plus five x plus one equals zero. All right, what are the values of x that will solve this? Right? So we know that we can solve this general equation by the well known Sridhar Acharya's method. That is, x is minus b plus minus root over b square minus four ac divided by two a. By this we can find the roots of this equation. And since it is a quadratic equation, how many roots will be there? There'll be two roots. We also know that if b square minus four ac is equal to zero, then this part will be zero. What will be the roots? Roots will be minus b by two a only. So there'll be two roots which are equal, the same roots. For example, if I have x minus a whole square that is equal to x squared minus two ax plus, what will that be plus a square, right? Now, and if I say that this is equal to zero, from here I say that this is equal to zero. If I solve it, I'll make this as x minus a whole square. And that means x assigned a will be the root, right? That means x minus a is zero. So x both the roots will be equal. So if I have root over b square minus four ac equal to zero, in that case I'll have both the roots equal. If root over b square minus four ac is negative, we know then our roots, which are minus b plus minus root over b square minus four ac by two a. If this part is negative, then the roots will be imaginally right. If b square minus four ac is greater than zero, then we'll have real roots, right? And the real roots will be minus b plus this and minus b minus this by two a. Okay, so that is a school level knowledge that we have. Now, if I want to apply this knowledge to write a program that can take as input any equation of that form, ax squared plus bx plus c and find its root, how will the program look like? Suppose I want to write such a program, and now, henceforth, in my discussion about this problem, I'll call this b square minus four ac to be the discriminant. I write it for short dis as the discriminant, because that is what is telling me, discriminating between the roots dis. Okay, so whenever I refer to discriminant, that means I am talking of b squared minus four ac. Now, I want to write a generalized program for finding the roots of ax square plus bx plus c equal to zero. So I want to write a program that will be equally applicable to solve this root, this equation, solve this equation, or 25 x square plus sorry, here I should not write c. Let me put it something like 525 x squared plus 17 equals zero, or any such equation. So you see here, what is the coefficient of x? Coefficient of x squared is 25. What is the coefficient of x in this equation? It is zero. That's why this term has vanished. And what is the value of c? Here it is 17, whereas in this equation, the coefficient of x is three, x squared is three, the coefficient of x is four, and the constant term is five. Okay, so since I am going to solve any general equation of this form, how can I define the specific equation? An equation of this form can be specified by specifying the coefficients. So I have to accept the values of a, b and c from the user. And you can see that the root is dependent on the value of these coefficients, because we know the root x is minus b plus root over b square minus four ac by two a and minus b minus root over b square minus four ac by two a. So the roots are determined only by the value of these coefficients. Therefore, the first step that I'll have to do here, we can start with a flowchart. So I'll first I write read abc, read them from the user. Then I compute find discriminant equal to b square minus four ac. I just compute this part, b square minus four ac. Because depending on this, we'll have the different values of the root. Or I'd say, all right, so earlier, probably I said that the discriminant is root over b squared minus four ac. I'd like to correct myself, I'd say discriminant is this part, b square minus four ac, because depending on the value of this, if this is negative, then the roots will be imaginary, because the square root of this will be imaginary. Okay, so this is the discriminant part. If this is zero, then the roots are equal. If this is greater than zero, then the roots are positive and real. And if it is negative, then the roots are imaginary. So at this point, I will make a decision. Discriminant greater than zero. Yes. Then what shall I do? I'll print roots are real, and then I'll print the roots. If the discriminant is not greater than zero, then I come here and I check whether discriminant is zero. If yes, then my decision is roots are equal. And then I go and print the roots. If this is no, then obviously I'll print imaginary roots. I can't see this part. And then I'll go and print the roots. That is the flowchart of the whole thing. So I am computing this value, and based on that, I am finding the roots. Now, if the flowchart is clear to you, let us proceed to write the program for this. Now here, obviously I should have said that the discriminant is actually this part, b square minus four ac. And then I take the square root of that. Okay, so now if we start writing the program, if I am a nice programmer, I'll always start with. So first, of course, hash include stdio h. Then I am including another thing which is a library called math Leap. Leap stands for library. Why I'm including that? I'll come to that later. Okay, now we start our program main, and we start, I can give a comment program to find roots of a quadratic equation. All right, so that's a comment so that anybody can understand what I am writing here. Now, I'll have to declare a number of variables. I'll declare, okay, let's say the coefficients are all integers. So int, A-B-C okay, now, b square minus four ac can be anything. So I put float discriminant also float root one, root two, two roots. Okay, next, what should I do? Let me proceed to the next page with these declarations. I hope you have been able to take down this declarations. Now let's proceed and go to the next page. I'm continuing with that. I start with printf, enter coefficients a, then b, then c. All right, so the user is told that he is supposed to enter the coefficients. Now next thing will be scanf, since I know, I can also say that please enter integer coefficients. I am just restricting it here like that, though it's not necessary. So scanf percentage D, percentage D, percentage D and a and b and c. So what I'll do, my system will read the three integers a, b and c. Now starts the main program. And as if you have studied the flowchart that I had shown here. Here you can see that I have got only one decision box and I can proceed through that decision box. There are two decision boxes actually. One in this direction, another in this direction. So accordingly, I don't have any loop here. So what is the construct that I'll be needing here? The construct that I'll be needing here is if. So, what should I do? First, let me compute the discriminant. All right, I have got b, a and c, so I do discriminant assigned b squared minus four ac. So b times b minus four times a times c. So this is an arithmetic expression. I get discriminant. Now I have to take the path depending on the discriminant. So what I'll write here is if. Then a parenthesis for the condition. If discriminant is greater than zero, roots are real, and I can put a backslash in here. Else, I have not computed the roots as yet. Okay, so let me write the else as close to the if as possible. As we have learnt about indentation. So, else, if I should have written this if also in small, just for the sake of uniformity, and not only for the sake of uniformity. C is very much case sensitive. So capital if is not if. So, if discriminant is equal to zero, printf roots are equal, backslash n else. Now this else comes under this if you remember that else. And ifs are tied up based on the closest. The else is connected to the closest tip. So these two else, the only option is discriminant is neither greater than zero nor equal to zero. So discriminant is less than zero. Then printf roots are imaginary. Backslash n again. Now, so I have just said what type of roots they are, but I have not printed the roots as yet. I have not found out the roots. So what I can do, I can modify this a little bit, or how do I find out the roots? Let me go to the next page, I do this, and then I come back to a particular stage. Or I can do it here itself. How do I find out the roots? Say, let me go back and do it here. Here I have not written down what the roots are. How could I? Suppose I modify this part a little bit. I modify this part a little bit. Okay, so let me modify this part. I'll rewrite this part in the next page. So I rewrite it as if disk is greater than zero. Printf roots are real. Now I compute, I compute, say I compute, let's call it, I should have declared this also discriminant one another part, that is. Oh, I had the discriminant part, so I can certainly make another variable. So I add one more variable here, int abc, and here I enter another variable, say d y, I'll show later. So I have entered another variable there. So printf roots are equal and d is square root of disk. So I called disk to be b square minus four ac. Now I am finding the root of that. Now here I have committed one mistake. Can you tell me what the mistake is? So this discriminant can be integer, but when I take the square root of that, it can be a float, right? And also here I have already declared, if you look at, I somehow declare disk as float. But since abc are integers, then this will also be an integer. So I should correct it a little bit. Okay, what should I do? Or it really doesn't matter if I keep it as float. So only thing is that I cannot keep the d here. I'll have to remove this d. All right, and I'll also remove this, and we'll make this small d as a float. So then I come here, d is square root of the discriminant. Okay, now what is this square root? Who will compute this square root? This square root computation is done by an inbuilt function in c library. C compiler provides us with a library of some inbuilt function, mathematical functions, which we can call and invoke whenever we need them. Okay? So you can see here, that's why I have included this math leap. That means I'll be using some library function here, dot leap means library. So you will find in the course of this lectures and more examples where you will see more number of library functions. But just for this, we need the square root function. So, I compute the square root of disk. Okay. D. Assign the square root of disk and then root one is what? Root one is minus b plus d by two a. Is it clear the two roots? One is. My formula is b plus minus root over of b squared minus four ac by two a. So this b squared minus four ac is d here. All right, so b plus d whole divided by two a. I should also put a parenthesis here is root one and root two is minus b. Sorry, minus b minus d divided by two a. Then I have got the two roots and I can print here. So I have computed the roots. So I can either print it here, I can print f. Now, the roots can be float. I can say the roots are r, percentage f, roots are floats, percentage f, percentage f, backslash n and root one, comma, root two. So this is the whole part. Compound statement. If disk is greater than zero. So if we go up. So I'll modify this part in this way, you will also have to modify this part. What should you do? Simply, what can I do to write this? If disk is zero, then I'll print roots are equal, right? As I've written, roots are real. And then I'll find out. Now, I don't need to find out this part. So let me just show you this part and I'll leave the other part for you. That second part. If disk. Oh, my God, what did I do here? Oh, this is all right, that's okay. Greater than equal. If disk is zero, then printf will be more than one. Sentences. So this is coming. Else that else part. Else, if disk is zero, printf, the roots are equal. And here I don't need to bother much. I can put a backslash n that you know by now, printf, the roots are equal, root is what? Now, if in this b plus minus root over b square minus four ac by two a. If this part is zero, then my root is only minus b divided by two a two multiplied by a. Okay, and printf, the root is percentage f, backslash n root. Or I can say root one, because I did not declare anything as root. So root one, any one root that's same. Okay, this is this part. If the discriminant is zero. So I have just mentioned root one. Why? Sorry. You see here, I declared only root one and root two. I did not declare any root. So I can make root one, root two. Now. So this is replacing this part. Now, what will you do here? The roots are imaginary, but the same thing. The values will be the same. Only thing is, roots are imaginary. I leave it to you as an assignment. You think of what will you do for that part. Okay. For the imaginary part, you can understand that. Only thing that you need to do is to print some roots as, say, the real part. Real part is this. And imaginary part is this. So you think about it. We can discuss about it in the next lecture. Bye.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Example of Loops (Contd.), Use of FOR Loops.mp3","So we have seen the application of the constructs of if then and if else as well as while, do, while and for constructs. Till now we have seen examples of while and do while. We'll see more examples for loops, for example, let us also see another application for the application of for loop. Say, for example, I want to print. I want to add 20 numbers. I think we have seen such examples. We'll see more interesting examples a little later. But before that, let's look at some common errors that take place, often unintentionally, in writing loops. And that gives rise to a number of logical problems in a program. For example, let's look at this. Here you can see the first line. What will happen? The intention was that while sum is less than equal to num, that means it is less than equal to a particular value, maybe 20. We are adding sum plus two. What does this mean? Let's try to understand this example. Forget about this. Forget about this part. What is the intention of doing this? That means suppose num is ten and sum is zero. So while sum is less than num, I'll be adding sum plus and two. So sum will be two. And then sum is still less than num. So again, it will be four. Sum is still less than num it will be six. Still less than num it will be eight. Still less than equal to num it will be ten. Then still less than equal to num it will be twelve. And then when it goes there, it will stop. So what will be the sum? Sum will be twelve. But that was my intention of the program. But unfortunately, I have put a semicolon here. What does that imply? That implies that the entire while statement ends here. That means while sum equal to num do nothing. All right, so that is the end of the statement. So nothing has been specified there. And whatever sum was there, suppose sum was zero. Sum will perpetually remain less than ten or num, and will go on forever. So this semicolon should not be given, because the while statement is actually extending up to this point. Up to this point. That is the whole statement. Okay, so next example we take is this one. For I assign zero, I less than equal to num plus plus. I forget again about this. What is the intention of this program? What will it do? I is zero. All right. And num was, say something like 20. Then sum will be added to I, so sum will be zero. Then I will be incremented, so I will become one. Less than num. It will be added, so sum will now be sum was zero, so sum will now be one. Here was sum. Sum was zero. Sum becomes one, then sum becomes two. Sum becomes three. Like that, it will go on. All right. However, since I have put a semicolon here, this part is not a part of this for statement. Consequently, this loop is a null loop. Nothing is being done here. And for I equals zero, I less than equal to num, I plus plus do nothing, right? So, nothing will happen here. This statement will not be executed. Here is another type of pitfall where. Let's study this. For I equal to one, I not equal to ten, I assigned I plus two. What will happen to this loop? Can anyone guess? I is one. So, sum, sum, sum has been computed. Sum is sum plus I. Sum was zero, so zero plus one. Sum is one. Then I is incremented to three. Then sum equals sum plus I, so sum becomes four. Then this is incremented to five. After each incrementation, I am checking with this condition. So I is five not equal to ten. Fine. So I'll add five with this, so it will become nine. Then comes seven. I is changed to seven. I check with this, still not equal to ten. So, seven is added to this, 16. This becomes nine, still not equal to ten. So then nine plus 16 plus 9 may be 25. And then this is incremented to eleven, because I plus two, still it is not equal to ten. So what will happen? It will go on. It will never be equal to ten. This means as long as I is not equal to ten, you will go on. So, this will be a case of another infinite loop. All right? Just as in this case, there's a null statement, this will be done. And then this statement will be done only once. Here. It will be an infinite loop, okay? Because this condition will never be met. So these are some points where we should be very careful about. Ah, now let's have a very interesting program. We want to print. We want to print. We want to print a pattern like this. We want to print a pattern like this, say, five stars in a row and three such rows. So this sort of pattern, how can I do that? My algorithm will be. So I want to print. I want to print a row of stars. How many? Five stars. So how can I print five stars in a row? If I just write one statement, printf star, and do not give a backslash n, then what will be done? A star will be. Suppose this is my screen, all right? A star will be printed. And if I put it in a loop, say, for I assign zero, I, five, I want to do less than equal to five, I plus plus. And I do this, then what will happen? I zero. So once it is printed, then I one. Once it is printed again in the same line, then again another one. So since I'm giving a gap, what I can do here, I can keep a space here, star, and then a space. I show space by blank. So exactly, a star and a blank will be printed. So I is zero, I is one, I is two, I is three, I is four. And then it is incremented and checked. I is five. So less than five. It will not happen. Okay, so this will be a loop. After doing that, so in a loop, I'll be printing one row. Then I'll give printf. I have to come to the next line. So I'll simply give a backslash n. That means I'll come to the next line. And this again, loop. I'll carry out how many times? Three times. Because I need three rows. So what should I do? I should do this again, loop this three times. So how should I write it? How would that look like now? It should be something like this. For j, j is another variable. Assign zero, j less than three, j plus plus. For I, assign zero, I less than five, I plus plus. And then here, printf star followed by a blank. And then the quote, no backslash at the end of this. So after this loop is done, then I'll do printf, backslash n. Backslash n. So this part, this part will be repeated three times. And in this part, this one will be done five times. So star, star will be printed. Then we'll come to the next line. And here, this is my next for loop. So I come to printf and again do the same thing. This part, star five times. This printf by this loop. This is print a row, printing a row by five times. Okay. And then again, I come and do a backslash n. I come here and do the same thing three times. And then come here, backslash n. And then stop. So print a row of five stars and repeat. Therefore, I am repeating this. Print star five times in a loop. So that's a very nice, interesting application of a for loop. I hope you have understood this. So here, that's exactly what I was showing you. Look at this here. The number of rows and columns have been made a little flexible. Rows, three, columns, five. Now, row equal to one, while row is less than rows. Print a row of five stars. I have done it with a four. Here it is shown using a while. So let's see. While whether you can understand this also with a while row is one. Now, row is less than rows. How many rows will do? Row is less than rows. That means as long as it is three rows, we'll print a row of five. And how do I do a row of five? That we have already shown that how we do it. And then we increment the row. All right. So here, while row is less than rows, print a row of five. Printing a row of five is done in this manner. So this is the outer loop. This is the outer loop. Okay. Column is one, while column is less than columns. So five columns. 12345. Why column is less than column? Printf, star and blank. And then column is incremented. Now, since I am doing it in a while, it is done in this way. Okay. I've already shown you in the earlier this thing how we can do it with four. I can do the same thing with four. Right? The same thing with four. And here it is being shown how it can be done with a while. And then I print fn and do this. You can try to understand this again yourself. Next, say here, this is being done again in the way that I had written using four. Here, only three and five. These things are variable. For rho equals one to rho, less than equal to three, plus plus row. Here it is a plus plus row. That means first is incremented. Then column is less than equal to columns. Why it is less than equal to while. If you remember, when I was doing it here, when I was doing it, I had less than three, less than five. Less than three, less than five. But here it is being less than equal to three. Less than equal to five. Why? Because I started my index with zero. And here I am starting my index with one. All right, so this, you should be very careful and you should always hand trace your program and see whether you have done it correctly. If there is a little bit of confusion, because this is very important and you should be very careful about it. Okay, so the same thing that I had shown is written again here, another 2d figure. This is a little more interesting. First row, we print one star. Second row, we print two stars. Third row, we print three stars. Fourth row, we print four stars. And then five stars. So how many stars I'll print that is also variable. So if we think about that, how many times I'll print in a row that is also a variable. How many times I am doing this. So, for the first, when Rho is equal to one, then I am printing one star. When Rho is equal to two, I am printing two stars. When Rho is equal to three, I am printing three stars. So every time I can also say that I am printing Rho stars. I am printing row stars. Okay, row number of stars. Therefore, how many times I'll do. In a loop in the inner loop, you could see that when we had drawn this thrice or twice, whatever there was here there is an inner loop five times. And an outer loop that was doing two times. Right? Now here what we'll change it to is inner loop. Row times outer loop, maybe three times. So this is variable. Okay, now let's see how we can program it. Constant integer rows is five that I have not made variable. There are two integers, row and column. For row, equal to one, I start with rows, row as an index and row less than rows, less than five, plus plus row. What do I do? Column equals one. I'll do up to column less than equal to row. So first row, column one. Column is less than equal to row. Only once I'll print then plus plus column, so column becomes two. But what is my row? Row is one still I am pointing at this row. Row is one, so I'll do printf. Now the value of row becomes two as an increment. But then the column. This is the column. This is row. The column will be less than row because row has become two. Now it's pointing to this row. So column being less than that. I'll come out of the first row, okay, second row, what will happen? Column will start from one and row is two. So column less than row. I'll print once, I'll go back here. Column is becoming two and column is still equal to row, right? Not less than, but equal to row. Therefore I'll again print here. Then I'll come back here. And now column is three, column is three but row is two. Therefore I'll not print any longer. I'll come out of this loop and go here. Then row will be incremented here. All right. Row has been incremented here. And now again, column is deinitialized to one. For the third row, first it is printed incremented. Column comes here. All right. Then columns. Column comes here. So column is three still less than equal. Equal to row. So I print the third one. And then it is incremented so the row becomes four, but my column is. Sorry. The column becomes four, but row is three. Therefore the column is. I go out of the loop. And again, column is initialized to one. And my row is incremented to this. So that is how it is done. You please look at it more carefully and you will have to understand it. And this will give you a very clear idea how a nested loop is working. Okay, so this is one example here what we are trying to do. Just think of this figure. First row is five. So row is this, column is here. How long shall I print in the columns? Keeping the row fixed? What will be my logic? The logic will be. Well, here I started row with zero and less number of less than number of rows. Rows is five. That is not that important here. Let us look at this. First I'll do five, then I'll do four. But there is another one for the second row. I am shifting one space. I am shifting. This should have been aligned. And then I am shifting and giving a space and then doing it. So gradually it's being shifted. So let's see what is being done. Let's look at the first for loop here. This is the outer for loop. Let's. Outer for loop is up to this. Outer for loop is up to this. And let's see what is happening. Row is zero to number of rows, less than. So I started with zero, so I did not make it less than equal to. It is less than less than five. I'll do this number of times internally. What am I doing this doing here? Column is one and column is less than row because less than equal to row because row is zero, row is zero, and column is one. Look at the trick here. The trick that has been applied is column has been, is starting with a value, one. And as long as column is less than row, I am printing blank. So how many blanks should I print for the first column? One blank. Okay, then column less than now here. From the first column, look at this point. Column equals one. Column less than equal to rows. Rows is five. As long as column is less than equal to rows minus row. What is my row initially? My row is zero, so rows minus row is five. Okay, it's five. So column is one. Column is less than equal to five plus plus. So I do printf, I do a printf and I go on doing this. As long as the column is so, column is now incremented to two, three, four. How long will it come for the first row? It will come five times because rows minus row, five minus zero. So I'll print this and then I'll come back. This loop is over. This loop is over. I'll print a backslash n up to this. Sorry. I'm sorry. This for loop is actually extending up to this. So from here I go back. So I come to the second row. So now row becomes one. Let's see. Now row becomes one less than five for column equal to one. Column less than equal to row one still valid. I give one blank here, one blank here. For the second row, my row pointer has come here, row is one. Then I do column one, two, column minus row, so one's blank. I have already given. So I am. Now my starting is here. How many? Now row is one. So five minus one. So that means four, four times. This will loop and print star and then print fn. Next time I go back here and this becomes two. So row two to less than five. Column is again now two blanks, column is one, two less than equal to rho and rho is two. So one to two. So there will be two blanks here, one blank here, one blank here. So I'm coming here and then I am printing. This is two. So five minus two, three stars. So in this way I can go on and print this figure by an intelligent way of applying the for loops or the nested loops and putting in the spaces together spaces properly. Okay. I think this gives a very interesting example for you to look at. So these are some of the examples that we have seen. We'll come to this fourth thing again later, but let us just remind you a little bit about some things that we had mentioned in passing. For example, this operator plus equal to as for example here, a plus equal to b. This means a assigned a plus b. These are some shortcuts. All right. A minus equal to b. That means a is assigned a minus b. Here a star b plus ten. A star assigned b plus ten. That means a will be assigned a times b plus ten. So in that way we have got this one also say a assigned b, that means a is assigned a divided by b. These are some of the shortcuts. So this is just to wrap up some of the assignment operations that we had talked about. But these are, as I said, that you can keep this for later use. Right now, more fundamental thing that you need to know is the use of if else for while, do while, et cetera. In the next lecture we will start with a new concept called arrays. And there you will find that this loops are becoming so important and will have many interesting applications using arrays. That will be done from next lecture onwards. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Example of Loops (Contd.).mp3,"So, in the last lecture we have seen how we can write a program to find out whether it is prime or not. Now, this program that you see that we had discussed in the last class will certainly give us correct result. Now, our job is not only to write a correct program. It's also very stimulating intellectually to think of how we can make it a more efficient program. Often the program can be correct, but it's not very efficient. What do I mean by this efficiency? Say if we look at this program, and again, I take the earlier example that suppose I have my n is 13, okay? And I start with the value of I to be two. I is two and n is 13. And since it is prime, I am checking this condition time and again. And since this is third prime number. How many times? It will never come here. It will never succeed. So I'll have to carry on this loop. And ultimately, when I exhaust all the possibilities, then only I'll come to this point. So how many times do I have to do this? Let's see. I'm starting with two, checking once. Then start incrementing and making it three. Then four. Then testing with five. Then testing with six. Testing with seven. Testing with eight. Testing with 910. 1112. So how many times did I check it? 1234-5678 910 eleven times. I had checked it with eleven times. Now do I really need to check it with eleven times? If you think a little bit. If this number is n, then I did not check it. And I'm starting with two. So n minus two times. I am checking. Right. Do I really need to check n minus two times? If I do not find it divisible by squared within square root of n times. So square root of 13 as an integer, what would it be? 13 would be three point something. Right. So four times within four. If it is not divisible, it will not be divisible by the future numbers also, right? So if I just apply this knowledge that if it is not divisible within square root of n. Then it will not be divisible later, I can make this program much more efficient. So now let us go to another example. This is again finding the sum of sum of the digits of a number. Now this one we did not do sum of the digits of a number. What is meant by this? Suppose I have got a number 123. Sum of the digits of a number means one plus two plus three six. If my number is 243, then the sum of the digits will be two plus four plus three six and three nine. Okay, this is what I want to find out. So how do you go about doing that? How do I find out the digits? Say one, two, three from there, how do I extract out one, two and three? Just think over. If I have got 123 and I divide it by ten, I'll get a quotient, twelve and a remainder. So the remainder is one digit. Now I take the quotient divided by ten. I'll get a remainder, sorry, a quotient and a remainder. The remainder is another digit. And then I go on till it is. The number is not equal to zero. So next I take one and divide it by ten. The quotient is zero and the remainder is one. So you see, I have got all the digits from the right hand side, one after another, right? So I can add them, okay? That is my basic way. So let's keep it on the side and see what we have done. In this program. I have got a number, n. Now, this number that has been given initially 123. I don't need to preserve that number, so, so I can play with that. And I have to make a sum of this, right? One, two and three. So I keep a sum to be initially zero. I keep a variable sum which is initialized to zero, as we saw in the earlier examples, and sum is also an integer. Then I read the number that is, say, 123 has come. Now, while the number n that is 123, 123 is not zero. Then I take add n modulus ten. N modulus ten will give me what the remainder three and add it to the sum. So my sum now becomes three. And then I want to find out this thing also. I make my n to be n divided by ten. Now this operation gives you the quotient, right? This operation gives you the remainder. So now I get n by ten means. Now twelve and I go back to this loop. I check that twelve is not zero. So I'll again do that. Sum will be sum. What was that? Three plus n modulus ten. So I again divide it by ten and take the remainder. And that remainder is added sum plus this. So three plus two will be five. And then I divide n by ten. So now I find out one. Still I go back. One is not. I go back. Actually here one is not zero, sure. So I again divide it by. I take the remainder, divide it by ten and take the remainder. So the remainder is one. I add it with the sum, so it will be six. And then I divide. I find the quotient and that is zero. I go back again here and find that n is not equal to zero condition. Is not true. So I come out of the loop and I apply this printf statement. What is the printf statement doing? The sum of digits of the given number, I cannot say given number n because n has already changed. I'll come to that in a moment. Now it's sum. Okay, so I've got the sum. So this is another example of a while loop. Now my question is, if you have understood it, I want the output to come as printf. The sum of digits of the number 123 is six. How can I do, what modification should I do in this program? What I want to be printed is the sum of digits of 123 is six. What should I modify? Of course I should modify this statement. This statement should be the sum of the digits of the number. Percentage d is percentage d. And here before sum, what should I do? My n that was provided by the user has already been destroyed in this loop. So what? Because every time I'm dividing it by ten and making a new number, 123 is becoming twelve and then it is becoming one, then it's becoming zero. So I have to save it somewhere, this 123. So what I can do here, after this reading this, I can save it in another variable, num as n. And here I'll put num comma. Now, because I am destroying n here, but I am not touching num, so num will remain intact. Only another thing that I have to do. I have to add this num here. I must declare it num as an integer, otherwise it will give you syntax error. All right, so this is another nice example of, while using which we can find the number of digits, the sum of the number of digits of a number, sum of the digits of a number. Right? With that we move to another example, decimal to binary conversion. Some of you may know it and some of you may not be very conversant with that. We know that we have got the binary number system where the base is two, so everything is expressed using zeros and one. So if I have a binary digit, sorry, decimal digit four, its binary equivalent is 10, zero. If we have five, that's 10, one. If it is one, then it is one. If it is two, it is zero, 10, like that. The question is that given a decimal digit, how can I convert it to binary? What is the algorithm? The algorithm is something like this. Let us take the number four and I want to find out what is the binary equivalent of this. The algorithm goes like this. I first divide it by two, because two is the base of any binary system. I divide it by two, so I get the quotient as two and remainder as zero. Okay. Next, I divide it again by two. So my quotient is one and remainder is zero. Next, I divide it again by two. My quotient is zero and remainder is one. So I go on dividing till I get a quotient to be zero. And I have remembered all the remainders that I got. Now I can get the binary if I did it in this direction. So it is 10, zero. All right, let's take another example. Suppose I want to have the number 15. Now what is the binary of 15? To understand that, let's look at the weights of the different positions in binary. This one is with two to the power zero, two to the power one, two to the power two to the power three. That means this is 8421. Now 15, if I have to have, I must have a one here and seven more. So one here, eight and 412. And one here, 1213, 14 and 15. All these should be one. Okay, so can we find out, find this out. Let's see. 15. I divide by two, my quotient is seven and remainder is one. I again divide it by two. My quotient is three and remainder is one. I divide it by two. Again, my quotient is one, remainder is one. I divide it by two. Again, my quotient is zero and the remainder is one. I did it in this direction and we get one, one, one. All right, let's take another example again. The weights of this system are 1248. Okay? Two to the power zero, two to the power one, two to the power three, two to the power, sorry. Two to the power, two to the power three, okay. One will be 16 is two to the power four. Now let's take a number 23. What will be the binary representation of that? Let's see here. 16 will be there. Of course it's greater than 16, so 20, 316 and six and seven more. So this should be zero. I cannot put a one here because that will be 16 and eight will be 24. So one here, 20, this, so my binary is 1011. Let's try in our algorithm, divided by two, my quotient is eleven. I've got a remainder, one. I divide by two, my quotient is five, remainder is one. I divide by two, quotient is two, remainder is one. Divided by two, it's one and zero, and divided by two, it's zero and one. So, I reach a zero, I stop. And this is the pattern 101-1011. All right. Now let's see how this algorithm that we are talking of can be encoded in C program. You see here, I have declared one variable as Dec. That means the decimal number that I'll be reading. So I am reading that number here. Now, in the earlier example, we did it while do now here, people. That's also very interesting and known to us, that is finding the greatest common divisor of two numbers. Greatest common divisor of two numbers. What is the algorithm? The algorithm is shown here. Suppose I have got a number 45 and twelve. I am to find out the greatest common divisor, or the HCf of these two numbers. What I do is I divide the bigger number with the smaller number and get a remainder. You see, remainders are becoming so important. We come to the remainder, and then if the remainder is not zero, I divide now the smaller number, this one, with a remainder, and then I get again a remainder, which is nonzero. Then I take the divisor, current divisor, and divide it by this until we get zero. That's what we used to do in school, right? So ultimately, when I get zero, whatever is the divisor, currently, current divisor. That is our HCA for GCD. Okay? Here you see how the code is written. You just look at the code a little bit and try to understand it. A and b are two numbers. Now, I do not know as yet which one is smaller and which one is bigger. Here, in our example, we can see one is twelve. One is 45, but one is twelve. One is 45, but I am going to try this here. The computer does not know which one is twelve, which one is 45. And I am taking another variable, temp. I am reading the numbers a and b. Now, if a is greater than b, that means I am taking the greater number and moving that in temp out of this twelve and 45, which one is the greater number? 45. So Thames becomes 45 and b becomes a. B is the smaller number. So twelve becomes a and b becomes temp. Now, you see, I have written these three in one shot. So let's see here what is happening after this. First temp is 45. A is twelve, and b is 45. Now, what I am doing here, I'm keeping this temp. What I am doing here, I am dividing b by a. So 45 is being divided by a twelve, and I am checking the remainder. I am checking the remainder. The remainder is not zero. You can see that. Since it is not zero, I am taking temp to be the modulus of twelve. Sorry. B is what b was. B was 45, right? So here, b was 45 and a was twelve by this point and temp was 45. I try this, it's not zero. So then I take this remainder, nine, and again make that to be b. So now b becomes nine and a becomes the temp, which was this number. And I go on dividing this and I go on carrying out this loop till this becomes zero. As soon as this becomes zero, then I have got my GCD stored in a, because every time I am taking the a in a, I am storing the temp. And what is temp? Temp is after I divide, I get the remainder and that I'm storing in temp. And that temp is coming in a. All right, is being stored in a, and that is also copied in b. But in the next loop that is being divided by. So here you are having three, nine, and here three. So look at this iteration one here, looking at this picture, first temp will become nine, b is twelve and a is nine. Next time temp is becoming three, b is nine, this nine and a is becoming temp. And whenever I find that b divided by a, this part is zero, remainder is zero. Then that is my GCD. A is my GCD, I get the three. This is another very interesting example of computing using this while loop. And repeatedly I am doing this till I find the remainder to be zero. So there are many such nice examples and we'll give you some more during for assignments which you will have to solve and you will get more confidence about it. Okay, so next we'll come to some of the pitfalls of loop and then move to something, ah, more useful, something very useful. That is the concept of arrays. Okay, thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Example of Loops.mp3,"So you are looking at solving a quadratic equation, and we have seen that there are three cases. One is, if the discriminant is zero, we print the roots, that the roots are real. Sorry. If the discriminant is greater than zero, then the roots are real. Otherwise, if it is equal to zero, then the roots are equal. And if the discriminant is neither greater than zero nor equal to zero, that means it is less than zero. Then the roots are imaginary. So, next, what we did is we started with a program like this where we declared the coefficients here and then the discriminant and intermediate variable d and two roots, right? Root one and root two. Next, we proceeded with this and we modified this part. If disk is greater than zero, printf roots are real. And then I modified this part and replaced this part with this. If discriminant is zero, print the roots are real and also compute the root. Okay. Now, if the discriminant is equal to zero, then print the roots are equal. Compute the root and print it. Now, I asked you to see how you will deal with the third case. If the discriminant is not equal to zero. So this, if. When this if comes, then it has already failed. The condition that discriminant is greater than zero. And if the discriminant is not equal to zero, then we'll come to just an else here. Right. And let me go to the next page to write the else part of this. So it will be else simply. I'm sorry. Here. Did I give the parenthesis? Yes, I did. So I'm okay. This is. Please note, these are the points where we often make the mistakes. Else, printf. The roots are imaginary. Backslash n. Fine. And what are the roots? So, if the roots are imaginary, then the real part, say one root is minus b by two a is the real part. And the image plus I. That's what we I d by two a. Is it clear? Another. This is one root. Another root is b by two a, minus I, d by two a. So basically, you see what we are doing is x is minus b plus minus root over b squared minus four ac by two a. So this is my discriminant. And I take the square root of that. So, plus, minus root over d by two a. Right? In my program, what did I write? A d or discriminant. Square root of disk. Sorry. Disk. So I should not use different name. So it should be disk by two a. And that square root of disk can be either imaginary. So, negative. If this is negative, then I'll find its absolute value. And so this can be written as minus b by two a. Plus square root of disk by two a is one root. Another root is b by two a, minus root over disk by two a. And since it's imaginary, it should be I, the imaginary part. So I can print it as the real part to be b minus two a. And imaginary part is square root of disk by two a. And say square root of disk is nothing but d. So minus b by two a, plus I, d by two a. That's what I am writing here. All right, so this is the real part. This is the imaginary part. So I can print it in different ways. So I can just say, else printf roots are imaginary. Or rather, I should have said, this is wrong to say, what should I have said? I am doing a mistake here. All through starting from this point, you must have observed it here. The roots are complex roots. Then in that case, not the imaginary roots because it has got a real part and the imaginary part. Okay, so the roots are complex. I should have written roots are written, flex roots. And then I could print real part, percentage f, backslash n. I can put an expression here, minus b divided by two a. Let me make it a little cleaner. Looks very nasty here. B divided by two a. That is the imaginary part. That's the real part. All right. And printf imaginary part is plus I, percentage f, comma, minus I, percentage f, backslash n, followed by. What is my imaginary part? Imaginary part is d by two a. So you see, I have put this I part plus I and minus I here, comma, d divided by, again, d divided by twice a. All right? And then, of course, everything is done. So I come to the end of my program. Before that, here there should be a parenthesis. Okay, so this is the complex part. Now, as we'll become little more conversant with programming, you can see that I have repeated many things, right? So instead of doing it, there are some common. You can think of how you can write it in a much more elegant and shorter way. But this is an example which gives you an exposure to the use of if then else statements. If else statements in C. Okay, next. Well, another example we can take up. Say, for example, we are going to compute the income tax of a person. Suppose if the income tax is less than rs100,000, then income tax is nil. If it is between 100,000 to rs200,000, then you pay 10% of the amount above one lakh. 100,000 for income above this 200,000 if the income is above 200,000, then you pay 20% of the amount, whole amount, not how much is exceeding 10,000. Suppose this is our, suppose this is our income tax policy. How can we do this? So what is the input that I need from the user? I need this income from the user, right. And what is the other variable that I want to compute? The tax. So here, earlier I needed math Lieb. In this case, probably I'll not need that, but I'll not need that. If needed, I can always add it later. Main and then you can say put a comment. Computation of income tax. Tax computation. All right, now I start my program. All right. I can put the parentheses above then printf. It's always better to do this. Please enter your income, because if you do that, then you make your program interactive. That means the user can see what you are doing, right. Please enter your income. Well, I have not yet declared the variables at all, so here I should write float income and tax. Then here scan f, percentage f and income. So I read the income here. Fine. Then what should I do? Let me come to the next page then, because there will be number of if conditions. So this part is okay, I've read the income here. Now, if income is less than or equal to 100,000, printf no tax. Else, what is my principal? One lakh to two lakhs. 10% of the income. 10% of the income above 100,000. So else, if income is less than equal to 200,000, so it is not when it's coming here, it's already greater than 100,000. So if it is less than 200,000, then tax will be 10%. That means zero one times the amount that the amount exceeding 100,000. So income -100,000 printf tax equals percentage f. Backslash n tax. Is this part clear? This part is. So when am I coming here? This if condition has failed. So I am coming here. That means it is not less than 100,000, so it is more than 100,000. But if it is less than 200, less than equal to 200,000, then I'm in the second bracket and I'll be paying 10% of the amount that is exceeding 100,000. That's why I computed this and then I am printing this. So here it's more than one statement. I put a bracket here. You see, under, if I had only one statement. So putting a bracket is not mandatory. But here it is mandatory. Otherwise it will mean something else. So else this. Now, if this is also not true, that is if this if does not satisfy, then I am in the third bracket, that is here. What should I do? Else tax is 20% of the income and printf tax assigned percentage f backslash n tax. Now here. Then I come to the end. So I come to this beginning, this beginning point, and I end the program here. Now you can see that I can reduce this program a little bit. How I have written this, printing the tax, this thing, the same thing twice. I'm sorry. Here there should be another bracket for completing this. This should be completed and then the next bracket. Now this I could have done later after these tweets. All right, but under this else, under this else. So you can also try to reduce it. And as an assignment, you should run this program and get yourself satisfied. All right, so this is another classical example of if then else usage. All right, given this, we'll now move to some more examples, some more examples of the other construct, that is while and do while type of constructs. Okay, so here is an example to show if a number is prime or not. Now, how do I go about it? Let's first think of the algorithm for finding out whether a number is prime or not. Say, for example, I take a number 13. I want to find out whether 13 is prime or not. So when is a number called prime? When the number is not divisible by any other number other than the number itself and one. Okay, so in order to find out whether 13 is prime or not, what shall I do? I'll start with two, and I'll try to see whether two is dividing 13. How do I know whether two is dividing 13 by the modulus operator? So if there be two integers, say 14 modulus two, the modulus leads gives me the remainder. So if 14 is divisible by two, the remainder will be zero. Okay, 26 divided by two, the remainder will be zero. But 13 divided by two, the remainder will be one. Okay, so similarly, so suppose I want to see whether a number 15 is divisible by three. I'll do the modulus operation of 15 with three, and the remainder will be zero. So 15 is divisible by three, right? So now if I want to find out whether 13 is a prime or not, I'll first try to divide, see whether it is divisible by two. If it is divisible, yes, will tell me not prime, right? It will tell me not prime, but no. Then I'll try to divide it by three. If this is divisible by three, then again not prime. No, I'll divide by four, then obviously not divisible. Then I'll divide it by five, so on and so forth. I'll go till I divide it by twelve, since of course by 13 it will be divisible. So if the answer continuously up to twelve is no, then we say it is not a prime. Right, not a prime. So here you see, there are two things happening. One is I am taking a check, branching here, I'm dividing it by two. If it is divisible, I say it is not a prime. If no, then I am taking another path. What is that path? That path is again trying with the next successor of these two. Yes, if the result is yes, I take this path. Otherwise I'll follow this path with a successor of this. So the same thing, trying with the successor, I am doing continuously, repeatedly. If the divisibility result is false, that means if it is not divisible, I'll continuously go on till I reach. If this number is n, till I reach n minus one. Right up to that, I'll try. Up to n minus one. I'll try. Okay, so this is an example where there is a branching as well as looping. Another real life, mathematically important application. So let us look at the program. Now let's try to understand the program here. This include st do iu, h is known to you, Main. I am declaring two variables. One is n, another is I. Okay, n is an integer. I is also an integer initialized to two. I am reading the number here, say 13, while I is less than n. That means I was two. If you look at, ah, this page, we started with two. We started with two and then went on, right, so this is the value of I and this is the value of n. Okay, so now while I is less than n, so I had 13 and I is two. This is n. I'll go on up to 13. Up to. While I is less than n, that means up to twelve, I'll go on trying this thing. What if n is divisible by I? Is n divisible by I? Yes. Then print that the number n is not a prime. Okay, and then exit, we come out of this loop just like break, we come out of this loop, but break is not applicable. In if statement exit, we can write. So I come out of the loop. Otherwise, what I am doing still in the while loop, the while loop is starting from this point and going up to this point. I am incrementing I. So I becomes three. And again I go and try to see if it is divisible with three. No. Then I come. Make it four, make it four. I again, try this. One fails. It's not divisible. So I don't do this part. I don't do this part. I come here, make it five. And gone in this way, while I is twelve. Up to twelve, I check, and then it becomes 13. So I come here, and ultimately I come out of the loop until 13. I could see that I could find no number, no integer that is dividing it. So we say that this is a prime number. Say, for example, what would have happened if I had given the instead of n 13? If I had given it 14, what would be the change in this flow? I'd start with the two two. And again, I divide it by two. Try dividing it by two. It is divisible. I print that it is not a prime, and I exit and come out of this entire while loop. Okay, so in the while loop here, I am exiting from the while loop altogether. Not from the if loop. I'm exiting from the while loop. If is not a loop, by the way, I'm exiting from the while loop completely. Okay, so this example also illustrates the use of if here and the while loop here. All right, we'll see a few more examples in the future lectures.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
examples.mp3,"You. To round off this week, let's look at some examples to illustrate some of the concepts we have seen so far. So, we have already seen a function which computes the factors of a number n. So we observed that all the factors must lie between one and n. So this is something we can naturally compute using a for loop. So we define factors of n as follows. We assume that the list of factors is empty, and for each number in the range one to n, if that number is a divisor, it's a factor of n. We append it to the list of factors, and eventually we return this list. So this is a simple function which just takes the list of factors, gives back the list of factors of the input n. So a prime number is one which is divisible by no other number other than one and itself. In other words, the only factors of n should be one and n if n is a prime. So 17, for example, which is a prime number, has only two factors, one and 17. Whereas 18, which is not a prime, has many more factors. It is also two times nine and three times six. So a list of factors of 18 is a longer list than just one, comma 18. So this allows us to write a very simple definition of prime based on factors which we've already seen. So a number is prime if the list of factors is exactly one, comma n. So what we do is we invoke the function factors and check what it returns and see if it is equal to the list one comma n. So this is another illustration of the fact that if we break up our code into functions, then we can use functions one inside the other, and break up our problem into smaller units which are easier to digest and to understand. So here we said that a prime number has only two factors, one in itself. We have separately written a way to compute the list of factors, so we can take that list and directly check whether or not a given number is prime. So one small thing to be aware of when we are dealing with prime numbers is that we should not accidentally define one to be a prime. Because if we just look at this definition that the only factors are one and itself, it is a bit ambiguous, because one is a factor and itself is one is also a factor. So we could naively read this as saying that one is a prime, but by convention one is not a prime. So there should be two factors separately, one and itself. Fortunately, if we call our function factors, then factors of one will return a single list containing singleton list containing the value one, because the code will run from one to one, so it will only find it once, whereas in order for this return statement to be true, I would like the actual value to be one comma, one one comma, n. So n is one. So fortunately, the way we have written is prime, it will correctly report that one is not a prime. But these are the kind of boundary conditions that one must be careful to check when one is writing functions in python or in any other programming language. So what if we want to list all the prime numbers which lie below a given number n. So we have to just check for every number from one to n whether or not it's a prime. So we already know how to check if something is a prime. So once again, we can write a function primes up to, which takes an argument, n. So initially we say that there are no primes up to n. Now, for all numbers in the range one to n plus one, which means from one two up to n, we check if that number I is a prime. Now, this is a function we've already written. If it is a prime, then we append it to our list. If not, we go to the next one. And finally we return the list of primes we have seen. So once again, now, we have used a function we have written before. Is prime. Is prime, in turn uses a function called factors, which we don't see here. So we have three levels of functions. Now, primes up to which calls is prime, which calls factors. So this is a very typical way to write nice programs where you break up your work into small functions. Now, the other advantage of breaking up your work into small functions is that if you want to optimize or make something more efficient, you might first write an most obvious or naive way to implement a function so that you can check that your overall code does what it's supposed to do, and then you can separately go into each function and then update or optimize it to make it more efficient. So breaking up your code into functions makes it easier to update your code and to maintain it, and to change parts of it without affecting the rest. So, primes up to m we knew in advance that we have to check all the numbers from one to n, so we could use a four. What if we change our requirements, saying that we don't want primes up to n, but we want the first n primes? So now we want the first n primes. We don't know how many numbers to scan, we don't know where the nth prime will come. If n is small, we might be able to figure out just by looking at it. But if n is large, if we ask the first thousand primes, it's very difficult to estimate how big the thousandth prime will be. So we have to keep going until we find 1000 primes and we don't know in advance. So this is a good case for using the other type of loop, namely while. So what we need to do is we need to keep a count of how many primes we have seen. We need to go through all the numbers one at a time to check if they are primes. And we need a list of all the primes we have seen so far. So, just to illustrate another point that we have seen, this is a simultaneous assignment which says, okay, initially we have seen zero primes, so count is zero. We start with the number one. This is the first number we check whether it's a prime or not. And initially, the list of primes is empty. So this says, take these three values, take three c names and assign them. These three values assign. This is saying the same as count is equal to zero, I is equal to one, and p list is the empty list. So this is the same effect, this particular assignment. Now, so long as we have not seen n primes while count is less than n, we have to check whether the current I is a prime. And if so, add it. So if the first, if the value I we are looking at is a prime, then first of all, we have found one more prime. So we increment the value of count, and we have found a prime, so we must add it to the list of primes. If this is not a prime, we must just go to the next number. In any case, we must go to the next number until we hit a count of n. So we outside the if so, this is unconditional. We always update. So for each I, we first check if it is a prime. If it is a prime, we update count and we append I to p list. And whether or not it is a prime, we increment I, and each time we increment count, we are making progress towards this while terminating. So remember that it's our job to make sure that this while will eventually get out. This condition will become false. So every time we see a prime, count is going to become count plus one. We start with count equal to zero, so eventually it is going to cross n. Of course, we are using fact, the implicit fact. We know that there are an infinite number of primes, so we will always, for any n, be able to find the first n primes. So when we do find n primes, when we have gone from zero to n minus one and we have reached the count n, we have seen n primes. Then we return the list that we have found so far. And this is p list. So these two examples, the primes up to n and n primes, illustrate the difference between the use of four and y in primes up to n. We know that we must scan all the numbers from one to n, so it's easy to use a four in n primes. We don't know how many numbers we have to scan to find n primes. So we use a while and we keep count, and we wait for the count to cross the number that we are looking for. So it turns out that you don't actually need a four. You can always simulate a four by a while. So, let us look at the two typical ways in which we write for. So the first way is this, four in a range. So we say for n in the range I to j. So we start at I and we let n go through the sequence I, I plus one up to j minus one. And for each value of n, we execute this statement. Or there may be more statements here. So, this is a block of things inside the loop that we will execute. So if we want to do this without a for, we could do it with a while as follows. So we initialize. So, this says that the first value of n is I. And so long as n doesn't cross j, you execute the statement, exact same statement, and you increment n. So it comes back here and you check. Now you get I plus one, I plus two, and then when you reach j minus one, the next time it will be j and it'll exit. So we have to have a range in the for we can just set up a counter and manually increment the counter and check the counter value against the upper ground in the while. The other way that we use for is to iterate through the elements of a list. So n. Now, if l is a list of values, x one, x two up to xk, n will take each value in this list. So here again, we can now set up positions to walk through the list and pick up the value at each position. So we say we start at the zero th position, and so long as we have not reached the end of the list in terms of positions, we set n to be the value at position I. Then we execute the statement and we increment the position. So both forms of the four can be written as while. But notice that the right hand side is significantly more ugly and complicated than the left hand side. So while we can use the while statement to simulate the for statement, it is much nicer to use the for where it is natural, where we know in advance what exactly we are repeating over. So this makes for more readable code. And in general more readable code makes for a better program. So what do you need to do to write a good program? Well, first of all, it must do what you expect it to do, so it must be correct. And secondly, it must do it in as efficient a way as possible. We have not looked at efficiency so far. We will look at it as we get further in the course. But we want to do things quickly, we want to do things in the most efficient manner. And this is where the algorithm comes in. How you do something is what an algorithm will tell you. And the second part is that you must write down your instructions in a way that is easy for you to validate as being correct, and for somebody else to understand. And if necessary, update. Now, we should not underemphasize this fact of maintenance. You write something today which serves a certain function. Very often somebody will have to later on either make it more efficient or change the functionality, increase the range of things your program does. And in that case, very often it is not the person who writes the code, but somebody else who has a job of understanding and updating the code. So at every stage, if the person who is making modifications, starting from the person who wrote the code initially writes it in a clear and readable style, it makes it much easier to maintain the code in a robust manner as it evolves. So, to summarize, there are two parts to programming. First is what you want to say, which is the algorithm, and the second part is how you say it, which is the style. So every programming language has a style. Use the style to make for the most effective and readable code you can find. If you have a for use it, don't force yourself to use a while, and so on. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
exception handling (1).mp3,"You. So let's see what to do when things go wrong with our programs. Now there are many different kinds of things that can go wrong. For instance, we might have an expression like x divided by z, and z has a value zero, so this expression value can't be computed. Or we might be trying to convert something from a string to an integer, but the string s is not a valid representation of an integer. We could also be trying to compute an expression using a name whose value has not been defined. Or we could try to index a position in a list which does not exist. As we go forward, we will be looking at how to read and write from files on the disk. So we may be trying to read from a file, but perhaps there is no such file. Or we may be trying to write to a file, but the disk is actually full. So there are many situations in which while our program is running, we might encounter an error. So some of these errors can be anticipated, whereas others are unexpected. So if we can anticipate an error, we would prefer to think of it not as an error, but as an exception. So think of the word exceptional. So we encounter a normal situation the way we would like our program to run. And then occasionally we might encounter an exceptional situation where something wrong happens. And what we would like to do is provide a plan on how to deal with this exceptional situation. And this is called exception handling. So exception handling asks, when something goes wrong, how do we provide corrective action? Now, the type of corrective action could depend on what type of error it is. If, for instance, we are trying to read a file and the file does not exist, perhaps we had asked the user to type a file name so we could display a message and ask the user to retype the file name saying the file asked for doesn't exist. On the other hand, if a list is being indexed out of bounds, there is probably an error in our program, and we might want to print out this value, the value of the index, to try and diagnose what's going wrong with our program. So sometimes the error handling might just be debugging our error prone program for all this. What we require is a way of capturing these errors within the program as it is running without killing the program. So as we have seen when we have spotted errors while we have been using the interpreter, if an error does happen and we don't trap it in this way, then the program will actually abort and exit. So we want a way to catch the error and deal with it without aborting the program. Now there are many different types of errors, and some of these we have seen. But you may not have noticed the subtlety of these. For example, when we run Python and we type something which is wrong, then we get something called a syntax error, and the message that Python gives us is syntax error, invalid syntax. For example, supposing we try to create a list, and by mistake we use a semicolon instead of a comma. Then immediately Python points to that semicolon and says, this is a syntax error. It's invalid Python syntax. Of course, if we have invalid syntax, that means the program is not going to run at all, and there's not much we can do. So what we are really interested in is errors that happen in valid programs. So the program is syntactically correct. It is something that the Python interpreter can execute. But while the code is being executed, some error happens. So these are what are called runtime errors. These are errors that happen while the program is running. And here again, we have seen these errors, and they come with some diagnostic information. For instance, if we use a name whose value is undefined, then we get a message from Python that the name is not defined, and we also get a code at the beginning of the line saying this is a name error. So this is Python's way of telling us what type of error it is. Similarly, if we have an arithmetic expression where we end up dividing by a value zero, then we will get something called a zero division error. And finally, if we try to index a list outside its range, then we get something called an index error. So let's look at all these errors, just to be sure that we understand. So supposing we say y is equal to five times x and we haven't defined anything for x, then it gives us an index error, a name error, and it says clearly that the name x is not defined. On the other hand, if we say y is equal to five divided by zero, then we get a zero division error, and along with a message division by zero. And finally, if we have a list, say one, two, and then we ask for the position three, then it'll say that there is no position three in this list. So this is an index error. So these are three examples of the types of error that the python interpreter tells us. And notice that there is an error name at the beginning, index error name error zero division error, plus a diagnostic explanation after that. So let us first quickly settle on some terminology. So USually the act of signaling an error is called raising an exception. So when the PYtHON interpreter detects an error. It gives us information about this error. And as we saw, it comes in two parts. There is the type of the error, what kind of error it is. So it is a name error, or an index error, or a zero division error. And secondly, there is some diagnostic information telling us where this error occurs. So it's not enough to just tell us, oh, some VaLue was not defined. It tells us SPECIfICALlY the NAme x is not defined. So this gives us SOme Hint as to where the error Might be. Now, when such an error is signaled by PyTHON, what we would like to do is from within our program, handle it. So we would like to anticipate and take corrective action based on the error type. So we may not want to take the same type of action for every error type. So that's why it's important to know whether it's a name error or an index error or something else. And depending on what the error is, we might take appropriate action for that type of error. And finally, if we do get an error or an exception which we have not explicitly handled, then the Python interpreter has no option but to abort the program. So if we don't handle an exception, if an exception is unhandled, then the execution aborts. So this is done using a new type of block which we haven't seen before, called try. So what we have is try block. So when we have code here in which we anticipate that there may be some error, we put it inside a try, right? So this is our usual block of code where we anticipate that something may go wrong. And now we provide contingencies for all the things that could go wrong depending on the type of error. And this is provided using this accept statement. So it says try this. And if something goes wrong, then go to the appropriate accept one after the other. So the first one says, okay, what happens if an index error occurs? So this is the code that happens if an index error occurs. On the other hand, maybe I could get a name error or a key error for both, of which I do the same thing. So this is the next accept block. So you could have as many accept blocks as you have types of errors which you anticipate errors, for it is not obligatory to handle every kind of error, only those which you anticipate. And of course now you might want to do something in general for all errors that you don't anticipate. So you can have a pure accept block. So a kind of a naked accept block in which you don't specify the type of error and by default, such an accept statement would catch all other exceptions. So the important thing to remember is that this happens in sequence. So if I have three errors, for example, if I have an index error and a name error and a zero division error, then what will happen is that it will first go here and find that there is an index error, and so this code will execute. So the name error code will not execute. On the other hand, if I had only a name error, and if I had a zero division error, for example, then because there is a name error first, so it'll come here and you'll find that there's no index error, then it'll come here and say there is a name error and it'll execute this code. So the zero division error will not be explicitly handled, the program will not abort, but there will be no code executed for the zero division error. It's not that it tries each one of these in turn, it'll try whichever except matches the error, and it'll skip the rest. So finally, if I had only a zero division error in this particular example, then since it's not an index error and it's not a name error, it would try to go through these in turn. So it would come here, find this is not the type of error, this is not the type of error, and it'll go to the default accept statement and catch all other exceptions. So finally, Python offers us a very useful alternative clause called else. So this else is in the same spirit as the else associated with a for or a while. Remember that a for or a while that does not break, that terminates normally, then executes the else. If there is a break, the else is skipped. In the same way, if the try executes normally, that is, there is no error which is found, then the else will execute. Otherwise the else is skipped. Right? So we have an else block which will execute if the try terminates normally with no errors. So this is the overall structure of how we handle exceptions. We put the code that we want inside a try block. Then we have a sequence of accept blocks which catch different types of exceptions. We can catch more than one type of exception by putting a sequence in a tuple of exceptions. We can have a default accept with no name associated with it to catch all other exceptions which are not handled. And finally, we have an else which will execute if the try terminates normally. Now, while we normally use exception handling to deal with errors which we don't anticipate, we can actually use it to change our style of programming. So let's look at a typical example we saw recently that we can use dictionaries in Python. So dictionaries associate values with keys. Here we have two keys, Dhavan and Kohli. And with each key, which is a name, we have a list of scores. So this scores is a dictionary whose keys are strings and whose values are lists of numbers. Now, suppose we want to add a score to this. So the score is associated with a particular batsman B. So we have a score s for a batsman B, and we want to update this dictionary. Now, there are two situations. One is that we already have an entry for b in the dictionary, in which case we want to append s to the existing list scores of b. The other situation is that this is a new batsman. There is no key for b, in which case we have to create a key by setting scores of b equal to the list containing s. Right? So we have two alternative modes of operation. It is an error to try and append to a nonexistent key, but if there is an existing key, we don't want to lose it by reassigning s, so we want to append it. So we want to distinguish these two cases. So a standard way to do this using what we have already seen, is to use the command the statement in to check whether the value b already occurs as a key in scores. So we say if b is in the score keys. If we have b as an existing key, then we append the score. Otherwise we create a new entry. So this is fine. Now, we can actually do this using exception handling as follows. We try to append it. We assume by default that the b batsman b already exists as a key in this dictionary. Scores. And we try scores b append s. What would happen if b is not there? Well, Python will signal an error saying that this is an invalid key and that is called a key error. So we can then revert to this accept statement and say, oh, if there is a key error when I try to append s to scores of b, then create an entry scores of b equal to s. So this is just a different style. It's not saying that one is better than the other, but it's just emphasizing that once we have exception handling under our control, we may be able to do things differently from what we are used to. And sometimes these may be more clear. It's a matter of style. You might prefer the left or the right, but both are valid pieces of python code. So let's examine what actually happens when we hit an error. So suppose we start executing something and we have a function call to a function f with parameters y and z. This will go and look up a definition for the function, and inside the definition, perhaps. So this call results in executing this code. And this definition might have yet another function called in it called g. So this will in turn transfer us to a new definition. Sorry, this should be on the same line, g. And this might in turn have another function h. And finally, when we go to h, perhaps this is where the problem happens. So somewhere inside h, perhaps there is an index error. And where we used this list, for example, in h, we did not put it in a try block, and so the error is not handled. So what happens, we said, is when an error is not handled, the program aborts, but the program does not directly abort. This function will abort, and it will transfer the error back to whatever called it. So what will happen here is that this index error will go back to the point where h was invoked in g. So now it's as though g has generated an index error. Okay, calling h has generated an index error. So the index error is actually now within g, because h did not do anything with that error, it just passed it back with the error. So now we have two options. Either g has a try block, but if g doesn't have a try block, then this error will cause g to abort. So what will happen next is that if g doesn't handle it, then this will go back to where g was called in f. And likewise, if now f doesn't handle it, then it will go back to where f was called in the main program. So we keep back, going back across the sequence of function calls, passing back the error. If we don't handle it in the function where we are right now, the error goes back. This function aborts. It goes back, and finally, when it reaches the main thread of control, the first function, or the first Python code that we are executing there. If we don't handle it, then definitely the overall Python program aborts. So it's not as though the very first time you find an error which is not handled abort, it'll merely pass control back to where it was called from and across the sequence of calls. Hierarchically, we can catch it at any point, so we don't have to catch the error at the point where it's handled. We can catch it higher up from the point that is calling us. To summarize, exception handling allows us to gracefully deal with runtime errors. So Python, when it flags an error, tells us the type of error and some diagnostic information. So using a try and accept block, we can check the type of error and take appropriate action based on the type we also saw with that inserting a value into a dictionary example that we can exploit exception handling to develop new styles of programming. And finally, what we will see is that as we go ahead and we start dealing with input, output, and files, exceptions will be rather more common. As we saw earlier, one of the examples we mentioned was a file is not found or a disk is full. So input and output inherently involves a lot of interaction with outside things, outside the program, and hence is much more prone to errors, and therefore it's useful to be able to have this mechanism within our bag of tricks. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
exception handling.mp3,"You. So let's see what to do when things go wrong with our programs. Now there are many different kinds of things that can go wrong. For instance, we might have an expression like x divided by z, and z has a value zero, so this expression value can't be computed. Or we might be trying to convert something from a string to an integer, but the string s is not a valid representation of an integer. We could also be trying to compute an expression using a name whose value has not been defined. Or we could try to index a position in a list which does not exist. As we go forward, we will be looking at how to read and write from files on the disk. So we may be trying to read from a file, but perhaps there is no such file. Or we may be trying to write to a file, but the disk is actually full. So there are many situations in which while our program is running, we might encounter an error. So some of these errors can be anticipated, whereas others are unexpected. So if we can anticipate an error, we would prefer to think of it not as an error, but as an exception. So think of the word exceptional. So we encounter a normal situation the way we would like our program to run. And then occasionally we might encounter an exceptional situation where something wrong happens. And what we would like to do is provide a plan on how to deal with this exceptional situation. And this is called exception handling. So exception handling asks, when something goes wrong, how do we provide corrective action? Now, the type of corrective action could depend on what type of error it is. If, for instance, we are trying to read a file and the file does not exist, perhaps we had asked the user to type a file name so we could display a message and ask the user to retype the file name saying the file asked for doesn't exist. On the other hand, if a list is being indexed out of bounds, there is probably an error in our program, and we might want to print out this value, the value of the index, to try and diagnose what's going wrong with our program. So sometimes the error handling might just be debugging our error prone program for all this. What we require is a way of capturing these errors within the program as it is running without killing the program. So as we have seen when we have spotted errors while we have been using the interpreter, if an error does happen and we don't trap it in this way, then the program will actually abort and exit. So we want a way to catch the error and deal with it without aborting the program. Now there are many different types of errors, and some of these we have seen. But you may not have noticed the subtlety of these. For example, when we run Python and we type something which is wrong, then we get something called a syntax error, and the message that Python gives us is syntax error, invalid syntax. For example, supposing we try to create a list, and by mistake we use a semicolon instead of a comma. Then immediately Python points to that semicolon and says, this is a syntax error. It's invalid Python syntax. Of course, if we have invalid syntax, that means the program is not going to run at all, and there's not much we can do. So what we are really interested in is errors that happen in valid programs. So the program is syntactically correct. It is something that the Python interpreter can execute. But while the code is being executed, some error happens. So these are what are called runtime errors. These are errors that happen while the program is running. And here again, we have seen these errors, and they come with some diagnostic information. For instance, if we use a name whose value is undefined, then we get a message from Python that the name is not defined, and we also get a code at the beginning of the line saying this is a name error. So this is Python's way of telling us what type of error it is. Similarly, if we have an arithmetic expression where we end up dividing by a value zero, then we will get something called a zero division error. And finally, if we try to index a list outside its range, then we get something called an index error. So let's look at all these errors, just to be sure that we understand. So supposing we say y is equal to five times x and we haven't defined anything for x, then it gives us an index error, a name error, and it says clearly that the name x is not defined. On the other hand, if we say y is equal to five divided by zero, then we get a zero division error, and along with a message division by zero. And finally, if we have a list, say one, two, and then we ask for the position three, then it'll say that there is no position three in this list. So this is an index error. So these are three examples of the types of error that the python interpreter tells us. And notice that there is an error name at the beginning, index error name error zero division error, plus a diagnostic explanation after that. So let us first quickly settle on some terminology. So USually the act of signaling an error is called raising an exception. So when the PYtHON interpreter detects an error. It gives us information about this error. And as we saw, it comes in two parts. There is the type of the error, what kind of error it is. So it is a name error, or an index error, or a zero division error. And secondly, there is some diagnostic information telling us where this error occurs. So it's not enough to just tell us, oh, some VaLue was not defined. It tells us SPECIfICALlY the NAme x is not defined. So this gives us SOme Hint as to where the error Might be. Now, when such an error is signaled by PyTHON, what we would like to do is from within our program, handle it. So we would like to anticipate and take corrective action based on the error type. So we may not want to take the same type of action for every error type. So that's why it's important to know whether it's a name error or an index error or something else. And depending on what the error is, we might take appropriate action for that type of error. And finally, if we do get an error or an exception which we have not explicitly handled, then the Python interpreter has no option but to abort the program. So if we don't handle an exception, if an exception is unhandled, then the execution aborts. So this is done using a new type of block which we haven't seen before, called try. So what we have is try block. So when we have code here in which we anticipate that there may be some error, we put it inside a try, right? So this is our usual block of code where we anticipate that something may go wrong. And now we provide contingencies for all the things that could go wrong depending on the type of error. And this is provided using this accept statement. So it says try this. And if something goes wrong, then go to the appropriate accept one after the other. So the first one says, okay, what happens if an index error occurs? So this is the code that happens if an index error occurs. On the other hand, maybe I could get a name error or a key error for both, of which I do the same thing. So this is the next accept block. So you could have as many accept blocks as you have types of errors which you anticipate errors, for it is not obligatory to handle every kind of error, only those which you anticipate. And of course now you might want to do something in general for all errors that you don't anticipate. So you can have a pure accept block. So a kind of a naked accept block in which you don't specify the type of error and by default, such an accept statement would catch all other exceptions. So the important thing to remember is that this happens in sequence. So if I have three errors, for example, if I have an index error and a name error and a zero division error, then what will happen is that it will first go here and find that there is an index error, and so this code will execute. So the name error code will not execute. On the other hand, if I had only a name error, and if I had a zero division error, for example, then because there is a name error first, so it'll come here and you'll find that there's no index error, then it'll come here and say there is a name error and it'll execute this code. So the zero division error will not be explicitly handled, the program will not abort, but there will be no code executed for the zero division error. It's not that it tries each one of these in turn, it'll try whichever except matches the error, and it'll skip the rest. So finally, if I had only a zero division error in this particular example, then since it's not an index error and it's not a name error, it would try to go through these in turn. So it would come here, find this is not the type of error, this is not the type of error, and it'll go to the default accept statement and catch all other exceptions. So finally, Python offers us a very useful alternative clause called else. So this else is in the same spirit as the else associated with a for or a while. Remember that a for or a while that does not break, that terminates normally, then executes the else. If there is a break, the else is skipped. In the same way, if the try executes normally, that is, there is no error which is found, then the else will execute. Otherwise the else is skipped. Right? So we have an else block which will execute if the try terminates normally with no errors. So this is the overall structure of how we handle exceptions. We put the code that we want inside a try block. Then we have a sequence of accept blocks which catch different types of exceptions. We can catch more than one type of exception by putting a sequence in a tuple of exceptions. We can have a default accept with no name associated with it to catch all other exceptions which are not handled. And finally, we have an else which will execute if the try terminates normally. Now, while we normally use exception handling to deal with errors which we don't anticipate, we can actually use it to change our style of programming. So let's look at a typical example we saw recently that we can use dictionaries in Python. So dictionaries associate values with keys. Here we have two keys, Dhavan and Kohli. And with each key, which is a name, we have a list of scores. So this scores is a dictionary whose keys are strings and whose values are lists of numbers. Now, suppose we want to add a score to this. So the score is associated with a particular batsman B. So we have a score s for a batsman B, and we want to update this dictionary. Now, there are two situations. One is that we already have an entry for b in the dictionary, in which case we want to append s to the existing list scores of b. The other situation is that this is a new batsman. There is no key for b, in which case we have to create a key by setting scores of b equal to the list containing s. Right? So we have two alternative modes of operation. It is an error to try and append to a nonexistent key, but if there is an existing key, we don't want to lose it by reassigning s, so we want to append it. So we want to distinguish these two cases. So a standard way to do this using what we have already seen, is to use the command the statement in to check whether the value b already occurs as a key in scores. So we say if b is in the score keys. If we have b as an existing key, then we append the score. Otherwise we create a new entry. So this is fine. Now, we can actually do this using exception handling as follows. We try to append it. We assume by default that the b batsman b already exists as a key in this dictionary. Scores. And we try scores b append s. What would happen if b is not there? Well, Python will signal an error saying that this is an invalid key and that is called a key error. So we can then revert to this accept statement and say, oh, if there is a key error when I try to append s to scores of b, then create an entry scores of b equal to s. So this is just a different style. It's not saying that one is better than the other, but it's just emphasizing that once we have exception handling under our control, we may be able to do things differently from what we are used to. And sometimes these may be more clear. It's a matter of style. You might prefer the left or the right, but both are valid pieces of python code. So let's examine what actually happens when we hit an error. So suppose we start executing something and we have a function call to a function f with parameters y and z. This will go and look up a definition for the function, and inside the definition, perhaps. So this call results in executing this code. And this definition might have yet another function called in it called g. So this will in turn transfer us to a new definition. Sorry, this should be on the same line, g. And this might in turn have another function h. And finally, when we go to h, perhaps this is where the problem happens. So somewhere inside h, perhaps there is an index error. And where we used this list, for example, in h, we did not put it in a try block, and so the error is not handled. So what happens, we said, is when an error is not handled, the program aborts, but the program does not directly abort. This function will abort, and it will transfer the error back to whatever called it. So what will happen here is that this index error will go back to the point where h was invoked in g. So now it's as though g has generated an index error. Okay, calling h has generated an index error. So the index error is actually now within g, because h did not do anything with that error, it just passed it back with the error. So now we have two options. Either g has a try block, but if g doesn't have a try block, then this error will cause g to abort. So what will happen next is that if g doesn't handle it, then this will go back to where g was called in f. And likewise, if now f doesn't handle it, then it will go back to where f was called in the main program. So we keep back, going back across the sequence of function calls, passing back the error. If we don't handle it in the function where we are right now, the error goes back. This function aborts. It goes back, and finally, when it reaches the main thread of control, the first function, or the first Python code that we are executing there. If we don't handle it, then definitely the overall Python program aborts. So it's not as though the very first time you find an error which is not handled abort, it'll merely pass control back to where it was called from and across the sequence of calls. Hierarchically, we can catch it at any point, so we don't have to catch the error at the point where it's handled. We can catch it higher up from the point that is calling us. To summarize, exception handling allows us to gracefully deal with runtime errors. So Python, when it flags an error, tells us the type of error and some diagnostic information. So using a try and accept block, we can check the type of error and take appropriate action based on the type we also saw with that inserting a value into a dictionary example that we can exploit exception handling to develop new styles of programming. And finally, what we will see is that as we go ahead and we start dealing with input, output, and files, exceptions will be rather more common. As we saw earlier, one of the examples we mentioned was a file is not found or a disk is full. So input and output inherently involves a lot of interaction with outside things, outside the program, and hence is much more prone to errors, and therefore it's useful to be able to have this mechanism within our bag of tricks. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Flow Chart and Pseudocode.mp3,"In the last lecture, we had concluded with a term called algorithm you. And we said that an algorithm means a sequence of steps that are followed to solve a problem. To be followed to solve a problem. Now, the question is that how do we express an algorithm? How do we express the sequence of steps? How do we express that? There can be different ways of expressing it. Right? So usually, ultimately, we'll have to write a program for this. Ultimately, we'll have to write a program for this. So obviously, program is the final form of expression of the sequence of steps that we want to reach to. But even before that, a program is for communicating the sequence of steps to a computer. But even for our human exchange, we may like to express what are the steps to be followed? There are two distinct ways by which an algorithm can be expressed. One is Flowchart. Another is pseudocode. Now, a flowchart, as the name implies, is a diagrammatic representation of the sequence of steps. It's a diagram, all right. And pseudocode, on the other hand, is an English like English, or whatever. In human language, English like, not exactly English. We can take a lot of liberty. You will see how to, when I express the sequence of steps, English like language, to express the sequence of steps. Okay, now we will show both the flowchart and pseudocode with respect to some of the problems that we had discussed earlier. Okay, so let us start with this, finding the average of three numbers. This is the simplest possible way, simplest possible problem that we can solve. So we will start with the first. We will start with the start node. We are trying to draw a flowchart. So once we draw this start, then next will be sum assigned zero. Now what? All of us know that in order to find the average of any number set of numbers, we have to first add those numbers. So the addition result is stated as sum. So here, when there is no number that has been, we have already taken into account, we initialize the sum to be zero. So right now sum is zero. Right. Next, what we do is we read the first number. We read the first number, read number one. Now, what does this read mean? Read means who is reading? Whom do you want to read? Whoever, whoever will be finding the average, he or she will have to read the number. If I ask a human being to do that, the human being will have to know the number. So if I show that number on a piece of paper, writing five, he will read that number five and will say, okay, so five is the first number. Then I show the second number, seven. Okay, seven is the second number in that way, that is the significance, that is the meaning of this read. Now, in our case, ultimately the computer will read it. And earlier we had talked about the input, and often we had discussed about this. This is also known as an input mechanism. So it is reading the number. Now, here I would like to state a few things. That is, say, flowchart has got some basic fundamental elements. This one you have already seen, that is a start symbol. Okay? Now, this figure is known as oblong. This figure is a rectangle. Now, this oblong is actually used for input and output specification. Wherever I need to do some input or the system provides me some output. Let me explain this. So, input, I have already explained that when I am writing some number for you to read or for anybody who will do the computation to read, that is the input. And you know, all of you, that we have got some input devices. The most standard input device is the keyboard, using which we can put in the data. The output is, after the computation is done, the system will, or system will give me the output. Or if it be a human being who is doing the computation, he or she will be telling me the output, that this is the result. So that is known as output. So while drawing the flowchart, sometimes we'll write, read for this input and maybe print or write print or write for output. Okay? Now, this diagram is essentially the computation box. So whenever we do some computation that we show in this sort of a box, for example, we can say x is p multiplied by q, something like this. The other very important block is the decision blocks block, which looks like this, a diamond. Now, here what we do, we just take decisions depending on some conditions. Depending on some conditions, I'll either take the left path or the right path. Okay? So, for example, I can say whether the age of a boy is greater than 14. If the age of the boy is not greater than 14, he is not allowed to go to a film. Okay? So if it be no, then he cannot go to see a particular film. And if it be 14 or greater, that means it is greater than 14. If it is yes, then he can go to a film. So we come to this particular point and make a decision looking at this sort of scenario. So this is known as the decision box. Now, these are the basic four elements of any flowchart. All right? So now we will again come back to our flowchart. So you can see here that sum is zero, and the number that has been read is the first number. Right? Now suppose that number that was read, the number that was read is five. Suppose the number that I read is five. So, sum number. So next, what I do is I add that particular number with the sum. So now, the sum was initially zero. So I add five with sum. So it becomes the total. Sum becomes five. Right? Sum becomes five. So next, what should I do? After I computed the sum. Then I read the second number. Because I have to read three numbers and find the average. I read the second number, and then I add the second number with the sum. The first number was five. So the value of sum is now five. Okay? Value of sum is now five. I've read the second number. Suppose that was eight. Then the sum becomes eight plus five. That is 13. Now I come and read the third number. Suppose it is three. All right? So I read the third number. And then I compute the sum. So I have computed the sum to be 13 plus 316. Next, what do I do? I have to compute the average. So, what I do, I find the avg is by avg, I am depicting the average. Average is sum divided by three. Okay, so it was. What was it? 13 plus 316 divided by three. So it will be five point something. So that result. Whatever. I get that. I'll be printing. So that's a flowchart. These are the steps that I have to do. Okay? Now, the same thing. The same thing I can express in the form of a pseudocode or English like language. Let us see how it looks like here. You just see what I have done. I have initialized what I wrote in the first step is. This one is equivalent to this. All right. Initialize the sum to zero. And then I read the first number. Sum is added. Sum equals sum plus number one. Exactly what I did here. Read the second number. Then I. Sum equals sum plus number two. And then I read the third number. And then sum is sum plus number three. So these are the steps, you see. Exactly. If you just don't look at the left part of the whole thing. If you just look at this right part. You can also understand what are the steps through which I must go. Okay? And so, ultimately, I compute the average, which is. I just write. So it's English like, compute avg. Equal. So it's not exactly English. It's English like anybody who knows English will be able to understand this. So this is known as the pseudocode. So this is for the very simple problem that we are doing now. Suppose. Let's think of for a second that. Suppose instead of three numbers. I asked you to find the average of ten numbers. How would the flowchart look like, obviously, this same thing that I have done here. Read number three, read number four, read number five, read number six. In that way it will go on and on and on. Okay, had it been 100 numbers, then it'd be even larger. Okay. Now, can we do something better in order to. I don't have so much paper to west, so can I write it? Can I express it in a much better way? So let us go to the next problem where we want to find the average of n numbers. Average of n numbers. I want to find out. So the first thing will be again, start, that is, from where I am starting. Next is read the value of n. So what is this value of n? Now, if I say this value of n when I read what is this n, this n is telling me how many numbers I'll be considering for finding the average. Is it 100, is it thousand, is it ten? Whatever. So that is n. So, I am reading the value of n. Okay, now I am initializing the sum to zero again, just as before, I initialize the sum to zero and then I read. Now, you see here I have written, read number. I have not written read number one earlier, since I had to only do number one, two and three here. There I wrote down number one, number two, number three. Here I am just writing read number. Okay, because I do not know how many numbers I'll be reading. The reason will be very clear soon. So next, what do I do? I read the number. Then sum is sum plus number. So I take the sum was zero. I take the sum and add that number. Which number? The number that I just now read. Say, I have just now read number five. Okay, I have read just now. I'm sorry. I just read number five. So I read number five. And I have added that number with sum. So sum is now five. Okay, next, I decrement. This is a new thing that is coming up here. Since I know here at this point, the user or whoever supplied the data told me that you have to look for 100 numbers. Say n is 100. I have learned that. So now here I have read one number and I have taken care of that number because I have added that with sum. And so therefore, I now decrement that value of n. What does this signify? This signifies that now, since initially it was 100, I have to read 99 more numbers. 99 are yet to go. Right now I have to check, have I read all the numbers? What is the value of n? The value of n is 99. That means n is not zero. That means I have not been able to read all the numbers. If I have, since in a decision box, as I have told you just a couple of minutes earlier, that I can have two options, I can either have yes or no answer. If n is equal to zero, what does that signify? If n is equal to zero, that signifies that I have read all the numbers. I've already read all the numbers. Then I compute. Then I can compute the average as sum, whatever sum I got divided by n. Otherwise, if n is not equal to zero, then let's look at here. If n is not equal to zero, no. Then I'll go back here again. Look at this part. I'll go back here again and read number. I'll read the second number, read the and add it to sum. I'll go over here, decrement. So I've read two numbers. So now how many are yet to go? 98. N is zero. No, n is not zero. Okay, n is not zero. So I go up again. I read another number, add that particular number to the sum decrement. Ten. How many to go? 97. Is it zero? No, not yet. Zero. So I go on in this way. I'll go on in this way. Ultimately, after I have read the hundredth number, this n will become zero. So at that point, I'll come to this average and compute the average as sum divided by n. And then I'll print the average. And stop. So, see, just by this thing, I'm sorry, just by this thing, which is nothing, but this is called a loop. This is called a loop. And using this looping repetition, I could reduce the length of the flowchart, the repetition of the flowchart, in a very elegant way. I hope it is clear. So the same thing can be also reflected in the flowchart. Now, compared to with the earlier flowchart, earlier statement here, when I read it only for three numbers, I did initialize sum to zero. Read number one, read number two, and at every point I was adding it to sum. Here, what I do is I write it in a little bit flexible way, because when I write in a pseudocode, I am not very constrained. I can take the flexibility. As long as I can express myself, it's good enough. I just wrote get the value of n earlier, probably I wrote, read the value of n means the same thing. So get the value of n. Initialize sum to zero. Until now, here I am talking of this looping till. N is as long as till means as long as n is greater than zero. It will be better to say as long as n is greater than zero. Read a number, add the number, read the number that you have read to sum. You read a number, add the number red to sum. Okay, and one thing I missed out here. And you decrement n. You decrement n. Here you have to make n equal to n minus one. In your note, you please take it down that here it will be n n minus one. As long as n is greater than zero. I'll be going on doing this. After that, I'll compute average as average divided by sum. Average is sum divided by n. I'm sorry. And then I'll print the average so I can express it either in the form of a flowchart or in the form of a pseudocode. Okay, now let us take, it's not very visible here. Finding the maximum of three numbers, that was another problem that we had discussed last time. What I'm trying to do is I am trying to find the maximum of three numbers. So how can I go about in doing the flowchart? So I start just three numbers, not a large set of numbers. I first read the number one. Now tell me one thing. When you have first read one number, what is the maximum number? Obviously, since you have read only one number, that itself is the maximum. Only one. So it is a singleton, so it is the maximum. Therefore, I say that max is nothing but the first number. The number that I have read, max, is number one. All right, now I read the second number. Okay, I read the second number. Now, which one is the maximum? If the second number is greater than the first number, then the second number will be the max. Now, when I read the first number, when I read the first number here, I set that to be the max. So now after reading the second number, I can compare the second number with respect to the max. If the second number is greater than the max, if the second number is greater than the max, then what will happen? Then number two will be the max. Okay, if it is yes, then number two becomes the max. And if no, that means what number two is not greater than the max. Then I skip this part. I skip this part and go out, by this way, skipping this part. That means at this point, who is the max? Obviously at this point I had number one and number one is still the max. Okay, I hope it's clear. Next, I read the third number again. I do the same thing. After reading the third number. Is the third number greater than what? Number two? Should I compare? No, I should compare with the max, because till now between number one and number two, whatever is the maximum, I have already remembered that in max. So I read the number three, and then again compare. Is number three greater than max? I can have yes or no. So if it be yes, then number three becomes the max because number three is greater than the maximum number till now. Okay, and then I'll proceed. And if not, if number three is not greater than max, then obviously whatever was the max till now, that is the number one. That will remain the max. Okay, think of number one to be five, number two to be three, and number three to be one. What will happen? Three. So max is three. Sorry, this was five. So I read five. Okay, next I read three. Is five greater than three? No. So I kept five as the maximum. All right, I read number three. That was one. I compared is it greater than the maximum, which was five? No. Then I print that five, which is the maximum. But if suppose number three was seven, so it is greater than five. So then I can go here and update this max to be number three or the seven. And then I come to the print max part. So this is the flowchart of finding the maximum of three numbers. And consequently you can see the pseudocode of this start. Read first number. Then I assign max to be the first number. Then I read the second number. Assign. Now, if number red is greater than max, then I'll make the max to be number two. Okay, if the number, read. If it's badly written, read number. It is wrong. If number two is greater than max, then make max number two. All right? Then read number three. If number three is greater than max, then make max number three, otherwise you are continuing. So if number two is not greater than max then I'm reading number three. I'm not doing this part. Okay. This is another way of explaining the pseudocode. So the same thing. Now we come to another variety of this. Finding the maximum for n positive integer. N positive integers. Here I have taken a little liberty finding the maximum of n positive integers. Earlier, I was doing it for all numbers, but just as a change. So let's see, I read n again. N means the number of numbers that I want to read. Now, I set max to zero. Why do I set max to zero? Because I am trying to find the max of n positive integers. So any positive integer will be greater than or equal greater than zero. So I am putting that max to the minimum value possible. And then I'm reading a number. I read a number, and if that number is greater than max, if that number is greater than max, which is by default, zero, I've kept it at the bottom most possibility, right? Unless that number is zero, it will always be greater. So I'll set that number to be the max. Next again, you remember what I did for finding the average? I reduce the value of n. Suppose I had to do find the max of ten numbers, so n becomes now nine. And then I check. All right, I, if the max, sorry, this is mistake here. This arrow, this arrow should come from this point. This arrow should come from this point. So I'm just drawing it here. I'm drawing it here. It should come like this. So I have read a particular number, and then if that number, if that particular number is greater than max, I'm sorry, I read a number, and if that number is greater than max, number is greater than max, then if it is true, then I'll make that number to be the max. Right? Max will be that particular number. And then I check n. I have already read n, so is n zero. Then I've read one number, and then I reduce n just as I did in the earlier case, and then I check n greater than zero. If yes, then I have to go back. I have to go back and again, read a number. Right, read num. And this will go on as long as n is greater than zero. If n is greater than, is not greater than zero. No. Then I'll come and print the max. Right, so there was a little error in that diagram, which you will be. So you can see that this line should have come from here. Here is n zero? Yes. Then print max. Otherwise this should have come from this point. All right, this should have come from this point. This is wrong. Okay, so in this way, we can again find the max for n numbers. It's a flowchart. So again, I can have the pseudocode for this. So the pseudocode for this is shown here. Read the value of n. Here. Initialize max to zero till. Until n is zero. Read the number. If number is greater than max, max is equal to number decrement. N is n minus one, and then it will be not one. Here it will be. Again, print the max. So in that way, you have seen examples of some intermediate representation of the sequence of steps or the algorithms. We'll encounter a number of algorithms in the course of these lectures. And at the next point, next step, we'll see what is to be done in order that this sequence of steps can be converted, can be transferred to a computer width so that can be transferred to a computer so that the computer can solve the problem that we'll see in the next part. Bye.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
For Statement (Contd.).mp3,"Now we are discussing about formation of loops, creation of loops in a program using for statement. Before that, we have seen the while statement and do while statement. And then we have seen the for statement as well. Now the for statement, as we had shown we had discussed in the last class, it is basically starting to check an expression, arithmetic expression. And then it starts with, sorry, initialization expression. And then we check a particular condition. So something like this, for some variable, integer variable, j assigned some value, five maybe, and then some expression. Here, this one is j less than equal to 25. And then here there will be some statements which will be executed. And after that, there is a third expression which is altering it, and that can be j assigned j plus five. All right, and the body of the loop. This is a structure that we had seen. So now there are some critical issues that are to be noted for the force structure. So, if you look at this, you can see that we are using arithmetic expressions. For example, x assigned two and y assigned ten. That's an arithmetic expression. So similarly, this is a valid arithmetic expression for j assigned x, j less than equal to four times x times y. That is the condition that means after some computation, we'll have to find out whether j is satisfying this condition. And here, j here, probably this is something, this construct we have not shown you. I don't like it very much. And initially you did not bother about this. J plus equal to y by x. This is a c structure, c syntax expressing j equals j plus y by x. So the whole thing can be written in this way. Okay? But that is not important for the purpose of understanding for expressions. So here is just an expression, and this is equivalent to like this. For, say, x was two and y was ten. Then this is equivalent to j assigned two, because j assigned x and j assigned two are essentially same. J as less than equal to four times x times y. That means four times two times ten, that means 80, and j equals assigned j plus y by x is five. So this is equivalent. All right, so this is initialization, and this is loop continuation condition. And this is the increment, or I, as I was saying, that this is a modulator or the alteration. Okay, now, increment can be negative. So this increment, although we are calling it increment, that's why we should not call it increment. Let's call it a modulator, because, say the same thing I can write as for j assigned to maybe something j less than equal to eight t and might be j minus minus. It can be the case when can it be? Say, for example, if I add, if I want, that, I'll be printing the numbers in the reverse order starting from ten. Okay, so what should I do? So can I do this? What I want to do is that I want to print something like ten, 9875. All right? In this order. So, simply, I can do this repeatedly in a loop. For example, for j assigned ten and j, sorry, j greater than equal to five. J minus minus. And here, I just do printf percentage. D backslash n j. So what will happen? Initially, j is ten greater than equal to five. So ten will be printed. Then I go back, I decrement j. So j will become nine, still greater than equal to five. I come in here, print j nine, I again decrement j. Decrement j becomes eight. I compare with this, still it is greater than equal to five. I get in and print it. In that way, I can do it. I can repeatedly do the same thing. But here, as you can see, I am being able to achieve this reverse order by, instead of incrementing, I'm decrementing this index. That's why I can increment, decrement. I can multiply it, I change it, I modulate it. That's why this to be an alteration expression or modulation. Expression is a better term than increment or decrement. Okay, so if the loop continuation condition is initially false, is initially false, then the force structure will not be executed. It will proceed with the statement for the next statement. So, for example, if I write something like this, as you have seen earlier, j equal to 20. And for I equals, I assigned one, I greater than j, I plus plus, say. And then I want to do some things here. All right. Now, j is 20. I'll first initialize I to one. And immediately I find the first thing that I do is it's false. I check this, and it's false. I is not greater than j. Therefore, these statements will not be executed even once. And the statements following the for loop will be executed. Okay, so now here are some examples of for loops. This is again, computing the factorial factorial is the variable. Fact is, storing the factorial factorial, all of you know, is factorial. N is n multiplied by n minus one, multiplied by n minus two, so and so forth up to one. So it's one. And I have got a variable. I. Now, you can see simply I can do it like this. I assigned one, I less than ten. I plus plus fact assigned fact times I. Now what is happening here? So I have got fact to be one, so I equals one. Then with that, what I do is one times one is fine, and I then make I to be two, and then I, so I becomes then two. So one times two, then I becomes three, then one times two times three, then I becomes four, then one times two times four times three times four, and so on and so forth. It will go on in this loop. Okay, so that is a nice way of writing factorial. And here is another example. You can see what it does quickly. You can explain it yourself. What it does. Sum is zero and n is a variable, and count is another integer variable. All right. Sum is zero. N is one variable, and count is another integer variable. Now we are reading n, and for I equals one, I less than equal to n, I am adding sum. So what is being done here? What will happen if I trace this program? What is going to happen? Let us do that. Suppose I have read n to be here. I have read n to be five. Now what am I doing here? I here, there is one problem here. I should have been declared. There's a mistake here int n. And here I also add, I. I should have been declared here. Now, I assigned one, so I is one, n was five, I less than five, less than equal to five. So sum is sum was zero, so sum is zero plus I times I, I was one, so zero plus one square. And then I check I increment I, so I becomes two, I becomes two, and I check that I is less than, not less than is still less than equal to five. So I got this sum, and with that I add, now I square, I times I, so two square. Similarly, it will go on, it will do three square, so I'll become then four, and then still it is less than equal to so four square. Then I will become five, and still it is true. So it will be five square, then I become six. This condition will be violated and I'll come to this printf. So what will sum be? Sum is one square plus two square plus three square. And if I make it n, then up to n square. So this is the very well known series, the sum of the square of natural numbers. We can compute by this small program using for loop. Right? So it is a nice example. Now we introduce the comma operator, as we said that here for when we write for, then I assigned one. Instead of that, I can put in more than one statements here using a comma operator. For example, for fact, one, I equals one, I less than equal to ten. Now, this part is what? This part is the initialization okay, now remember that this will not be continuously initialized. This is just a statement that I put here, an assignment statement. But my index variable for the control variable for the loop is I. So I could have written this earlier example of factorial, maybe earlier example of factorial. This could be initialized here also. All right, so that is just saving space, saving the number of lines of code. But personally, I'd suggest, as I did earlier, also, that for those of you who are beginners in programming, you should not try these tricks or should not try this thriftiness, reducing the number of lines. That is not so important, how much you can reduce. The most important thing is to be logically and syntactically correct while you write a program. Okay? So we can give several things in comma, like sum here again, so the program becomes even smaller, looks smarter. But sometimes at the beginning, if you try to do that, you try to be smart, and in the process, you may result in some wrong program, wrong logic. Better avoid that. Now, infinite loop, in general, what is an infinite loop? When a program continues? Program continues in a loop repeatedly. It goes on, and it's never completing. It's going on because the condition that is supposed to turn out to be false at a particular point of time so that it comes out of the loop never happens. All right, that can always happen. That, say, if I write something, like for I equals one, I less than n and whatever, I plus plus. Now, every time inside the loop, when you get in, you do something and then increment I, and when you come inside the loop, you do I minus minus say, then whatever has been done here will be cancelled out here, so this loop will never reach this condition, I less than n less than n. Therefore, that this loop will continue forever. Such situations are known as the condition of infinite loop. Now, sometimes, usually we do not like that, but sometimes it may be necessary to specify that something will happen forever. All right, say some particular work has to be done continuously. Now, in order to specify that for loop provides us some facility, like, say, for and while everything, say this one we had discussed earlier, while one that means always, it is true, it's nonzero. This while loop, this expression part, condition, expression part, should return nonzero, and so it will go on. Now, here, four, and I put null, okay? That means the four has had three parts for the initialization part, some condition part, and some incrementation, decrementation part, whatever. Now, I just keep everything blank, so I turn it to be for nothing and nothing. All these things are blank. In that case, what will happen in that case, what will happen if I keep some statements here that will go on forever. Okay. Similarly, in the case of do while, if I just put while one that is Again infinite loop. So by this I can express my desire that some things should continue forever. All right, so this is another trick that you can utilize in some cases for the for and the while constructs. Now we come to another statement which we have encountered a little few lectures earlier in the context of switch statements. While we are considering the switch statements, if you recall, you have seen that after every case statement switch on a particular variable, then they're case red, case green, case blue, if you recall, then we did something and then give a break. Did something give a break. Like that we proceeded, right? So the break statement, of course we know can help us. We can use it with several things. One is while, do while for, and switch. Now this switch switch part we have seen, but we can also use it for while, do while, and for breaking out of the loop. We want to break out of the loop. Sometimes that is required. It works with while, do while for, but does not work with if and else statements. Okay? It causes immediate exit from a while for or do while or case. We have seen that switch statements earlier, so the program continues after with the next statement. Let's see, why do we want to use it? It helps us to escape early from a loop. Sometimes we want to escape early. I don't want to go till the end of the loop. When a particular condition is met, I want to come out. I'm doing it in a loop, but waiting for some condition to take place. As soon as that condition takes place, I come out of the loop. Okay, maybe as we have seen in the case statement, switch some expression. All right, color then case r we do something and then give break, right? Case g, we do something and then give break, right. We do like that. So we skip the remaining part of the switch block, right? We come out of that. So similarly, we'll see a couple of examples of this. Say here there is a complete example. Let's look at that. Here's a complete example. Complete program once again include stdio h. You are running some programs main then fact and I are integers. Fact we are computing factorial, so fact is one, I is one while I is less than ten. That means I want to break out while I is less than ten. Fact times I. If fact is greater than 100, then factorial is above 100. Factorial of a number is above 100. So for example, I am going on up to ten numbers. So what will happen with the factorials? Let's see. So factorial one will be one. Factorial two will be two. Factorial three will be three times two, that is six. Factorial four will be four times three, four times six, it will be four times three times two. So four times six, that means 24. Then 24 times five. So that will be how much it will be more than how much will it be if I have got this? Four, three, two, and multiply that with five. So, 2060. So here, just with five numbers, I am exceeding the value 120. But I do not know when I am going to reach the value 100. So, I've written the program in this way, fact. While I is less than ten, I'll test it up to ten numbers. Every time I compute fact. If fact is greater than 100, print. So here, as soon as fact becomes 100, we'll say factorial of five is above 100, factorial of five is above 100, and then I break out. Otherwise, if I had not put this break, then this would have continued till this loop. All for all the ten numbers up to factorial ten. But I just want to stop whenever my result becomes more than 100. So this is one way we can utilize break, right? Similarly, there is another statement. Although we don't use it often, it's better to know that sometimes it can come handy. That's a continue statement. That means the remaining part of the body of a loop we will skip if I put a continue. All right, so let's see. And it proceeds with the next iteration of the loop. So what happens is, let's look at one example here. So while one, that means what that means, it is always true. It will continually go on doing it. So fact is fact times I, I plus, plus. So I start with I one, then two, then three. If I is less than ten, I'll go into the loop. Otherwise I'll break. So this continue is basically remain, forcing me to go back to this point. By forsaking this part, I am not coming to the remaining of the loop. But if this condition is not holding, then I'll not execute continue. I'll straightaway come here and do break. I think it will need a couple of moments for you to just realize what is happening here. All right, so just look at this. So in this way, it will. I think you can understand it. So I have got I to be one. So fact will be one times one, then I becomes two, and then I go back. So it will be fact will be one times one. Times two, I will be three. And in that we will go on. But it will go on as long as I is less than ten. Then I'll not come to break. I'll go back here. But if I is less than ten, I'll come to break and I'll come out of the loop. Okay, so it's a combination of continue and break. But what I want is that you should understand how the for loop is used for repetition. That is very important to understand. And we'll carry out with some examples in the next lecture.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Function (Contd.).mp3,"So in the earlier lecture we have seen how a function can be invoked and it returns the values, as we had mentioned, that it is not the case that always a function will return a value. Here is an example. You look at this function div seven, which says that means the purpose of this function is to find out whether a particular number that is passed on to it as a parameter or a parameter, whether that is divisible by seven or not. So the program, the code is very simple. What should you do if n is divisible by seven? That means if n modulus seven is equal to zero, then we say printf n is divisible by seven. Otherwise we print n is not divisible by seven. Now in this case, we are just printing from here. Straight. The printout is coming, printing is coming out from here. The main function is only passing on the value reading, scanning, reading some value of n and passing on that value of n here. Or maybe here it is, n is the argument. So might be the main program is reading a value num and passing that value num here. Now this num is also of type integer, and the rest of the things are being done by the function. It is testing whether it is divisible by seven. If it is divisible by seven, it's printing like that. Otherwise it's printing the other message. Now, in this case, putting this return is optional, because even if I did not put the return, when I would have met this parenthesis, this end bracket, it would automatically return to the calling point. However, there is no harm if I put the return. Okay, so returning control. We have seen that how the thing is invoked by parameter passing. Now returning control. If nothing is returned, then we can simply write return semicolon, or we can skip that and until it comes to the right brace, that is last right brace, that is automatically taken as the return. But if something is to be returned, if something is to be returned, then we must put the return statement with, say, maybe return a times b, some expression, or it could be return c, or it could be something like return zero or return one. Whatever, we have to do something, some expression. An expression automatically will also capture the constants. So now let's look at this example. Here. You see, the layout is also important. Here we are first writing the function. This is the function. The function declaration is coming first. Square of x, square of an integer x, and square of an integer. X will also be an integer. Therefore, the type of the function is int, as you can see here. So that is, this whole thing is the function declaration then starts the body of the function. So here the function declaration consists of the name of the function and the parameter that is x of type integer. And this int here is the return data type, the type of the data type that will be returned. So these three together make the function declaration. Next we are coming to the body of the function int y. What is that? That's a temporary variable. Temporary variable? Why I am calling it temporary because it leaves as long as this function is active. As soon as the function is function ends, the role, the definition of this y is also lost. Okay, so here you see, we'll come to that later. But here you see that this is an internal variable. Here I am computing the square y assigned x times x, and I'm returning y. I'm returning y, and after return that y vanishes. Okay, where is y returning to? Wherever the square has been called. Now here you see, here is a sum of square. What is main doing? Now let's come to main. Main has got some variables, a, b, and sum of square is another variable. So printf give a and b. I am reading a and b. Now I am calling this function twice, first with a parameter a, next with a parameter b, and a and b in sequence goes to this argument x. And the square of a is computed. So return y will return first here a square. So we get a square here. Then this is called, and y is returned here. So we get b square, and then these two are added and we get sum of square. All right, and then we are printing the sum of square. So you can also try to see what is a flow of data in such cases. All right, let's move ahead. So these are the parameters passed. And here is the argument. You can see that now invoking a function call here, the same thing. What's happening when the thing that I just now explained, when I am saying, now let's see what happens to the variables. Assume that the value of a that has been read here is ten. All right? Then square of a means square of ten. So ten goes to x, right? So a is ten here. That goes to x. So x becomes ten. Now we compute y, which is ten times ten. I am getting y. Y is becoming 100. Right. Now this hundred is coming here. Actually, the shadow is a little wrong here. So it will be actually coming to this point. Okay, clear. Next. Suppose so. In that case, so similarly, it will be for b if b was some value. That is how then x. Suppose b was seven, then x will get seven, and then y will be 49 and 49 will come to that square of b. So 100 plus 49 will now be added and will be kept as the sum of square. So in the earlier example, you could see that in the earlier example, first the function was written and then the main. Now let's look at. Go ahead. Function definition. So we have seen that a function name preceded by a return value type and declaration statement, and then the function body. I'm repeating certain things. Variables can be declared inside the blocks. The blocks can be nested. That means there can be multiple blocks. Function cannot be defined inside another function. This must be clearly understood. A function cannot be defined within another function. And returning of control, the control will have to be returned. As we have seen, if nothing returned, then return. We have already seen that if something is returned, then return that expression. Here again, another example of function. The more examples you do, the better you will understand. Here, the function as the name implies. You see, it's always better to use meaningful names for functions. Sum of digits of n. So if there be number like 125, then I'm trying to extract this digits. One plus two plus five, so that will be eight. That is what my program wants to do. So initially, sum is equal to zero, while n is not equal to zero. Sum is sum plus remainder. So 125. If I divide by ten, then I'll have twelve here, and remainder is five. So sum plus five, so sum becomes five. Clear. Now then we find out the divide dividend, that is twelve, and again, divide that by ten. We get two to be the remainder. So we take sum to be five plus two, and so on and so forth. Ultimately, I am getting the sum, so return sum. This is another example of a function. Here you can see that this n is coming as a parameter. All this sum sum is an internal variable and will not have life beyond the body of the program. So here you see, sum of digits is a function name, int is a return data type parameter list is that local variable is sum. Sum is a local variable, and return statement is return sum. Clear. All these we have already discussed. This is merely a division. And here you can see that the return can have an expression. Here only a variable is an expression. Now we come to a very important concept which I was mentioning in the passing that the life of an internal variable, internal to a function, exists as long as the function is live, as long as the function is active. Now that formally is known, is called the scope of the variable, or the variable scope. So let us look here. There is an interesting program. Now, here you see my entry point is the main. But even before that, I have declared a variable int a. That means this a is a global variable. That means it is there always. Suppose it is a value hundred. Then it remains, this is retained. So let us keep this and let's see what happens. Now I'm entering main and I have assigned a to one. Okay, now that means, now, inside this function, inside this main, I have got mains a, which is another a. Let me write it in. Is it visible? Let me do it in a better way. So there is one a. I am calling that ag. That is, this a is ag, that is the global a. And suppose that is 100. Now, this is another a, which is defined in the main. So the function this will be live inside main. So let me call it am. All right? So now, a becomes one here as I come here a one. Then I am calling my proc a function, my proc. From here it comes to my proc. And suppose my proc has got another a here. So let me call that to be ax, just for understanding that it is of my proc, or let me call it of the function. Right. So af. Now that is initialized to two. Now you see how many different a's I have. Multiple a's. Now, inside this block, I initialize another a to be three. So that is another a. That means this one is not being disturbed. A is two, and while a is two, I'm making another a, because here I am declaring. You see, this is a pure declaration inte. If I had just written a. If I had just written a assigned three, then this a would be assigned three. But here I have declared another a int a. Therefore, there is another a coming within this while block that I am calling ab, and that is becoming three. Now I am printing a, which a will be printed, the innermost, the current a. That means three will be printed. Then I break. Break means what I come out of the while loop. We have learned break. So we come out of the while loop, and then I print a, which a is. So as soon as I break out of this, this is gone, no longer live. So I am coming here. Now, which a is in my scope. Which a is in my scope. My scope is this. I am within this function. So this a, so that will be printed here. So two, or there was some backstash n. I'm ignoring them that it will come one after another. And then I come out of this, it's over. So I go to this main function, go back, sorry, not here. I'm sorry. It should go back to this point, that means I'll now execute print which a is in my scope. Now, I have come out of this, come out of this function. So its scope is also gone. So the scope of this function main is now live. So what is the value one. So that will be printed. Okay, that's how the things will be printed. So we'll repeat it if necessary. But let's try to see the execution now. So, if I first do it, then this one will be printed a, assigned three. Next, that is gone. So here, this will be assigned a, assigned two. Then I'll go up there, and the a that is in the scope of this function, that will be assigned. And then, so that will be assigned. Okay, you see, although I declared a global a internally, when I declare some other a, this global a, look here, a point has to be seen. I declared a, a global a. Here, a global a was here ag, that was declared here, I have assigned to a, I have not declared another a, I have not written inte, I have simply written a assigned one. That means the a that was there is already existing globally, that has been assigned one. But when I come here and I am declaring int a internally, inside this process, another a is created, which is the a of the function, and that is assigned by two, not this one. There are two distinct entities. Now, again, here I have declared another a. So, since I have declared another a, this is the a of this while loop might be, and that is becoming three. And accordingly, the corresponding, whenever I say print, which one will be printed, which one will be printed will be the one that is within its scope. This a is in the scope of this. So that was printed this and gone. This a was in the scope of this, so printed and gone. And this a is in the scope of this, and this is printed. So this is known as the scope of variables. Okay? So if we summarize functions, you can see this, I don't know how much is visible. So, main function, I am calling a function factorial, and we have already seen that. And then the function is having different, it's a self contained program which has got its definite named function definition, where the type of the argument is also specified. Now, main is a function, and here I am calling a function, I'm actually calling a function by name, calling by name, and here's a return data type repeating that the function name is there, the parameter is there, and the return statement, okay, and the other variables like temp and all those are local variables we have repeated. Now, some point is a function cannot be defined within another function which we have told, but I am repeating it again. All function definitions must be disjoint. That means I cannot define one function within another. Nested function calls are allowed. What is meant by nested function call? Nested function call means nested function call means that suppose here is a main program going on, I call a function. This is function, say f one, and this was my main from some point in the function. In order to solve this problem, f one, I may call another function, f two. This is nesting calling, but not defined. They are defined separately. F one defined separately. F two defined separately. M defined separately. Now from f two, I may call another function, f three, and f three completes. F two has called f three because of some reason. So that reason is answered. I mean, for some value or for some computation that computation has been done. From here it returns to the point from where it was called. So this is a return point. So is it clear or should I use some other color for the return point? Is it necessary? So I'm not getting the color. So let me use the existing color. Whatever was there, where did it go? So from here, now the color has come, so I can show the return. Here I'm returning, but then again I am continuing with this function. And when f two is over, then I again return to f one. So it was called f one, called f two. For some purpose. That purpose is solved. So I return here, and then f one continues again in its whatever it was doing. And f one was called by main for some particular reason. When that purpose is served, then we return to this point, and then main continues, right? And ultimately main ends with this bracket. Now here, this is known as nesting. That means nesting of calls. So I have made a call, and from that call I can make another call. From there I can make another call. But the point to note is that all these functions must be independently and separately defined. They cannot be defined one among the other. Okay, so nested function calls are allowed a calls b. B calls c. As I have shown, m calls f one. F one calls f two. F two calls f three. Like that it can happen. The function call last will be the first to return. Obviously we have seen that in our earlier slide that we go back to the f four. From f four, I return to f two. And like that. And so a function can call also call itself, either directly or in a cycle. We'll see this separately. What is meant by that? A calls b. This can mean two ways. One is that say a calls b. B calls c, c calls back a. That's possible. Like say here, if we see that main was running it called f one, called f one, f one called f two, and then f two can again call f one. And then this call, ultimately for this call, the return has to come here, and ultimately it will have to return here, et cetera. So this part we'll have to see separately. That is, it's a function. One function is calling another, and that can mean a cycle. F one calling f two, f two calling f one. It can happen. Or recursion means, say, a particular function. F one calling itself f one is calling itself a number of times. That requires a special attention and a special discussion that we have to carry out. We'll do that subsequently. But right now just let's remember that this calls can be in a cycle, or it can be called to itself, which is a recursion. Now we have got some math library functions which perform common mathematical calculations, and I do not remember whether in an earlier class I mistakenly said that I don't remember exactly whether I did that or not, that you need to include just as we include math stdio h. Similarly, we have to include math h. Okay, so just as we include stdio h, if we use some mathematical functions which are already available in the c library, we have to include math h. I don't remember whether, while first introducing the square root function, I might be mistakenly, I wrote math lib, that's a library function. So if I had said that, that you should ignore it is math h. Okay, include math h. So here there is an important thing. When I compile, you know, any function that we, any program that we write, we have to compile it in order to get an executable code. Now, in your exercises you must have done by now that typically you compile a C program like this ccmyprog C, right? But if you use some mathematical library in your function, then you should write cc minus lm myproc c. Or that means link to the mathematical library you compile. First you compile. Now you see what's happening is the mathematical libraries are here, say some square root function somebody has written for you, and that is in the C library. All right, maybe some other function like two upper, which converts from lowercase to uppercase. All these things are there. Now, two upper is a separate library, but square root is a math library. So if in your function, if in your program you write, you refer to the square root, some mathematical library, then you must do this. Why? Because purely MyProg C will generate some object code. All right, object code. Now the code for this has to be linked to this has to be linked so that ultimately the full executable code also takes this into account. This code linked to this code will be forming your executable code because the square root you will need anyway at that time of running it, right. So here it has shown minus lm at the later also cc program name and then link with the mathematical library format for calling the functions. Forget about this, let's make it for the time being ignored. This just say percentage f function name. So this is point number one. There are many mathematical library functions. In order to use them, we have to include immediately after stdio h hash include math h and we must use this. Give this linking command. Now when we call the function the function name argument, if multiple arguments, then we can use a comma separated list. Okay, say for example pintf, some format that square root nine. There is only one argument, not much. Arguments may be constant variables or expressions. Okay, now this is important. All math functions all math functions return the data type double. This is important. You should keep in mind for c, all the math functions are returning the data type double. So in order to make it compatible with the variable where you accept the value returned by the math function, that should also be double. Okay, arguments may be constants or variables. So here are some examples of math library function like finding the cos of some angle x. Finding the sine. All these functions are known as a sine a cos, a tan inverse tan arctan ceiling function. Floor function. Floor function means it finds the greatest largest integral value that is less than x. Suppose 200.56. So the largest integral value is 200. That is the floor function. So cos acos is finding the cos of an angle in degree, whereas a cos, I'm sorry, cos is for finding the cosine of angle in radian. Now there is no point in memorizing them as and when you need them. Look at the manual, look at the book, and very soon you will get accustomed to the different library which are available for C. And we'll come back to this in the next lecture about some more very well known functions which you have already encountered with, and then we'll proceed further with recursion. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
function definitions.mp3,"It. So we have seen that we pass values to functions by substituting values for the arguments that define the function. And this is effectively the same as having an implicit assignment. So when we say power x n and we call it values three and five, then we have this assignment x equal to three and n equal to five. It's not really there, but it's as though this code is executed by preceding this assignment there. And of course, the advantage of calling it as a function is that we don't have to specify x and n in the function definition. It comes with a call. So for different values of x and n will execute the same code. So the first thing that Python allows us to do flexibly is to not go by the order. It's not that the first is x and the second is n. If we don't remember the order, but we do know the values or the names assigned to them, we can actually call them by using the name of the argument. So we can even reverse the thing and say call power. I know that x is the bottom value, I know it is x to the power n, but I don't remember whether x comes first or n comes first. So I can say, okay, let's just play safe and say power it n equal to five, x equal to four, and this will correctly associate the value according to the name of the argument and not according to the position. Another nice feature of Python is that it allows some arguments to be left out and implicitly have default values. Recall that we had defined this type conversion function int of s, which will take a string and try to represent it as an integer. If s is a valid representation of an integer. So we said that if we give it the string 76, then int would convert it to the number 76. If, on the other hand, you gave it a string like a five, since a is not a valid number, a five would actually generate an error. Now, it turns out that int is actually not a function of one argument, but two arguments, and the second argument is the base. So we give it a string and convert it to a number in base b. And if we don't provide b, then by default b has value ten. So what is happening in the earlier int converter is that it's as though we are saying int 76 with base ten. But since we don't provide the ten, Python has a mechanism to take the value that is not provided and substitute with the default value ten. Now if we do provide it a value, then, for instance, we can even make sense of a five. If you have base 16. If you have studied base 16 ever in school, you would know that you have the digit zero to nine. But base 16 has numbers up to 15. So the numbers beyond nine are usually written using AbCDef. So a corresponds to what we would think of as the number ten in base ten. So if we write a five in base 16, then this is the 16th position and this is the one position. So we have 16 times ten because a is ten plus five. So in numeric terms this will return 165 correctly. So how does this work in Python? So this would be how internally if you were to write a similar function, you would write it. So you provide the arguments, and for the argument for which you want an optional default argument, you provide the value in the function definition. So what this definition says is that int takes two arguments s and b, and b is assumed to be ten and is hence optional. If the person omits the second argument, then it will automatically take the value ten. Otherwise it will take the value provided by the function call. So the default value is provided in the function definition, and if that parameter is omitted, then the default value is used instead. But one thing to remember is that this default value is something that is supposed to be available when the function is defined. It cannot be something which is calculated when the function is called. So we saw various functions like quicksort and merge sort and binary search, where we were forced to pass along with the array, the starting position and the ending position. Now this is fine for the intermediate calls, but when we want to actually sort a list the first time, we have to always remember to call it with zero and the length of the list. So it would be tempting to say that we define the function as something which takes an initial array, a as the first argument, and then by default takes the left boundary to be zero, which is fine, and the right boundary to be the length of a. Now the problem is that this quantity, the length of a, depends on a itself. So when the function is defined, there will be or may not be a value for a, and whatever value you have chosen for a. If there is one, that length will be taken as a default. It won't be dynamically computed each time you call. So this does not work. So when you have default values, the default value has to be a static value, which can be determined when the definition is read for the first time, not when it is executed. So here is a simple prototype. So suppose we have a function with four arguments, Abcd, and we have c as a default value 14, and d as a default value 22. Then if we have a call with just two arguments, then this will be associated with a and b, and so this will be interpreted as f 1312, and for the missing argument c and d, you get the defaults 14 and 22. On the other hand, you might provide three arguments, in which case a becomes 13, b becomes twelve as before, and c becomes 16, but d is left unspecified, so it pick up the default value. So this is interpreted as f of 1312, 16, and the default value 22. So the thing to keep in mind is that the default values are given by position. There is no way in this function to say that 16 should be given for d and I want the default value for c. You can only drop values by position from the end. So if I have two default values, and if I want to only specify the second of them, it's not possible. I will have to redefine the function to reorder. So therefore you must make sure that when you use these default values, they come at the end and they're identified by position, and you don't mix it up. And don't confuse yourself by combining these things at a random. So the order of the arguments is important. A function definition associates a function body with a name. So it says the name f will be interpreted as a function which takes some arguments and does something. So in many ways Python interprets this like any other assignment of a value to a. So, for instance, this value could be defined in different ways, in multiple ways, in conditional ways. So as you go along, a function can be redefined, or it can be defined in different ways, depending on how the computation proceeds. Here is an example of a conditional definition. You have a condition, if it is true, you define f one way, otherwise you define f another way. So depending on which of these conditions held when this definition was executed later on, the value of f will be different. Now, this is not to say that this is a desirable thing to do, because you might be confused as to what f is doing, but there are situations where you might want to write f in one way or another way, depending on how the computation is proceeding. And Python does allow you to do this, probably at an introductory stage to Python. This is not very useful, but this is useful to know that such a possibility exists, and in particular you can go on and redefine s as you go ahead. Another thing you can do in Python, which may seem a bit strange to you, is you can take an existing function and map it to a new name. We can define a function f which, as we said, associates with the name f the body of this function. At a later stage we can say jg equal to f. And what this means is now that we can also use g of abc, and it'll mean the same as f of abc. So if you use g in a function, it will use exactly the same function as a. It's exactly like assigning one list to another, or one dictionary to another or something. Now, why would you want to do this? So one useful way in which you can do this, use this facility, is to pass a function to another function. So suppose we want to apply a given function f to its argument n times. Then we can write a generic function like this called apply, which takes three arguments. The first is a function, the second is the argument, and the third is the number of times the repetition. So you start with the value that you're provided, and as many times as you're asked to, you keep iterating the function f. So let's look at a concrete example. Supposing we have defined a function square of x, which is returns x times x, and now we can say apply square to the value five twice. So what this means is apply square of five and then square of that, so do square twice, and therefore you get five squared 25 25 squared 625. So what is happening here is that square is being assigned to f, five is being assigned to x, and two is being assigned to n. So this is exactly as we said like before, like saying f is equal to square. So in this sense, being able to take a function name and assign it to another name is very useful because it allows us to pass functions from one place to another place and execute that function inside another function without knowing in advance what that function is. One practical use of this is to customize functions such as sort. Sometimes we need to sort values based on different criteria. So we might have an abstract compare function which returns minus one if the first argument is smaller, zero if the two arguments are equal, and plus one if the first argument is bigger than the second. So when comparing strings, we may have two different ways of comparing strings in mind. And we might want to check the difference when we sort by these two different ways. So we might have one sort in which we compare strings in dictionary order. So a string like aab will come before ab because the second position, a, is smaller than b. So this will result in minus one, because the first argument is smaller than the second argument. If, on the other hand, we want to compare the strings by length, then the same argument would give us plus one, because aab has length three and is longer than ab. So we could write a sort function, which takes a list and takes a second argument, which is how to compare elements in the list. So the sort function itself does not need to know what the elements in the list are. Whenever it's given a list of arbitrary values, it's also told how to compare them. So all it needs to do is apply this function to two values and check if the answer is minus 10 or plus one, and interpret it as less than equal to or greater. And if you want, you can combine it with the earlier feature, which is you can give it a default function. So if you don't specify a sort function, there might be an implicit function that the sort function uses. Otherwise it will use the comparison function that you provide. So, to summarize, function definitions behave just like other assignments or values to names. You can reassign a new definition to a function, you can define it conditionally, and so on. Crucially, you can use one function and make it point a name point to another function, and this is implicitly used when we pass functions to other functions. And in situations like sorting. You can make your sorting more flexible by passing a comparison function which is appropriate to the values will soften.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
functions.mp3,"We have seen how to alter the flow of a program by using if for and while. So we can have conditional execution, we can have repeated execution. So the last ingredient in our typical python program is a function. So what is a function? A function is a group of statements which performs a given task. So of course we could write the function code as part of the main program, but by isolating it, we can logically separate out units of work. And very often these functions are called repeatedly with different arguments, so they constitute a unit of computation which can be used repeatedly from time to time. So we define functions using the depth statement, as we have seen informally. So the definition defines the name of the function. In this case, we have just called it f. Usually we would give it more meaningful names. And then it says that this function takes three values as inputs. So these are called parameters or arguments. So the first one is called a, the second is called b, and the third is called c. And within the body of the program of the function a, b, and c will refer to the values which are passed to this function for a given call. Within a function, we might have a statement like this called return. So the body of the function is indented like we had for if, while, and for, and the return statement, if it encountered it says, at this point the execution of the function will end and you will get back to where you called the function from, returning the value in the name v. So this could be any expression. So we could just have return of a constant, or return of v plus one, or whatever. So when we call a function, we have to pass values for the arguments. And this is actually done exactly the same way as assigning a value to a name. So suppose we have a function like this, which takes x and raises it to the power n. So let's just look at the function, just to understand what the code is doing. So we assume that the value of the answer is one. And now for as many I as there are in the range zero to n minus one, we multiply x into answer. So we get effectively x times x times x n times. So each time we go through this loop, we multiply one more x, and finally we return the answer that we have got. Now, the way we would use this function in our code is to write an expression of the form, say power 35. So obviously what this means is that three should be used for x and five should use for n. And we would then run this code with the values x equal to three and n equal to five. So actually you can imagine that when we run this code. It's as though we have this code inserted into our program at this point, preceded by this assignment. So this assignment basically says, set the value of the name x to the value passed by this, namely three set n to five. So this assignment is what takes place effectively when you call a function. And since it is an assignment, this behaves very much like assignment in the regular case. In particular, the same rules apply for mutable and immutable values. Remember we said that when we rate something like x equal to y, if it is immutable, that is, the value in y cannot be changed in place. Then we copy the value and we get a fresh copy in x. So the value in x and the value in y are disjoint. So this is if it is immutable and if it is mutable. We said we don't copy, we share the value. That is, both names will point to the same copy of the value. So change in one will also make a change in the other. That happens with mutable things like lists. So immutable values will not be affected at the calling point in our case, and mutable values will be affected. So it's as though we are making an assignment between the expression or the name in the calling function, calling point to the name in the function. So if the function modifies that name, the value of that name, if it is an immutable value, nothing will happen here. If it is a mutable value, something will happen. So here is a simple function just to illustrate this point. So the aim of this function is to update a list. So I give you a list which is called in this function l, and I give you a position which is I. And what I want to do is I want to replace whatever is there by a new value, v. So I get three arguments. L is a list, and then I is the index or the position. And finally, v is the value to be replaced. So what do we do? We first check that the index is a valid index. So we check that it lies between zero and l minus one, so it is greater than equal to zero and it is strictly less than the length of l. If so, what we do is just replace l of I by the value v which we have got, and we return true to indicate that the update succeeded. Now, if I is not in this range, then we can't do an update. So what we will do is effectively return false. So this is just to say that the update didn't work, and then the person, the part of code which is calling this can understand that something went wrong. And presumably what went wrong is the index was not in the valid range. But just to illustrate what happens with immutable values in this case, we are also updating, for no good reason, the value of v to be v plus one. So remember that v is being passed as a value to be put in here, and we are assuming normally that v would be an immutable value. So let's assume we call it now. So what we do is we set up a list of numbers, a list of numbers 311, twelve. And then we want to replace this twelve, say, by eight. So just for the sake of argument, we first set up a new name, z, called eight. And we say update the list ns at position two. So remember the positions are zero, one, two. So update the list at position two by the value of z. And then we say update the same list at position four by the value of z. Now, as we saw, if the value is four, then this if will fail. So it'll instead go here. So this won't work. So it'll go here. And what will happen inside the code is that v will be incremented. Now, v has been copied from z. The question is, what happens to z? So, as you would expect, after executing these four statements, because of this update succeeding, the value of z is copied into the list at position two. And so we get the value eight instead of the value twelve that we started with. On the other hand, if we execute this statement, then because this is an immutable value, the change in v inside the function doesn't affect z at all. So, although v has been incremented from eight to nine, z remains eight. So this is just to illustrate that if we pass a parameter through a parameter, a value that is mutable, it can get updated in the function. And this is sometimes called a side effect. So the function affects the value in the other program. So this is called a side effect. So a side effect can happen if the value is mutable. But if the value is immutable, then the value doesn't change no matter what you do inside the program. Now, there are a couple of other points to note about this function, just to illustrate. One is that we have here two return statements, return true or return false. The idea is that they indicate to the calling function whether or not the update succeeded. So ideally you should have said something like result is equal to update, and then check after the update whether result is true or false. Because remember, update will update the list or not update the list, depending on whether the index is valid, and it will return true or false, depending on whether the update succeeded. So by examining the value of whatever is returned, we can check whether the update we intended worked or not. So this is something which we would expect, but we have not done it. So this is just to illustrate that there may be a return value, but maybe the idea is the function will actually update some mutable value, so you don't care what it returns. All the work is done inside the function, so even though there is a return value, you are not obliged to use it. You can just call a function as a separate statement, as we have done here. It doesn't have to be part of an assignment. The other thing is that because of this there may be functions which don't return anything useful at all. A typical example would be a function which just displays a message like there was an error, or it displays some other indicative things for you to understand what your code is doing. Now, such a function just has to display something. It doesn't have to compute or return anything. So there may be no return function. So by default what happens is that a function executes like everything else from top to bottom when it is invoked, and now if you encounter a return statement at that point the function stops executing and you go back. On the other hand, if you run out of statements to execute, if you reach the last statement and there is nothing more, then also the function will end. So there is no obligation for a function to actually have a return statement. So a return statement is useful if the function computes a value and gives you back some result which you will use later on. But you may have functions which don't have a return value, in which case you can either return some empty thing, or you can return nothing and everything will work fine. Another point to note about functions in Python is that names within a function are disjoint from names outside a function. So let's look at again a kind of toy example which doesn't have anything useful to do. So we have a function which we call stupid, which takes, essentially takes an argument and returns it. So it does nothing. But in between what it does is it just for no good reason, sets the name n to have the value 17. Now suppose we had in our program outside a statement which assigned the value seven to the name n, and then we call this function. Now obviously if we say stupid of eight, then v will be also the input, so it'll be v will become 28. The question is that while executing the fact that v is 28, the function internally set n equal to 17. The question is, we have asked n to be seven. Then we call this function n became 17 inside. The function is n 17 now or not. So the answer is that n is still seven. And that's because the n inside and the n outside are two different copies of n. So any name which is used inside a function is to be thought of as disjoint from the name outside, right? So the names outside are not visible inside, the names inside are not visible outside. Now, this is not something that you normally do, because it's just confusing if you use the same name inside and outside. But sometimes it is useful to have this separation, because very often we do use common things like ijk to run through lists like ranges and things like that. And it will be a nuisance if we have to use remember and use I outside and j inside and make sure that they don't interact. But since they don't interact anyway, we can freely use I and j wherever we want and not worry about the fact that we already have an I or a j outside in the calling function. One of the things that we mentioned upfront was that a function must be defined before it is invoked. Now, this is a slightly subtle point, so let's just look at it a little more. So remember that a Python program is read from top to bottom by the interpreter. So when the Python program is read, it reads the definition of f, but doesn't execute it. And notice that this definition of f has an invocation to g, which is actually later. But the point is, when reading the definition of f, g is not used. It's only remembered that this statement, which should be in a bracket, by the way, just to be consistent. So this statement should be computed if I call f. So it's not calling f, it's just defining f. So I define f, then I define g. Finally, when I come to this statement, it says, what is f of 77? So f of 77 will come here and it'll say, okay, f of 77 is nothing but g of 78, right? So that will come here and it'll say g of 78 is nothing but 81. So it'll come here. So 81. And then finally I'll get 81. So it's only when I execute the statement f is executed. At that time, g has already been seen. So though we say a function must be defined before it is invoked, it does not rule out the fact that one function can call a function which is defined after it, provided that you use this function only after that definition. So this sequence is fine. Suppose we rewrote this sequence in a different way. So supposing we had the definition of f, then we had this statement. So we have basically exchanged these two statements. Now what happens is that when the Python interpreter comes down this line at this point, it will try and call f. So f will try and call g, and g will say, well, I don't have a definition for g yet, because I have not yet gone past this statement. So if I put this statement execute f before I define g and f requires g, then this statement will create an error, whereas this statement will not. So it's really useful if we define all functions upfront, because any interdependency between functions will be resolved right away by the interpreter, and we don't have to worry about it. Whereas if we do this intermixing of functions and statements, then we have to be careful that functions don't refer to later things which have not been scanned yet by the interpreter. So this is one more reason to put all your function definitions at the beginning, and only then have the statements that you want to execute. A final point that we will return to later when we go through more interesting examples as we proceed in programming, is that a function can very well call itself the most canonical function of this kind. These are called recursive functions. Functions which rely on themselves is the factorial function. So if you remember, n factorial is defined to be n into n minus one, into n minus two into n down to one. So you take n and multiply it by all the numbers smaller than itself up to one. And by definition, zero factorial is defined to be one. So what we observe in this definition is that this part from n minus one to one is actually the same as n minus one factorial. So in other words, n factorial can be defined in terms of a smaller factorial. It is n times n minus one factorial. So that's what this function is exploiting. So there is a base case factorial of zero is one. And since the factorial of negative numbers is not defined, and we want to be safe, we can say that if n is equal to zero, or if n is less than equal to zero, we return one. So this is what we normally call the base case. So in this case the factorial is completely defined without having to do any further work. Now, if n is not less than equal to zero, then n is greater than zero. So if n is greater than zero, then we take the current number and we multiply it by the smaller factorial. That's exactly the definition given above. So this in turn, so if I take, say, factorial of three, so this will result in three times factorial of two. So that will invoke this function again, and this will give me two times factorial of one, and so on. So factorial of one will give me one times factorial of zero. And the point is that factorial of zero will now terminate, and it'll give me one because it says that if factorial is less, the argument is less than zero, less than or equal to zero term one. So I'll then get so this one will now come back and get multiplied here. So I'll get one times one. So one times one will come here and will come here. So then this will bring back a two, and then three times two, and this will be back a six. So this is how the function will execute. We will talk about this more later, but just to illustrate that functions can very well call themselves. So, to summarize, functions are a good way to organize your code into logical chunks. So if you have a unit of computation which is done repeatedly and very often done with different possible starting values, then you should push it aside into a function. If you break up your function, your code into smaller functions, it's much easier to understand, to read, and to maintain. When we pass arguments to a function, it's exactly like assigning values to a name. So the values that are passed can get updated in a function only if they are mutable, if they are immutable. Any change within a function does not affect the argument outside. Also, if we use the same name inside a function as is found outside a function, the name inside the function does not in any way affect the name outside. So functions have a local notion of what we call scope. So there is a scope of a name. Where is the name understood? So the name inside a function does not exist outside, and vice versa. Also, functions must be defined before they are used, and this is a good reason to push all your function definitions to the beginning of your program, so that the python interpreter will digest them all before they are actually invoked. So if there are mutual dependencies, you don't have a problem. And finally, we saw that we can write interesting functions which call themselves, and we will see many more examples of this in the weeks to come.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
generating permutations.mp3,"You. So, we have been looking at backtracking. So, in backtracking, we systematically search for a solution one step at a time. And when we hit a dead end, we undo the last step and try the next option. Now, in the process of doing backtracking, we need to generate all the possibilities. For instance, remember when we tried to print out all queens? We ran through every possible position for every queen on every row. And if it was free, then we tried it out. And if the solution extended to a final case, then we printed it out. Now, if you look at the solutions that we get for eight queens, each queen on row is in a different column from every other queen. So the column numbers, if we read them row by row, the column numbers form a permutation of zero to n minus one. So each number zero to n minus one occurs exactly once as a column number for the n queens. So one way of solving a problem like eight queens or similar problems is actually to generate all permutations and keep trying them one at a time. So this gives rise to the following question. If we have a permutation of zero to n minus one, how do we generate the next permutation? So this is like thinking of it as the next number, but this could be in an arbitrary number of symbols. So suppose, for instance, we have the letters a to m. So these are 13, the first 13 letters of the Alphabet. And we treat the dictionary order of Words as the ordering on the number. So we think of them as digits. So if you want, you can think of it as base 13. So here, for instance, is a number in base 13, or alternatively, a rearrangement of a to m in some order. Now, what we want to know is what is the next rearrangement after this immediately next one in dictionary order. So, in order to solve this problem, the first observation we can make is that if we have a sequence of such letters or digits, the smallest permutation is the one in which the elements are arranged in ascending order. So we start with a, which is the smallest one, then b and c, and so on. And there is no smaller permutation than this one. Similarly, the largest permutation is one in which all the elements are in descending order. So we start with the largest element, m, and we work backwards down to a. So if we want to find the next permutation, we need to find as short of suffix as possible that can be incremented. It's probably easiest to do it in terms of numbers, but let's do it with letters. So the shortest suffix that can be incremented consists of something followed by the longest suffix that cannot be incremented. So this will become a little clear when we work through an example. So we want to find the longest suffix that cannot be incremented. So a suffix that cannot be incremented is one which is as large as it could possibly be, which means it's already in descending order. So if you look at the example that we had before for which we wanted to find the next permutation, we find that this suffix on j, I, these five letters are in descending order. So I cannot make any larger permutation using this. So if I fix the letters from d to k, then this is the largest permutation I can generate with d to k fixed. So if I want to change it, I need to increment something, and I mean to increment it. I can't increment it within this red box. So I must extend this to find the shortest suffix, namely the suffix started with k, where something can be incremented. Now, how do we increment this? Well, what we need to do is that now it's like saying that we have with k, we cannot do any better, so we have to replace k by something bigger. And the something bigger has to be the smallest thing that we can replace it by. So we will replace key by the next largest letter to its right, namely m. Among these letters, m, n, and o are bigger than k. If I replace it by j or I, I will get a smaller permutation which I don't want. So I may replace it by m, n, or o. But among these, since m is the smallest, I must now start a sequence where the suffix of length six begins with the letter m. And among suffixes which begin with the letter m, I need the smallest one. That means I may rearrange the remaining letters Konji in ascending order to give me the smallest permutation, who begins with m and has the letters K-O-N-J-I after it. So this gives me this permutation. So I have now moved this m here. And now I have taken these letters and rearranged them in an ascending order to get ijkno. So therefore, this means that for this permutation, the next permutation is this one. So algorithmically we can do it as follows. What we need to do is first identify the suffix that can be incremented. So we begin by looking for the suffix that cannot be incremented. Namely, we go backwards so long as it's in descending order. So we keep looking for values as they increase. So I is smaller than j, j is smaller than m, m is smaller than n, n is smaller than o, but o is bigger than k. So that means that up to here, we have a suffix that cannot be incremented. And this is the first position where we can make an increment. Having done this, we now need to replace k by the letter to its right, which is next, bigger. Now, this is a bit like insert. We go one by one. We say that k is bigger than, smaller than o, so we continue. K is smaller than n, so we continue. K is smaller than m that we continue. And now we say that k is bigger than j, so we stop here. So this tells us that the position m is the letter m is the one that we want. So we can identify this in one scan, because this, remember, it's in descending order, so it is in sorted order, so we can go through and find the first position where we cross from something bigger than k to something smaller than k. And that is the position of the letter that we need to change. So it's exactly like inserting something into a sorted list. Now, having done this, so we have exchanged this m and k. Now we need to put this in ascending order. But remember, it was in descending order, and what we did to the descending order was we replace m by k. But what is the property of k? K was smaller than m but bigger than j. So on ki remains on kji remains in descending order. So if we want to convert it to ascending order, we don't need to sort it, we just need to reverse it. So we just read it backwards. So this is just a reversal of this. So this is a concrete way in all which to find the next commutation. Walk backwards from the end and see when the order stops increasing. So wherever it first decreases, that is the suffix that you want to increment. Of course, if we go all the way and we go back to the first letter and we have not found such a position, then we have already reached the last commutation. In the overall scheme of things, once we find such a position, we find which letter to swap it with by doing an equivalent of a search that we do for insertion sort. So we do an insert kind of thing, find the position in this case m to swap with k. After swapping it, we take the suffix after the new letter we put, namely m, and we reverse it to get the smallest permutation starting with that letter M. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"global scope, nested functions.mp3","You. So we were looking at the eight queens problem, and our solution involved representing the board which squares are under attack, and placing the queens one by one. One feature of this solution is that we had to keep passing the board through the functions in order to update them, or to resize them, to initialize them, and so on, because the board had to be updated through each function. Now, question is, can we avoid passing the board around all over the place? So can we avoid passing this board explicitly, or can we have a single global copy of the board that all the functions can update, which will save us passing this board back and forth? So this brings us to a concept of scope. So, the scope of a name in Python is the portion of the code where it is available to read and update. Now, by default, in Python, scope is local to a function. We saw that if we use a name inside a function, then that is different from using the same name outside the function. But actually this happens only when we update the name inside the function. So let's look at this particular code. Here we have a function f which reads a value x and prints it by storing it in the name y. Now the question is, what is this x? Well, there is an x here. So will this x inside the function correctly reflect the x outside the function or not? So here we see the function. We have written a file f one PI, which contains exactly that code. So we have a function f which reads an x from outside and tries to print it. And if we run this, then indeed it prints the value seven, as we expect. So y gets the value seven, because x has the value seven outside, and that x is inherited inside the function from inside f. So this works. Now, what if we do this? This is exactly the same function, except that after printing the value of y, it sets x equal to 22 inside x. Now what happens? Right, so here is f two PI, the code in the middle of the screen. The only difference with respect to f one phi is the extra assignment x equal to 22 inside it. Now, if we try to run f two PI, then it gives us an error saying that the original assignment y equal to x gives us an unbound local name. There is no x which is available at this point inside f. So somehow assigning x equal to 22 inside f changed the status of x. It is no longer willing to look up the outside x. It insists that there is an inside x. So this gives us an error. So if x is not found in f, Python is willing to look at the enclosing function for a global x. However, if x is updated in f, then it becomes a local name, and then it gives an error. So strictly speaking, this applies only to immutable values. So if we change this function as follows, we made x not integer, but a list, for example, and we ask y to pick up the zero th element of the list, and then later in f, we change the zero th element of x to 22. So here we have this function in which we now change x from an integer to a list, and then we try to assign it in y, but we update that list inside the function, and then if we run it, then it does print the value seven as we expect. So this works. So if we have an immutable, we have an immutable value. I mean, if you have a mutable value, sorry. Then we can actually change it inside f and nothing will happen. So global names that point to mutable values can be updated within a function. In fact, this means therefore, that the problem that we started out to solve, namely how to avoid passing the board around with inside eight queens, actually requires no further explanation, since board is a dictionary to the mutable value. And in fact we can write eight queens in such a way that we just ignore passing the board around. We change all the definitions so that board doesn't occur and works fine. So here we have rewritten the previous code, just removing board from all the functions. So initialize earlier. Took board and n. Now it just takes n. Print board doesn't take an argument at all. And all of them are just referring to this global value board, which you can see everywhere, right? So we have this global value board here, which is being referred to inside the function, and it doesn't matter that it's not being passed, because this is a mutable value. So it's going to look for the value which is defined outside, namely this empty dictionary, and then all these functions like place queen or undo queen or add queen, just take the relevant parameters and implicitly refer to the global value of board. So if you run this now, this global version, we get exactly the same output. So as I said, for our purpose, which is to fix that eight queens problem without having to pass the board around. The fact that Python implicitly treats mutable global names as updatable within a function is all that we need. But what if we actually want a global integer? Why would we want a global integer? Well, suppose, for instance, we want to count the number of times a function is called. So every time a function is called, we would like to update that integer inside this function. But that function that integer cannot be a local name to the function, because that local value will be destroyed when the function ends. We want it to persist, so it must be a value which exists outside the function. But being an integer, it's an immutable value, and therefore if we try to update it inside the function, it will treat it as a local value. So how do we get around this? So Priceon has a declaration called global, which says a name is to be referred to globally and not taken as a local value. So if we change our earlier definition of f, so that we add this particular tag, global x, then it says that this x and this x both refer to the same x outside. So this is a way of telling Python, don't confuse this x equal to 22 with creation of a new local name x. All x's referred to in f are actually the same as the x outside and to be treated as global values. So this is one way in which we can make an immutable value accessible globally within a Python program. So here is that global code. So we have global x. And just to make sure that the x equal to 22 inside is actually affecting the x outside, we have a print x now after the call to f, right? So at the bottom of the main program we have print x. Now, x was seven before f was called, but x got set to 22 inside f. So we'd expect the second print statement to give us 22. So this statement should first print seven should print a seven from the print y, and then print 22 from this print x. So if we run this, indeed, this is what we see, we have two lines. The first seven comes from print y, and the second, 1122, comes from print x outside. So while we are on the topic of local scope, Python allows us to define functions within functions. So here, for instance, the function f has defined functions g and h. G of a returns a plus one, h of b returns two times b. And now we can update x, for instance y, for instance, by calling g of x plus h of x, rather than just setting it to the value x. Now, the point to note in this is that these functions g and h are only visible to f. So they are defined within the scope of f. So they are inside f. Right? So they are inside f, and hence they are not visible outside. So from outside. If I ask g of x at this point, this will be an error, because it will say there's no such g defined. So this is useful because now we can define local functions, which we might want to perform some specialized task which are relevance to f, but it should not be a function which is exposed to everybody else, and this is possible here. Now of course the same rules apply, so if we look up x inside g or h, so if you look up an x here, it'll first try to look up f. If it is not there an f, it will go outside, and so on. So either we can declare it global, in which case we can update it within g or h, or it will use the same rule as before. If we don't update an immutable value, it will look outside, and if it is the mutable value, it will allow us to update it from inside. Now there are some further refinements. So Python has an intermediate scope called non local, which says within Gnh refer to the value inside f, but not to the value outside f. So this is a technicality, and it will not be very relevant. If we need it, we will come back to it. But for the moment, if you want to find out more about non local declarations, please see the Python documentation. But global is the important one. Global allows us to transfer an immutable value from outside into the function and make it updatable within a function. To summarize, what we have seen is that Python names are looked up inside out from within functions. If we update an immutable value, it creates a local copy. So we need to have a global definition to update immutable values. On the other hand, if we have mutable values like lists and dictionaries, there is no problem within a function we can implicitly refer to the global one and update it. And this we saw in our eight queens solution. We can make the board into a global value and just keep updating it within each function, rather than passing it around explicitly as an argument. And finally, what we have seen is that we can nest functions so we can create so called helper functions within functions that are hidden to the outside, but can be used inside the function to logically break up its activities into smaller units. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
grid paths.mp3,"You. So, in the last lecture, we looked at how to make iterative or inductive definitions more efficient than naive recursion. And we saw memoization and dynamic programming as tools to do this. So now let's look at a typical problem and see how we can apply this technique. So here is a problem of grid paths. So we have a grid here, can imagine there are roads which are arraigned in a rectangular format. And we can imagine that the intersections are numbered. So we have zero, zero at the bottom left corner. And in this case we have 510, because we have going across from left to right. We have 12345 different intersections and ten going up. So we have at 510 the top right corner. So if these are roads, the constraint that we have is that one can only travel up or right. So you can go up a road or you can go right, but you cannot come down right. So this is not allowed. So these are one way roads which go up and right. And what we want to ask is how many ways there are to go from the bottom left corner to the top right corner. So we want to count the number of what are called grid paths. So, a grid path is one which follows this. So we want to know how many such different paths are there which take us from zero, zero to 510, only going up or right. So here is one path drawn in blue. Here is a different path drawn in red. And notice that these two paths actually start in different directions from the first point, and they never meet except at the target, so they don't overlap at all. On the other hand, we could have paths which overlap. So this yellow path overlaps for part of its way with the blue path in this section. And it also overlaps with the red path in two portions. So there are many different ways in which we can choose to make these up and right moves. And the question is how many total such different paths are there? So, there is a very standard and elegant combinatorial solution to it. So, one way of thinking about this is just to determine how many moves we have to make. We have to go from zero to five in one direction and zero to ten in the other direction. So we have to make a total number of five horizontal moves and ten vertical moves. In other words, every path, no matter which direction we start in and which choice of moves you make, must make 15 steps. And of these, five must be horizontal steps, and ten must be vertical steps, because they all take us from zero, zero to 510. So all we have to do, since we know that these five steps are horizontal and ten are vertical is to just demarcate which ones are horizontal, which are vertical. Now, once we know which ones are horizontal, we know what sequence they come in, because the first horizontal step takes us from column zero to column 1. Second one takes us from one to two, so we can't do it in any order other than that. So we have, in other words, we have 15 slots where we can make moves, and then we just say, okay, first we make an up move, then we make a right move, then we make an up move, we make another up move, and so on. So every path can be drawn out like this as ten up moves and five right moves. And if we fix the five right moves, then automatically all the remaining slots must be ten up moves. Or conversely, so it's either 15 choose five, which is the way of choosing five positions to make the right move out of the 15. And it turns out that the definition of 15 choose five is clearly the same as 15 choose ten, because we could also fix the ten up moves. And the definition is basically, if you know the definitions n choose k is n factorial upon k factorial into n minus k factorial. So this k and n minus k basically says that 15 minus five is ten. So we get a symmetric function in terms of k and n minus k. So in this case, we can apply this formula, as you would like to call it, that, and directly get that the answer is 3003. So there doesn't appear to be much to compute other than writing out large factorials and then seeing what the number comes. But the problem becomes more interesting if we constrain it by saying that some of these intersections are blocked. For instance, supposing there is some road work going on and we cannot go through this intersection two four. So this is the intersection two comma, four, the second column and the fourth row. Counting from below, it's actually two comma three, but two comma four. So now if we can't go through this, then any path which goes through this particular blocked intersection should no longer be counted. Out of those 3003, some paths are no longer valid paths. For instance, in the earlier thing, the blue path that we had drawn actually goes through this. The red path does not, but the yellow path overlap with the blue path, unfortunately, in this bad section. So it also passed through this. So there are some paths which are allowed from the 3003 and some which are not. So how do we determine how many paths survive this kind of block? So again, we can use a combinatorial argument in order to be blocked a path must go to two four and then from two four to five five. So if we could only count how many paths go from two four and then how many parts go from two four to 510. These are all the bad parts. So we can count these bad parts and subtract them from the good parts. How do we count the bad parts? Well, we can just solve a smaller version of the problem. So we have an intermediate target. So we solve this grid. How many parts go from here to here? How many parts go from here to here? So from two four we get four plus two. Remember, it's ten plus five. It was at the target. So ten four plus two. Choose two. So we get 15 and from here to here. The difference is that we have to do in both directions, three and so we have to go, sorry, we have to go up six and we have to go right three. We are at two four, so we have to go from four to ten and from two to five. So we have six plus three. Choose 384 ways of going from two four to this. And each of the ways in the bottom can be add combined with the way on the top. So we multiply this and we get 1260 parts which pass through this bad intersection. We subtract this from the original number, 3003, and we get 1000 and 743 parts which remain. So our combinatorial approach still works. Now, what happens if we put two such intersections so we can do the same thing? We can count all the parts which get blocked. Because of the first intersection, we can count all the parts which pass through. In this case, four four is the second intersection which has been blocked. So we can count all these parts which pass through four four. So this we know how to do. We just computed it for two four. But the problem is that there are some paths, like the yellow path, which pass through both two four and four four. So we need a third count. We need to count paths which pass through both of these and make sure we don't double count them. So one way is that we just add these back. So this is something which is called, in combinatorics, inclusion and exclusion. So when we have these overlapping exclusions, then we have to count the overlaps and include them back. And we have to keep doing this step by step. So if we have three holes, we get an even more complicated inclusion exclusion formula. And it rapidly becomes very complicated even to calculate the formula that we need to get. So is there a simpler way to do this? So, let us look at the inductive structure of the problem. Suppose we say we want to get one step to an intersection, I comma j. How can we reach this in one step? Since our roads only go left to right and bottom to top, the only way we can reach Ij is by taking a right edge from its left neighbor. So we can go from I minus one j to I J, or we can go from below from I J minus one to IJ. Notice that if a path comes from the left, it must be different from a path that comes from below. So every path that comes from the left is different from every path that comes from below. So we can just add these up. In other words, if we say that paths ij is the quantity we want to compute, we want to count the number of paths from zero zero to IJ. These paths must break up into two disjoint sets, those which come from the left, which recursively or inductively if you prefer to say, is exactly the quantity. Parts I minus one j. How many parts are there which reach I minus one j? Every one of these parts can be extended by right edge to reach I j, and they will all be different. Similarly, parts I comma, j minus one are all those parts which come from below, because they all reach the point just below I j. And from there, each of them can be extended in a unique way to I j. So this gives us our simple inductor formula. Parts I j is just the sum parts I minus one j, parts I j minus one. Then we need to, of course, investigate the base cases. In this case, the real base case is just part zero zero. How many ways can I go from zero zero and just stay in zero zero? Well, there is only one way. It's tempting to say zero ways, but it's not zero ways, it's one way. Otherwise, nothing will happen. So we have one way, by just doing nothing to stay in zero zero. And if we are now moving along the left column, we are moving along the left column. Then there is no parts coming from its left, because we are already on the leftmost column. So all the paths from to zero j must be extensions of parts which have come from below to zero j minus one. Similarly, if we are in the bottom row, there is no way to come from below because we are already on the lowest set of roads. So parts I zero can only come from the left from parts I minus 10. So this gives us a direct way to actually compute this, even with holes. Because the only difference now is that if there is a hole, we just declare that no path can reach that place. So we just add an extra clause which says path I j is zero if there is a hole at ij. Otherwise we use exactly the same inductive formulation. And now what happens is, if that I have a hole below me, if I have a hole below me, no paths can come from that direction because by definition, parts of ig at that point is zero. So once again, if we now apply this and do this using the standard translation from the inductive definition to a recursive program, we will find that we will wastefully recompute the same quantity multiple times. For instance, paths 510. So if you have paths 510, it will require me to compute this and this. These are the two sub problems for paths 510, MD 410 and five nine. But in turn, in order to compute 410, I will have to compute whatever is to its left and below it. And in order to compute five nine, I will also have to compute what is to its left and below it. And now what we find is that this quantity MD four nine is computed twice, once because of the left neighbor of 510 and once because of the neighbor below 510. So as we saw before, we could use memoization to make sure that we never compute IJ twice. By storing a table I comma J, and every time we compute a new value for I comma J, we store it in the table. And every time we look up, we need to compute one. We first check the table. If it is already there, we look it up. Otherwise we compute it and store it. But since we know there is a table and we know what the table structure is, basically it's all entries of the form I comma J, we can also see if we can fill up this table iteratively by just examining the subproblems in terms of their dependencies. So in general, a node value depends on things to its left and below. So if there are no dependencies, it must have nothing to its left and nothing below. And there is only one such point, namely so this is the only point which is a base case which has nothing to its left and nothing below. So its value is directly given. So we start from here. So remember that the base value at one. And now once we have done this, it turns out we remember the row dependency. It said I comma zero is I minus one comma zero. So we can fill up this because this has only one dependency which is known now. So in this way I can fill up the entire row and say that all along this row there's only one path, namely the path that starts going right and keeps going right now, we can go up and see that this thing is also known because it also depends only on the value below it. And once that is known, then these two are known, so I can add them up. Remember, the sum of the value at any position is just the value to its left plus the value to its bottom. And now I start to get some nontrivial values. And in this way I can fill up this table row by row. And at each point when I come to something, I will get the fact that the dependencies are known. So the next row looks like this, and the next row now we come to the row with holes. So for the row with holes, wherever we hit a hole, instead of writing the value that we would normally get by adding its left and bottom neighbor, we deliberately put a zero, because that means that no path is actually allowed to propagate through that hole. So now when we come to the next row, the holes will automatically block the paths coming from the wrong direction. So here, for instance, we have only six paths coming from the left because we have no paths coming from below. Similarly, we have 26 parts coming from the left and no parts coming from below. So this is how our inductive definition neatly allows us to deal with holes. And from that inductive definition we recognize the dependency structure. And we imagined a memo table. And now we are filling up this memo table row by row, so that at every point when we reach an IJ value, its dependent values are already known. So we can continue doing this row by row. And eventually we find that there are 1363 paths which avoid these two. So we could also do the same thing in a different way. Instead of doing the bottom row, we can do the left column. And the same logic says that we can go all the way up. Then we can start in the second column, go all the way up, and do this column by column. And not unexpectedly, you should get the same answer. There is a third way to do this. So once we have one at then we can fill both the first element above it and the first element to its right. So we can do this diagonal. Now notice that any diagonal value like this one has both its entries, right? So this has only one entry. So I can now fill up this diagonal so I can go one more diagonal. Then I can go one more diagonal. So we can also fill up this thing diagonal by diagonal. So the dependency structure may not require us to fill it in a particular way. We might have very different ways to fill it up. All we want to do is systematically fill up this table in an iterative fashion, not recursively. We don't want to call f of ij and then look at f of I minus one j. We want to directly say, when we reach ij, we have the values we need, but the values we need could come in multiple different orders. So we could have done it row wise. We could have done it column wise. And here, you see, we can do it diagonally, but it doesn't matter so long as we actually get all the values that we need. So one small point. So we have said that we can use memorization or we can use dynamic programming. One of the advantages of using dynamic programming is it avoids this recursive call. So, recursion, we had mentioned earlier, also in some earlier lecture, comes with a price, because whenever you make a recursive call, you have to suspend a computation, store some values, restore those values. So there is a kind of administrative cost with recursion. So actually, though, it looks like only a single operation, when we call fib of n minus one or fib of n minus two, there is actually a cost involved with suspending this operation, going there and coming back. So, saving on recursion is one important reason to move from memorization to dynamic programming. But what dynamic programming does is to evaluate every value, regardless of whether it's going to be useful for the final answer or not. So, in the grid pathing, there is one situation where you can illustrate this. Imagine that we have these obstacles placed exactly one step inside the boundary. So now if you want to reach this, it's very clear that I can only come all the way along the top row or all the way up the rightmost column. There's no other way I can reach there. So anything which is inside these positions, there is no way to go from here out. So there's no point in counting all these values. Okay? So we have this region, which is in the shadow of these obstacles, which can never reach the final thing. So when we do memorization, when we come back and recursively explore, it will never ask us to come here because it will never pass these boundaries. On the other hand, our dynamic programming will blindly walk through everything. So it'll do row by row, column by column, and it will eventually find the zeros, but it will fill the entire n by m grid. So in this case, how many will memorization do? It will do basically only the boundary. So it will do only order m plus n. So we have a memo table which has only a linear number of entries in terms of the rows and columns. And a dynamic programming entry which is quadratic. If both are n, it will be n square versus two n. So this suggests that dynamic programming in this case is wastefully computing a vast number of entries. So n square is much larger than two n, remember? So it will take us enormous amount of time to compute it if we just count the cost of the per entry. But the flip side is that each entry that we need to add to the memo table requires one recursive call. So the reality is that these recursive calls will typically cost you much more than the wastefulness of computing the entire table. So, in general, even though you can analyze the problem and decide that memorization will result in many fewer new values being computed than dynamic programming, it is usually sound to just use dynamic programming as the default alt way to do the computation. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
handling files.mp3,"You. So, in the last lecture, we saw how to use the input and print statements to collect input from the standard input that is the keyboard, and to display values on the screen using print. Now, this is useful for small quantities of data, but if we want to read and write large quantities of data, it is impractical to type them in by hand or to see them as they scroll past in the screen. So, for large data, we are forced to deal with files which reside on the disk. So we have to read a large volume of data which is already written on a file in the disk. And the output we compute is typically written back into another file on the disk. Now, one thing to keep in mind when dealing with disks is that disk read and write is very much slower than memory read and write. So to get around this, most systems will read and write data in large blocks. Imagine that you have a large storage facility in which you store things in big cartons. Now, when you go and fetch something, you bring a carton at a time, even if you're only looking for, say, one book in that carton. So you don't go and fetch one book out of a carton from the storage facility. You bring the whole carton. And then when you want to put things back again, you assemble them in a carton and then put them back. So, in the same way, the way that data flows back and forth between memory and disk is in chunks called blocks. So even if you want to read only one value or only one line, it will actually fetch a large volume of data from the disk and store it in what is called a buffer. And then you read whatever you need from the buffer. Similarly, when you want to write to the disk, you assemble your data in the buffer. And when the buffer is enough quantity to be written onto the disk, then one chunk of data and a block would be written back on a disk. So when we read and write from a disk, the first thing we need to do is connect to this buffer. So this is called opening a file. So when we open a file, we create something called a file handle. And you can imagine that this is like getting access to a buffer from which data from that file can be read into memory or written back. Now, having opened this file handle, everything we do with the file is actually done with respect to this file handle. So we don't directly try to read and write from the disk. Instead, we write and read and write from the buffer that we have opened using this file handle. And finally, when we are done with our processing, we need to make sure that all the data that we have written goes back. So this is done by closing the file. So closing the file has two effects. The first effect is to make sure that all changes that we intended to make to the file, any data we wanted to write to the file is actually taken out of the buffer and put onto the disk. And this is technically called flushing the buffer. So closing a file flushes the output buffer. Make sure that all writes go back to the file and do not get lost. And the second thing it does is that it in some sense makes this buffer go away. So it disconnects the file handle that we just set up. So now this file is no longer connected to us. If we want to read or write to it again, we have to again open it. So the command to open a file is just open. So the first argument that you give open is the actual file name on your disk. So now this will depend a little bit on what system you're using, but usually it has a first part and an extension. So this command, for instance, says to open the file GCD py. Now implicitly, if we just give a file name, it will look for it in the current folder or directory where you're running the script. So you can give a file name which belongs to a different part of your directory hierarchy by giving a path. And how you describe the path will depend on whether you're working on windows or Unix or what operating system you're using. Now you see that there is a second argument there which is the letter r. So this tells us how we want to open the file. So you can imagine that if we are making changes to a file by both reading it and writing it, this can create confusion. So what we have to do is decide in advance whether we are going to read from a file or write to it. We can't do both. So there's no way we can simultaneously read from a file and modify it while it is open. So read is signified by R. Now, write comes in two flavors. We might be wanting to create a new file from scratch. In this case we use the letter w. So w stands for write out to a new file. We have to be a bit careful with this because if we write out to a file which already exists, then opening it with more w will just overwrite the contents that we already had. The other thing which might be useful to do is to take a file that already exists and add something to it. So this is called append. So we could have two writing modes, w for write and a for append, what append will do is it will take a file which already exists and add the new stuff that we are writing at the end of the file. So once we have a file open, let's see how to read. So we invoke the read command through the file handle. So this is like some of the other functions that we saw with strings and so on, where we attach the function to the object. So fh was the file handle we opened, so we want to read from it. So we say fh read. What fh read does is it swallows the entire contents of the file as a single string and returns it, and then we can assign it to any name. Here we have used the name contents, so contents is now assigned the entire data which is in the file handle pointed to by fh in one string. Now we can also consume a file. So we are typically dealing with text files. So text files usually consist of lines. Think of Python code. For example, we have lines after lines after lines. So a natural unit is a bunch of text which is ended by a new line character. If you remember, this is what the input command does. The input command waits for you to type something, and then you press return, which is a new line. And whatever you typed up to that return is then transmitted by input as a string to the name that you have assigned to the input. So read line is like that. But the difference between read line and input is that when you read a line, you get the last new line character along with the input string. So when you say input, you only get the characters which come before the last new line. The new line is not included, but in read line you do get the new line character. So you have to remember that you have this extra character floating around at the end of your string. So this is conventionally denoted by this backslash n. So, backslash n is a notation which denotes a single character, even though it looks like two characters. This is supposed to be the new line character. Now, the actual new line character differs on operating systems from one to the other. But in Python, if you use backslash n, it will be correctly translated in all the systems that you're using. The third way that you can read from a file is to read all the lines one by one into a list of strings. So instead of read line, if I say read lines, then it reads the entire file as a list of strings. Each string is one item in the list. And this. Remember again, each of these lines has the backslash n included. So read line and read lines. None of them will actually remove the backslash n. They will remain faithfully as part of your input. So in other words, if you're going to transfer this from one file to another, you don't have to worry about reinserting backslash n because it's already there. So you can use this input to output directly. But on the other hand, if you want to do some manipulation with the string, then you must remember that this backslash n is there and you must deal with it appropriately. Reading files is inherently a sequential operation. Now, of course, if we use the basic command read, it reads the entire contents. So obviously it reads it from beginning to end. But if we are reading one line at a time, then the way it works is that when we open the file, we are initially at the beginning of the file. So you can imagine a pointer like this red arrow, which tells us where we are going to read next. So initially when we open, we are going to read from the beginning. Now, each read line takes us forward. So if I do a read line at this point, it will take me up to the next backslash n. Remember, a line is a quantity which is delimited by Backslash n. So we could have a line which has 100 characters, next line could have three characters, and so on. So it is from one backslash n to the next is what a line is. So this is not a fixed length. So we will move forward, reading one character at a time until we have backslash n. Then everything up to that backslash n will be returned as the effect the string returned by read line, and the pointer will move to the next character. Now we do another read line, possibly of a different length. Again, the pointer will move forward. So in this way we go from beginning to end. In case we want to actually divert from this strategy, there is a command seek, which takes a position, an integer n, and moves directly to position n regardless of where you are. So this is one way to move back or to jump around in a file other than by reading consecutively line by line. Finally, we can modify the read statement to not read the entire file, but to read a fixed number of characters. Now this may be useful if your character actually, your file actually consists of fixed blocks of data. So you might have, say, for example, pan numbers, which are typically ten characters long, and you might have just stored them as one long sequence of text without any new lines, knowing that every pan number is ten characters. So if you say fh, read ten, it will read the next pan number and keep going. And this will save you some space in the long run. So there are situations where you might exploit this where you read a fixed number of characters. Now, when we are reading a file incrementally, it's useful to know when the file is over, because we may not know in advance how long the file is or how many lines the file is. So if we are reading a file line by line, then we may want to know when the file has ended. So there are two situations where we will know this. So one is if we try to read using the read command and we get nothing back, we get an empty string. That means the file is over, we have reached the end of file. Similarly, if we try to read a line and we get the empty string, it means we have reached the end of file. So read or read line. If they return the empty string, it means that we have reached the end of the file. Remember, we're going sequentially from beginning to end, so we've reached the end of the file and there's nothing further to read in this file. So having read from a file, then the other thing that we would like to do is to write to a file. So here is how you write to a file. Just like you have a read command, you have a write command. But now, unlike read, which implicitly takes something from the file and gives it to you, here you have to provide it something to provide put in the file. So write takes an argument, which is a string. So when you say write s, it says take the string s and write it to a file. Now, there are two things. One is this s may or may not have a backslash n. It may have more than one backslash n. So there's nothing that tells you that this is one line. It's part of a line more than a line. You have to write s according to the way you want it to be written on the file. If you want it to be one line, you should make sure it ends with a backslash n, and this write actually returns the number of characters written. Now this may seem like a strange thing to do, I should tell you, because you know from the length of s what is the number of characters written? But this is useful if, for instance, a disk is full, right? So if you try to write a long string and you find out that only part of the string was written, then this is an indication that there was a problem with the write. So it's useful sometimes to know how many characters actually got written out of the characters that you tried to write. So the other thing, which writes in bulk to a file is called write lines. So this takes a list of strings and writes them one by one into the file. Now though it says write lines, these need not actually be lines, so it's a bit misleading. The name. If you want them to be lines, you must make sure that you have each of them terminated by backslash n. If they are not, then they will just cascade to form a long line in the thing. So though it says write lines, it should be more like write a list of strings. That's a more appropriate name for this function. It just takes a list of strings and writes it to the file pointed to by the file handler. And finally, as we said, once we are done with the file, we have to close it and make sure that the buffers that are associated with the file, especially if you are writing to a file, that they are flushed. So fh close would close the file handle fh, and all pending writes at this point are copied out to the disk. It also now means that fh is no longer associated with the file we are dealing with. So after this, if we try to invoke operations on Fh, it's like having an undefined name in Python. Now, sometimes there are situations where we might want to flush the buffer without closing the file. We might just want to make sure that all writes up to this point have been actually reflected on the disk. So there is a command flush which does this. So in case we say flush it, just say if there are any pending writes, then please put them all onto the disk. Don't wait for the rights to accumulate until the buffer is full, and then write as you normally would to the disk. So here is a typical thing that you would like to do in Python, which is to process it line by line. So the natural way to do this is to read the lines into a list and then process the list using a for. So you say contents is fh read lines, and then for each line in contents you do something with it. You can actually do this in a more compact way. You can do away with the name contents and just read directly every line returned by the function fh read lines. So this is an equivalent formulation of the same loop. So as an example of how to use this line by line processing, let us imagine that we want to copy the contents of a file input txt to a file output txt. So the first thing that we need to do is to make sure that we open it correctly. So we should actually open the out file with mode w and infile with mode r. So this says that I'm going to read from infile and write to the out file. Now, for each line in return by read lines on the infile. Remember that when I get a line from read lines, the backslash n is already there, and if I don't do anything to the backslash n, I can write it out exactly the same way. So for each line that I read from the list in file read lines, I just write it to out file. And finally I close both the files. So this is one way to copy one file from input to output. So of course we can do it even in one shot because there is a command called write lines which takes a list of strings and writes them in one shot. So instead of going line by line through the list read lines, we can take the entire list contents and just output it directly through write lines. So this is an alternative way where I have replaced. So this is basically replacing the for, right. So instead of saying for each line in influence, I can just write it directly out. So one of the things we have been talking about is this new line character, which is a bit of an annoyance. So if we want to get rid of a new line character, remember this is only a string and the new line character is going to be the last character in the string. So one way to get it is just to take a slice of the string up to, but not including the last character. Now remember that when we count backwards, minus one is the last character. So if we take the slice from zero up to minus one, then it will correctly exclude the last character from the string. So s equal to line, colon minus one will take line and strip off the last character, which is typically the backslash n that we get when we do read lines. Now, in general, we may have other spaces. So remember, when we write out text, very often we can't see the spaces at the end of the line because they're invisible to us. So these are what are called white space. So spaces, tabs, new lines. These are characters which don't display on the screen, especially spaces and tabs. And if they're at the end of the line, we don't know whether the line ends with the last character we see or there are spaces afterwards. So r strip is a string command which actually takes a string and removes the trailing white space, all the white space at the end of the line. In particular, if there's only a backslash n, then it'll strip the backslash n. It'll also strip other junk if there is some spaces and tabs before the backslash n and return that so s equal to line r strip, that is strip line from the right of white space. This is an equivalent thing to the previous line, except it's more general because it strips all the white space, not just the last backslash n, but all the white space at the end of the line. So we can also strip from the left using l strip, or we can strip on both sides if we just say strip without any characterization of lrr. So these are string manipulation functions, and we will look at some more of them, but this is just a useful one which has come up immediately in the context of file handling. So before we go ahead, let's try and look at some examples of all these things that we have seen so far. So here we have created a file called input txt, which consists of the lines the quick brown fox jumps over the lazy dog. Now let's open the Python interpreter and try to read lines from this file and print it up so we can say, for instance, that f is equal to open input txt in read mode. Now I have opened the file and now I can say for instance for line in f dot read line, print line. Now you'll see something interesting happening here. So you'll see that we have now a blank line between every line in our file. Now why is there a blank line between every line in our file? That's because when we read lines, we get a backslash and character from the line itself. So the quick brown the first line ends with backslash n, fox ends with backslash n, and then over and above that, if you remember, the print statement adds a backslash n of its own. So actually print is putting out two blank lines for each of these. So now let us try and do this again. So supposing I repeat this thing and now I do this again. Now nothing happens. Now the reason nothing happens is because we have this sequential reading of the file. So the first time we did f dot read lines, it read one line at a time, and now we are actually pointing to the end of the file. So if for instance, at this point we were to say, say text equal to fh read f dot read, then text will be the empty string. So this is an indication that we have actually reached the end of the file. Similarly, if we try to say read line again, text will be the empty string. So remember we said that if read or read line returns the empty string, then we have reached the end of the file. So the only way that we can undo this is to start again by closing the file. So what we say is f dot close. So this closes the file. Now if we try to do f dot read, then we will get an error saying that this has not been defined. Okay, so we don't have f with us anymore. So we again have to say f is open input txtr. And now we can say while for line in f dot read lines for each line. Supposing now we use that trick that we had last time, which is to say end equal to empty string that says do not insert anything after each print statement. Now if we do this, we see that we get back exactly the input file as it is without the extra blank lines, because print is no longer creating these extra lines. So let's say we want to copy input txt to a file output txt. So we say f is equal to open input txtr as before, and we say g is equal to open output txtw. And now we say for line in f dot read lines g write line. Now notice you get a sequence of numbers. Now why do you get a sequence of numbers? That's because each time we write something, it returns a number of characters written and it'll turn out if you look at the lines, the quick brown, fox, et cetera. Now for example, the second line is just Fox. Fox has three letters, but if you include the backslash n, it wrote four letters, right? So that's why the quick brown was 15 letters plus a backslash n. Fox was three plus a backslash n. So this is line by line. Now, if I correctly close these files and then come out of this, then output txt is exactly the same as input txt. So, to summarize, what we have seen is that if you want to interact with files, we do it through file handles, which actually correspond to the buffers that we use to interact between memory and the file on the disk. We can open a file in one of three modes, read, write, and append. We didn't actually do an example with append, but if you do append, what it will do is it'll keep writing beyond where the file already existed. Otherwise, write will erase the file and start from the beginning. So we saw that we have read read line and read lines. So using this we can either read the entire file in one shot as a string, or read it line by line. Similarly, we can either write a string or we can write a list of strings too. So we have a write command and a write lines and write lines is more correctly to be interpreted as write list of strings. Finally, we can close the handle when we are done, and in between we can flush the buffer by using the flush command. And we also saw that there are some string operations to strip white space, and this can be useful to remove these trailing backslash ends, which come whenever you're processing text files. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Idea of Algorithms.mp3,"So we move to the next module of this course. In the earlier module, we have seen some example problems and the problems which can be some example problems which can be solved through programming using computers. And also, we said that all problems cannot be solved by computers, right? So what are the problems that can be solved using computers? That's a natural question that can be asked. The answer to that is that if it is known what are the steps that we must execute or perform in order to arrive at the desired result, then we can solve it by programming. Now, those steps may be directly known. For example, in the case of finding the average marks in a class for n students, we know the steps, right? So let's see, if we write down the steps following which we can solve this problem. How would it look like I want to read one number. Suppose I am reading phone numbers. I want to find the average of phone numbers. Read. Read means I just know. Get. I can also say, get first number, two. Get second number. Suppose you want to find for three numbers. Get third number. Add the numbers. That means first number plus second number plus third number. And let that be the sum. And then I say divide sum. There is this sum by the number of numbers. And what is the number of numbers? Number of numbers. Here is three, because there are three numbers. And then say announce result. So this one divide the sum by numbers. So that is something like. Say something like this. That result is equal to sum divided by three in this case. Right, an announce result. So these steps are very well known, very clear. And since these are very clear, so I can solve them by programming. Okay, why? Because programming. What is programming? Programming is informing a computer as how to solve a particular problem. So I can say, let me just do it afresh. Programming is nothing but letting the computer know how to solve a problem. Now, there are some important aspects to this sentence. This phrase letting the computer know is one important thing. But what do we let the computer know? How to solve a problem. So how to means I have to tell the computer that. What are the steps to be followed to solve a problem, I have to be very clear about it and I have to let the computer know. So there is a big problem here. How I let the computer know. I'll come to that later. The steps to be followed is what we have to tell the computer. So in the earlier example, we just saw that the steps for finding the mean of three numbers are very clearly stated. And I can inform the computer. Often this is informing the computer is also known as instructing the machine. The machine is nothing but the computer itself. And these are the computer instructions. A program, therefore, consists of a number of instructions to be executed. Now, the example that we saw was for adding three numbers. Now, you'll soon see that the thing becomes a little more complex. If I wrote get first number, get second number, get third number. Suppose there are 20 numbers. Then I'll have to write them 20 times. Get first number, get second number, get third number, like that, up to get 20th number. That is boring, isn't it? So instead, I can possibly write that for 20 numbers. Let me do it in a, let me do a number here for 20 numbers, repeatedly, get number. All right, that's possible. So for 20 numbers, I'll be getting the numbers. So I don't need to write down one, get first number two, get second number three, get third number. Not like that. I can straightway, with one instruction, I can express myself. But whether this will be understood by the computer or not is a different question. So I am keeping that question open, understood by machine. And whenever I talk about machine, I mean a computer. All right? So for 20 numbers, get number. In that way, I can say that, or say I could have written that in a little more smarter form. Let me try to do that. Now, if I do that, then what would be the next one? I have to add those 20 numbers. So one thing is that, again, I can write here, add number one, number two, number three, up to number 20, then divide sum by 20. There's one way of saying that. But this is, again, boring, right? This is very boring. I mean, it's not interesting to look at this. Why should I write in this dot, dot, dot, dot form instead? Say I can write it in a smarter form. Say I write it in this way, and you just see whether you can understand what I am writing. For 20 numbers. I am using my own language, okay? It's not a computer's language. It is an English, and it's a version, my version of English, all right? I just need to express it to you, and then whether that will be understood by the computer or not is a different question, and we will address it separately, okay? For 20 numbers, gate number. Sorry, I say, repeat, gate number. Or let me add the number with the current sum. That means presently, whatever is the value of sum, I add that number that I read with that. Now, initially. Therefore, what should be the current sum? Initially, when I am starting, the sum is zero, all right? So I can say let sum be zero initially. Now I get a number, add the number to the current sum, and this repeat, I am just using my. So just showing as if it's a bracket that this part I am repeating. I am repeating this part. How many times? I'm repeating this part. This part I am repeating. How many times? I'm repeating 20 times. Because for 20 numbers, I am getting the number, adding the number, getting the number, adding the number, and I'm going on doing this and adding the number, and I'm keeping that number in sum. All right? So ultimately, I do it 20 times, and then this part is finished. Then what I have to do. So this was step one. This was step two. This was step three. So this step three was repeated 20 times. I'm sorry. Let's make it sorry. Actually, this is the second step, which I did 20 times. And after that, I have got all the numbers added. So next I come and I say, result is sum divided by 20. So that will be my result. And then I can announce the result, print the result, whatever. So here you see, in the earlier example, what I did is read first number, read second number, read third number, read fourth number like that. Here I have just expressed it in a smarter way, that for 20 numbers, do this activity repeatedly 20 times. So that is another way I can express it. All right? And that shows that I can specify very clear steps by which the problem can be solved. And since I can specify the steps, clear steps through which the problem can be solved, this problem can be solved by programming. Okay. I can program a machine to solve this problem. So, similarly, say how many times, the second problem that we had looked at, how many times a particular word human occurs in a particular text. So I have to do something like this. I have to open the text. I have to see, look at the text and read a word and see, is it human? No. Is it human? No. Is it human? Yes. So I'll have to have some sort of counter, some sort of a counter or count, which I'll increase every time. I'm sorry. Every time I encounter the word human. And this will go on. This will go on as many times for every word in the text. So I can write that down as for every word in the text. If the word is human, increment, count. So this will go on only if the word is human, I'll increment the count. Otherwise, I'll go on reading the word. So this is a very clear step, which I can express to the computer in its own way so that it can find out how many times the word human has occurred. Now, there are different other variants of this that I had told you that whether it's a human being or whether it is an equivalent man, woman, boy, girl, whether it refers to a human being or not, then obviously the instruction will be a little more complicated than this. So in these ways. So I once again come back to my statement that what are the problems that I can solve using a computer? I can solve the problems where I can enunciate. I can express the clear steps, set of steps, one after another, by which I can solve the problem correctly. Okay, so that is now, for example. Now if we take the example of that, searching in a maze where I was trying to use the diagonal, up, down, whichever, there. Also I can express some intelligent ways by which I can instruct the computer to approach the problem. But everything, as I said, do not render themselves to such enunciation of very clear steps. I don't really know. I really do not know exactly that. Maybe either the problem is not well understood. I mean, a student, a friend of yours, is feeling depressed, is not feeling well. Now there may be, you really do not know exactly what is the reason for that. If you know the reason, then you can try to solve it. Help him out. Now, when the problem is not well understood, then of course we cannot solve it through such clear steps. If the information that you are getting are not very reliable, then also there are ways and means by which we can think of how we can get a good enough solution. Another thing is that there are some things which we do not know. So we cannot solve that using programming. Or maybe some cases where the problem is so complicated. For example, solving the problem of hunger. All right, now, obviously, if you say buy food, give food, by that hunger will be solved. Now, that's too simplistic solution. And that's not a realistic solution. There are many angles, many interacting variables which are working towards that. So that is not directly amenable to solving using programming. So, however, we have been able to give an idea of the category of problems which can be attempted to be solved by programming. And I have also said, what is programming? Once again, programming is the set of instructions. I'm rewriting it in different way. Set of instructions to be provided to a computer to solve a problem. Now, a computer is an electronic machine. Till now, what I was doing, I was writing the set of the statements in the form of somehow like English, so you could understand that. But a computer, being an electronic machine, will not be able to understand that. An electronic machine is made of switches. So since it's made of switches, it will understand only. It understands only zeros and ones. Okay? So whatever I say, get, number. Now, each of these get and number, there's one simple instruction, or you can always understand this. All of you can understand this. But for a computer, I'll have to somehow write it in the form of some zeros and ones. So maybe something like this. Suppose this is representing get and number can be this. N-U-M-B-R. That number can be, say, 110-0101 something like that. So that's a completely different type of expressions, alphabets. So the way we are writing it here cannot be directly understood by the computer. I think in the last lecture I had mentioned that how to let the computer know the steps. Now, if I want to let somebody know of I want to express myself to somebody, I must do it in the form of a language that he or she understands. For example, whenever I am talking to a french person, I love to talk in French. Otherwise he will not understand if he doesn't know other languages. Right? Similarly, if I encounter an alien, for example, I'll have to talk in his language or I'll not understand his language. Therefore. But how do you do that? If I meet a person who doesn't understand my language, the natural solution is that we'll have somebody who will be acting as an interpreter who understands both my language and the other party's language, so he can understand my language and convert it to the other language. So what is the other party's language? So what are the parties here? Let's see. On one side it is we who want to do something. On the other side, we have got this machine called computer. All right? This machine which is lying in front of you. All right? Now I have to communicate with this machine, and this machine will have to communicate to me and this communication, but this understands. Its world consists of zeros and ones, and my world consists of abcds. And with that I can say Apple. But this apple to this machine is something like that. So I'll not understand this to be Apple, and he will not understand this to be apple. So there we need some sort of mechanism. That is, this is the translator. Okay? Some sort of translation is required. So we will be talking about this translation process in the next class. But before that, let's summarize what we have learned till now. We have seen that there are problems which can be solved by computers and there are problems which cannot be solved by computers. The problems which can be solved by computers, in order to solve them, we have to express the specific steps to be followed for solving that particular problem. We have to express that to the machine. We have to express that to the machine in its own language. Somehow we have to express it in its own language. And this specific steps, the steps that to be followed to solve a problem, this is also known as algorithm. Algorithm consists of the specific steps or the methods that have to be followed in order to solve a problem. In the next lecture we'll see how we can express these algorithms. How can we express the algorithms? Okay, that's what we'll do in the next module, next lecture. How can we express algorithms? There are different ways. Even I mean when I say how can we express algorithms? Not to the computer, but maybe I want to communicate an algorithm to you or you want to communicate an algorithm to me. I was showing some examples in which I was writing in English. So there are different ways of doing that. We'll discuss that in the next class. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
IF-ELSE Statement (Contd.).mp3,"Welcome. In the last lecture we had looked at the nested if else structure. Today we'll continue with that discussion. So here is an example that uses the nested if else structure. Here you can see again. Let us come to the programming fundamentals in C we have got just for revision, we start with an include stdio h and then we have got the main function. Inside the main function we declare three variables, a, b, and c. And probably you might have guessed now that we are again trying to find out the maximum of the three integers a, b, and c. So what are we doing next? We are first reading the three numbers from the keyboard. Right. Scanf percentage d, percentage d percentage d. Then a, b, and c preceded with an ampere sand. And you know why this ampere sand is used. That is the address of the location. A, b, and c. Now comes the main logic here. If a is greater than equal to b, a is 25, b is 20. So if a is greater than equal to b, then I check whether c a is greater than c. So this is passed. Then I check this. So if a is greater than b, then I proceed to do if a is greater than equal to c. If that is also true, then we print the largest number is a. Okay it otherwise. Otherwise what? We don't know as yet. So if a is greater than b, a is 25, b is 20, c is 15. In that case a is greater. But suppose c is 30. Then what happens? A is greater than b. True. Then I come and compare a is greater than c. This part no false. Therefore this else is with respect to this nearest if that we learned in the earlier lectures. So if this fails, then we print the largest number is c because a was greater than b, but a is not greater than c. Therefore c must be the largest. Okay, now if a is not greater than b, suppose a is 20 and b is 25. Then a greater than b. This fails. This fails. Then I am not entering this block at all. I am straightway going to this else. Then I am checking a is not greater than b, but therefore b must be greater than or equal to a. Or not even equal to b must be greater than a. Then I check if b is greater than c. Suppose b is greater than c. Then the largest number is b. Otherwise, if that is not so, b is not greater than c. Suppose c was 30. Then this else will come because this if will fail. Therefore I'll print again the largest number is c. So I would suggest you to work it out yourself. And I can also write the same thing if you consider that this if a is greater than b, then if a is greater than equal to c, tell me if I write it in this way. If a is greater than equal to c, and. And that means and a is. Sorry. Here I write a is greater than equal to b and a is greater than equal to c. Printf f. This line, largest is a. Else printf largest is c. So do you think that these two are equivalent, these two nested ifs and this logical operator. Now here, I should have put a parenthesis here. Please note, I need a parenthesis here. It's better that if I put it, it becomes much clearer. Are these two equivalent? If you just think a while, you'll find yes, they are equivalent, because I am computing this and then I am computing this. If any one of this is false, I'll not be executing this statement. Right. So this is an example of nested f. We can have many such examples. Let me give you one example. Let's work out right now. Suppose I am trying to see if a figure is a triangle or a square or a rectangle or four sided figure, whether it's a triangular figure or a quadrilateral figure. And if it is a triangular figure, then I want to see whether it is isosceles. That means two sides are equal or it is not isosceles. Suppose that is what I want to do. So how can I proceed to do that? How would I write the logic? Let me just only write the relevant part. I have done some. The declarations are here. And then I have done scanf percentage d. Number of sides. All right, number of sides. So number of sides is a variable. And then what I can do, I check if number of sides is equal to three. Then I'll be doing something. All right, because in that case it will be a triangle. Then what do I do? I then read, that is Scan f the three sides of the triangle, percentage d. And suppose all the sides are integer has got. All the sides have integer values. All right. Five, six, five, something of that sort. That's why I'm putting percentage d. Then I am reading the three sides and a and b and c. Semicolon. If a is same as b, or you remember, this is the logical order, a is the same, equal to c, or b is equal to c. Then what can I say? Printfills backslash n as or common practices. If any of these conditions are true, either this is equal to this or this is equal to this, or this is equal to this. Then it is isosceles. Else I'll print. Say, I am writing in brief, not isosceles. You can write in a much better way. Remember this, double quotes. We complete this. Now. That is the now. I complete this now. This is the if part. If the number of sites is three. If the number of sites is not three, then I don't do anything. I'll come at this point. Because this. If you will fail, I'll come at this point. I can say here. Can I write here printf, not a triangle. Can I do this? Just think, because here I have checked that the number of sites is three. If it is number of sites is three, I'll do this and print. And otherwise I write it here. Is it all right? If you look at it, you will see that there is a problem here. That if the number of sides is three and then it checks whether it's isoclescellus or not. And then it comes out and again prints. It's not a triangle. I don't want that. So what should I do? How can I avoid this problem here? You must have guessed. Now here I have to put an else that goes with this if. All right. And then if this is not true, then only this will be executed. Otherwise, some point down the line here will be executed. Another thing that I'd like to mention in this case. Look at the use of this parenthesis. Why was this parenthesis required? Because I had more than one statements for this if condition. If this condition is true, then there are more than one statements. Now here is a puzzle. How many statements are there inside this block? How many statements are there? 1234. Let's see. Here is one statement. Scanf. So one. And then this if statement, you see goes up to this. So that is one statement. But here I am using. I said that if else is a structure. So this entire thing is a statement. So actually I have got two statements. Since I have got more than one statement, I had to put these braces. Now suppose, of course, then the program will not work here. Suppose I had not written this statement. This statement was not there. All right? This statement was not there. In that case, I could have done away with these braces. Because then it is within this if statement, there is one statement only. This brace was not essential. Okay, so you could see this and you can practice. And in the assignment we will also give few programs that you have to do using this sort of if else type of structure. So now, ah, here is. Here is the example that we did. Now there is a problem here. There is a danger. I'd rather say you have seen earlier when I was writing, I was writing if a is equal to b, then I was doing something right. Now, this is very important. That's a common point of source of, common source of error that often, because we have learned to say equal to like this, we can write in this way. Now the problem is, if I write it in this way, when a compiler looks at this, what will it assume? It will see that it's an if. Often you will not find that it will cause an error, because what the compiler will think is, well, what is the meaning of this? A, this means a is assigned the value of b. So it will try to successfully, it will try to transfer copy the value of b to a. All right, and this operation will be executed successfully. Now, if x in a expression is computed successfully, what does it return? If you recall, it returns a one and one means true. That means this condition will evaluate to true. Okay, I once again repeat. Now, we can use any expression that produces a value in the control structure. Now, if it be a non zero value, then it's true and zero value is false. So if I write if a plus B plus c is, they will just be added, but there will be no assignment. Suppose I make it more meaningful. Suppose I make it z, sorry, Z assigned. Let me clear this up. I write Z assigned, a plus B plus C. All right, then this, there is a problem here because there is no semicolon here, right? So this will be, suppose I do this. Now, this will be computed and this assignment will be done. And this assignment will be done successfully. So anything that is done successfully will return. This will be equivalent to if one, if one means it is true. And so what will be printed? Printf a will be executed. This will be printed. Now, similarly, I can say, let's see, I just write if there, and something, what does this mean? Semicolon, nothing. Before this, we call it a null statement. That means I have not said anything meaningful, but it is still a statement. Remaining silent is sometimes a set statement. Now, this means that this is always true. This will always be true. So this is equivalent to if one, this, that means always, you do this statement. Whatever is here, you do it always. All right, so this is an interesting thing in c. However, sometimes, you know, it varies with the compilers. Also, some compilers take care of such situations and may give you a warning. Some very few compilers can also give an error. Now let's look at this. This example, sorry, this example, if paycode is equal to four, what does this mean? This means if the paycode is four. This is a logical equality. If this is true, then we'll print. You will get a bonus. Now instead of so I want to do like this. This means that I am coming here. I am checking paycode in non C language. Is paycode four? Yes, I do something. No, I do something else. But if I had written it in this way, what would it mean if paycode assigned four now, paycode being a. Suppose paycode is an integer type of variable. Then this can be assigned the value four successfully. And anything that is done successfully, this will result in. If done successfully, one do this. That means it will be successfully executed. It is not doing what you are intending. So sometimes we are saved by the compiler when it points out that, okay, note here. Here is something, some syntax error that you are committing. All right, but there are situations when we unintentionally can do such mistakes which will go unnoticed by the compiler, and the result that we'll be getting may not be what we desired. So this is a very critical point. You should keep it in mind for all programming languages. You'll find there are such nuances, some specialties which you'll have to keep in mind. Okay, we are just mentioning here the ones for C, but if I had done it in this way, it would be okay, right? So generalization of expression evaluation in C is assignment operator is also a part of expression that we know. Now let's see here. I is assigned three. So typically some compilers, what they do. Till now I was saying that if an instruction is executed correctly, it will return a one, but generally speaking, it will return the value that has been assigned. So typically here I assign three will return the value three after assigning it to it. But for us, when we do what we are bothered about, if the condition this part is. Sorry, I'd rather now say this part is zero or nonzero. If it is nonzero, then it is true. Okay, I was saying if one, then it's true. If three, that's also true. The only falsity will come if it is zero. Okay, so this returns the value three after assigning it to I, and then. So let's look at this code. I'll give you 1 minute to look at this code and think what this code will do. What will be the result of this. Look at this code carefully, then we'll analyze it. You can see that here we have initialized a variable I to four, and j has just been declared but not initialized. So here the picture is something like this. I has been initialized to four and j can have something. But I have not initialized anything. Now, here, if this statement, what will this statement do? First, the condition part that means within the bracket, this part will be evaluated and what will happen? What is this? I is being assigned three, so this will be three. And the value that will be returned by this execution of this statement will be three. Then j will be zero, then j will be zero, else j equal to one. That will never come. Because this will be done successfully. This will never come. So the output will be output. I have not given any printf here, but this j value of j will be zero. Okay, so what will be the value of j? Whatever be the value of I, j will be zero. Right. Now, instead, if I had written it correctly, correctly means if my intention was that if I is equal to three, j should be zero, otherwise j should be one, then I should have written it in this way so that if I is equal to three, then j will be zero, otherwise j will be one. So this is a very important point that you have to keep in mind, and gradually, with practice, you'll be okay with this. So more about expression now, here we introduce two new expressions. Typically when we write suppose there is a variable I and the variable I has got a value five. Now, if I want to increment the value five, I. If I want to increment the value of I, I'll write I assigned I plus one, or if I want to decrement the value of I, then I can write I assign I minus one, but c allows us or gives us one special increment and another special decrement operation. So this thing I could have written also as instead of this part, I could have simply written I plus plus I plus plus means I is assigned I plus one, and this one will be I minus minus. All right, so this is known as the decrement operator. This is known as the increment operator. Sometimes it becomes handy to write it in this way, but if you are new in programming, I personally would discourage you because you should not get ground in the special features of a language initially. Okay, better you go by the standard features because these features have got some more complications, which we'll come to later. But you may know that this is an increment operator, which is equivalent to this, and this is a decrement operator, which is equivalent to this. All right, so this is. I can write it in two ways. Sorry. I plus plus or plus plus I. The reason why I discourage you to get into the usage of this initially will be evident soon. If I write I plus plus, it means this is called post operation. This means pre operation, a prefix operation. Okay. We'll soon see what that means. So I can have plus plus I or minus minus I. That is a prefix operation. All right. And postfix operation is I plus plus and I minus minus. Now, plus plus I means first increment or decrement, depending on whether it's plus or minus, and then use it in the evaluation. For example, suppose I have got the value I here as five, and I write x assigned plus plus I plus z. Or let me make it a constant. Let's say z is five. Then what will happen? This is what this is a pre increment. I first increment I and then do the operation. Now, this has got a precedence, of course, over this. So first I will be incremented. So I'll be six and z was five. So the result will be z. X will be eleven. But if I had done written it, x assigned I plus plus z here. Also, I'll first increment this six, and then z will be added to that. But there are situations where we'll do it after computation of the whole thing. I think I'll need a separate session for you to explain this clearly. We'll do that in a more careful manner. Let's look at this here. Int t. T is an integer and the value of m is one. T assigned plus plus m. That means what? M was one, and m is first incremented and assigned to t. Therefore, t will be two. All right, again, if we do it like this here, then. Yes, here it makes the difference very clear. I'm sorry. T. Sorry. Here, you see, m was one. And what I have done, I have put the assignment of. I have done a post operation. Post fix operation. That means first I'll be doing the assignment. First I'll be doing the assignment, and then I'll increment. So what will happen? M was one here. So the first. This one will go over here. So t will become one. Right? And then before I complete this operation, I increment m, so m becomes two. All right. So we'll see more examples of such things in the subsequent lectures. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Implementation of Loops with for Statement (Contd.).mp3,"We were looking at a new construct for building up loops in c language. And that construct is a four construct. Um, so let me first write a simple program again, the same program that we are writing for reading, for finding the sum of ten numbers. So just I am writing and you try to follow what the meaning of this program is. Then we'll go and further explain it. My intention is to read n numbers and find their sum. The simple thing. How can I write that? So I put a variable again, sum is zero. Okay. Um, it. And I have read some value, n, whatever that value is. Suppose, say n equals five. User has provided me. Or I can initialize it to five. So five numbers I'll read and add. Now I write for I. What is this? I. I is an control variable, or we also call it as very common name of. This is an index variable. Index variable. It need not be I. It can be anything but an integer variable. So that has to be declared at the beginning. Okay, so I can declare. Let me start with normal declarations. Int. So some program has started. Main, int, sum, I and the number that I'll read. I'll see if I need any other variables later. And also n. Sorry. Ah, and also n. And here I do sum zero. N equals to five. Now this thing I could have read from the user. Could have taken from the user the value. How could I take it from the user? By doing a scanf. Scanf. Printf. Please enter the number of numbers you want to add. Then scan f percentage, d amperes, and n. In that way I could read this. But here, for the sake of saving time, I am just initializing it. N is five. Now, what I do for I, this, I equals one semicolon. So this one complete statement. I less than equal to n semicolon. I plus plus. What does it mean? We'll see what it means. Then what would I do? I will printf. Please enter a number. Let's say integer. I call it. Please enter an integer. Scanf percentage. D num. Ampere. Sand num. Okay, then sum assigned sum plus num. That's all here. I don't have to increment this control variable. Why? After I add the number that has been read here, after I add that with sum, I am going back to this for loop. And where am I going to? I am now doing this operation that is incrementing I. So I will become. It was. I was one, so I will become two. Okay. And then again, I add the number. After I make I equal I increment I. So initially I was one here. So what is happening? Let's look at what is happening to the control variable of the index. I was one. I do it once. So the sum becomes number. Suppose the number was five. Suppose the number was five that was entered. Okay, so the sum becomes five. I increment I. So, I becomes two. I check. It is less than five. Less than this n. I again, read another number. Suppose I read seven as a second number. So, sum becomes five plus 712. And then I go back here. Increment it. It becomes three. All right. I check again. After doing this, I come here, check. It is still less than five. Okay, so less than n. I again, do this. I did another number. Suppose it is twelve. So twelve plus twelve will be 24. Here, increment this. So it becomes four. I still go over there. Still it is less than five. I read the next number, which was six. Say so sum becomes 30 here. Then I is incremented to be five. I again come here and check. That is less than equal to n. True. So, I come here. I did another number. Say ten. Sum becomes 40. Come back here. I becomes six. I come at this point. This condition is not true. Therefore, I'll come to this point where maybe I'll be writing something like printf percentage, d backslash n sum. So the sum will be printed at this point. Okay, 40. So now, you see, I have read how many numbers. 5712. 610. Five numbers. And that's what I wanted to do. Now, I can look at this. Now, I could have done several this thing in a different way also. For example, if I had just. Instead of this, I equal to one. I make it. I initialize this to be zero. All right. I initialize I to zero and keep everything the same. What will be changing? N is five. So here I will start not from one, but from zero. So first will be zero, then till one. Then it will be two, then with three, then be four. Then will five. So ultimately, how many numbers would I read? Six numbers. But I was actually trying to read five numbers. Okay, I'm sure you are confused, so let me show it in another. Through another example. Suppose I want to read three numbers. If I write it in this way, for I. Now, by the way, it need not be I. I could have written. Declared it properly. And I could have taken any variable to be my index. I could have said that it is my index. But the only constraint is that this must be an integer variable. My index is zero. Note the semicolon here, because this is one statement. Then I write my index. Less than equal to five. Say less than equal to. I'm trying to read three. So my index is less than equal to three. Semicolon again. And then my index plus, plus. And I just read the numbers. So I am dropping off the printf, just writing scanf percentage d and num. Now, since it's only one statement, I can simply remove this parenthesis. Okay, now let's see. I wanted to read three numbers. Now, what will happen here? I write my value, the value of my index, and the value of num. Myindex has been initialized to zero. And I check with my index. I check with this statement. It is less than equal to three. So I read the number. Suppose the number is 15. I increment my index. So my index now becomes one. All right. My index becomes one. Still less than equal to three. I read another number, five. Next, I come here. So I do this and come here. And my index becomes two, still less than equal to three. I read the number, say 14. I again come here. My index becomes three. Less than equal to three. I read another number, five. I come here, my index becomes four. I compare. This condition is not satisfied. So I come out of this loop. But in the process, how many numbers have I read? I have read four numbers. 1234. But what was my intention? My intention was to read three numbers. So where did I go wrong? Where did my logic go wrong? This is what, as a programmer, you must be very careful and cautious about where did I go wrong? You can say that I have gone wrong. In either of the two places one is, I could have simply initialized my index. Not with zero, but I could have initialized it to one. In that case, what would have happened first? This part we forget. We'd start with my index. One read one number less than three. So then it become two. Less than three. I read the other number, increment it. It becomes three, still less than equal to three. I read this number whenever I come to four. Then my index becomes four. This condition is violated. So I'll not be reading this number. It would be all right otherwise. Another thing I could have done. What could I have done? You must have discovered it by now that suppose I had kept my index to be zero. I decide, no, I like this circular figure zero very much. So I keep it like that. Then what should I do? In order that I can still be logically correct, I would have changed this condition from less than equal to. To less than. Then let's see what would have happened then. Also, my index starts with zero. I read one number incremented, so it becomes one. I check for the condition. My index is still less than three. So I read the other number, five. My index is incremented. Two. Okay, still less than three. I read the other number, 14. Fine. As soon as after I read, I make it three incremented, and I check the condition. Now, it is no longer true. It is not less than, but equal to, but less than equal to is not my condition. My condition is less than. Therefore, I'll not read the fourth number. So, this is a point where often people make mistakes while writing for loops. So I encourage all of you to very carefully study this. We'll look into the for loop a little bit more. So we have seen the initial. So I've given you some example, one point that is very important. You must have noticed while I was writing this that there is no semicolon at the end of this statement. Why? Because the for Statement has not ended here. It is going on for this period. Do this. That is the end of the statement. So no semicolon is given for this four conditional part. All right. And here, all these are expressions. You can see that this. I'm sorry, what happened? You can see that this is an expression. Sorry, this is an expression. This is another expression. This is another expression. Now, since these are expressions, it can be very general. For example, I could have written initialization is fine, but here I could have done something I plus p times two is less than 25. That's very much valid. And here also I could have done I assigned, I could have written I assign I plus five. Or I could have written I assigned I times five. Anything. This is a modifier modulator. I am changing the condition and changing the index variable, and then testing that index variable with respect to a condition. Only point that you should remember is that this must be an integer variable. So how it works, the expression one, that is, say, typically I assigned one. The expression one is used to initialize some variable called index that controls the looping action. Expression two, I less than equal to five represents a condition that must be true so that the loop continues. And expression three, say I assigned I plus two. All right, that is a bracket. I assigned I plus two, or I plus plus. As you are seeing till now, they are used to alter the value of the index initially assigned by expression one. One. Okay, we have seen this, so not much to worry about it. So expression one is used to initialize. So here. So what is the way it is done is first, expression one is executed. So for j equals zero. J less than equal to k plus five can be anything. It can be an expression. J plus plus. So first, this expression is executed. Then after we execute this, I check by initialization. Have I violated the condition? In that case, of course, there is no point getting into the loop. I'll go out. Otherwise, if it is not done, then I go inside the loop, carry out the loop, and then instead of going into the loop, straight back. I'll first come to this alteration or modulator statement. So it is. I'm sorry, what did I write here? I wanted to write j assign j plus one here. Okay. Or j plus plus whatever. I do that. And after I do that, what do I do? I immediately come back to this expression and test it again. Is it true? If so, I'll get into. Otherwise, I'll exit. So, this is the structure of the for statement. Okay, now, there are a couple of critical issues, but before that, let's write a simple program with four. Suppose I want to find the sum of first ten natural numbers. What are the first ten natural numbers? 12345. Up to n. So, in school mathematics, you know that the sum for ten numbers, it's the formula is n times n plus one by two, right? So one simple program is, if I want to find the sum of ten numbers, you can simply do in your main int sum, assign zero. And then in one shot, you can write sum assign ten. Because I want to write ten natural numbers. Ten times eleven divided by two, and then printf sum. That could be one way, but that's not what I am going to do. I want to illustrate the for loop. So the way I can do it is main function n. And here I put in int sum equals zero. Now, I know that I'm not going to find the sum of n natural numbers. I'm going to find the sum of ten natural numbers. So I can write it in this way for so in sum equal to zero, another variable I have to initialize. That is my index. I write it int my index. Not necessarily I or j. All right, but it must be an integer. So for. But I'm not initializing it here. For mind x assigned zero, mind x less than ten, please verify whether I am right or wrong. My index plus plus sum assigned sum plus my index plus one. What will happen? Sum was zero. Mind x was zero. So mind x plus one. So the sum will be one. What am I expecting? Ten times eleven by two, right. So that will be 55, right. Sum of first ten natural numbers. Now my index becomes one. So my index is one, now less than ten. I again add that. So sum was. What was my sum? My sum was one. So here is first iteration. Sum was one, then sum was one. I have written it here. So sum plus my index. My index was one. So one plus 01:00 a.m.. I. Right. So here it was, right. Now sum was one and my index is one plus. So two, one plus one. So it will be one plus two. So this will be added. So the sum will be three. Next, my index will be incremented to two. So now sum is three. My index is two plus one, so three plus two, five and one. So sum will be six. Okay. In that way, it will go on. And ultimately I'll come to this point where it will exceed ten. And then I can stop. Okay, so here is. Now you can also do that. So sum of natural numbers. You can do that in a loop using the index itself, being updated and creating the different natural numbers every time. So if I had written it in this way for I equals one, that's the first one. I less than ten. Less than ten. Would that be okay? I plus plus sum equals sum plus I, what would have happened? I is one. Sum is one. Right. Now next, I is incremented. I is two. And then sum was one. So that will be added. Sum is three. Again, this will be added three. Sum is four. Sum is three. So then it will be six. Again four. Then it will be ten. In that it will go on, ultimately. So suppose I was trying to do it for five numbers. So I just. I less than five. First, five natural numbers. So, sum is five. So now four I have already taken. Now I plus, first it becomes five. But I'll get stuck here. So if I start it with one, what should I do? I just did it in a couple of moments earlier in the earlier lecture. So what should I do here? I should make it I less than equal to five. In that case, I'll take this. Ten plus 515. So five natural numbers. Sum of five times six by two is 15, right? So I can compute that using this loop. All right, so that is a very interesting application. So four is a very powerful. We'll see in future application that Ford is a very powerful construct using which we can do many things. Okay.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Implementing Repetitions (Loops).mp3,"We were looking at c constructs by which we can achieve repetitions or loops. That means a set of statements will be executed repeatedly for a fixed number of times. Okay, so one of such constructs that we came across was the while statement, as is being shown here. While, and you can see the structure of this, that while a particular condition is true, we'll carry out a set of statements. It can be one statement, or it can be a number of statements, as is shown here. A number of statements will be repeated as long as this condition is true. An example that we had seen in the last lecture was this. That is as long as I can read this, while as long as. All right, as long as the weight is greater than 65, you'll have to do exercise. All right, and here you again check the weight, and if it is greater than 65, you will carry it out. Okay, that is the structure of the while statement. Now, how can we use it fruitfully? Let's take an example of using the while loop for some meaningful computation. For example, I want to add ten numbers, the example that we are doing. Earlier, we had shown the pseudocode for that. So I have got a value n. Let's see. Let's do it for a smaller number. N equals five. So I'll carry out the sum of five numbers. Okay, so I will have a count, another variable count, which may be initialized to zero. Okay, now we can write something like. So, initially, count is zero. Count is an integer. Count is zero, while count is less than n. And also I do another thing. I am going to add five numbers. So I create another variable, sum. So sum is zero and count is zero. So while count is less than n, I can write a complete program. Now. Printf, please enter a number. And then, so on the screen, on the screen, I'll have please enter the number printed here. Then I am doing scanf percentage d, and num. Num is the variable which I'm reading. And then I am adding, updating sum. Initially, sum was zero, so sum plus num. All right, I do this, and then how many numbers I have read. I have read one number, so I'll do count plus plus. That means count is now one. So one number has been read. So I'll be completing here. Now let's see what will happen. Suppose n was five, so sum is zero. So the first number has been read. So count to a zero. Please enter a number, and some number has been entered. And suppose that number was five. Then sum is sum plus number. So this one becomes five. Then I increment count, so count becomes one. I come back here, I find count is still less than five because I am going to. N is five, right? So count is still less than five. I again do that. Suppose I did the second number, six. So then this becomes here. I add, this becomes eleven, and count becomes two. Please note that count in this case is therefore keeping a count of how many numbers I have already read. Because I am reading the number here and then incrementing count. So count. Now I've read two numbers and I have added the sum, okay, so now after doing this, count is becoming two. I have read two numbers. I again go here. Now, two is less than five. I take another number, say eleven. So I add sum, so it becomes 22, and I increment count. Three. I have read three numbers. I go up again here and read the fourth number, 15. Add that with sum. So 22 plus 15 will be 37, and then count will be upgraded. It will become. So I have read four numbers. 5611 15. Now I again go up here and check count. Count is 15, sorry, count is four, which is less than five. So I read another number. Suppose that is seven. I come here, add it, it becomes 44, and I increment count. I first add that number, so it becomes 44, and then I increment count. So count becomes five, meaning that I have already read five numbers. Now when I go back here, I check, is count less than n? No. Therefore I will come out of that. And maybe here I'll write something like printf. The sum is assuming integers is percentage, d, backslash, n. And here I print sum. Okay? And whatever I do here are the other components of the complete program. Declarations, integers, and all those things are there. All right, now, a point to be careful about. I must be very careful about expressing the condition. Look here. If instead of this, if instead of this, I had made it less than equal to n, then what would have happened? If instead of count less than n, if I had written count less than equal to n, what would have happened? After count is five. That means I have read five numbers, I have added five numbers, and 44 is my result. I would again go back here and I would find that count is less than equal to five. Count is five. Therefore this condition would be true. I would again come and would have read another number. Sorry, I shouldn't cut it out. I would have read another number, and then count would be incremented six. I would have 45, which would be a wrong result. Because here, actually I have read six numbers. So you must be very careful to specify this particular statement so that the number of times you want the loop to work should be accurate. Should be correct. Okay, so, I think you have understood this example. A very simple program, but some care is needed about this. So, that was an example of while statement. So, here is another example. Suppose the digit is zero. What would this one do? Can you find out what this will do? This is a while statement. All of you try to look at it and find out what this loop does. Okay, this while loop does. If you look at it carefully, you will see that I am starting the digit. I have initialized digit to be zero. Now, while digit is less than equal to nine. First time I come here, it is less than equal to nine. So what will it do? Careful. It will come to this printf statement and will print digit. Now, it is a post increment or pre increment. It is a post increment. That means first digit will be printed. So zero will be printed. Then digit will be incremented. So this digit will now become one. I again, go back here and find that digit is less than equal to nine. Right? So I'll come here, print the digit one, and then again, increment, digit, Digit will become two. I go back here, check whether it is less than equal to nine. It is still less than equal to nine. I'll come inside the loop, we'll print the digit two. In that way, it will go on. Ultimately, eight will be printed, and eight has been printed. And I go back after printing eight, this has been incremented to nine. I go back here. Now, you see here, less than equal to nine. Therefore, I will still execute it. That means I'll print nine and then increment it. It will be ten. And then when I go up here, this condition is no longer true. Therefore, I'll come out of this loop. Okay, so what will be printed? Zero to nine. The ten numbers will be printed. Okay, so that is how the while loop works. So, this flowchart is very important to remember what while does. You have actually understood it by now. But the key point to note, the most important point to note is this, that when I am executing the program in this direction, I first compute the condition. First I compute the condition, and if the condition is true, I execute the body of the loop. Then I again, go up, go up, take the condition, and this will be going on. So, first the condition is checked. If it is false, I'll go out of the loop. So if initially, say, for example, I write something like this, say, digit is equal to 20 and I start something like while digit is less than equal to 15, some things I'll be doing now, in this case, when it comes to this condition, at the very beginning, it will fail because this condition is not true. So it will come out through this false path and this loop will not be executed. We'll be just coming to the next statement after the loop. Okay, so, in while the condition is first evaluated, and depending on the success of the test of the condition, will either enter the loop or will bypass the loop. So this flowchart is very important. Now, we will be contrasting while statement with another statement, which is the do while statement. What is the difference? Looks like very similar. So there is a scope of confusion. While and do while. So as the name implies, here do comes first do something and then check the condition. What it means is say do some statements here while condition, you will do all these statements and then check the condition. So let's see what will happen here. The weight loss program again rewritten with while is do go exercise. So you start with a do you do go exercise? Printf, come back, whatever. Then read the weight. And while weight is 65, so at least the condition is being checked here. The condition is being checked here. So it will at least carry out the computation once. So that digit thing, if we do, suppose I write something like this. So digit is 20, and I write while digit is less than equal to 15. Say I do digit plus plus printf f digit. Now, in this case, since the digit is 20, what will be printed here? Nothing. All right. Or say, say, let me make it even simpler. Let me make it a little different. Digit is 2015. Digit plus plus percentage d backslash n digit. If I do this, since digit is 20, what will be printed here? 20 will be printed because this plus plus will not be executed, right? Because here it will fail. But if I do it now, if I do it as digit equals 20, do I need to give the bracket? I may or may not, but let me just give it. It really does not matter. Digit plus plus while digit is less than 15. Less than equal to 15. And here I write printf percentage d backslash n digit. All right, what will happen? Let's contrast this here. Also, digit is 20. Here also, digit was 20. Now here it was tested at this point. So this digit plus plus will not be executed. It will straightway come here and will print digit. It will be 20. Whereas in this case, I first encounter this do. And as I do, I check this digit, I make this digit plus plus. That means it becomes 21. And then I check while digit is less than equal to 15. Now I find digit is not less than equal to 15. Of course I'll not do it again, but once I have already done it. So when I take the printf, digit will be printed to be 21. So here is the difference between while and do while. So these are two constructs by which just two example constructs by which we can carry out the loop. So at least one round is carried out. So if I look at the flowchart, it will be looking like this. It will have a set of statements which will be executed at least once, whatever the condition. B condition is. So this will be executed first. It will be first executed here. And then we check the condition. If it is false, I'll not do it again. I'll come out otherwise, I'll repeat. So here again, that old example digit was zero. Do printf digit plus plus while digit is less than nine. So you remember in the earlier case, we had printed zero. One, two, three, four, five, six, seven, eight, nine. Now, what will be printed in this case? Let's see. Digit is zero initially. Now we come here. First we print digit. So zero is printed. Zero is printed. Then digit plus, plus is done. So digit is one. Right. So digit now becomes one. Digit was zero, so it becomes one. And then I check, is digit less than nine? Yes, it is less than nine. So I, again, print digit one is printed. Let's make this nine. Let's say that is five. All right. Let's say it's five. So we have done make it one. And after printing one digit has been made two. Plus, plus has been done. I check again. It is less than five. So I'll go to the loop again. I'll do it again. So I'll be printing two and then make digit to be three. It is still less than five. I'll go again. I'll print three. And then I make digit to four. Still less than five. I print four. I make it five. All right. Less than equal to five. Right. So I print five. Okay. Print five. I first print five and then increment it to six. As I do it. I increment it to six. And then I check whether it is less than equal to five. So if it is, since it is less than. Not less than equal to five, I'll come out of the loop. So what I'll be printing is 012345. Okay, so this is an example of while. Do while. Next. So this is one type of statement that we have encountered here. That is, while and do, while here we are not prespecifying any number of times that it will be doing. As long as a condition is not met, I'll be doing it. Now, how is it that the condition is being affected? It is through the computation inside. So for example, the computation here, this plus, plus that's being done by that. This condition variable is changing. All right. There are cases where I know a priority beforehand. I know beforehand that I'll have to carry it out ten times. I'll to carry it out 20 times, so and so forth. Okay. So for that another construct is very important and is used in C language. That is the four construct. We'll come to the four construct. This is a little complicated. You should pay attention. There are three components of this four. One is an initial value. Now, this initial value can be assigned to a control variable. So there's a loop, a program, and how many times it will loop. How many times it will loop that is being determined by some control variable. In the case of while, what was our control variable, say for example, in the case of earlier example, the value of digit was the control variable. Here we put some control variable and initialize the control variable with some value. Here some control variable is initialized. Okay? And then we have a condition. If that condition is true, then I'll enter the loop and do that. And after doing this loop, I have got some iteration parameter by which we update the control variable and check the condition. Okay. In that way it will go on. So let's have a look at the structure in a little more detail. Say here we have got some initial expression, some condition and iteration. And we have got some statements which will be looping. Okay, here is an example. Say I'm calculating the factorial of ten. So I'm trying to compute the factorial of ten. Some people write it in this way. Some people write it in this way. All right. Now here what is being done. I'll explain it in a little bit more detail. Fact is, a variable which is standing for factorial, it is initialized to one. Now, you know, factorial of five is what, one times two times three times four times five, right? So I'm starting with some variable and multiplying it with its successor. And then the product I take and multiply with the successor of the last integer. And in that way it goes on. So here is a look of how it will look like. We have got a for statement here. And I'm saying for I assigned one. Now this is what I was talking about. I is a control variable here that is being initialized to one. So that is less than ten, of course, because here I'm trying to compute factorial n ten, and then what I do, fact was one. So fact will be fact multiplied by I. What was I? I was one. So it is one times one. Then after this operation is done, after this operation is done, I go and do this iteration operation. Iteration operation. What it is doing, it is incrementing I and I is becoming two. And then before I enter, I just check whether it is still less than ten. Yes, it is less than ten. I'll again do that. So fact will be it was one one times what is I now? Two. One times two. After I compute one times two, I'll increment I, so that will become now three. It is still less than ten. Please follow my pen. It is still less than ten. I go in, compute what was I? Three. So whatever was fact, fact was the product of one and two. So I multiply that with three, and then I increment the iteration variable. It becomes four. Again, I come and check. Is it less than ten? Yes, it is. I go on here, and I multiply it in that way. It goes on and on. Now, ultimately, ultimately it will be. Ultimately it will be like that. 5678. Now suppose I is nine. Sorry. Suppose I is nine. So I come here, I multiply fact with nine. I plus plus, so I becomes ten. I come here. I is still less than equal to ten. Is it's equal to ten. I come here, multiply ten, I plus plus, it becomes eleven. I come here, this condition is not satisfied. I come out. All right. This is the for statement. We'll look at it in a little more detail in the next class. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
improving naive gcd.mp3,"In the first lecture we used GCD as an example to introduce some basic concepts in programming. We will continue to look at the same example and see how to refine our program and explore new ideas. Here was our basic algorithm for GCD, which, as we said, more or less follows the definition of the function. So, we construct two lists of factors for the inputs m and n. So we construct fm the factors of M-F-N the factors of n, and then from these we compute cf. The list of factors in both lists or common factors, and our goal is to return the greatest common divisor, or the largest number in this common list, which happens to be the last one in this list. Since we add these factors in ascending order, so can we do better than this? So the way we have proceeded, we first scan all numbers from one to m to compute the list f m of factors of m, and then we again start from one to n to compute f n. So an obvious improvement is to just directly scan the numbers from one to the larger of mn, and in one scan compute lists fm and fm. In other words, for each I in this list, one to the maximum of m and n, we first check if I divides m. If so, we add it to the list of factors of m, and then we check if I divides n, and if so we add it to the list f n. So instead of doing two separate scans over one to m and then one to n, and repeating the pass, we do it in one scan. But even this can be improved upon if we are doing it in one pass and we are checking if numbers divide both m and n, why don't we just directly check for common factors? In other words, instead of computing two lists and then combining them, we can just directly do the following for each I from one to the maximum of m and n. If I divides both m and n, then we directly add I to the list of common factors. If it divides neither, or if it divides only one of them, then it is not a common factor and we can discard it. In fact, notice that rather than going to the maximum of m and m, we should go to the minimum of m and m, because once we cross the smaller number, we will not get a factor for the smaller number. Remember that the factors of m lie between one and m, and for n lie between one and n. So if m is smaller than n, for example, if we go to m plus one, though it may be a factor of n, it certainly cannot be a factor of n. So our better strategy is for each I in the range one to the minimum of m and n. If I divides both m and n, then we add I to the list of common factors. Here is a much shorter Python program implementing this new strategy. So instead of computing the list fm and fn, we directly compute the list of common factors. So we let I range from one to the minimum of m plus m and n. And remember that Python requires us to give the limit of the range as one more than the limit we want to go up to. So we go from one to the minimum of mn plus one. And now we have an extra connective. It's called a logical connective, and which says that we want two conditions to be true. We want the remainder when m is divided by I to be zero. In other words, I divides m, and we also want the remainder when n is divided by I to be zero. So I should divide both m and n. And if so, we add I to the list of common factors. And having done so, once again we are doing it in ascending order. So the common factors are being added as we go along. The larger ones come later, so we finally want the last element, which in Python is given as the minus one element of the list cf. So having done this, maybe we can simplify things further. Do we need a list of common factors at all? Remember that we only need the largest common factor. We observed that there will always be at least one common factor, namely one. So the notion of the largest common factor will always be well defined for any pair mn. Each time we can start with one, and each time we find a larger common factor, we can discard the previous one. We don't need to remember all the common factors, we only need the largest one. So this can greatly simplify our strategy, because we don't need to keep the list of every possible common factor in this list, we just need to keep the largest one that we have seen, so we can use a name, say mrcf for the most recent common factor, and keep updating this name with the value of the common factor that we saw last. So here is a python implementation of this idea where we don't have a list at all. We directly scan all the possible common factors from one to the minimum of mnn. Whenever we find a common factor, we update the value of our name mrcf to be the current common factor that we have found. Now remember that one will always be a common factor. So initially MrCF will be assigned the value one. It will not be that we go through this repeated execution of this and never assign mrcf because the condition is never true. Since one is a common factor, we will at least have MRCF equal to one. But if we find a larger common factor, the one will be replaced by the later common factor. So at the end of this four iteration or loop, what we end up with is the largest common factor that we found between one and the minimum of Mnn, which is indeed the gcd of MnN. So we can still do some further optimizations. Since we are looking for the largest common factor, why do we start at the beginning, which will give us the smallest common factor? So we can start at the end of the list and work backwards. So instead of running from one to the minimum of mn, we can start from the minimum of mnn and work backwards to one. Again, the guarantee is that one will always show up as a common factor. So if there are no other common factors, at the very end we will find one as the greatest common factor. And in this process, we don't have to ever go past any common factor that we find. If we are working backwards from largest to smallest, the very first common factor we find must be in fact the GcD of mnN. How would we write this in python? Well, you can modify that for I in range. So notice that normally this function goes from a smaller value to a bigger value. You can modify this to go backwards instead. But instead of doing this, which we will see how to do later on when we actually get into formal python, let us explore a new way of going through a list of values. So we start by assigning to the index I, the value that we want to start with, namely the minimum m and n. Remember, we want to start at the largest possible value for I and go backwards. So what we have is a new word instead of for called while. So while, as the english word suggests, is something that happens while a condition is true. So while the I that we are looking for is positive, so while I is greater than zero, what do we do? We check if I is a common factor. This is the same as before. We check whether I divides m and I also divides m. If we find a common factor, we are done. We just return the value of I that we have found, and we implicitly exit from this function. Every time you see a return statement in a function, the function terminates and the value in the return is what the function gives back to us. So we start with I equal to the minimum of m and m, and we check whether I is a common factor. If it's so, we exit and return the value of I that we last found, and this is the only value that we need. We don't need any other common factors. So we return the very first time we see a common factor. On the other hand, if I is not a common factor, we need to proceed by checking the next one, which is to go backwards, and this is achieved by this update. So remember that we said that we can assign values or update values using this equality operation. So this equality operation is not mathematical equality as it looks, but rather it is the assignment of a value. So it says take the old value of I and make it the new value. So it says update I to I minus one, take the current value of I, subtract one, and replace it in I. The mathematic equality is written as double equal to. This is what we use in our condition. So it's important to remember this that double equal to means equality, as in the left hand side is equal to the right hand side, whereas a single equality in Python and many other programming languages means assign a value to a variable. So this is the final optimization that we have of this naive algorithm, which is to basically scan for common factors from the beginning to the end. So now we are doing it from the end to the beginning and keeping only the first factor that we find. So what we saw in this example is a new kind of loop. So this new kind of loop has a special word, while, and while is accompanied by a condition. So long as the condition is true, we do whatever is within the body of the while. Now, notice that Python uses indentation, right? So these statements here are offset with respect to the while. So this is how Python knows that steps one to k belong to this while. So these are the steps that must be repeated. At the end of this thing, you come back and you check whether the condition is still true. If it is true, you do it one more time, and so on. So while is useful when we don't know in advance how many times we will repeat the steps. When we were scanning for the list of factors, we knew that we would start with one and go up to the minimum of mn, so we could predict in advance that we would do precisely that many steps. And so we could use this for loop. So for loop has a fixed number of repetitions. On the other hand, a while loop is typically used when you don't know in advance when you're going to stop. So in this case, we are going to start with the minimum of mmm, work backwards and stop as soon as we find a factor. But we have no idea in advance whether this will come early or we'll have to go all the way back to one, which we know is guaranteed to be a valid factor. So, one of the problems that one could face with a while is that we keep coming back and finding that the condition is true, so we never progress out of the while. So, so long as the condition is true, these steps will be executed, and then you'll go back and do it again. So if you have not changed something which makes the condition false, you will never come out. In our previous example, in order to make the condition false, we need I to become zero. So we start with the minimum of mn. So what we guarantee is that every time we go through this while and we do not finish what we wanted to do, we reduce I by one. And so, since we start with some fixed value and we keep reducing I by one, eventually we must reach zero. So, in general, when you use a while loop, you must make sure that you are making progress towards terminating the loop. Otherwise, you have a dangerous kind of behavior called an infinite loop, where the computation just keeps going on and on without returning a value, and you have no idea whether it's just taking a very long time to compute the answer or whether it's never going to finish. So, in this lecture, what we have seen is that we can start with a very naive idea, which more or less implements the function as it is defined and work our ways to dramatically simplify the algorithm. Now, one thing from a computational point of view, is that though the newer versions are simpler to program, and therefore, to understand, the amount of time they take, is not very different. We are still basically running through all values, in principle, from one to the minimum of Mn. If we start from the beginning, then we will run through all these values anyway, because we scan all these numbers in order to find the common factors. In the last version, where we were trying to work backwards and stop at the first common factor, it could still be that the two numbers have no common factor other than one. So, again, we have to run all the way back from minimum of mn back to one before we find the answer. So, although the programs look simpler computationally, they are all roughly the same, in that they take time proportional to the values m and n. What we will see in the next lecture is that we can actually come up with a dramatically different way to compute GCD, which will be much more efficient.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
insertion sort.mp3,"You. So in the previous lecture we saw one natural strategy for sorting, which you would apply when we do something by hand, namely selection sort. So now let's look at another natural strategy which all of us use at some point. So the second strategy is as follows. We have now a stack of papers, remember, with marks on them. And we have to compute a new stack which has the marks arranged in descending order from top to bottom. So we will take the first paper of the stack we have and create a new stack. By definition, this new stack is now sorted because it has only one paper. Now we pick the second paper from the old stack and we look at its marks as compared to the first paper that we pulled out. If it is smaller, we put it below, if it is higher, we put it above. So in this process we now have the new stack of two papers arranged in descending order. What do we do with the third paper? Well, the third paper can be in one of three positions. It can either be bigger than the two we saw before, so it can go on top, or it could be in between the two or it could go below. So what we do is we scan from top to bottom. And so long as it's smaller than the paper we have seen, we push it down until we find a place where it fits. So we insert the paper that we pick up next into the correct position, into the already sorted stack we are building. So we keep doing this. For each subsequent paper we'll take the fourth paper and insert it into a correct position among the remaining three and so on. So this is obviously called insertion sort. So let's see how it would work. So what we do with this same list that we had for selection sort is we will pick up the first value and move it to the new stack saying now I have a new stack which has exactly one value, namely 74. Then when I pick up 32, since 32 is smaller than 74, I push it to the left of 74. Now 89 is bigger than both, so I keep it on top of the stack at the right end, 55. I have to now look with respect to 89 and 74. So it is smaller than 89. So it goes to the left of 89. Then I look at 74, it's smaller than 74, it goes to the left of that. So eventually it settles down as 32, 55, 74, eightynight, 21. Similarly, I have to start from the top and say it's smaller than 89, smaller than 74, smaller than 55, smaller than 32, so it goes all the way to the left. And finally 64 will move down two positions past 84 and 70, 89 and 74, but it will stop above 55. So this is how insertion sort would build up a new list. You keep picking up the next value and inserting it into the already sorted list that you had before. So we start building a sorted sequence with one element, pick up the next unsorted element and insert it into the correct place, into the already sorted sequence. So we can do this as we did with insertion sort, without building a new sequence. And here is a function insertion sort defined in Python, which does this. So what we will assume is that at any given point we have our sequence from zero to n minus one and there is some position. So that up to this point everything is sorted. And now what I will do is I will pick up the next element here and I will move it left until I find the correct place to put it. So that now the sorted thing extends to this level, right? So we take a sorted sequence of length I and we extend it to a sorted sequence like I plus one by inserting the I plus in the current place. So we are going to take this position, the slice end. The slice end is going to be the last position that we have sorted already. So this is supposed to be slice end. So we say slice end starts from the value zero and goes up to the n minus one's position. And at each time we look at the value at. So actually the slice is up to slice n minus one. Sorry. So slice n is the number of elements that we have sorted. So we look at the value immediately after that, which will be the position called slice n. And so long as this position is bigger than zero, and if the value at that position is strictly smaller than the value at the previous position, we exchange these two. So what we are doing is that we are saying to draw it again. So we have an already sorted slice from zero to slice n minus one and we have this position, slice n. So we then assume that this is sorted. So we compare with this value, and if this is smaller, then we exchange it. Now, if you have exchanged it, that means that this value has now gone here. So now we again compare it to the previous value, and if it is smaller we exchange it. So again this means that it goes one more position. So we just keep going until we find that at this position the value to the left of it is equal to or bigger than this, or equal to or smaller than this. So we should not swap it and we have it in the correct position. Right? So that's what this is doing. So so long as you have not reached the left hand end, you compare the value you're looking at now to the value to its left. If the value to its left is strictly bigger, this one must exchange with that and then you decrement the position. So let's run this the way we have written it on this particular sequence. So what we do is we initially assume that this thing is unsorted. So our first thing is here. And so when we sort it, we just get a sorted list of length one, which is 74. Then we look at this and we must insert it into this list, 74. So since this is smaller than 74, it gets exchanged and we get now a new sorted list, 32, 74. And now we must insert 89 into this list. And now we see 89 is bigger than 74, so nothing happens. So this list now is sorted from 32 to 89. Now we try to insert 55 in this. So we will first compare it with this. And this will say that 55 is smaller than the value to its left. So we must exchange. Now we will compare 55 again to the value to its left. Again we will exchange. Now we will compare 55 to the value to its left, and there's no change. So now we have a sorted list of length four. Similarly, we will take 21, right? And we'll compare it to 89. Since 21 is smaller than 89, it will swap. Since 21 is smaller than 74, it will again swap. Since 21 is smaller than 55, it will swap. Since 21 is smaller than 32, it will swap. But now the position, sorry, will swap. And now the position is zero. So we stop, not because we have found something to the left which is bigger, but because we have nothing to the left. So we have two conditions. If you remember that algorithm, it said that either pos should be positive, the position should be greater than zero, or we should compare it to the value on its left. So in this case we have no value to its left, so we stop. So how do we analyze this? Well, at each round, what are we doing? We are inserting a new value into a sorted segment of length k. So we start with the length zero segment, we insert one value to it, we get a sorted length of sequence of length one, we insert a value into that, we get a sorted sequence of length two, and so on. But in the worst case, when we are inserting, we have to take the value all the way to the beginning of the segment it. So, sorting a segment of length k in the worst case takes k steps. So again we have the same recurrence not expression that we had for selection. Sort says that t of n is one plus two plus three up to n minus one, which is n into n minus one by two, which is order n squared. So again, remember that this is n squared by two minus n by two. And so this is the biggest term. And that's what we get here. So once again, let us see how insertion sort actually works in the Python interpreter. And we will see something slightly different from selection sort when we run it. First, let's look at the code. So this is the code that we saw in the slide. So it just keeps scanning segments, keeps taking a value at a position and inserting it into the already sorted sequence up to that position. So if we start the Python interpreter and say, import this function, and then as before, if we, for example, take a long list and sort it, then l becomes sorted, right? So before l was in descending order, now we sort it. And now l is in ascending order. Now, as before, what we said is that if we try to do this for a length of around 5000, then it'll be much smaller, much slower. Right? So you can see it takes a long time, and that's because insertion sort is again an order n squared sort. So though it does it eventually, it takes a long time, but there's a small difference here. So suppose we do it the other way. Suppose we take a list which is already sorted, and now we ask it to sort, then it comes back instantly. Why should this be the case? Well, think about what's happening now. The list is already in sorted order. So when we try to take a value at any position and move it to the left, it immediately finds that the value to its left is smaller than it. So no swapping occurs. So each insert step takes only one iteration. It doesn't have to go through anything beyond the first element in order to stop the insert step. So actually, if we take even a large value like 10,000 or even 100,000, this should work. So insertion sort, when you already have a sorted list, will be quite fast because the insert step is instantaneous. Whereas this doesn't happen with selection sort, because in selection sort, in each iteration, we have to find the minimum value in a sequence, and with no prior knowledge about what the sequence looks like, it will always scan the sequence from beginning to end. So the worst case for selection sort will happen regardless of whether the input is already sorted or not. Whereas insertion sort. If the list is sorted, the insert step will be very fast, and so you can effectively sort larger things. So in that sense, insertion sort can behave much better than selection sort, even though both of them, technically, in the worst case, are order n squared sorts, so.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Interpolation.mp3,"Today we will first discuss a technique called interpolation. We have seen how a function can be represented in a computer in the form of a table or a two dimensional array. Now, what is interpolation? Let's try to understand. Say I have got a function where I know the, I have got a function which is something like this, but I do not know the function beforehand. All right, if I had known the function, this description of this function, in that case, given any x, I could have found out the corresponding y, right? But suppose the function is not given. Instead, what is given to us are for some specific x's, say x one, I have been given this value, all right, this value of y. For x two x equal to two, I have been given this value of y. All right, this particular value of y. Similarly, for three, I am given a particular value of y, but I do not know what is the value of this function for 1.5. So if I call this to be the function f of x, then f of f of 1.5 is not known, although I know that f of one is, say, something 2.5, I know f of two to be maybe 3.2, f of three, maybe something like four. But these information are known to me. This part is known to me. Given this known part, can I find out what are the intermediate values for f 1.5 f 1.32.52. .6 can I find that out? That is the task of interpolation. That means given some values known, I want to find out the value of the function for some independent value of the dependent variable. So for a particular x, what is the y? That I want to find out. Now, obviously you can look at this blue line and say it's so simple. You draw it like this and you will find the value of y. But unfortunately, what I have is not the blue line. What I have is only the red crosses and this line is not there. I do not know that these three points, whether the curve is something like this or the curve could be, the curve could be a straight line through these points, right? In that case, you see, if it was the case, then the value of x, this particular x, would be different from this. So I have to actually see that what is the curve that best fits all these given points? This problem is known as interpolation. Now, I can extend it. Suppose a table is given to you where values for f, one, two and three are given. And so the range is from one to three. But you are asked for some particular x prime, which is beyond this. Beyond this range. In that case, it's also extra interpolation on the other side. That means beyond the boundary that is known as extrapolation. All right. Right. Now, so basically, the concept of extrapolation and interpolation are more or less the same. So here, what I try to, we'll try to see is given some values of f x, known values of f x for some particular x's. How do we find out the value of f x for some intermediate value of x? That is the task of interpolation. Now, the simplest possible way of interpolating. Now here I had shown a curve. Usually you can also start with a table like this where some x's are given and some y's are, some x values are given, say zero, 1.2.3. Each of them you have got some y value, 2.73.21 .6 coming down. Again, say 0.6. And again it goes up, say 3.2. Now, if this be the table, then my question is for interpolation, what is the value, what is the value for x, which is 00:27 what is the value of this? So that is the task of interpolation. Now, obviously, the simplest possible thing is if I can fit in a line, which is known as a linear interpolation. So I have got some points here, all right? And I try to fit in a line in between them. Or let me do it in a different way, not exactly this line, because this line is matching two points, but not the others. So this is my y and this is x. So there could be some points like this here, something here, something here, something here like that. Equidistant points, say this. And I try to fit in a line that is somehow I draw a line like this. This is a straight line, although my drawing is a little curved, but it is a straight line. So I'm drawing a straight line. So one way is that I try to find out a line such that I minimize the error. So of course, if I assume that this line is representing my function, then I can see there is some error here. There is some error here. There is some error here. There is some error here. I could have fitted another line. Also, I could have changed this line a little bit. One of the ways is to find a line that minimizes the error. Now, it depends on how you define the error. Okay? Here you can see it's a negative error. It's a positive error like that. It can go on. So one way is to find out, minimize, find a line such that the least square or let's see, such that the squared sum of squared error is minimized. That can be one way. That means what is an error? Error is ei, when I take whatever my line is saying, let me call it li. What the line is telling me, the value, let me call it li, and whatever is the actual value, minus yi, if I consider that to be the error or the other way. Now, so you can see it is a positive or negative, and I take the error of all these. So that could be a sum of error. But here, what I am saying is that I can have the square of this error, and I try to find out a line such that ei square is minimized, okay, so that I get a very good line. Now, suppose I get a very good line like this. Then I have the equation of that line. Now, given two points, it's very simple, right? Let's take the simplest case first. So if there be only two points given, then I can certainly draw a unique line between these two points, right? And so I can find out the equation of these. So this is school level coordinate geometry. X one, Y one, x two, y two. So you can find out the slope of this line, right, you can find the slope of this line, which will be nothing but Y two minus y one divided by x two minus x one. So once you get the slope, then you can find out the line. So there are school level equations like Y minus Y one is equal to m into x minus x one, where m is this, m is the slope. So you can find the line. So when you find the line, then your problem is solved, because now, given any particular, suppose you get a line of the equation ax plus c, where c is this, and you get the coefficients like this. Now, given any x, I give x prime. Then from that equation I can straightaway find the value of y ax prime plus c, right? That's straightforward. But the problem is that often it's not only two points, but the points are rather distributed, as I was showing in the earlier one like this, where I do not get an exact line that is cutting through all the points, I'll try to minimize the error and I'll choose such a line. Now, when I choose such a line, that means I have chosen an equation. And therefore, again, from that linear equation, I can find out the value of y for any given x. So this approach is known as linear interpolation. However, the linear interpolation, often, as you can see, the error will be there. So people try to find out more accurate solutions. So we will look at another interpolation. So, first of all, we have seen what is linear interpolation. The basic idea is very simple. We try to fit in the best possible straight line through all the points so that the error is minimized. Total error is minimized. One way is to minimize the sum of the square. Or there could be some other measures you can take for error that should be minimized. So you get a line to your satisfaction. So once you get a line to your satisfaction, you know the equation of the line. Therefore, given any x, you can find the corresponding y. Okay, now, fitting this line, always, there may be situations where the points are distributed in such a way. For example, it can be the points are something like this. All right. It's very difficult to find a line over here. So often I'd like to find out a curve or maybe another curve. Even better. That can be, that goes through these points like this, where I have got errors, but I am trying to fit in a curve. So that is not a line. This is not a linear interpolation. There are further extensions, like quadratic interpolation, spline interpolation, cubic spline, and all those. So it's better to know the names spline interpolation, quadratic interpolation, where I want to fit in a quadratic curve, et cetera, et cetera. But today, we'll discuss another interpolation technique, which is known as Lagrange interpolation, in the name of the mathematician who invented it. So, let's have a look at the Lagrange interpolation. Interpolation, as you have understood, is given a set of k plus one data points, x zero y zero x one y one x two y two. Like that, up to xkyk. So many data points are given. The Lagrange polynomial is this. That is multiplication of. So, I have to find out for a particular x x minus x m divided by xj minus x m, where m is varying from zero to k. For all these, m is varying. So x zero x one x two x three. For all these, I'll do that. And xj minus xm, where j is for a particular Lagdange interpolation. So you see, it's for l one, l one x will be x minus x zero. By x one minus x zero x minus x zero x one minus x zero. Like that, it will go on. All right, so this is the Lagrange polynomial. So, using this polynomial, we can see, let's see how it works. Just to give you an example, I have reproduced that polynomial that I had shown in the earlier slide here, again, you can see this right? Now, suppose I have got the points given. Look here. The points that are given are for x, zero. For x value one. F x is one, for x value two. F x is four, three, it is nine. So I have to fit in a polynomial. I have to fit in a polynomial. So my polynomial is capital lx. Now, each term of this, each term of this is one small l x. So this is l one x. This is l two x. This is l three x, like that. Okay? So you see, the value of x is one. One times x minus x. M will be something that will be not the same as j, so it will be, I have got three points, so I'll not take this one. X minus two divided by one minus two times the second term, x minus three divided by one minus three plus four. Now, I'm taking this one, so it's four. And in that case, I'll leave out two. My xj is now two, so x minus one. I'll not take x minus two here, because look at this. M not equal to j. So for the other x's, I have selected this row. So I'll only concentrate on the other rows. X minus one divided by two minus one, into x minus three, x minus three, the other row divided by two minus three. Here I take nine, this value, and I am taking this row now. So now I am taking this row, right? I've taken nine, so x minus one by three minus one, x minus two by three minus two. If I solve this, I am getting a polynomial x square. Possibly, you can see that is a perfect fit with the given data points. X one, X-F-X is x square, that is one, two, it's x square, four, three, it is x squared, nine. So in this case, there is no error. It's absolutely a perfect fit. So this is how I get the polynomial. All right, let's try once again for these data value. For x zero, it is one. X zero one. The f x is one. For x equal to two, it is eight. For x equal to three, it is 27. So obviously you can see it is no longer x square. All right? It's not also x cube, because here it is cube. Here it is cube. It is matching the cube. It is actually x cube. Right? But let us try to fit in a polynomial here. Right? So what is that polynomial? Using the Lagrange method, I'll first check one. So I'm taking first row, taking this value, one here, then x minus two, one minus two. All right, times x minus three, three. One minus three plus. Next time I take the second row eight times x minus one divided by two minus one. Because here it is, the value is two in that way. For this it will be, for the third row it will be again x minus one, three minus one, x minus two, six minus two. By doing this, I am not getting x cube, which would be a perfect fit. But I am getting a close enough polynomial, six x squared minus eleven, x plus six, which will be approximating the cube function very closely. You can see that. So it's not that Lagrange polynomial will always give you the perfect fit, but it gives you a very close fit. So this is what is known as Lagrange interpolation. So if I want to write a program and try to solve it, I'll have to implement a function that, I have to write a function that will implement this or this. Right. Let's see how we can do that. So here is an algorithm, scan the number of data available. Okay, x and y values. Now, so you take the, here is how many data points. This is telling how many data points. Here you are finding the data. Now here loop for I equal to number of data factor. Then here you are computing this. Here you see what we are trying to do at this point, we have just read the data, and here in a loop we are trying to compute. Here we are finding the sum. But here in the loop, I am finding the factor. So if you go to the earlier slide, you will find that I have got, these are my factors, right? I'm finding these factors, each of these factors, I am multiplying them. This is a factor, this whole thing is a factor. And then I multiply that with the coefficient and add them up. So I am doing the summation at the end. So here you see that I am taking the factor, then I'm taking whatever is the value. This part you can yourself compute, right? The key part is computation of the factor part, where I am showing this part. You can see that for I zero two data, I plus plus. Initially I factored is one, because I am multiplying that. Then if I is not equal to j, I'll take the factor times the value minus the data, and then ultimately I'm printing the coefficient, so you can translate that into in the form of a c function. That is the basic idea of Lagrange interpolation. You can similarly write programs for linear interpolation and other interpolation techniques. So the point of this course is not to, because I assume that you now know how to do programming, and this is a simple loop type of programming, so you'll be able to do that. So whenever you want to solve, apply some numerical methods. You will have to first look at the technique, then try to find out the expression, and you will have to write an algorithm so that you can solve it. Okay. In the next lecture, we'll discuss two other very interesting techniques for integration and differential equation solving. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Introducing Functions (1).mp3,"In the earlier lectures, we had discussed about one dimensional array as well as two dimensional array. We have seen how one dimensional array can be stored, read, and printed, and as well as we saw how a linear search can be applied over one dimensional array. Similarly, we have seen for two dimensional arrays, how it can be read, it can be stored, it is stored in a row, major form, and how it can be printed. Now, today we will start discussing on a very important and vital component of programming, and also a part and parcel of the C language, that is functions. The concept of functions is very general, and we'll have to first look at it from the general angle, why it is required, what is a function? And then we can look at some of the details of this, the implementation of this concept in the C language. So, first, let us start with functions. Okay? So we will start to visualize a task. Suppose I have got a big task, all right, which I have to implement by programming. Now, any task, this is one task. This task may be too complicated, and for any human programmer or any human being to solve this task from the beginning till end in one shot, may be difficult. Often, what we do, we break up this task into a set of smaller subtasks. Right? Different subtasks. And each of these subtasks are smaller enough, small enough so that we can manage it better. Okay. Each of these are possibly better managed. All right, we can say, if you think of a program segment, a part of a program, if the task is broken, big task is broken down into a small task, a number of small tasks, then it is easier to write the program for each of these smaller tasks. And each of these tasks can be independently tested for its correctness, whether it is working properly or not. Each of these can be separately tested, and then if all these are connected together, if all these are connected together, one after another, and then I can ultimately get this entire task done. So instead of addressing the whole task, to execute the whole task, or implement the whole tasks as a single task, it is often advisable to break it down into a number of subtasks. Now, let's talk about programming. Now, if we want to. Now, when we say the term function, function, if we take the english meaning of that function means doing something, so it is also a task. Therefore, this entire function can be broken down into smaller functions, and each of these functions can be implemented independently. So the advantage that we get by this means is that we can divide the problem into smaller parts, and thereby we can conquer the small, we can conquer the smaller subsegments and in the process, we. In the process we achieve the complete task, right? That's the first thing. Okay? So by this, it is easier to implement and also easier to test or verify. We can check whether each of these components are working correctly or not. Now, when we find that all the components are working correctly, and if they are connected together correctly, then we'll have the entire problem solved correctly. That is the first advantage of writing a complex program broken down into smaller functions. Okay? Now the other advantage is, suppose I had to implement one task, and in order to implement this big task, I had to write a number of functions, okay? Smaller functions, say three smaller functions, together. Implement this big function, all right? So let's call them f one, function one, f two for function two, and f three for function three. Now suppose I have. Now, this problem has been solved by solving each of these three functions. Each of these three functions have been written and tested, and consequently they have been connected together and we have got the complete function. Now suppose another friend of yours wants to write another task. Solve another task. Say this was also a task. So this is also a function. I'm writing that as capital f one. And there is another friend of yours who is trying to complete another task which we are naming as f two. All right? Now, in order to develop f two, he finds that, okay, I have to solve some sub problems which are solved by f one. And another sub problem which is solved by f three. Might be that this sub problem requires f one, f three, and say, another function which was not written by anybody till now, f four. Now obviously, since f one has been written and tested, he, the writer of f two, did not write f one. Again, because that f one, this f one, can be used for this purpose. Similarly, this f three can be used for this purpose. And only effort that he has to spend is to write f four. Thus, the functions which are written already, right, can be reused. So this reusability is another very important advantage of writing functions. Now, we have said that in order to solve f one or f two, we will have to independently write and test smallest functions and connect them together. What do I mean by connecting them together? Let us try to understand that. So say we have a function that is to be done, developed, and we find that, okay, this part has to be this part, this task has to be solved by some function. So I write a function here for this part. Let me do it again. This is my whole problem that I have to solve. And so I am solving some things here, some steps I'm solving, and then I find here there is some thing that has to be done, which is not very easy. Okay? So for that I came at this point, and for this I need to write a function, or might be there is a function already existing in my library which has been written by somebody else, which I can reuse now in that case, and also say here, after doing that here, I can do a couple of simpler tasks, and then here I come to another point which requires it to be independently solved and written. So I need a function for that. And then after that, I'll do some more simple things and my task will be over. Say, this is the situation. So when I come here, I'll have to, I means this program, which is the main tasks, main task that I have to solve. So since we have seen the name main in our description for c earlier, let me also name this to be main. And I'm just for nothing, I'm just putting some parentheses here. So main is the main task that I have to do. And at this point, I am doing some things, and here I need the help of this. Now, remember that this function, whose name is, say, f. F. One that can be used by my main function or somebody else's main function also. Therefore, when I need this to be executed with my data, then I must, whatever data I have prepared here that some of that I'll have to pass on to this here, right? And this will solve this subtask, and then I'll have to, that means that this must give back whatever it computed to the main task, and the main task will continue doing simple things here. So you see that there are two links. One is going in the function, another is coming out, or some data that is being returned by this function. Okay, this is being returned by this function. Then I carry out some task, simpler task here. And at this point I find, no, I need help. So some part of the data from here will be used by the function f two. And that has to come to f two here. And f two will carry out the task and will return to the point here. Now, about this return, you should observe one thing, that the function was called from this point. We call this thing to be a function call, okay, function call with some data being passed on to this. And function call or function invocation. And after invocation, this function works and it returns. Where does it return? It returns to the point in the main task just after the point from where it was called. It was called from here. So it comes here and then returns to the next point just after the after this call. So this is the calling point and this is the return point. Similarly, for here you see that it is executing, and at this point it is being called. And after execution, the control is returning to the point immediately after the point from where it was called. Okay, so this is one important thing to understand. The other important thing is that. Let me draw it again. Here I have got my main task, and this is my main. And here is another main task, some other main task, not written by me, but somebody else. This is of Mr. A and this is of Mr. B. For Mr. B, he has written another main. Now, Mr. A or Mr. B, both will require this function f. All right, now, the purpose of what this task does is same. For example, this task computes the average of some numbers. Ten numbers, five numbers, whatever it is, or maybe floating point numbers, integer numbers. Whatever it is, it computes the average. So let me quickly rename it, not keeping it vague any longer, let me call it average. Or for a specific purpose, I want to write it inside. The reason will be clear immediately. This computes the average. Now, Mr. A wants to use this average function for sum data. For three data, he wants to compute the average of three integers. Suppose this one, this one computes the average of three integers, but the integers can vary, right? So this also wants to find the average of three integers. To make it simple, but the numbers for which a wants to compute the average is different from the numbers that b will compute the average for. But this avg is common to both. Therefore, suppose the numbers that some integers, say, are a, b and c. And here this person wants to find the average of three integers which are pq and r, three variable names. Right? Now, this average cannot remember Pqr or ABc. It will simply just like think of a box with three pipes coming in and data will come in through there. So he just names this average for. He names these pipes as x, this is y, and this is z. So when this function main wants to compute the average of Abc, he must send a through the pipe x, b through the pipe y, and c through the pipe z. And he will get the average computed and the average will be returned from the point where it was called. It was called from this point. Immediately after that, it will go back. Clear. Now when? Let me change the color. Yeah. Now, when the function main b wants to compute the average, he wants to compute the average of pqr. So p will be sent to the pipe x, q will be sent to the pipe y, and r will be sent to the pipe z. And the average will be computed. Suppose it was called from this point. From this point, this average was called. So then it will return to this point with the value of the average, with the value of the average, whatever is computed here. Therefore. So if this is clear, then let us come to two more terms. They are that this function, main, a's main, was sending Abc to the function as parameters. We call it as parameters. And this function, which is our average function, is not biased to a, right, it has got, it knows that it needs three inputs and there are three input pipes, three input positions. So this X-O-I-Z are arguments. This we call as arguments. All right? That means this average, when it is written, it has got three input pipes. So we can write simply like this function name average with three arguments, x, y and z. Now, whoever calls it will have to establish the mapping between the parameters that it wants to pass the parameters it wants to pass through to the arguments. So the connection that we had shown in the earlier diagram, which was where both the programs were, both the programs were accessing it. So each of these parameters should, the parameters should be matching with this arguments. Let's come to this once again. Say, so here is main of a, and here is main of b. I repeat what I was saying till now, and this has got pqr. Now you must be, must have realized now what are these pqrs? When I use this function average, which has got three arguments, X-Y-Z which are nothing but three pipes, which are arguments. And when I call from some point, when I call this function average, then I have to pass these parameters pqr to these arguments X-Y-Z. So p will go to x, q will go to y and z, r will go to z, okay? On the other hand, when a is calling, when a is calling, what is happening when a is calling? Then a had the Abc to be passed on to this. So a goes to x, b goes to y, and c goes to z, right? Now, since now if you just think these are three pipes, now the pipes are, every pipe has got a width, right? So if I want to fit a smaller pipe into a bigger pipe, that won't fit, right. So the width of diameter of both the pipes must fit together. What do I mean by that? What I mean by that is that whatever arguments are, whatever are the types of the arguments, types of the arguments that must match the types of the parameters. Or in other words, the types of the parameters also must match the types of the argument so that the pipes fit. There should not be any mismatch over there. So let's take a little more deeper. Look here. So suppose I have got a main function here. I'm not so much bothered about the syntax now. And the main function is running. And here I want to say, say result is average of abc and et cetera, et cetera, et cetera, et cetera. And we end here. And let's assume that here I have declared int abc. Both of them are integers. Now we have got the function which is average. Now, this average of three integers can be a float. So I just write, I'll explain it a little later. Float, average, X-Y-Z. And I can say intex y z and whatever. I am computing average here. This is simple. You can have int sum and sum equals x plus y plus z. And average is equal to x plus y plus z by three. Then I write return. Why do I write return? I'll come to that. Now look at the two things. A. I'll talk about this part a little later, okay, here I have declared abc to be integers. So in the memory for a, b, and c, two bytes or four bytes, as the system may demand, that much memory has been given. Okay, now when I write here, avg, that means I am invoking or calling this function avg, and I am passing on avg requires three parameters. X-Y-Z and X-Y-Z are all integers. And I could have written, there is another way of writing it that I could have written here, intex into I int z. That's also possible, but later we'll see that now. So, Abc, there's a correspondence between ab and c with x, y and z, and they are matching in the type. Then this computation. So we come here, then follow my blue line. This has been computed and ultimately the value of average is computed. Look that the value is being computed in avg, which is also the name of the function. So in a way, you can say that the name of the function is just like a variable that is holding the value, okay? That's holding the value. So that average, any variable that is holding a value must have a type. That is why since average of three integers can be a float. Therefore, we have to assign a type to the name of the function, designating what type of value it is returning. So here we can see that it will compute average. And then there is a statement, new statement that you are encountering here is return. Where is it returning? It is returning to the point from where it is called at is this point. And so the average. Suppose if the values are one, two and three, then the average is two. So then two goes to this avg, and that avg is being transferred to result. Now, if I do print result here, two will be printed. All right, so this is to give you an idea of what is meant by in calling a function, invoking a function, what is meant by returning from a function, and what are parameters and arguments. We'll see more of this in the subsequent lectures. But you should also understand why we do this. The reasons are twofold. As I said, one is to divide or break down a complex problem into manageable subproblems and the second, and test them independently. And the other issue is, other big advantage is that once we make a thing, a function which is tested, we can keep it for being reused. That's a very, very important thing. And this concept is general over different languages. Okay. Like we have got class, et cetera, which we can reuse a number of times. And this idea, the implementations are varying from language to language, but the concept is common and is used in different languages. Thank you, and we'll continue with functions in the subsequent lectures. Thank.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Introducing Functions.mp3,"So we were discussing a little more complicated and little more different program that is using a function. So here, what we had discussed in the last lecture is that we are using a new type of statement that is hash define. This is a preprocessor statement, okay? This is called a preprocessor statement, which is replacing PI with the value that is specified. Now, anywhere I can define other things like this. Also, for example, I can write, say hash define, um, resistance is ten ohm. All right, 10.2 ohm, whatever that means. In my program, wherever I get this variable name resistance, that will be replaced by this constant value 10.2 even before the program is compiled. Okay, that is the first new thing that we saw. The second thing is, look at this. Let's study this program. First I am putting a comment, and the comment tells me what this program is going to do. The comment is compute the area of a circle. Okay? And as usual I start with a main. Sorry, as usual I start with a main. All right, and inside main. Let us see what we have done. We have done something different. Now all of you will be able to say, what is this? This is a type declaration for two variables, radius and area. And what sort of type declaration is that? It is float. That means radius and area are two variables which will hold real numbers or floating point numbers. Right. Now I also declare my funk. This is another function, and the style in which I wrote tells the compiler that this is a function. And this function is also of type float. What is the type of a function? When we'll be studying function in detail, we'll be understanding that. Now, what have you done here, scanf? You know that by now scanf is reading the value of some variable. How many? Here I look at this point, I find that it is one percentage f. So only one variable is being read. And what is that variable? That is radius. All right, so I'll read the value of the radius, and radius is of type float. Right? So it will be say 15.25 that has been read. Now, computing the area, the main function is not doing itself. All right, so let us quickly go back to our old diagram. So this is the main machine or the main function. So here, what have we done? We have read, I am writing in a pseudocode. I have read the value of radius and there is a function called my funk. My function. All right, now after I read the radius, I don't want to take the botheration of computing the area. This machine, submachine knows how to compute the area. It knows that area will be computed as PI times r times r. That means PI r square, right, area of a circle. But this is a function that can compute area of any circle. It has been designed because by PI r square, you are not finding the area of only this circle. You can find the area of this circle, or might be this circle. Only thing that is differing is the radius. Right here it is one radius. Here there is another radius. Here there is another radius. Okay, so this machine or this function can compute any area of any circle provided it gets the radius told to him, told to this. So this machine is expecting some value to be passed on to this, to be passed onto this. Okay, please note the terms I am using. This function wants some value, requires some value to be passed onto this. Now you can ask that. Well, this is such a simple program. I could have written it here itself. Yes, certainly you could have written it here itself, but this is just an example. Actually, in a very complicated scenario, there are many complicated tasks. And if we want to solve the entire task by ourselves through a single program, there is a chance of error. Okay? That is problem number one. So we want to divide the problem into subproblems. That's a general programming philosophy that we want to divide the problem into subproblems and solve each of the sub problems separately because they are more manageable. I can find out what are the errors, whether they are working properly or not, and then I combine them together and solve the overall problem. That is advantage number one. Advantage number two is that suppose, just for the sake of argument, assume that my function, this finding the area, is really a complicated program, okay? Very complicated program. So somebody has really taken the effort to develop this complicated program. Now, whenever me or you or anybody, any programmer wants to use this facility, then they do not need to reinvent the wheel and write that complicated program. Once again, it is available and I can reuse it. And only thing that I need to do while reusing it is just to pass the parameter. Therefore, the second big advantage is reuse of functions. That is why the concept of functions is so important in programming. All right, you will encounter this irrespective of programming languages. So let's go back to this. So here you see, I am not computing the area. I means the main is not computing the area. What the main is doing, it is just here. It is calling my function. So immediately this one is being called. And what will my function do? My function is ready. My function is here, and it is just expecting something which is r to come in because it will compute PI r square, it's expecting r. And this one has got the variable, that radius, in the variable radius. So this is being passed on to this. So over here from the main function, here is the main, from the main, this radius is being connected to this r. All right. And this function, my function is reading is getting the value of r. And inside that it is computing the area. Now there are some details which I'll mention later. It is computing the area and it is finding the value in its own variable a. A is the variable. Now, for any program, if this function is used, then instead of radius, you may have my radius or any other value. Any other variable name can be there. Now, this will work for all of them. Let me clarify it once again. Say here there is a function and this function accepts r and produces a. Now, as I said that it can be reused from my program, I am using it with the variable radius. It is being connected here, maybe from your program you have not used the variable name radius. You have used the variable name, say rad. All right. So when your program is using this function, this rad will be connected to r. Now suppose here in my program I have used the variable name area for noting the area. So this output a will connect to area. For example, for your program you said area. Now recall that in c, small and capital makes difference. Makes difference. So this is another variable name. This is a different variable. So for you, this a will connect over here. Now, this person, this, my function is only concerned with r and a, and the job of connecting them is up to the function that is using it. All right, so here what happened? I called the main function. My function computed a how, here I wrote PI rr. Now, how do I know PI? Because PI has already been defined here. So this PI will be replaced by this value. So 3.1,415,926 times r times r. And what is this r? Since it has been called, when it has been called with radius, the value of radius will come here and return a. Now this return means where will it return? This is another new word that you are coming across. This return means it is returning to the point from where you were called. Okay, the program was going on like this. From here it called my function. So after my function is executed, it will return back to the same point. All right, so we have come across a new word, return. And return is returning the value a. And that is being assigned to my variable area. All right. And then printf. You can now understand what will be printed. Area is dash. And this one will take some floating point number, maybe 255.72, whatever it is, and this value of area will be filling up this place. So this is another example of a c program. So through these examples, what we try to do is to introduce you to some of the very common names and common words and common features of the c programming language. All right, next we move to this. That main is also a function. I have already said that that main is also a function. This is clear to you now, but just quickly have a look at this. Here I have identified some variables. I have identified some variables, ABC, which are integers and the same old program. And there's also a function. Fine. Now here are some words of advice. When we are writing a program, it has got a couple of things we have to keep in mind. First, it must be correct so that it can be executed by a compiler. It should adhere to the rules of the game, the syntax and the grammar of the C language. The other thing is also, this program has to be understood by others, because if you have written a program and someone else wants to extend this program, you are working in a big company, and there are a number of programmers, and each of them are writing a small segment of the program, and everybody must be able to understand everybody's program. Therefore, the program should be written in such a way so that it is understandable, more better understandable, just like if we write in very bad handwriting, write something here, something there, something there, I'll not understand it, but if you write it nicely in a sequence, it is much, and with proper paragraphs, et cetera, it is much better readable and better understandable. So here we will see some of the requirements for a desirable programming style. One is of course, clarity, right? It must be very clear. The program should be clearly written. It should be easy to follow the program logic. Now, here is something that is very important. I insist on that. There should be meaningful variable names. For example, I want to add two numbers, and when I say sum assigned a plus b or sum assigned num one plus num two, it is good. Semicolon. Please do not forget the semicolon. Okay, understand? Now, this sum is a meaningful variable name. It immediately tells me what this variable is meant for. It is holding the sum. But suppose if I had written something like tt is equal to tt, t multiplied by t minus x. Then from this it is not very clear. What is this tt? Why are you using this tt? All right, if, say, for example, average, I am computing average as avg. And that is x plus Y plus z divided by three it's very understandable. Semicolon. It's understandable. I could have written the full thing average equals to this. Or I could have written avg. All these things are fine. But if I had written PQr is equal to x plus y plus z divided by three, then it's not very clear, although I can look at this side and understand that. Okay, therefore it is PQr is the average. But this is not a very good practice. Okay, now, so make variable and constant names meaningful. For example, PI should be written as PI. It's not good that 3.1415 all those that value, I write as chi. Okay, because that is not very clear what this value is standing for. All right, so here are some examples. Use area instead of a, radius instead of r, and program documentation. We had said that we should be very generous about writing comments. But if there are too many comments, then that is also not very desirable. Now we are coming to a very important point. That is program indentation. What is that? The structure of the program should be immediately visible. We'll give you some examples. Here is a good example here. This is simple. I am writing in straight line here. There is a function. That's fine. Let's come to another example which will be better. Illustrating this. This is a bat style. You see here. Compare these two. All right, compare these two. Here there is a declaration. Then I leave some blank. And then I put the actual code here. These are the declarations. So I understand. This is a declaration compared to this, which is easy to understand. Okay, this is something, this is something else compared to that here where I do not put a gap, it's difficult to understand where the declaration ends and where the code starts. Okay, so here is another good example. Say, finding the largest of three numbers. Look at this as I said that if I have read this, but one bad thing is here. There should be a gap here. There should have been a gap here. All right. Now here if a and b. So that is the first diamond or decision box. If a is greater than b and a is greater than c, then I am doing something. All right, then I am doing this. This part of the program. Otherwise I am doing this. So here you can quickly looking at this indentation that this printf is under this. And this part is under this. That is very clear from this indentation. I have shifted it a little bit. And so immediately you can understand that this printf is, if this condition is true, that means this part is for this diamond box to be true like that. Okay, this is a good indentation, good style. Now, the same thing. Same thing would be a bad style. If I write it in this way from here, it is not at all clear which one is corresponding to which one. Not very clear. If I study it closely, I'll be able to understand, sorry. I'll be able to understand that this printf, this printf corresponds to this condition, but immediately when I look at it, it's not very visible. So this is a bad style. All right, so indentation is something that is very much prescribed in good programming. This becomes very important when we actually go for more complicated programs. Now, coming to the C character set, in an earlier lecture, I had briefly talked about this. Just as in English, we have got a character set, a to z, capital a to z. Similarly, C language has got a character set with which we make the words. You have already seen them. So the first thing is, of course, the uppercase letters, the lowercase letters, a to z, digit zero to nine, and some special characters, like you can see this, hash, we have already encountered this. When we said hash include, that's a part of the C symbol set, percentage, we have seen that. When we said percentage, d, percentage f, you have seen that. And this sort of symbols, this you have already encountered. All these are some certain special characters that are allowed in C. All right, now the identifiers and keywords, we have also talked about that. The names are given to different programming elements. For example, variables we already know, constants we already know, functions we have already seen. Each of them are given some names. For example, when we wrote my funk, that was a name given to a particular function. All right, when I wrote avg, that was given to a particular variable. That was the name given to a particular variable. When I wrote PI, that was the name given to a particular constant. Right? So in that way, we have encountered this. Now how? There is some restriction on the names that I have also mentioned may consist of letters, digits zero to nine, and this underscore character with no space in between. Whenever I want to put space, I'll put in this underscore character. This is very useful. It is very useful to put this underscore character here. What's happening here? The first character must be a letter. The first character must be a letter. Okay. This character must be a letter. An identifier can be arbitrarily long, but that depends on some C compilers. Okay. Some C compilers recognize only the first few characters, 16 or 31. And another very important thing that we had talked about, that it is case sensitive. A small area written in small letters and area written in capital letters or an area with a mix of small and capital are all different. These are not the same. This we had mentioned in the last class. There are some keywords, some words which are reserved for and have got some predefined meanings. And have got some predefined meanings. Some predefined meanings in c. Okay, for example, auto break, constant, float, you know, float has got a specific meaning. Int has got a specific meaning. Return you have seen it has got a specific meaning, et cetera. If you have seen it has got a specific meaning, else you have seen it has got a specific meaning. But within comments you are free because comment is never being so closely looked at by the compiler. The compiler simply takes it and prints it out. All right, so this is another thing that you have to remember. Whatever keywords you face during programming, you will gradually remember that these are the keywords and that should not be used as a variable name. Okay, so here we'll conclude this lecture with some examples. You can see some valid identifiers. X is a valid identifier. ABC. Now, simple interest. I have put in an underscore here. A one, two, three is fine because it's starting with a and Alphabet list. Fine. Stood name. It's a student name. Very clear, understood. Employee one, employee two. Average employee salary. See, I wanted to write a big thing, and I could do that by, instead of blank, I just put underscore. All right, invalid identifiers are these. And why? Because I can't start with a. Sorry. Because I can't start with a blank. Sorry, I cannot start with a numeral. So this is wrong. This is wrong because there is a special character that has been put in here. I mean, I could have written my underscore name. My thing is also, it's not looking nice. I could have done this. My name, but hyphen is not allowed. Hello is not allowed because here I have put in some special characters. Simple interest is not allowed because there's a blank. I cannot put in a blank, but I could have written simple underscore interest. That is quite valid. Area is not valid because it has got a parenthesis, and percentage is using a special character here. So these are invalid identifiers. Examples of invalid identifiers. So you should keep that in mind. We'll continue with our programming lectures. So till now, what we have done is we have looked at some of the rules for writing the program and how, how the variables and the constants should be named. We'll continue with this.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Introduction to Arrays.mp3,"Till now, we have looked into. We have seen different programming constructs using which we can implement repetition. That means set of statements will be repeated in a loop and in c. Such constructs were while, do, while, and for loop. Right now also, we have seen how we can branch out, coming through a sequential one after another execution of the instructions. Depending on a condition, we can go out to one path or another path through if else structures. And we have also seen some examples by, in which a combination of the if else structure as well as the while loose structure are combined together to give us more powerful and useful programs. Today, we'll start discussing about a new form of representation of data that is very useful and very fundamental. That is called arrays. Okay? Arrays. The word arrays simply means arrangement. Arrangement of data, okay? So we can think of, for example, an array of soldiers or array of people standing in a line. So people are standing in a line. This is an array, okay? We can also have two rows of people standing, all right? This is a very regular structure. We can have three rows also. So these are arrays of people. Now, if I just have only one row, in that case, say, for example, I consider one row, then it's a one dimensional array. When I consider rows as well as columns, then it's a two dimensional array. However, we will now initially concentrate on one dimensional array like this. Okay? What is this? This is an array of people. Similarly, we can have array of numbers. For example, 17053. That's again an arrangement of data. Arrangement of data in a linear fashion. Okay, this is the first element, and this is the last element of this arrangement. So this is also an array. Array of some numbers, okay? So in an abstract way, we can say that an array can be drawn in this form. It can be an array of integer or an array of real numbers, depending on what I want to store here. Suppose this be an array of integers. Then each of these places can have one integer stored in this. 2653, maybe again, two and nine. So this is an array. Now, how many elements are there in the array? Each of these are elements of the array. How many elements are there in the array? 123456. So this is the size of the array, okay? And these are the elements of the array. All these are elements of the array. Also, another thing we need to know is how do I identify one element of the array, say this element, six of the array. This array, how do I identify that? What is its identification? The identification is the position. So this is the second position. All right? This is the first position. This is the third position. Fourth, position, so on and so forth. Now, these positions in the array is known as index, okay? Index is the position in the array. Index determines position in the array. Position of what? Position of an element in the array. Okay? So for the time being, we assume that arrays are linear structures. Linear arrangement of data. Now, one point to remember is one array can store data of the same type. For example, it's not possible to have an array in which there will be some integers, some real numbers, and some, again, characters, okay? So that is not possible. That's not allowed. So an array is allowed to store data of only one type. We know that int, float, cat, all these are defining different types of data or data type, right? Or data type. So an array can store data of only one data type, whatever that is. It can be all floating point numbers, it can be all characters. It can be all integers, whatever. All right? So these are two words of caution. So what have we learned? We have learned that array is an arrangement of data of the same type, and the array is identified as a whole by a name. And say, for example, this array, this is not a valid array. So let's have a valid array. Let's have a valid array of four elements, say of real numbers maybe, right? So this array will have a name. Let's say arbitrarily put a name, a. That means a is the name to this array, and this array has got a type. What is the type of this array? The type is float. So array a is a float. So a is an array of type. Float. That means it can store only floating point data. Also, an array consists of different elements. Each of these are elements. And each element, each element can be a floating point number. And the particular element is identified by the index of an array. All right? And also, we know that an array has got a size. Given this, let us think of why are we talking about all these things? Why is this needed? After all we have encountered till now, quite a few example problems. For example, let's again come back to the old problem of finding the maximum of a set of integers. Now in that case, what did you do? We read one integer, we initialized a variable, say first integer. We read, let me once again do it. So if you recall, I'm writing the flowchart, I'm not writing the c program. Read a number. You know how to read a number by scanf, then put that number to be max. Read again. Read number. Okay, and if number is greater than max, then I'm writing pseudocode so I can write. Then max is getting the number again, I read number and in that way I go on. Or you can say that, okay, why should I write in this way? I shall simply implement a loop while loop or for loop, so that this thing is carried on till I stop. Say for n numbers or for. So here I can use for, I assigned one to I less than equal to n I plus plus to implement the loop here, here. But that is possible when I know the total number of numbers. Okay, if I didn't know the number of numbers, there are some other ways of doing it. Say for example, I am reading integers and I say when I want to stop, I'll enter a zero. So here I could have put in something like this. While num is greater than zero, do so we do this. As long as num is greater than zero. I'm going on doing this. And if num is zero, or num that we decide, or some negative number, I know that my job is done. But in this case, if I want to remember, what were the numbers already given to me? Suppose the numbers that were given were five initially here, then two, so nothing was done. Max was five, then seven. Then here there has been an interchange. So now here max becomes seven. Then again it was three, so nothing was done. Then it was eight and max became eight. So that will work for this sort of program. But if I want to know what were the numbers? He was saying max is eight, but what were the numbers that were input by the user? We have not remembered them anywhere, isn't it? We have not remembered them anywhere. So here in my program I'll not be able to say what was the second number entered? What was the first number entered? Was there any zero entered or was there anything greater than three entered? We can't answer these questions because we read this and we operated on this and we forgot them. Now, if you can think of that, if I had used an array, this sort of thing, and I had, as the user gave the numbers, I stored them here, five, then three. User gave three. I stored three here, then user gave seven. I stored seven here, then the user gave something, maybe again four, I stored four here and then the user gave nine. I stored nine here. Then even after, or eight here, even after reporting the max, that this is the max, I have got these in my array. Say my name of the array is still a, which is a, is an array of integers. Then this is stored here. I have remembered them in the array, so I can now say what was my first element. I go to the first element of the array using the index value. Okay? And second, I go to this value. Okay, what is the fourth value? 1st, 2nd, 3rd, fourth. I come to this point and I can say, okay, the fourth value was this. So all these things I can remember because I have been able to store them in the form of an array, okay, so array is again an arrangement in the memory. All right? So an array, when I, you know that every variable is stored in a memory location, right? So when we had num and the program that I had written that num initially, initially I read num, and then I do this, and then again read num. If num is greater than max, max, assign num. When I do this thing in a loop or whatever, what is happening whenever I have got variable. Num is a variable, one location in the memory. This is num, and max is another variable. I have declared all of them here, int num, int max, I have declared them. So here there is another location which is known as Max. So when I did this, read num, and suppose some data, five was read that five is stored here. All right? Five is stored here when I come here and I put max num assigned to max. So it comes here. Now, I did num again. So suppose num is four and no update in max. Next time I read it seven. So this is updated here and this becomes seven. So this is the process that goes on. All right? Now every time I am losing the old value of num and storing the current value of num. And similarly, whenever there is an update required, I take the current value, the max up to now. Okay? So I am having two variables of integers. But if I had done it in the form of an array, then I could have thought of like this, that I have got. Suppose the array size is five. Suppose the array size is five. So that means conceptually, I am talking of something like this, that there are five positions in this array, okay? And as I am getting the data, it's coming over here. 53729. Whatever. Now, actually, internally, what's happening internally? This is being stored in the memory. The array size is five here. So I have got five locations in my memory. Four, five. So these five locations of the memory are being given to the array a. Suppose the name of the array is array a. So for the array a. So the first element is coming here. When I'm actually writing it here, it's coming here. Second element is coming here. Next element is coming here. Next here, next here. So these are the memory locations. So an array is actually a representation in the memory, which are contiguous, and, you know, each memory location has got an address. So suppose, hypothetically, the address of this is thousand and each of them are integers and integer, if I say integer is requiring two bytes. Okay, then if this is thousand location, the next one will be 1002. Next one will be 1004. Then thousand and six. Then thousand and 8008 2009. Right? So thousand 2001 is for the first element. This one coming here, thousand 2003 for this element, thousand and four. 2005 is this element. Six to seven is this element. Thousand and eight 2009 will be this element. So 1000 2009. That means ten locations. We are requiring for these five elements of the array. Now, since also in my program I have got two other variables, one is the num or one is the max. All right, I can manage it with one more variable. Max is a separate variable. Suppose so, that is here, this variable is Max. Let me delete this variable. This is not required, right? Because this diagram is redundant, because max is another variable which I have here. We'll write a program, we'll show later how we can write a program to deal with this. Since I have computed, I have read the numbers, I've stored them in the memory locations, and since I am going through an array, I have not written, overwritten one number by another. Therefore, I can remember all the numbers. So this is one basic reason of usage of array, where I want to remember the numbers in the memory. Given this, let's quickly recapitulate what we have said till now. So many applications require multiple data items that have a common characteristics. What is that? Common characteristics? Common characteristics like whether they're integer or float or character, whatever that is. It can be even more complex. So we call, say, so that numbers that we are showing, say we can. In mathematics, we often represent them as x one, x two, x three, x four, say up to x n. And that whole thing I can represent as an array, x, where x one is the first element, x two is the second element, x three is the second 3rd element. Like that. Now, here is an example, finding the minimum set of numbers. Minimum of a set of numbers. Okay, how we can find a minimum of a set of numbers. So, this is what I have already discussed, but just for the sake of revision, let's look at it once again and say for three numbers. You know, this program must be familiar to you. Now, you should be able to understand it quickly. If a is less than b and a is less than equal to c, then a is the minimum. I was showing the maximum here. It's an example of the minimum, okay. Else if b is less than c, then b is the minimum. Else c is the minimum. So far so fine. As soon as I extend from three numbers to four numbers, you see the program becomes a little bigger. If a is less than equal to b and a is less than equal to c and a is less than equal to d, then minimum is a. Otherwise, if you see everywhere, I have brought in more number of comparisons and the program code has also been bigger. All right? And I am not storing the numbers as yet. I'm not storing the numbers. That's one issue. The problem is. So from three to four we needed so much extension. Now suppose we have got ten numbers to handle. That will be even bigger, 20 numbers, even bigger, 100 numbers. So how do we do that? The solution is, the solution to the problem is what is the solution? The solution to the problem is use of arrays. Right? Using arrays. Right. Now as I said that all the data items constituting the group shared the same name. All these data items that I had shown say integers like 57632. All these can share the same name, x. Or maybe let me give a meaningful name, num. Now this one is num one. This one is num two. This one is num five. Okay, so I've got, just as we had shown, x one, x two up to x n. So here n is five. So I've got this five. Okay, individual elements are accessed by specifying the index. This is the index which is telling me in which position, which number in this array of numbers I am looking at. Okay, we'll look at this further. The use of arrays and many more things are to come.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Introduction to Programming Language Concepts.mp3,"So, in the last lecture, we had seen how we can represent algorithms, and we had mentioned particularly two different ways. One is Flowchart, which is a diagrammatic way of representing the different steps. And also we saw English like form, which is known as a pseudocode. It's not exactly, why is it called a pseudocode? It is called a pseudocode because it is not exactly the code that can run on the computer, but it is a way close to that and by which we can express ourselves and from which we can also convert to the computer language. Now, we had given few examples of such flowcharts for a few problems, but you can, and I strongly encourage you to take up more problems from textbooks or some mathematical problems that you may encounter and try to solve them. Try to draw the flowchart of those. Now, coming to the context of the books, here are some of the suggested books, but I'll start from the end. That is, any book on C will serve your purpose. You can take any good book on C language and try on that. And the number one, that is C programming by Carnegan and Ricci is the most authentic book for C programming, c language for that matter. But I suspect that for some of you, you may find it to be a little difficult. Therefore, a middle path would be this second book, programming with C by B. S. Gottrid, which is outland series. And this second book has got a number of examples solved. Examples and examples given as exercises. So I think that will be a very good starting point. Now, having said that. So what we have right now is we have some algorithm, right? And from that algorithm, we want to come to a program. Now, algorithm is the sequence of steps that might be in our mind also, okay? So I know how exactly I want to do that, and I express it in some way. Expressed in some way. And that is understandable. Now, you know about two ways. One is the flowchart. There is a pseudocode which expresses how, what are the steps that are to be taken. Now, from this algorithm to a programmer, program is the task of a Programmer. Programmer is a person who knows how to write programs, okay? So from the algorithm to the program, whatever language the program might be, that has to be translated. Now, the key point to understand is that this algorithm I can express in any particular way. However, that program must be written in a language that is understood by a computer. All right? Language understood by a computer. So a programmer is essentially a person sitting here who is translating the algorithm or the steps as expressed in some informal way, into a form that is understood by the computer. And this language, just like any other language, will have its own vocabulary, will have its own grammar. Now, here comes the question, what is the language that is understood by a computer? Now, in order to understand that, we have to look at what is there inside a computer. Now, all of you, many of you may be knowing it from your school days, but just it is a quick revision. It is a machine. A computer is nothing but a machine which can accept data, process them, and output the results. Now, so there is an input device, which can be a keyboard. Nowadays, it can be speech, microphone, it can be joystick, it can be many things, right? Mouse is also another one. And ultimately we have got the computer here, which consists of the cpu and the main memory and the storage peripherals, right? So this is the actual part of the computer. Now, the data comes over here, it is processed here, and the output is sent to the user. So the user is on this side. The user is also on this side. So this side is also the user. User. And this side is also the user. All right? Now there are a couple of important things to understand here. Typically, we tell the computer how a problem is to be solved. And that is the sequence of steps that we do and whatever sequence of steps that we specify. Now, whatever sequence we specify that is remembered by the computer in its memory. Now, the memory can be actually, it is stored in the secondary memory. I'll come to that later. But the key point to think about is that this entire box is nothing but an electronic machine, right? Electronic machine. And consequently, it only understands ones and zeros. So whatever we have to express, we have to express that using ones and zeros, okay? So this is the first thing a computer, being an electrical machine, understands only ones and zeros. Because it's an electric machine, it only understands whether a particular switch is on or off, right? That's what it can at best understand. Therefore, whatever we have to express, we have to express it in the form of ones and zeros. So consequently, say a, b, all these alphabets, small a, everything will have to be represented in the form of ones and zeros. So maybe a. Just hypothetically, it's not to be taken to be accurate. I'm just saying that suppose is a pattern that represents a. So similarly, maybe this pattern represents b and maybe 1001-0010 represents small a. In that way, everything will be represented into a pattern of ones and zeros. And, you know, might be knowing some of you, that each of these one and zeros, these are known as bits. Bit stands for binary digit. Okay, binary digit. So bi for binary and bit that last t for this. So binary digit forms bits. So it's a sequence of bits. So anything is represented in a computer as a sequence of bits, or we often say bit pattern. Now, just ones and zeros gives rise to a new number system that is known as the binary number system. So that leads to the binary number system. Might be, some of you might be aware of this binary number system where I have got only two elements, zero and one. I have to do now in decimals. Visa v. If I just consider that regularly we use decimal number system where we have got from zero to like that up to nine. And whatever I express, I express as a combination of this. Now in binary number system, everything is represented just by zero and one. So quickly let us look at what a binary number system is that. Suppose I have got a four bit number, all right? So there are four positions. 1234. And suppose so parallel. Let's think of a four digit number. All right? Four digit number. Remember that in decimal we call it digit. And in binary we call it bit, right? So if I have 7832. Now all of you know what is the value of this number. Each of this place have got a weight which are known as weights of the different places. So this is ten to the power zero. This is ten to the power one, this is ten to the power two. This is ten to the power 30 weight, one weight, two weight, three weight. So this number is actually meaning seven times ten to the power three. That is 7008 times ten to the power two. That is 803 times ten to the power one. That means 32 times ten to the power zero. That is two. So that is giving us 7832. It will be easier to understand this with this analogy. For example, here I have got something like 1011. Now unlike so here also the weights are 0123. But the base here was ten. So here it is two to the power zero. It's binary here. So it's two to the power one, two to the power two, two to the power three. Okay, here the base is two. Here the base was ten. That is why this is a binary system. This is a decimal system. So if I have this pattern 1011, then I can straightway convert it to an equivalent decimal. Like what does this mean? So I can take it. There is a one here, one times two to the power three. That is what? Eight. Then zero times two to the power two, that is zero. One times two to the power one, that means two. One times two to the power zero. That is one. So the value of this will be eleven, right? So this is the binary number system. So there are ways and means by which I can convert from a binary number system to a decimal system. From a decimal system to a binary system. That's possible, right? So if you want to see that, I don't want to go into that because many of you have done it in school. So let's leave it for the time being. But what is more important is to know that a computer, in a computer, everything is represented in the binary system as a bit pattern of ones and zeros, since everything is expressed as binary number system. So if I remember the, say we had something like this, let's not take max, let's take sum equals sum plus number one. This is something we saw in our earlier lecture, something like that. Now this is a statement. How do I represent it to a computer? In order to represent this to a computer, say, I want to say, say this is. And you have to do some addition and some assigned, some you have to copy it somewhere or write it somewhere, all right? Or I just take this simple part, add sum with number, okay? Sum plus number. How do I express that? Everything has to be expressed. Say this number will be some pattern, say something of that sort. Sum will be something 011-00-1100 whatever. And plus will also have some code. 011-01-1011 might be suppose this is add. And suppose 011-0011 is subtract. Similarly. Similarly, there will be some code for multiplication, et cetera. Now, since I am here, I am the user and I am also the programmer. And here is my computer. Here is my computer, and I have to translate my thoughts, my algorithm, in a way so that a computer understands. I have to translate that algorithm or the flowchart into this pattern of zeros and ones because that is the only thing that it understands. Okay? The language that the computer understands is known as the machine language. So let me once again draw another picture here. So here I have got my machine, all right, I've got a machine here, nice looking machine. And here is the programmer. The programmer understands flowchart, or the programmer understands English, like pseudocode, but this one only understands patterns of zeros and ones, patterns of zeros and ones. And this is the language it understands. And this programmer understands the language of Flowchart, for example. Now this patterns of zeros and ones that the machine understands. This is my machine. Mc is the machine. Now, this machine understands. That language is known as the machine language. And that machine language is not understood. Okay, if some genius can understand, remember all those patterns of zeros and ones for every possible combination, that's a different thing. But for normal people, it's very tedious. It's not possible. It's not advisable. Also, therefore, earlier people had to. For small computers, it was possible. At the very beginning, people used to program the computer by setting up different switches, and thereby it was being programmed. But at that time, the operations and the capability of the computers were much more limited. But once it became larger, we are doing much more flexible programming and everything. It's not no longer possible to remember the machine language. So what is the other alternative? The other alternative is the best alternative would be that on this side, I have got my normal language, English, and if I could directly translate it to machine language. But there are some problems with that, because in English, or any natural language that we use, many things are often ambiguous. It's not very clear. It can have multiple meanings. Just say, I'm giving you an example. Go to the bank. Go to the bank. It's an english statement. Now, what does this word bank mean? It can mean many things, right? It can mean the bank where you deposit the money. It can mean the river bank, et cetera. So therefore, English language, or any natural language, is not yet suitable to be translated to the machine language. So instead, people thought if we could have some intermediate language. So once again, I come here, I again draw the machine here. The machine is here and the person is here. So on this side is my natural language, like English, but which I am not being able to use. So people developed some intermediate language, which is close to English, but the grammar is much more stricter, and we cannot allow any ambiguity. No ambiguity, but it is high level language because it is easier for us to remember, it's easier for us to explain. For example, if I write this, say x equal to p plus q, all right? Or I write, read p. Now, this is meaningful, this looks like English, and I can understand this, okay? Now, given a high level language, and on this side, this machine can only understand machine language. So we need to have some translator, some translator which will convert this high level language to the machine language, okay? And this translator is known as the compiler. Now, think of the situation that here is a person. Say, just forget about the computer, high level language. Think of a person who knows French, and here is a person who knows maybe English. So a compiler or an interpreter is something which is somebody who will translate from French to English, right? So here, also, depending on what language I am using as the high level language, there will be different compilers. Examples of high level languages are C, which we'll be discussing or taking as an example in our course. It can be Java, it can be Fortran, it can be Python. All right, we can have many other languages that are coming up. Nowadays other languages are also coming up. So depending on the language, high level language in which we want to express our algorithm, we will have to select a suitable compiler. So for c we'll need a C compiler. For Java we'll have to need a Java interpreter. All right, the same thing, more or less same thing, that it will translate. The basic function of this is translation. So it will translate from a high level language to the machine language, okay? And as you had seen that here, all those things will be binary. I mean in binary system, in the pattern of zeros and ones, I have to convert, if this machine has to operate with my program, this has to process this, my program, I have to convert it into zeros and ones. Right? Now here is something more that we have to say. Now, whenever we write a program, whenever we write a program, what we do here is we write some high level program and that high level program is taken up by a compiler and is converted into a machine language. Now here you have to be a little careful, you have to be a little careful that depending on the different machines, you can have Pentium machine, you can have Apple machine and other things. So depending on what machine you are using, you may need different compilers for that particular machine. So for the time being, let's ignore that thing. Let's assume that one high level program can be translated by a compiler to a machine language. So there is a program, right? So remember what we did in our earlier cases. We said find the maximum of ten numbers and the numbers were 310, 712, five, six, so on and so forth, right? 1234-7215 so out of this I have to find out the maximum. Now through the flowchart or through the pseudocode, what did we specify? We specified the sequence of steps. So those sequence of steps that have to be adopted in order to find out the maximum of this is our program and this program will be converted to the machine language. Now this program will run on some data. This program is a program that can run on this set of data or another set of data, say 515, 16, seven, say for four data, if I just run it for n, number of things. And here the n was ten. N was ten. Remember what we did earlier? And here n is four. The same program should work on both of these, therefore the program remains the same. But here is some data set, and here is another data set. So we have got two different data sets. So in order to execute, we need both the program and the data. Okay, now when we start, say our program and the program, when we start with a high level program, I'm writing hll is a high level language. Now this, in the context of passing, I'm saying this is also known as the source language. So in my lecture often I'll be using this term source language. Source language means I'll not say source language. I'll say source program. By source program, I mean the program that is written in the high level language that will be translated by a compiler to a machine level language. Machine language. Okay, now when we, now this is one site, so the machine language has been generated by the compiler. If my source language is c, then I need a C compiler here, and I'll get the machine language. And this machine language is independent of what the source language is. It is only dependent on the particular machine on which it is running. All right? So the compiler will translate into that machine's machine language. Now, in my computer diagram, we had the cpu here and we had memory, right? We had memory. Now, the memory can be divided into two parts. One is the RAM and ROM. Some, let me put it, three parts. RAM and ROM are two types of memories, two types of memories which are of relatively smaller capacity. I think this is not very clearly coming, so let me write it clearly. RAM stands for random access memory and ROM stands for read only memory. Besides that, we have got the secondary memory, which is the disk. Right, the disk. Now the machine language. After compilation, when it is saved, I save it and it is saved and stored in the secondary memory. All right, in the disk. Now, when that program will be run. So I have done the compilation, and after compilation, my program is ready to be executed. Is ready to run. Now, when I run it, can I select some pin color? Sorry. So when I run it from the secondary memory, it will go to the RAM and the CPU. The program will move to the ram only when I execute it, and the cpu will read that program from the ram and will execute it. Okay, so this is a sequence you should remember. I repeat once again, I write the program and type in the program in the machine. After that, I do the compilation. After compilation, it is converted to the machine language and I save it. When I save it, it is saved in the secondary memory. Secondary memory is typically the disk. I save it in the secondary memory, but on execution when I execute it, when I run the program, then only it goes from the secondary memory to the ram, and the cpu reads from the ram and executes it. All right, so we'll be bothering about mostly this ram and the secondary memory and how that is stored. Many variables and all those things are stored. In the next lecture we'll see how we can gradually move towards encoding our pseudocode to the machine language, to the high level language. So, summarizing what we discussed in this lecture, it is that we have got the pseudocode, but on the other side we have got a machine which does not understand the pseudocode. The machine only understands the patterns of zeros and ones. So we have to have something which will convert. The pseudocode cannot be directly converted because of lot of ambiguity. So we'll have a high level language designed which can be, which is unambiguous and which can be converted to the machine code by another system, that is a compiler. And that compiler is nothing but another more sophisticated program using which you can convert this and keep it over there, take it in the machine language, and the machine can then read that machine language program and can execute it. Now we, you've have also seen that a program, I mean, if we have to run a program, we need the program as well as the data. Both this are stored in this memory part and from which the CPU will be taking that. Sometimes the data can be fed directly from the input device at runtime. All right, say, whenever we say read n, whenever we say read n, then from the input device somebody will type in the value, and that will come from, through the CPU into the Ram. Okay, so this part will see later gradually. Okay, thank you very much.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Introduction.mp3,"Good morning. Welcome to the course of problem solving through programming in C. This is a course of programming, no doubt about it, the first course on programming for many of you. But also the focus of the course is to show you how we can carry out problem solving. That means solving different problems using programming. We encounter different types of problems all the time in our life, and some of them can be solved using programming. Why? I'm saying that some of them can be solved. Not all can be solved. There is a reason for that. We'll come to that later. Also, there is another thing in the bracket. You can see that we will be discussing programming in C. Now, C, why I have put it in the bracket. The reason is that C is just one of the means, one of the languages using which we can do programming. There are different other languages, like as many of you know, Java, C, and others using which we can also do programming. Now, our objective is to not to just think about the C programming language, but also some programming principles, some programming logic, some programming methods that are adopted while solving problems. All right, now let us think of some of the problems that we often encounter in our regular life. Let's start with a very simple problem of there is a large volume of data, large volume of data, maybe integer or maybe numbers, different type of numbers. And we have to find the mean of that. And mean of that. Many of you know, mean is nothing but the same as average. Right? Now how do you find out the average of a large volume of numbers? Now, all of you know how that is done. So that's a relatively simpler problem. We can also have. So this has got some standard formula. If you have got ten phone numbers, say X-Y-Z and p, you add them and divide them by four. That's how we find out the average right. Now. Also, for n numbers, if there be n numbers, then we can write it as sigma xi by n. What does this mean? This means I am taking what is xi? Xi is each number. So x one is one number, x two is another number, x three is another number in that we have up to x n. Now, so each of these numbers, any of these numbers I can represent with x I. And by replacing different values of I, I can get any of these numbers. So sum of all these numbers, sum of all these numbers can be designated as x sigma of x I. This sigma means summation. And so I do the summation of this and divide by n. When it was phone number, when it was phone numbers, then I divided with four. Here, since there are n numbers, I divide it with n. Now, this is a very well known mathematical formula, mathematical approach, that all of us, these school children, will know. Therefore, we can very easily translate this problem and solve this problem into programming. We'll see how we can translate it to programming also. We'll also discuss why we should translate it to programming. All right? Now let's take a little different problem. Suppose there is a text, all right, there's a text of 20 sentences. All right? So we'll have a text of 20 sentences. All sentences are here. And I say that, okay? Find out how many times the word human occurs in this text. So this is my text, and I want to see how many times the word human occurs in the text. Also, the problem can be much more complicated. Now, this is another type of problem where I have to look at every word and see, is it a human? No. Is it a human? Yes. So accordingly, I'll have to go on counting. All right? Now, I can also say that how many times does the word pair human being appear in this text? All right, human being appear in this text. So that can also be. So I get human, but I don't get being after that. So I don't count it. All right? If it be human followed by being, then I count it once. In that way, I can formulate different steps by which I can solve this problem. Well, if you just spread your imagination, you can think of making the problem even complicated. For example, human being and man, woman, child, boy, girl, all right, parent, teacher, et cetera, et cetera, et cetera. All of them are human beings. Now, if the problem is posed in a way that, find out how many times earlier what the problem was. Earlier, the problem was how many times the word pair human being appeared as it is. Now, if I modify the problem statement and say that, find out how many times human being has been referred to in this text. That means if it'd be a man, then also it's a human being. If it'd be a woman, then also it's a human being. If it'd be a child, then also it's a human being. If it'd be a grandparent, it is also a human being. In that case, the problem becomes a little more difficult, little more difficult than the previous version of it where we wanted to just find out the word pair human being. This is an example of a second problem and third problem. So the third problem is a little more complicated, as you can see. Well, we can go on adding examples of problems. Let's take another one. Suppose you have got a fixed amount of money. All right, whatever that amount is, suppose you have got rs1000, you have got rs1000, and you have been asked to buy some items. Items may be rice, wheat, sugar, vegetables, et cetera, and each of them have got a price. Rice may be r 50, wheat may be r 30, sugar may be r 70, and vegetables, depending on the variety, there are different prices. All right, now suppose you have been told that you have been given this amount of money and you have to buy the maximum amount of rice possible. The maximum amount of rice possible. So with rs50, you can have 20 cages of rice. But there is a constraint. There is a maximum amount of rice you have to buy, but you have to buy at least five kg, at least five kg of wheat, at least two kg of sugar, at least some amount of vegetable. Now, given this, you can buy five kg of rice, you can buy wheat, you can buy six kg of wheat, you can buy seven kg of wheat, you can buy two kg of sugar or three kg of sugar, et cetera. You can do many things, but you have to see that how you will distribute this, so that even after satisfying these requirements, you can find you can buy the maximum amount of rice. So this is another problem. When you go to the market, such a thing is always told. Or we have got in mind that we have to cover these items and there is a cost for that, and we have to satisfy the cost. So this is another type of problem. We can see this is an maximization problem, or in problem solving terminology, we also sometimes call similar problems as optimization problems. That means I want to maximize the amount of rice that I want to buy. But these are the constraints that I have to satisfy, right? So I have to satisfy these constraints. I have to satisfy these constraints. After satisfying these constraints, how can I maximize this? So this is another type of problem, relatively much simpler maximization or optimization problem. All right, let's now move to another type of problem. Say I have got a number of places. Let's name the places Abcde. Now suppose these are, suppose some cities, and we have got direct paths among some cities, and there is no direct path among some cities. All right, suppose this is the scenario. So I can directly reach from a to c, but I cannot directly reach from a to d, I can directly reach from b to e, but I cannot directly reach from b to c like that. Moreover, along with each of these parts, along with each of these parts, we have got some cost associated, the amount of money, the amount of expense that we'll have to bear in order to make this travel possible, suppose this traveling b to e, I have got different options. Say, for taxi, first I put the taxi thing first. Then I put the cost by bus. And then I put the cost by train. Now suppose from b two e, I can go by bus, taxi and train both. So suppose by bus it is rs10 and train it is rs20. And also, of course, there can be. I mean, according to the mode of transport that I take, the time taken will also be different. Say, from d to e, I can go by taxi and that will cost me rs30. And by bus it will cost me rs5. And there is no train between these two. All right. So there is no train. No, I put a null here. So a to b. Suppose I have got a taxi. Of course, rs30. Bus. Maybe here in this route, it's a little expensive. Seven. And there is no train here. A to c. I have got rs20 by train. Rs4 by bus. And there is no train here, c to d, it is rs50. Again, rs8. And by train it is certain rupees. So this is the picture. Now I am here and I have to reach this point from a to e. Now I can go via a to c to d, d to e. Or I can travel a to b, b to e. Right? So if I come by from a to e by taxi, then it'll be 30 plus 50, rs80 required. If I come via this path, it will be 20 plus 50. 70 plus 3100 rupees required. But if I come here by train, there is no train. So I cannot come between these two by train. If I come by bus, rs4 and now by train, rs10.14. And here there is no train. I cannot do that. Right? So I cannot take train from here. So I'll have to take again bus from here. So in that way I have to solve the problem of how to reach from one city to another with some constraints. Now these constraints are coming every time. And these constraints actually generate the fun in this. What are the constraints that we can have in this problem? The constraint will be satisfying the time, how fast I can move. I have not shown the time information here. That time information should also be kept here. For example, from b to e by taxi it takes rs50 and say, takes 20 minutes. And by bus, rs10. But it takes 40 minutes. And by train is rs20. But it takes ten minutes. Like that. So if the time information is also there, I may be asked to minimize the time. And also what is shown here, this is cost. So I have got the cost and the time. So I may like to minimize the cost also. Now, I may be asked that, okay, I am not so much bothered about time. I am relaxed, it's a weekend, I can devote time. So let me try to minimize the cost. Then the problem will have one color, right? One form. Now if I just say that, well, no, I am a little pressed with time, so I'll be selecting a vehicle or selecting a mode of transport. I don't mind the cost, but I have to minimize the time. Then the problem is something different. Also, it may be that, okay, I am okay with total time spent between less than 1 hour, less than 1 hour, given this constraint, minimize the cost, okay, so in that way, different forms of this same problem can be put forward. And often we have to solve such problems in our real life. So that's the best way to reach a place, right? This is how we can find the best way to reach a place. Now I come to another interesting problem. So this problem that was there, it is again an optimization problem that you could see. Now, say, let's take another example. Although I am showing it as a game, it can act as a model for many real life scenarios. So this is a maze and I am here. I am here, and I have to reach, say here. So this is my source, this is my destination. And from here I can either from any place, each of them are places. From any of these places, I have got three moves. Um, so either I can have an up move, I can have a down move, I can have a diagonal move. All right? So for example, from here, with a diagonal move, I can come here. With an up move, I can come here. Here, I cannot apply a down move. Okay, now this up and down moves are allowed only if there is no bar. Okay, there are other moves also. I can move left or I can move right. All right. I cannot move diagonally down. Suppose these are the moves that I have. And any of these moves can be applied only if the corresponding destination place is not barred or if the destination place is free. For example, if this place is barred, and say this place is barred, then from this point source, I cannot apply the diagonal move. Why? Because this place is not free. Suppose I apply the up move, so I'll go from here to here. Now I am here. At this point, what are the moves that are applicable? Right move cannot be given. Sorry. Left move cannot be applied. This cannot be applied. This is out of question. Up move cannot be done. Down move, I can, do you see? Down move I can do, I can come back. All right. And diagonal move is possible. Suppose I come to. I find if I apply the down move, I come here. Then obviously if I again apply this move, then I'll be just doing these two repeatedly and I'll not progress any further. Maybe once I come back here because of some thought, I can apply this move. All right, now let us see once again. Let's start. Suppose I was here. Now apply up move. Then I can apply a diagonal move. And then I can make a horizontal move. Another horizontal move, 1234. Assuming that all these moves are having the same cost. Same cost, same effort. All right. Then with 1234 moves, I can reach my destination. Let's see, if I had, instead of going up, if I had taken this move, one, because I could not go diagonally, then I move diagonally. Two. Then with three moves I can reach the destination. Assuming that the costs are same, then this is a better move. All right. Now if the cost, the scenario becomes a little more complex when each of these moves have got different costs. Suppose it is I have to pay more or I have to put in more effort for moving from this point to this point, this point to this point in a diagonal manner. It's much more easier to move in a horizontal manner. All right, so this is another type. Then the problem would have been a little more complex, right? In that case, suppose. Suppose the diagonal move costs you five and all other moves cost you two. All right. Then what would be the cost in this? 2578, 910. Eleven. All right. In this path, let's do it again. Two because up is two. Five because diagonal is five. Seven. 8910. 1111 units. If I had done in this way, two, five. Seven and 512. So in that case, this is becoming costlier. But obviously, if the diagonal move was four and not five, then what would have happened? Let's see. 24678, 910. And if I do it in this way, what would it be? Two. Four and two. Six and 410. In that case, both of them would be equal. So this is another problem where again, you can see that we are trying to look at the cost and solve a problem. So this, you can think of a pathfinding problem or a search problem. What are we searching here? I am calling it to be a search problem. So what are we searching here? We are searching for the path through which we can move. We can reach the objective. Now, this is a very simple example of the type of problems that we solve in artificial intelligence. Okay. Say a robot has been asked to move from this point to this point. How the robot will find its way given some obstacles. So this is another type of problem that we can solve using programming. Now, having said that, is it that all the problems that are there in the world, can we solve them by programming? When we say problem solving, we are not actually meaning to address all possible problems. All the problems that are in the world, we are not saying that all of them can be solved by programming. For example, the problem of hunger cannot be directly solved by programming. Some person is feeling depressed, isn't feeling sad. That's a problem. We are not addressing that sort of problem here. Okay, so when we say problem solving through programming, then we are talking of not all kinds of problems, but certain categories of problems. Okay? So that we'll be discussing in the next module what are the problems that can be solved by programming, and we'll progress further. Thank you for this module.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 0 Introduction to C.mp3,"Hello. Welcome to NPTel's MOOC on introduction to programming in C. I am the instructor of the course, Satydev, an assistant professor at the department of CSE in IIT, Kanpur. So what is this course about? It introduces programmers to programming using the C language, which is an old and fair popular language. The course emphasizes solving problems algorithmically and writing readable and maintainable code for the solutions to these problems in the C language, and also the art of understanding code written by others and extending them if possible. So what does programming involve? We will take a look at certain problems, and then, given a problem, we will look into first, what do we mean by an algorithmic solution to a problem? So this is the logic of how to solve the problem. Then how do we code this in C? So this is concerned with the syntax of the language. Given an algorithm, how do we code the algorithm up in C? Once we have a solution to a problem, it is important to know how good the solution is. Are there better solutions? What do we mean by running time of this code? Are there code which will solve the problems faster, using less memory and so on? So we are concerned with the complexity of the problem and also in certain coding practices which makes our code readable and extendable by others. After all, programming is a social activity, and it is very rare that large software systems are written by single programmers. So in the course, we will try to emphasize a very basic introduction to modeler design of the code. How do you break up a problem into simpler components, which you can then build up to build the solution to the entire problem? So here is a quote by one of the famous computer scientists who says that the price of reliable code is the pursuit of simple code. The photograph is a very famous engineering feat which is known as the Bailey Bridge, which epitomizes modeler design. This is a bridge that can be built essentially by teams of five or six human beings without the need for heavy lifting equipment. And in some sense, the analogy of software engineering is that of a Bailey bridge being built by small teams of human beings working together and in making interchangeable parts. So we hope that you have fun in this course and enjoy your time learning and coding in C. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 1 Introduction   The Process of Programming.mp3,"Welcome to the introductory programming course on NPTEL moocs. The goal of this is to learn how to code basic programs in the C programming language. Basically, the aim of this course is to teach you how to solve problems using a computer. And by the end of this course, we will hope that you can write medium sized programs, maybe running to a couple of hundred lines of code comfortably in the C programming language. Programming nowadays is considered a basic skill, similar to mathematics, that is needed across all disciplines, like engineering, in the sciences, and nowadays even in the arts. So a little bit of programming skill is an enhancement to any other skill set that you might already have. This course we will start from the ground up. We do not assume any prior experience in programming, whether in C or in any other language. So the focus will be to start from the basics and to use C as a program medium of programming. Okay, a couple of words about the process of programming. It involves two basic steps. One is to define the problem. Often you get real world problems which are not precise enough to write a program for. So the first step would be to define and model the problem. And this is a very important step in large scale software development. However, we will not focus on this as part of this course. During this course, you will not write a large software system like the indian railways reservation system. Those are extremely complex problems involving multiple programmers. In this course, we will assume that the problem is well defined and already provided to you, so they will be precise and they will be fairly short and simple. So this is the first step of programming, which is definition of the problem, which you can assume will be given. Okay, now comes the second step, which is to obtain a logical solution to your problem. And what do we mean by a logical solution? A logical solution is a finite sequence of steps. Do this first, do this. Next, if a certain condition is true, do this. Otherwise, do something else. This is called an algorithm. So an algorithm is basically a finite step by step procedure to solve a problem. One way to visualize an algorithm is using a flowchart. If you are new to programming, it is recommended that you draw flowcharts to define the solution to your problem. Experienced programmers very rarely draw flowcharts, but that's not a reason for beginning programmers to avoid flowcharts. So defining a problem is there, then the process of coming up with an algorithm. This is a very important step in the programming process. And followed by this, there is a third step, which is to implement the algorithm in a usual programming language. Okay, so is the concept of an algorithm a new concept? I would claim that it is not an algorithm is a very familiar concept. The most important example that you can think of are cooking recipes. Now, cooking recipes are written in a way that they are almost algorithms. They are not quite precise enough for a computer, but they come quite close. Okay, for example, let's take an unnamed dish, a dessert, and let's look at how things are specified in a recipe. And we will see that this analogy is quite deep. There is a very strong similarity in the way that a recipe is written and a program is written. So usually they will have a list of ingredients up front. For example, you have ice cream, crushed cereal, and so on. And then once you have all the ingredients in place, then you have instructions to say, okay, how do you start and how do you end up with the dish? Now, those instructions will be fairly precise. Of course. You assume that the person preparing the dish is a fairly experienced cook, so that certain instructions need not be given in very precise detail. Okay? For example, you can say, do this heat oil? And so on. And it is assumed that a person knows how to heat oil. Even so, you will see that certain recipes are fairly vague and other recipes are fairly detailed. And in any recipe, you can see certain things which are vague and will cause confusion to most people. For example, here is a term which says, try to make each scoop about as large as your fist. Okay, now, that, of course, is a vague term because my fist could be a different size than yours. And then you see that in a formation that makes it easy to dip in order. So this is fairly vague, and it's not very helpful to a cook who is making this for the first time. So think of algorithms as similar to recipes, but mentioned in a more precise manner. Okay, another way you can be familiar with algorithms is when you buy a make it yourself kit for a furniture or something like that, and you will be provided with the step by step instructions on how to assemble the kit. Often, when you buy a disassembled table or something like that, it will come with a sheet telling you how to start with the components and build a table. Right. Those are also similar to an algorithm. Okay, so let us look at a flowchart to depict a mathematical algorithm, and we will use this flowchart to explain certain conventions about how algorithms can be described. So every flowchart will have a start and an end, and it will have a finite number of boxes. So this is the finite number of instructions that I was talking about. There are certain conventions in drawing flowcharts. The start and the end are often described in circles. Then there are ordinary boxes, and then there are diamonds. We'll shortly describe what they mean. So, suppose you want to write an algorithm for adding the first n numbers. All of you know how to do it. The point is, how do you describe this step by step, to somebody who doesn't know it already? So, first you have to take what is the upper limit? N. And then you have to sum them up. So, one way to sum them up is start with an initial sum of zero, and then add numbers one by one. So increment a counter from one all the way up to n. So you start with I equal to one, and then add the ith number to the sum, and then increment I. If I is already n, then you are done. If I is not n, then you go back and do the sum all over again. Okay, until you hit an I. Once you reach I equal to n, you come out of the program, print the sum, and end the program. So, this is a very simple flowchart. So, initially, if n is less than one, you have nothing to do. If n is greater than one, you start a counter from I equal to one to n, and add the numbers one by one until you hit the nth number. If you wanted to compute a slightly different problem, which is, let's say, the factorial of n, which is just the product of the first n numbers, the flowchart will look fairly similar. The only difference is that instead of adding numbers, you will multiply them. So, this flowchart is similar to the previous flowchart. You will first input an n, and then increment n until you hit n equal to m. If so, you will finally print the factorial. Otherwise you go back to the loop. Okay, so here are the conventions used. The start symbol is often depicted as a circle or an oval. The input symbol and the output symbol are often represented as parallelograms, and the normal operation boxes are represented as rectangles and the test box to see whether you have hit a limit to test some condition. In general, they are represented as diamonds.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 10 More while loops   Longest Increasing Subsequence 1.mp3,"Hello. So we will see one more example for writing loops. We'll see a slightly trickier example, and we'll cover this over multiple sessions. So the problem is the following. We have to read a sequence of numbers until a minus one is read. Minus one indicates that, okay, the sequence has ended. And the question is we have to out put the length of the longest contiguous increasing subsequence. Okay, so that's a lot of words. Let's illustrate it with an example. Let's say that the input is of the following numbers 924-03-4692 and then finally a minus one. And we have to output the length of the longest contiguous increasing subsequence. So let's say, what do I mean by a contiguous increasing subsequence? So I say that nine is an increasing subsequence. Then the next number is two. Two is less than nine, so nine and two cannot be part of a subsequence where the numbers keep on increasing. So two is the start of a new sequence. Again, the next number is four, so two and four form an increasing sequence. So you can continue increasing the sequence. The next number is zero. Zero is less than four, so you break the sequence there. And then when you look at the succeeding numbers, 03469, they form an increasing sequence, and the last number is two, which is lesser than nine. So the increasing sequence stops here. So these are the increasing contiguous subsequences, contiguous means together occurring adjacent to each other. So the largest or the longest contiguous subsequence is obviously 03469. Okay? And the length of that sequence is five. Let's take another example. Eleven, nine, 7811 1215 and minus one. Okay? So just to illustrate the point, eleven is greater than nine, so that can't be an increasing sequence. Nine is greater than seven, so that's another. The increasing sequence is just nine. But then 7811 1215, these are increasing. And I decided to stop here, even though the next number was 15, because I am interested in an increasing subsequence. So 15 and 15 are equal numbers, so we break it there. So the longest increasing subsequence is 7811 1215 and its length is five. So this is the longest contiguous increasing subsequence. So here is a basic property. Given any sequence of numbers, we can break it into a collection of increasing contiguous subsequences. For example, the numbers that the sequence that we have seen. So 9240-346-4692 and the longest increasing contiguous subsequence is five. So we have to write a program to do this, given a sequence of numbers, find the length of the longest increasing subsequence. Okay, so how do we do it? We do it in the way that we have been writing loops so far, like adding n numbers and finding their sum and so on. The idea was that you start from the first number and keep on adding the numbers until you hit a minus one, at which point you have the sum. So the idea of this algorithm was that you start from the first and you keep reading until a certain condition happens. We'll adapt that idea to solve our current problem. So what we need to do is to keep track of the current increasing subsequence. Let us say that it is denoted by s. Okay? So before we get into the code, let's see how we will do it by hand. So initially the increasing subsequence is s. And let's say that it is empty. After you read nine, you have an increasing subsequence which consists of exactly one number. So s is nine. Now the next number is 1010 is greater than nine. So you extend s, read the next number, four. Four is less than ten. Right. So 910, four cannot be an increasing subsequence. Therefore, you say that you break the subsequence there. Okay, so 910 is a different subsequence. Now you start a new subsequence which is four. So the current subsequence is just four. So zero is less than four. So you break it there. The current increasing subsequence becomes zero. Read the next number, three. Three is greater than zero. So you extend the subsequence, s is now zero, three. Four is greater than three, so the sequence becomes 00:34, and so on. Okay, so what are we doing here? We are reading the numbers integer by integer, and we are keeping track of the current increasing subsequence. Okay, so this is part of what we want to do now in order to decide whether we should increase the subsequence, extend it or break the subsequence and start a new sequence. What we need to do is we should remember what was the previous number we saw and what is the current number that we are seeing. So with two variables, we can say whether the subsequence should be extended or should be broken at this point. Okay? So if the previous number is less than the current number, then we should extend the subsequence. If the previous number is greater than or equal to the current number, then we should break the subsequence and start a new sequence. Okay, so extend a sequence means add one to the length of the current decreasing subsequence and add that number to the subsequence. Reset means you start a new sequence of length one. Okay, so from the description that we have seen so far, we need the following variables. We need c, which is for the current red number, p, which is the previous number that we have seen, and len, which is the length of the current increasing sequence. So we store the previous number into p, store the current length of the increasing subsequence into length and read the next number into c. Okay, so if the previous number is less than the current number, so we take the true branch, in which case we extend the sequence. So the new number that we have read is part of the currently increasing subsequence. So increase the length of the sequence by one. And now we move lock step. So what we do is so we are at a stage where suppose we have numbers one, two and three. Suppose p was pointing to one, c was pointing to two. So since two was greater than one, we extend the sequence. After extending the sequence, we have to proceed and see what will happen with the next number. So when you do that, you can do the following. I will extend the current sequence by doing the following. I'll now set p equal to two and c equal to three. So this is the idea that we will advance both the variables by one number each, so that it is always true that previous is one number behind current. So I hope this idea is clear that in order to ensure that p is one number behind current, you have to advance both p and c. So assign p to c. This will advance p and then read the next number so that will become c. Now what happens if C is greater than or equal to p? Then the new number is not part of the current increasing subsequence. So you start a new sequence which is of length one, and again do the same. Assign p to c, which is advancing the pointer, and read the next number. So here is the method that we will follow in order to keep track of the current increasing subsequence. Now what is left is to find the longest of all the increasing subsequences that we find.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 11 More while loops   Longest Increasing Subsequence 2.mp3,"You. In this session, we will try to code up the C code for finding the length of the longest increasing contiguous subsequence. So, let us first examine what we need to do. We will write a code, and from the previous discussion we saw that we need at least three variables, one for storing the previous number, one for storing the current number, and the third for storing the length of the current decreasing subsequence. So we start by declaring all those three variables and initializing length to zero. Okay, so here is a new construct that we are seeing for the first time, which is that when you declare a variable, you can also initialize it immediately by saying len equal to zero. So this is a very intuitive notation. So this will declare a variable and immediately initialize it to zero. Okay, so once we declare these three variables, let's say that we scan the first variable into previous. Okay, now let's focus on the main body of the program. If the currently read number is, if the currently read number is not minus one, then you say that you start with length one. So the length of the current increasing subsequence is one. And then you scan the next number into C-U-R. So here is the current number. So this part of the code is just to initialize. So if the first number is minus one, then there is no point in getting into the program because it's equivalent to the empty input. So there is no increasing subsequence to be found. So you just exit out of the program. So initially we just check to see whether the first number is minus one or not. If the first number is not minus one, you scan the next number, okay, so current will be the second number, and if current is not minus one, while the currently red number is not minus one, what you do is exactly the logic that we were discussing before. If the previous number is less than the current number, then you extend the length by one. Okay, so len equal to length plus one says that I am continuing the current increasing subsequence by increasing its length. Otherwise, that is, current is less than or equal to previous. You break the sequence and say length equal to one. Then we have this step, previous equal to current, which is the advancing both variables by one. So previous becomes the currently red number and current becomes the next number to be read. So, recall from the diagram that previous and current were at some position, and we will advance both of them by one. And when the loop condition is checked next time we will check whether the currently seen number is minus one or not. So, so far we have coded up part of the logic, which is the part of the logic dealing with when the next number is red, do we extend the sequence, or do we break the sequence and start a new sequence? So this is just part of the work that we need to do to solve the problem. So let's continue with the logic. Okay, so let's start with a few boundary cases, and let's see whether this works. If it works, we can try our logic on other cases. So let's say that by boundary cases, I mean maybe very long inputs or very short inputs. So these are cases where your code normally breaks. So when you test your code, it is always a good idea to check boundary cases. And one thing that makes programming difficult is that when we do things by hand, we know how to handle the boundary cases elegantly. But in a program, unless you say how to handle the boundary cases, the program might break. And a lot of testing and a lot of errors come from incorrectly handling the boundary cases. So it's always good to handle the boundary cases. Let's try test our code on very small inputs. Okay, so let us say that I enter a sequence phi minus one. So length is zero. Previous becomes five, and then since previous is not minus one, I have used an abbreviation here, which is the not equal to operator. This is the same as saying not of previous equal to equal to one. Okay, so previous not equal to one is the same as saying not of previous equal to equal to one. It's an operator in C, equal to one. Then you say that the length is one because you have seen one number and scan the next number. The next number is minus one, so you scan the next number, and the next number is minus one. So you break the sequence. So you immediately exit out of the sequence, and the length of the increasing subsequence that we saw. So five is the only increasing subsequence. And when we exited, the length was one. Okay, so we handled the boundary case of an extremely small sequence, a sequence with exactly one element correctly. This gives us confidence that the code could be correct. Of course, we have handled only the boundary case. Now we need to test it for other cases as well. So, so far, the program is not doing anything useful because we are just extending the sequence and breaking the sequence. What? Recall that what we were supposed to do was to find the length of the longest increasing subsequence. Okay, so this is the main thing that we have to do in the logic. So to do this, what we do is something simple. We keep track of the maximum length sequence that we have seen. So far, we keep track of the length of the longest sequence that we have seen so far. Also, we have the current sequence. Right now all we need to do is whether to check whether the current sequence is longer than the previously known longest one. So for this, what we do is keep track of the maximum length that we have seen so far. Okay, so this is a standard technique in programming. And how do I do that? So let's modify the program a little bit. So earlier we recent out that we need at least three variables. Now, in order to keep track of the length, the maximum length that we have seen so far, I need a new variable. Okay, so this part we have already done before. And here is the max length equal to zero. So that is the new variable, which is the maximum length that we have seen so far. When we start the program, we have not seen any increasing subsequence, and therefore the length of the longest increasing sequence. The current increasing sequence is zero, that is len equal to zero. And the length of the maximum length that we have seen so far is also zero. Okay, then you scan the new number. If the new number is not minus one, you continue. So length equal to one. Now, max length equal to one, because currently the longest sequence that we have seen so far is one, one long. You scan the next number. Here is the main body of the loop. And what we need to do is the following. If the currently red number is greater than the previous number, we extend the sequence. So this logic is the same as before. Otherwise, which means that current number is less than or equal to previous. So we are starting a new sequence. So the situation is the following. We have some max length sequence somewhere in the past. So max length is the length of the sequence that we have seen somewhere in the past. Now we are scanning the sequence, we have a current sequence, and we have decided to break the sequence. So we are now starting a new sequence, starting at current. Okay, so we are at this part of the logic. So we have decided to start a new sequence. That is because the current sequence's last number is greater than or equal to the current number. So here is previous and this is current. So we are deciding to start a new sequence. What we need to see is whether this sequence is longer than the previously known maximum length. Okay, if the sequence that we just stopped is longer than the previously known maximum length sequence. So if max length is less than length, notice that length is the sequence that length of the sequence that we just stopped, then we say that max length equal to length. So if the current sequence is longer than the previously known max length. What we do is that max length becomes. Becomes the length of this sequence. Otherwise, if the current sequence was shorter than the previously known maximum length, we don't do anything. So maximum length is the same.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 12 More while loops   Longest Increasing Subsequence 3.mp3,"You. So when we extend the sequence, we don't have to do anything special. When we break a sequence and we start a new sequence, then all we have to do is you check whether the sequence that you just saw was longer than the previously known longest sequence. If that is the case, then the sequence that just ended is becoming the longer sequence that you longest sequence we have seen so far. Otherwise you maintain the max length, just forget about the currently stopped sequence. So that's this loop, and at the end we have to do a slight tricky logic. It could so happen that the sequence ends with the longest increasing subsequence. In that case, we will never reset the max length. So if the last sequence is the longest, you also have to handle the case separately. Okay, so we will see an example where if you exit out of the loop, that is, you have already seen a minus one. You just have to check whether the last increasing sequence that you saw was in fact the longest. So there is a small if block at the end to do that. In this part, we will just see a small tracing of this program on a sample input, so that the logic of the program becomes slightly more clear. Okay, so I have picked a particular input, 3213 phi minus one. And you will see that the longest increasing sequences are three. So the increasing sequences are three, then two, then one three five. So one three five is going to be the longest increasing subsequence. And let's see how our program will find that out. Okay, so initially you have a bunch of variables which you declare, so length is zero, max length is zero, and previous and current are undefined. Then you first read previous, so previous becomes three. It's not minus one. So you enter the if condition, at which point you set length and max length to one. Now you scan the current number, so current becomes two. So remember that previous is now three and current is two. Okay, so current is not minus one. Therefore you enter the while loop. Previous is less than current is false because previous is three and current is two. Therefore you enter the else part. Max length less than length is false, both are one. Therefore you start a new sequence with length equal to one. Now you continue the loop with previous becoming current. So previous is now two, and current you read the next number, which is one. Okay, so previous and current have both moved one step, so current is not minus one. Previous less than current is again false because two is greater than one. So you enter the else part, max length and length. There is no change. So you reset the length to one. Previous is current, so current, previous becomes one, and you scan the next number, which is three. Okay? Now, at this point, previous is one and current is three. So the if condition is true. So you extend the length. Length increases by one. Again, you advance previous and current, so previous becomes three, current becomes five. Again, three is less than five, so increase the length. We are extending the sequence. So the length becomes three. Advance, so previous becomes five and current becomes minus one. At this point, you exit the loop. Okay? And now you encounter the situation that max length, which is the length that we have seen so far. Recall that it is one, but the length of the sequence that we just stopped the input with is three. That happened because the longest increasing contiguous subsequence was at the end of the input, so it happened right at the end. So when we exit the loop, we have to do one additional check. Okay? We can't simply say that the maximum length that we have seen in the sequence is one, because max length is the length of the longest sequence we have seen before the current one. And the current one was the one that we just stopped with. It had a length of three. So we just check if max length equal to length is less than the length, then you set max length to be the length. So once you do that, max length becomes three. This is just to handle the case when the longest increasing subsequence is the last. Okay, now you can exit out of the if condition and then print that the maximum length that you have seen is three. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 13 Do while loop.mp3,"So far we have been using while loops in C. Now, c programming language also provides you other kinds of loops. Let's look at some of them. The first alternative loop mechanism in C that we will look at is what is known as a do while loop. So it's a variant of a while loop. Um, and the general form is what you see here. You have do statement followed by while expression, and here is an important syntactic difference which causes some syntax errors when you code the do while terminates within semicolon, whereas the while loop doesn't. So the while loop has the following form, which is while expression and then statement. The difference is that here the statement is occurring before the while the test expression. So the way it executes is the following. You first execute the statement, then evaluate the expression. If the expression is true, you go back to step one, that is, execute the statement. If the expression is false, then you get out, so you execute the statement, then test whether the expression is true or not. If it is true, you go back and execute the statement again, so you loop. If the statement is false, you get out of the loop. The difference from a while loop and a do while loop is the following. You have a statement that will be executed without testing the expression even once. Okay, so when you start executing the loop, you will first execute the statement without testing the expression, and after testing the expression, you will go back and test the loop expression if it is true, and you start executing the loop again. So the first execution of the statement. There is no test done for that. So let us see the comparison between a while loop and a dual while loop. So we will look at the following problem. You have to read numbers and output each integer until a minus one is seen. Now the difference is that in this problem you have to include the minus one. So read all the numbers up to and including minus one, and print all the numbers. So we will have the following programs using while loop and do while loop. Now the important thing to notice is that the while construct and the do while construct are equally expressive. So you cannot write any more new programs using the do while construct than you could using the while construct. But certain kinds of programs are easier using are shorter using the do while construct. For example, let us solve this problem using the while construct. So what you do initially is you declare a variable, then scan the variable. If the variable is minus one, you immediately exit out of the loop and print minus one and finish the program. If the number is not minus one, you print the value and scan the next number. If the number you scanned is not minus one, you just print it and repeat the loop. If it is minus one, you exit out of the loop and print the minus one that you saw. So here is the logic using the do while loop. Using the while loop. And notice that when we exited out of the loop, we needed a printf statement. And before you enter the loop, you needed a scanf statement. Okay, so this was the structure of the program. This problem can be elegantly solved using the do while loop. What you initially need to do is you declare a variable, then scan the variable and print it anyway. Either the number is minus one or it is not. In any case, we need to print it. So go ahead and print it. Then test whether the number was minus one. If it is minus one, you are done and you exit out of the program. If it is not minus one, you go back and scan the next number and print it. So this is a program that we have seen where you could do the same thing with the while loop. The only difference is that the do while program is shorter. Okay. And please be careful about the syntactic difference between the while loop and the do while loop. Notice the semicolon at the end. This causes a lot of confusion when you compile the program. It is easy to miss this. If you are new to C programming, you can stick to one particular loop. As I said before, you cannot write any new programs that you can do using the do while loop than you could previously do using the while loop. Okay, so you can write the same logic. You can write the same number of programs using the while loop and the do while loop. It gives you no further power. So it is recommended that you stick to one loop. Pick while or pick do while, whatever you do, but stick to that loop in. When you write the program. When you're comfortable with one of the loops, programming using the other loop becomes easy. Okay, so let us try to solve a problem that we have already seen, which is to find the length of the longest contiguous increasing subsequence ending in minus one. The difference that we have is that earlier we did not include minus one in the sequence when you computed the length of the sequence. Now we will include minus one. Okay, so here is the program to do that and the core logic. So here is the initialization, and here is the loop logic. Okay, and the final check. So, if you recall from the lecture which covered the problem solving the longest increasing subsequence, then you will see that the main structures in the code, the main lines of logic in the code, are pretty much the same. All I have done is to change the while logic to the do while logic. Okay? And let's see what that has accomplished for us. So what this does is that you will scan a particular number. If the particular number is bigger than the previous number, then you extend the sequence. If it is less than or equal to the previous number, then you stop the sequence and start a new sequence. This was the logic. And when you start a new sequence, the length is you start with one. Okay? Then you say current equal to the next number and previous equal to the number that was just read. So the logic here is that the testing for whether the currently read number is minus one is done at the end of the loop. So if the first number is minus one, you just do all this and then say that the length of the increasing subsequence is one. And then you test if the currently red number is minus one or not. If the currently red number is minus one, then you are already done and you exit out of the loop. Then you check whether max length is less than length as before. The difference between this logic and the logic that we have seen before is that we do this execution without testing whether the currently red number is minus one. So automatically what happens is that if the number is minus one, all these steps will be performed before we test that the sequence has ended. So automatically we ensure that minus one is also included when we calculate the increasing subsequence.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 14 A matrix problem   nested loops.mp3,"Hello. In this session, let's look at a matrix problem. And the problem is given as follows. You have a bunch of lines of input. The first line of the input consists of two numbers m and n. This line is followed by m lines, each containing n integers. Okay, so this is supposed to represent a matrix x of size m times m cross m. We have to calculate the sum of the squares of the sum of numbers in each row. That's quite a mouthful. Let's look at the formula. So what I want to do is summation j. Aij. So once you do the sum, you square that and then do the summation I. So I is an index which goes over the rows. In C. We adopt the convention that the first row is starting with zero and so it goes from zero to m minus one. Similarly, the first column starts with index zero. So it goes on till n minus one. So the input will be given as follows. The first number m represents that there are three rows. The second number represents the number of columns in each row. And then this is followed by a matrix of size three cross four. Okay, now the numbering is give as follows. For example, if you have a 20, this means second row zero th column. Note that second row means we start with row zero, then row one, then row two, and zero th column. Is this the first column. So a 20 is this number which is two. Similarly, a twelve is first row, row number one, column number two, which is also two. So the desired output that we have is four plus seven plus eleven plus two, whole square, and so on. Okay, so how do we do this by hand. Let us just look at the calculation. So we have 4711 21124 and two 90 minus one. Notice that the form that we have to calculate is I going from zero to zero to two, j going from zero to three aij squared. Okay, so how do we do this? First, we sum the numbers in each column. Okay, so I'll name that as j going from zero to three aig and then squared. So if you sum all this, you see 11, 22, 24 squared, which is 576. And similarly, this is 64 eight squared. And this is ten squared, which is 100. Okay, so what I have tallied on the right hand side is for each row you sum the numbers, take that sum and square it. And then finally, in order to compute what we want, which is I equal to zero to two of summation j equal to zero to three aig squared. In order to calculate this, all we need to do is to sum this number up. And this turns out to be 740. Okay, so, notice when we did by hand, we did the following. We first calculated row wise. You summed over all the numbers in that row, take the sum, square it. Then you repeated the same operation for the next row and then for the third row. So, we have three numbers, and then we added them in sequence. So we will see how we will code this up. So, what we need here is something called an inner loop or a double loop. Okay, we need a loop inside a loop. Now, the inner loop is doing what we did first. It is taking a row and adding all the numbers in that row, then squaring it. So we need one loop to do the row sum of each row. Once a row is finished, we square the row sum. Once that is done. Remember that once we tallied numbers on the right hand side and squared them, we had to add those numbers up. So we need another loop, an outer loop, to add the squares of row sums. So, let us do this program in stages. First, let us write the inner loop. This is the loop, so that for a given row, you sum up all the numbers in that row. Now, let's assume that we are at the beginning of a row and we have not read any numbers yet. Now, what we have to do is to start reading the numbers. So, we write a while loop. We declare four variables, a column index. Then we need something for the row sum and some integer variable for row sum squared. Now, what you do is you go along the row and add the numbers in each column. Okay? So while the column index is less than n, recall that the matrix size was m cross n. You scan the next number. The next number is added to the row row sum and then increment the column index until you hit n minus. Until you hit n. Recall that the last column is n minus one because we start the column numbers from zero. Now, once you are done, you have the sum of the numbers in that row. And what you need to do is to square that number. Okay, so we have row sum. Times row sum will be row sum squared. That completes the inner loop, which is what we did when we added the numbers along a given row and then finally squared the sum. Now, what we need is an outer loop structure over this. So we have a code that reads the next n integers from the terminal and sums them. Now, what we need is some further code that takes the output of the previous code and then sums all those numbers up. Remember when we did this by hand? This was the second operation we did. We went over the rightmost column and added all those numbers up and that was the result that we wanted. Okay, so how do we modify the code? Okay, so what we need is something like this. Assume that we have the output available from the previous code in some variable called row sum squared. And we need a loop over that, which is going from row index zero to m minus one, and tallying up all the numbers in row sum squared. Okay, so for each row, you will end up with a row sum squared and you have to add all those row sum squareds together. So in this, the row sum squared comes from the previous code. So this is how we will visualize the outer loop. Now, note that this is not completely specified code. This is just a very intuitive picture that instead of rho sum squared, it should come from some inner loop which actually calculates it. So we should plug in the output from the previous inner loop, and this is the outer loop over it. Okay, so here is how we put these two loops together. We have a while loop inside a while loop. Remember that this was the previous loop that we had written. So this was the inner loop that we had written, where at the end of the inner loop, you have the row sum squared. Right. Now, at the end of the code, what you will end up is the exact row sum square of a particular column. So you can imagine that after this inner loop finishes execution, the row sum squared is the correct row sum is the correct square of the sum of the elements in that row. Now, the outer index does the following. You start from row index zero and sum the row sum square over all columns. So, this is the structure of the code. Let us look at the code in slightly more detailed. We have a row index, a column index, a column sum, a row sum, and a row sum squared. A is supposed to be the current number that we are reading. Suppose we know that the size of the matrix is m cross n. So rho index can go from zero to m minus one. So the termination condition of this while loop is row index equal to m. Now, for all that you are currently at a particular row, so you have to initialize the row sum to zero and the column index to zero, because for a given row, you have to start from row zero. For a given row, you have to start from column zero and you go on until column n minus one. Also, this previous row sum should not influence the next row. So for every row, you have to initialize the row sum variable. Once that is done, you go over the columns of that given row and you scan the numbers, add the number to the row sum and increment the column index until you hit n columns. Okay, columns zero through n minus one. When you have read all the columns in that row, you have the correct row sum so that row sum squared can now be calculated. Once row sum squared is calculated, you have the row sum squared for that particular row. So add the row sum squared to the previously computed column sum. So if you go back and think about how we did this by hand, you can convince yourself that this is exactly the coding of the logic that we had earlier. So let's try this on a small example to see exactly how the code works. Suppose the input is two three followed by two rows of three numbers each. Okay, so the input matrix size is two, cross three and the entries are 10 minus one and 00:11. Let's see how the code executes on this. So the output should be four if you do it by hand. And let's see, the variables are M-N-A row index, column index, row sum, and square sum. Finally, the result should be in square sum. You start with row index equal to zero, column index equal to zero, and you scan m and n. So you already know the size of the matrix. When you scan m and n. So m becomes two and n becomes three. Now row index is zero which is less than two. So you start the loop which reads the row zero. Okay, so notice the arrow here you are starting to read this particular row, the first row which is row zero. Now you initialize row sum equal to zero, column index equal to zero, and while column index is less than n, you scan the next number which is one. Add a to the row sum. So row sum becomes one. Increment the column index so you reach column one, row zero. Read that number, add it to the row sum, go to the second column, read the number, and add it to the row sum. Okay, so once you are done. Now column index is two, column index is three. So this means that we have read all the entries in the row zero. Okay, so we have got the correct row sum. What we will do is add the row sum squared to the square sum. So row sum is zero, zero squared to square sum, so square sum remains zero. Now you go to the second row, so increment row index. Now, row index is less than two, row index is one, so it is less than two. We are reading row one and you repeat the same execution. We reinitialize row sum to zero, column index to zero, and then scan the next number which is zero. Add, add it to the row sum. Increment the column index. Scan the next number which is one, and so on, until you finish reading the second row as well. So, once you read the second row, you will find that the row sum is two and square sum would be square sum plus two squared, which is four. After you do that, you increment row index, and rho index becomes three, which is greater than the given row index. So you exit the loop. So, we have correctly computed the sum that we wanted.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 18 A matrix problem using nested for loops.mp3,"In this session we will use the for loop to code up a matrix problem. So remember that we have seen a While loop and we have seen a do While loop inside While loops. We have written nested loops or double loops. So let's look at a for loop which problem where the solution involves a nested loop. So the for loops are a good choice when the number of iterations is known in advance. So a good example of such a condition is when you program for matrices, because the dimensions of the matrices are known in advance. So let us consider a sample problem. So the first line of the input has a number n. Now the matrix size is n cross n, and there are n floating point numbers in the matrix given row by row. Each line contains a distinct row. Now the problem is to compute the trace of the matrix. The trace of the matrix is the sum of the diagonal elements. So it is defined as summation from I equal to zero to n minus one of a sub ii. Notice that the matrix row indexing starts from zero. Similarly, the matrix column indexing also starts from zero. So let us write a c program to solve this problem. Okay, now you should be familiar with how we compute the trace of a matrix. So for example, if the matrix is given as let's say, 123-45-6789 so the way we do it by hand is look at the first row, only this element goes into the trace. So it is trace is one plus, okay, no other element of the row goes into the trace. In the second row, the second element goes into the trace, so it is five plus, and then no other remaining element goes into the trace. So you go to the third row and the third element goes into the trace. So one plus five plus nine. This is how we do it by hand. You go row by row and then pick out for each row, pick some element which goes into the trace. Only the diagonal element will go into the trace. Let's try to code this up. So in this we have two variables in j, which I will use to iterate over the row indices and the column indices. N is the designator for the size of the matrix. For example, the dimension of the matrix is n cross n. Now a is the variable into which I will read the current entry. And then trace is the sum of the diagonal elements seen so far. I'll assume that it's an integer matrix. It's not general enough. You can use a float variable as well. I'll first scanf the size of the matrix n. The matrix is of dimension n cross n. Once I've done that. Here is what I was talking about in the previous slide. Once you scan the number n, you know that the matrix is n cross n. Okay? So the number of times that you are going to iterate is known in advance. So the number of times that you have to iterate is known before you enter the for loop. In such cases, the for loop is more convenient to write than the while loop. So the outer loop is for each row from I equal to zero to I equal to n. Excluding I equal to n, you increment the row. Similarly, for j equal to zero to n, you increment the column index. So j is supposed to be the column index. Now you scan the number a. Now if I equal to j, remember that we wanted to add only the diagonal elements. So the diagonal elements will be when the row index is the same as the column index. So when the row index is the same as the column index, you should add the corresponding number to the trace. So once j becomes n minus one, you will fail the test. J is less than n. So we'll exit out of the inner for loop and you will go to the outer for loop. In the outer for loop you have I iterating over the row indices. So you will go to the next row and do the same processing for the next row until you hit row index n, at which point you will exit out of the outer for loop. So let us look at a sample input. Let's say that you have 123133 and minus 10 minus one. Okay, here is a particular convenience that c gives you, which I have used in this code. So notice that this if block I did not put the braces, okay? So it would have been necessary to put the braces according to the syntax that we have discussed so far. But if there is only a single statement in the if block, then we don't need to put the braces, and it is syntactically correct to do so. So let us just run the program on a sample input. So we have some sample array, 20 minus 1134 minus 10 one. So initially there is this number three. So you know that it's a three cross three matrix. So once you do that, you know that n is three. So representing that it's a three cross three matrix. So then you start with I equal to zero and go on until I less than n, incrementing I by one. Each time I is zero, I is less than n because n is three. So you enter the outer loop. The first statement of the outer loop is itself a for loop you start with j equal to zero. J is less than three. So you enter the inner loop. You scan a number, a, which is a floating point number. And if I equal to j. So remember that we are looking for diagonal elements. So we are currently at this point, and I equal to zero and j equal to zero. So we are scanning the zero th element of the zero th column of the zero th row. So that element has to go into the trace. So I equal to j is true. And then you say that trace equal to trace plus a trace was initialized to zero. So trace becomes now two. Once you do that, you iterate the inner for loop. So you go to the update statement. In the inner for loop, j becomes j plus one. So you go to the next column, and j is less than three. So you scan the next number, zero. If I equal to j, that is false. Now, because I is zero and j is one. So you don't execute the if statement and go to the update statement. So j becomes two. Two is less than three. So you scan one more number, which is minus one. I is not j. Okay? So you update again. J becomes three. Now, three is not less than three. So you exit out of the inner loop. When you exit out of the inner loop, there are no more statements to execute. So you go directly to the update statement in the outer loop, which becomes I equal to I plus one. So you are reading the first row, row number one. You have finished reading row number zero. Again. You scan the numbers. When j equal to one, that is the second number in the second row. You will see that I equal to j because I is one and j is one. So you will add it to the trace. So that is two plus three, which is five. So trace gets updated. And after you do that, you scan the remaining entry in the same row, but it doesn't go to the trace. And then you're done with the row after that. Again, you go to the outer loop. You update the row index. Now, the row index is two, which is less than three. So you enter the if condition and you execute the inner loop. When I equal to two and j equal to two, you will find an element which is minus one, which will go into the trace. So the elements that will be added to the trace are when two, three, and minus one. Once you're done, you get out of the inner loop, and then you go into the outer loop and update it. But then I becomes three. It is no longer true that three is less than three. So you're done reading all the rows so you exit the program. Okay. When you exit the program, you have the correct trace, which is four. It.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 19 The break statement.mp3,"Hello. In this session we will see one more feature that is present in C associated with loops. So we will motivate these statements using the concept of an infinite loop. Here is a drawing that's supposed to be a representation of an infinite loop and a trivia. For example, the apple headquarters. The address is one infinite loop. So let's see what is an infinite loop. So the simplest kind of infinite loop is when you have a while statement and the test condition, you can see that it will never be false. Okay, so remember that one is true in C. So this statement means that you will enter the while loop. You'll test the condition, the test is true. So you'll execute the statement. You will go back and test the condition again. It is again true, it has not changed, it is one. Therefore you will enter the statement again. So you will have an infinite loop. If the test is executed, then the control enters the body of the loop, and this happens without any change. So let's look at this simple while loop, which is while one. The statement is printf hi, I am an infinite loop. So if you'll run this code, compile and run this code after you write the main function and all that, then the program will keep on printing the same message over and over again, and you can't exit out of the program. If you're running a Linux system, you can press Ctrl C and the program will exit immediately. But here is an infinite loop. It executes an infinite number of times. So is there a statement which helps us to exit from a loop? Now this is useful not just to handle infinite loops. Even when you write normal loops, it is important to have these constructs. They make your programming easier. So C allows a programmer to explicitly break out of a loop using a particular statement known as break. When the break statement is encountered, the execution breaks out of the innermost loop. So what is a loop? So far we have seen while loop do while loop and for loop. Later we will see a construct called switch. So whatever is the innermost loop. Notice that we have talked about double loops. We have talked about a while loop within a while loop. We have talked about a for loop within a for loop. Whatever is the innermost for loop within which a particular break occurs. It will exit out of that. So let's write a very simple program which reads all numbers till minus one is seen and adds them up. Minus one is excluded so you can write a while loop. We have written this before where the while loops test condition was somewhat more sophisticated. Earlier we wrote something like while if you recall, we had written a loop saying, while not of a equal to minus one. Okay, so this was the earlier loop that we had written. And in this case, let's write a similar program, but with a simpler test expression, which is just while one. So you always enter the loop, no matter what number you read. So initialize the variable sum to zero, declare the integer variable a, and then you enter the while loop. Because the test is true, you scan a number. And here is a use of the break statement. If the scanned number is minus one, you break out of the loop. If it is not minus one, you go to the next statement, which is sum equal to sum plus eight. So you add the number again, you go back to the loop. The test condition is always true. So you enter and read the next number. So the net effect of the loop is that whenever you see a minus one, it immediately exits out of the loop. Otherwise it adds that number to the loop. So let's look at it using a sample input. Initially, a is undefined. It's just declared, so it has some garbage value, and sum is initialized to zero. Let's say that the input is phi, three, two minus one, while one. So one is true. Therefore, you enter the while loop. You scan f, the first number. So a becomes phi. A is not minus one. Therefore, you go to sum equal to sum plus a, so sum becomes five. And then you go back to the while loop. The test condition is still true while one. So you read the next number, three. Three is not minus one. So you add it to the sum. Sum becomes eight. And you go back, the same thing occurs. So you have the third number read, which is two, add it to the sum, and sum becomes ten. Then you read the next number, and now a is minus one. Okay, so what happens? The if condition, the expression within the if statement is true, and you execute the statement inside the if condition. The statement is break. Okay, so recall that the rule of break says that exit out of the innermost loop. Okay, so in particular, what is the innermost loop? You look starting from here, and imagine that you are going outwards towards the top of the state, towards the top of the program. The first loop that you will encounter on its way, that is the loop that you will exit out of. In particular, break doesn't mean that exit out of the if condition, okay, break means that exit out of the first loop that you see when you start from the statement and work outwards. Okay, so that is this while loop break means you will exit out of that while loop and print this statement. Okay, so you'll print that the output is one, the output is ten. So we have been dealing with integers for a long time. Let's write a small program using characters. So here is a problem and let's say that we are writing a very simple editor. Now, the editor has the following property. There are a particular number of maximum characters that you can read. Maybe it's 1000. So you can type in a bunch of characters until one of the two conditions occur. Either you enter a blank line by itself which is indicating that I am done entering the text, or you enter more than the maximum number of characters available. So recall there are two conditions for exiting out of our so called editor. You can type a lot of characters. If your limit was 1000 and you exceed thousand, then you can't type in any more characters and you exit. Otherwise, if you are within thousand characters, but you entered a blank line that is indicating that you are done. Okay, you have nothing more to enter. Then also you should exit. Okay, so there are two conditions. Let's try to write this code so you have maximum characters. And let's say I scan that, then an I, which counts how many characters I have read so far. So I should initialize to zero, and then there is a current character, and then there is a previous character. So I will initialize current to the new line character. Okay, now there is a particular reason for that which will become clear later. So you should initialize current to a particular character. And then what I do is use the getchair function. So Getchare function reads a particular character from the input and stores it in some variable if you need to. Instead you can also say something like scan f percentage c and into some variable. So you can do either of these two things and they are almost equivalent. Okay, so you read one more character. Now what should you do? You initialize by starting from zero. So you have read no characters until now and until you read maximum number of characters. So you execute this loop. Remember that I said that for loop is good when you know the number of iterations in advance. So we know that at most we will execute maximum number of character times because that's the maximum number of characters we are allowed to read. So a for loop is slightly better than a while loop. You can also do it using a while loop if you want. So you say for I equal to zero, I less than maximum characters, I equal to I plus one. Now we will do this programming style that we should be familiar with right now. So previous becomes current and current becomes the next character. Okay, so previous equal to current. So this will store the current character into the variable previous. Then you read the next character using Getchar. And as I said before, you can also write equivalently, scan f percentage c and current. Okay, so both these are almost equivalent. There is a slight difference, but it's not important. As of now, if current is new line and the previous was new line. Okay, so when will that happen? When suppose I write this is a sentence, I will explicitly represent the new line. So when I press enter, I will have a new line character here. And when will a blank line occur? When the next character is also new line. Okay, so by a blank line, what I mean is that the current sentence is over. So I press a new line and the next character on the next line is also a new line. That's what is actually meant by a blank line. So when that happens, then we know that an empty line has been encountered. And here is the important thing, break. Because one of the conditions to exit out of that loop was that either maximum number of characters is encountered or a blank line is encountered. So you may not have encountered maximum number of characters, but you have encountered a blank line. So you should exit out of the loop. Again, the rule is that break out of the innermost for loop, innermost loop, which in this case is this for loop. So you get out of that loop and printf a new line. Now, as with many constructs in C, you can avoid break altogether. You can write code if you have used break, you can write equivalent logic without using break. So here is a standard way to do it. Okay, so here is the code that we just dealt with. It had two exit conditions. One is that the number of characters that you read is greater than the maximum allowed. Another exit condition was that you had entered a blank line. Okay, so here we used the break statement, and now I want to write an equivalent loop without using the break statement. And here is a very standard programmatic style. These are known as flags. So flag is just a variable which indicates that a particular condition has occurred. Initialize flag to just zero. Okay, in our code, what flag is supposed to do is that it will indicate whether a blank line has occurred or not. So let's first look at the body of the loop without looking at the loop head first. Okay, let's just look at the body of the loop. So it's similar to what went before. Instead of the break statement, what I'll do is if I realize that an empty line has happened, then I will set flag to one notice that flag was initially zero, so flag equal to one will indicate that an empty line has been seen. Now I will modify the loop as follows. Remember that the test condition here is just that maximum number of characters has occurred. Instead, I will check for two conditions in the for loop, I'll check that maximum number of characters have not occurred, and I will also check that flag is not one. Because flag is one means that a new line, a blank line, has been encountered. So I'll check for both these conditions in the for loop itself. If either of them is true, that is sorry. If either of them is false, that is, if I is greater than or equal to maximum characters or flag equal to one, then the test condition will become false and you will exit out of the loop. So here is a standard way to avoid a break and notice that this condition is negated in the for loop because the condition in the for loop is the condition for entering the loop. So to exit out of the loop, you need flag equal to one. So in summary, what I want to say is that if you want to write a code using break, you can also write it without using break. One of the standard ways to do it is by using a flag variable. For whatever condition that we want to check. You can pick either of this style, whichever suits you more. So how do we decide whether to use the break statement or not? Sometimes the use of the break statement can simplify the exit condition, and on the other hand, it could also make the code a bit harder to read. What do I mean by harder to read? When I see the for loop in the code on the right hand side, it is clear that there are two ways to exit out of the for loop. One is I greater than or equal to maximum characters, the other is flag equal to one. Just by looking at the for loop, I can say that okay, here are the two conditions for which the loop will terminate. I greater than or equal to max caps or flag equal to one. On the other hand, if you look at this left hand side code, I actually have to look at the body of the code to realize what are the ways of exiting out of the loop. So you have to understand the body of the loop in order to see what are the conditions for the loop to exit. It's not just I greater than or equal to max gas. So in that sense, the code with break is harder to understand than the code without break. It's still recommended to use break when you have two or more exit conditions out of a for loop. So typically programmers do use break and it is just a matter of style whether you will use break or not. I myself prefer using a break. One final thing about the break statement. When you use break statement initially, it is important to notice that break causes an exit immediately out of the loop. So remember, when you have a for loop, the normal execution order is you initialize, then you test. So this is step one, this is step two. Then you execute the body of the loop. That's step three, and then you update. This is step four, and then go back to the test condition. So this is the normal execution order of the loop. When you encounter a break, you exit immediately out of the loop. In particular, when you break, you do not go back to the update statement. So let us examine what this code will do. You have I equal to zero I less than ten increment I okay, so you start with I equal to zero, I modulo two will be zero modulo two, which is zero. So it will say okay, fine, you need not get into the if condition. Then I equal to I plus one, so I equal to one one is less than ten. You enter the for loop one modulo two is one, so you will break. When you break, you immediately get out of a loop. So when you print this, then I will be one. In particular, I is not two, which is what will happen if you go back and update I equal to I plus one before exiting out of the loop. So the important thing to notice is that it's not two since I equal to I plus one is not done when you break. When you break, you get out of the loop immediately without doing the update statement.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 22 C operators and expressions   associativity of operators.mp3,"You. In this session, we will discuss operators and expressions. So, we have already used c expressions in our programs before, and expressions in c are similar to expressions in mathematics, and they follow rules similar to what mathematical expressions also follow. They are a basic unit of evaluation, and each expression has a value. We say that an expression returns a value of a particular type. So let us consider a few example expressions. For example, I have the following a is three, b is four, and I have a variable c, which is just declared to be of type int. And then say that c equal to a times a plus b times b. So the right hand side of the assignment operator so this is the assignment operator, and the right hand side is an expression. And that expression has sub expressions a star a and b star b within parentheses. So, an expression can be made up of variables. It can be made up of constants. These are the atoms or the basic components of an expression. And sub expressions can be combined into bigger expressions using operators. Now, operators can be unary. That is, they take one argument operation, for example, unary operators. The examples can be minus, which is the unary minus. For example, minus three is a negative number, similarly not operator that we have seen in connection with logical operations, so not of zero, for example, so the logical negation operator. Both of these operations take one argument. Now, there is also the binary operations like plus, minus, star, et cetera. So plus takes two arguments. For example, an expression like two plus three, and here is the binary minus. So if I say two minus three, this is actually a binary operator, which takes two arguments, which are two and three. Similarly, the binary multiplication so two star three would be the product of two and three. So notice the difference between it's the same sign for the unary minus and the binary minus. But the unary minus takes only one argument, and the binary minus takes two arguments. We have used the assignment operation many times, and let's understand it in somewhat more detail. For example, if we consider the expression b equal to b plus one. Now, if you remove the semicolon at the end, so the statement is b equal to b plus one semicolon. And if you omit the semicolon, what you get is an assignment expression b equal to b plus one without the semicolon. So how does the assignment operation work? For example, consider an expression like a equal to and then on the right hand side, within parenthesis, b equal to ten. What does this do? So, assume that a and b are integer variables. Now, assignment assigns to the left hand variable, left hand operand the value of the expression on the right hand side. For example, in this assignment operation, there are two assignment expressions. One is the expression b equal to ten, and the second is the expression a equal to b equal to ten. So the first assignment expression is supposed to do the following. Assign ten to b. So what it does is it assigns the value of the right expression, which is ten, in this case to the left hand side operand. That is one thing it does, and also it returns the value after the assignment. So, ten has been assigned to b and the return value of this expression is ten. So, we can now analyze a equal to b equal to ten as follows. First, evaluate the expression in parentheses. The expression b equal to ten has an assignment operator. So, evaluate the expression on the right hand side and then assign it to b. Now that operation returns, so that expression returns a particular value which is ten. Now, the original expression can be thought of as just a equal to ten. Right? This is evaluated as usual. So you take ten and assign it to a, and the return value of the whole expression becomes ten. So when executing this expression, when evaluating this expression, two variables are assigned their values. One is b, which is assigned the value ten, and the second is a, which is also assigned the value ten. The assignment operation can be used to initialize a number of variables in one shot. For example, if I write a statement like a equal to b equal to c equal to d equal to e equal to zero. What does this mean? Now here, there is some ambiguity here because we don't know which order to evaluate this. Should we evaluate from left to right? Should we evaluate from right to left? Does it matter? Okay, so, should the assignment be treated as the following, where a equal to b is done first, then equal to c, then equal to d, and so on. Or should it be the opposite way, right to left, where e equal to zero is first done, then d equal to that, then c equal to that, so on until a. So the expression is evaluated from right to left. In the case of the assignment operation. Assignment. For example, the above expression that we just saw will be done as a equal to so e equal to zero first, and then backward until a is assigned. Now, this is also the standard mathematical convention. We are not introducing a new strange rule here. Why is this? First, we will evaluate the innermost expression, which is e equal to zero. So e will be assigned zero. Then the return value of this sub expression. So this sub expression will return the value zero. Okay, so this becomes d equal to zero, d is assigned the value zero, and the return value of this sub expression becomes zero. So then we have c equal to zero and so on. So finally, every variable here will be assigned the value zero. So the reason for doing this is that if you try to do it in the opposite way, you will see that uninitialized variables are initialized to other uninitialized variables. For example, if you go from left to right in the previous, this simply doesn't make any sense because you've just declared abc and so on. And when you say a equal to b, a and b are not initialized yet. Right? So this assignment hardly makes any sense. The basic rule of assignment is that a left hand side equal to right hand side. So the left hand side is some value that can be assigned to, for example, this is a variable. The right hand side can be anything variable constant, or it can be an expression. So all these are valid assignments. So what is an invalid assignment? So a equal to zero can be a valid assignment, but zero equal to a. So the assignment operation is evaluated right to left. Now, we have the concept of associativity of operators. So what does associativity mean? We have just argued that a equal to b equal to c equal to d equal to zero. An expression like that will be evaluated from right to left right. So it is as though we had parenthesized the expression as d equal to zero innermost, then c equal to that, then b equal to that, and so on. So on the other hand, if you take an operator like binary plus the addition symbol, then the usual custom is that you parenthesize from left to right. So the evaluation is done a plus b first. Then that sum is added to c, then that is added to t. So the assignment operation goes right to left. The addition symbol operates left to right. So this concept of associativity of an operator tells us the order in which they evaluate the operations. If there are multiple occurrences of the same operator. Okay, so the first there are multiple occurrences of the equal to sign. In the second, there are multiple occurrences of the addition symbol. So associativity rules tells you that if there are identical operators in an expression, in which order do you evaluate them? Do you evaluate them from left to right? If you do, then it is called a left associative operator. If you evaluate from right to left, in the case of, for example, the assignment, then it is called a right associative operator. Binary minus is also left associative. For example, a minus b minus c minus d is evaluated as a minus b, then c, then minus c, then minus d so for example, if you say ten minus five -15 what will be done is ten minus five and then -15 okay, so this is phi -15 which is minus ten, okay. Whereas if the parenthesization had been in the opposite way, it would be ten minus phi -15 in which case it would be ten minus. This is minus ten, which is 20. Notice that this is not how you are supposed to do it even in mathematics. So the way that c handles the associativity with the binary operation is correct. So the correct parentheses is ten minus five and then -15 in general, for every operator, c defines an associativity. So let's see the part of the associativity operations of operations in C, there are several operations that we have seen so far. The parenthesis, the Boolean knot, the logical knot, and the unary minus, the binary multiplication division, and so on. Addition, simple comparison, less than, less than or equal to, and so on, equality, logical and logical or and then the assignment operator. We have seen all these operations so far. And of this, the typical associativity is left to right. There are a couple of exceptions. One we have already seen, assignment operation is right to left, okay. The unary operations are also right to left. Most of the other operations are left to right. So if you think for a little bit, you can see that the associativity for unary operations is also easily seen to be right to left. That makes more sense. So the idea is not that you should memorize this table, but you should understand. Given the table, can I understand what will happen with an expression, how c will evaluate it? So it's not that you should remember this, but rather, if you are given the table and an expression, can you correctly calculate what the value of the expression will be? So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 23 Precedence of C operators.mp3,"You. There's one more concept that we have to understand before we really understand how C evaluates expressions. That is the concept of precedence. Okay, so what do we mean by precedence? Let's pick an expression which involves multiple operators. Like for example, in this expression, you have two operations, the assignment operation and the addition operation. Now, how do we know how to evaluate this expression? So what are the two ways in which the above expression can be interpreted? The first way is you could say a equal to B and then say plus C. Or you can say a equal to B plus C to decide which of the above possibilities to really do. C also defines what is known as a precedence between operators. So we have already seen the notion of associativity, which is what happens when the many occurrences of the same operator occur in an expression. Precedence, on the other hand, is to mediate between two different or multiple different operations in the same expression. So let us see what is an example of using precedence. Okay, so in C, the plus operation is given more precedence than the equal to operation. So I really want to interpret this expression as a equal to B plus C. Okay, so this is how I want to interpret the operation, and not as a equal to B plus C. Okay? So I want to avoid this and I want to do it in this way. So one way I can ensure that is by saying that please do B plus C first, okay? And then take that result and assign it to a. So one way of doing that is to say, whenever equal to and plus appear together, give more importance to plus do that first. Okay, so proceed means going first. So plus has a greater precedence over assignment. Plus and minus have the same precedence and both have the same associativity. We have seen this addition and subtraction have the same precedence, but multiplication and division have a higher precedence. So if I want to evaluate a complicated expression, let's say that a plus B minus C star D modulo e divided by f. Okay? So suppose I have a fairly complicated expression. Then what I can do is what are the operations here? So the operations are plus, minus, Star, modulo and division. Now, according to the precedents, I know that Star, Modulo, and division have equal precedence above plus and minus. Okay? So I know that these operations have to be done before plus and minus. So they have a lower precedence. So these have to be done first. But among them, how do you know which to do first? For that, we use the left to right associativity of these operations. So as far as within the same precedence is concerned, let us just simplify the situation a little bit and think of them as the same operation. They are different operations of the same precedence. But I'll just fudge the thing a little bit to say that let's say that they are the same operation. All of them have left to right associativity. Therefore, according to the associativity rule, I will do c star D first, then that modulo E, and then that divided by f, because that is what the left to right associativity says. So, precedence by precedence, we will know that these three operations have to be done first. Among them, how do you do this? Star occurs first when you scan from left to right. So C star D has to be done first, and then the model operation, and then the divide by operation. Okay? And once you're done there, then you come to plus and minus. Okay, so currently, once we have finished with this, you will have some situation like this. C star D modulo E divided by f. And then on the remaining side, you have a plus b minus this. And now you have to decide which way you will do the plus and minus. Again, we know that they have the same precedence, so let's fudge a little bit and think of them as the same operator. Both of them have the left to right associativity. So I'll do a plus B first and then the minus. So within the same precedence level, you will decide which operation to do first purely based on the left to right associativity. So let us take a look at the precedence or associativity table. Again, I want to emphasize it's not to memorize. It's just that if you're given this table, you should be able to understand how an expression is going to be evaluated. So parenthesis is above all, because once you parenthesize an expression, then you're really saying, this is the order that I want, so it overrides any other precedence or associativity rule. Then you have the unary operations, which have the second highest precedence, then the arithmetic operations, then the comparison operation, logical operators, assignment, and so on. The comma is an operation we will see later. Okay, so within the arithmetic operations, multiply, divide, and modelow operator have higher precedence over plus and minus, plus and minus have higher precedence over relational operations like less than, less than, or equal to, and so on. So we will see a few examples of how to use this table to understand what will happen with an expression. Okay, so let us take ten plus phi star four, model two, and assign to a. Let's examine what will happen here. So what I will do is I'll make a list of operations so they are equal to plus, star, modulo, and then precedence. I know that multiplication and model o have very high precedence. Then the next level is plus, and then assignment has the least precedence. Now, both of these occur in this expression, star and model. How do we decide which goes first? Both of them have left to right associativity. So whatever happens first in the looking from left to right, we'll do that first. So among all these operations, we know that phi star four will happen first. Then this will be followed by modulo two, and then this will be followed by ten plus, and finally the last, which is that you do all these operations, get the value and assign it to a. So this is the way in which the above expression will be evaluated. So the above expression corresponds to giving the parentheses in the way that we have done. Okay, a. So once you do that, a will get the value one, a will get the value ten.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 26 How functions are executed.mp3,"When it comes to c functions, we have seen the following concepts. One is the declaration and the definition of a function, by which I mean the declaration is what type is the function, what are the input arguments, what types are the input arguments, and what is the result? Return type. So these form the declaration. Definition is the logic of the function. So this is what is known as the declaration and the definition of the function. And we do it only once. So a function is defined only once. We define a function. We can of course call the function multiple times. So definition is done only once, and calling can be done any number of times. Now, we refer to a stack, which is what is the central concept in executing a function. A stack is just a part of the memory that grows only in one direction. So that's what it's supposed to mean. Basically, you can think of it as a stack of boxes, or a stack of paper on your table, or a stack of plates. So it grows in one direction. So the stack grows as the main calls a particular function. That function calls us different function and so on. And you can imagine the stack as growing upwards or growing downwards. It does not matter as functions get called, it either keeps growing upwards or keeps going downwards. We will usually represent it as growing downward. So, let us look at this function that we were talking about earlier. So, n choose k is n factorial upon k factorial times n minus k factorial. And let's try to code this up. We know that factorial is something that we will need over and over in this program. So let us say that I'll write factorial as a function. So factorial takes an integer and returns an integer. So the declaration is int fact int r. R is the input argument, and the return type is int. Now, inside that we will write the code for factorial. All variables declared inside the factorial are local, are private to the factorial function. They cannot be seen outside. So the input argument, as well as any variables declared inside factorial, are private or local to the factorial function. So I have I and this encodes the logic of factorial that we have seen earlier. So you start with the product equal to one, and keep on multiplying the numbers till you reach r factorial. So once you reach r, you return the r factorial. So this logic is something that we have seen before. Now we will see how do we put this together in order to produce the function. So what we need to do is we will just encode up the solution that we have. So it is factorial n divided by factorial. K divided by factorial n minus k. So here I've encoded just the logic. So even though division is involved, I know that when I do nck, the result is always going to be an integer. So I can declare it as int res. So this part is known as the definition of the factorial function. So this part is what is known as definition. And each of these are what are known as calls. Now, let us try to see what happens when we execute this program. Okay, so regardless of how many functions have been defined, whenever you start executing a program, it always executes the first line of main. So let's try to add some temporary variables, because we call this function three times in this main, let's try to separate them out into three separate calls, just for the sake of clarity. So I'll add a slightly larger code. This is not proper c code. Let's say that I have three extra variables which I've declared up. Int t one, t two and t three. Now, t one will be factorial of n, t two will be factorial of k, and t three will be factorial of n minus k. I've separated these out so that I can clearly explain what happens when the code executes. Let's say that I want to calculate four c two. Now first, when the program starts executing, you start with the main on the first line of with the code on the first line of the main. So you scan of n and k. So n is four and k is two. Now, you do t one equal to factorial of n. So when t one equal to factorial of n is called, what you do is you set up the return value and return address. Okay, so return value is not yet decided. Return address is five because you have to go back to line five of the code. So that's why the return value is five. Also, what do you need to do? You need to copy the parameter value, which is four. So this is the actual parameter four, and you have to copy it to the input argument r. Okay, so r is the input argument r should be assigned to the value n. Here, n is four. So that is known as passing the argument. Now, once that is done, the code can be seen as jumping to factorial. Okay, so as soon as the function is called, you actually pass the execution to the factorial function. Now, inside the factorial function, you have two local variables, I and ans, which is answer, and we start executing the factorial function. So let's see what happens when we execute the factorial function. So, so far we have passed the arguments and so on. Okay, now I have just hidden the part of the stack that was used for main. And let's focus just on the factorial function. This computes the factorial function that we are familiar with. There's nothing new here. So it has a variable I, which keeps track of how many times the loop has executed. And r is notice four. So you compute the factorial of four, okay? Finally, when r equal to four, answer equal to 24. Now this 24 value, we say return the answer value, okay, so answer value is 24. So this will be copied to the return value location, okay, so the return value will get the value 24. And now jump back to return address. So return address is line five, okay, so we'll jump back to line five. And there we will say that t one equal to 24, okay, only the return value is copied back to the main program. Okay. All other things are irrelevant. So the correct way to imagine what happens when a function has returned is that the stack that was allocated to main to the execution of fact is completely erased, okay? So once you go back to main, as soon as the function returns back to the main, you should imagine that the entire stack is deleted and only the memory that was originally allocated to main remains. So the correct way to think about a function executing, you can imagine that you are main and you have a friend who can calculate factorial for you. Now you can ask your friend to calculate factorial for you. And things are done in a very hygienic manner. So what you do is you write on a piece of paper the number four and give it to your friend. Now, your friend is in another room, so he has at his disposal some blackboard. So he looks at the number four and using the private local variables that he has, which is I, and result or answer, he calculates the factorial of these numbers. Once he does that, he copies the result back onto a piece of paper. So four factorial is 24 and brings it back to you. Before he does that, he erases his blackboard and he will bring back the number 24 on a piece of paper. Now you can imagine that the space that your friend used to compute 24 has now been wiped clean. And all that remains is the value 24, which you can copy back into onto your notebook. Okay? So this allegory tells you exactly what happens in the case of a function execution. You write down what you want the factorial of on a piece of paper, pass it to your friend. He will go to a separate room and he will calculate whatever he wants. Once he does that, he will clean his blackboard, write down the result on a piece of paper and bring that paper back to you. So as far as you are concerned, you are least bothered with how he is computing the factorial function. All you want is the result. And this is the basic way to think about functions. You should be able to reason out a bigger program by saying, what does a smaller program, what does a smaller function do, regardless of how that function does it? Okay, now let's get on with the remaining execution. We have just computed factorial of four. Now we need to calculate factorial of two and factorial of four minus two. Okay, so we go to the next line. The next line also involves a call to Factorial of k. So we do the same things again. We save the return address. Now the return address is six because we are executing line six. Then we create a box for the return value and pass the parameters and finally jump to the called function. Okay, so we do all that. We have some memory for main, but we allocate a new stack, new space in the stack for executing factorial. At this point, return address is six because it's the second factorial that's being called r is two because k is two. And you execute the factorial function. Okay, so you again go to the factorial function and calculate two factorial two. Factorial is two. So that will be transferred back to the return value. And now you can imagine that you will get back to the address six, where t two will have the value two. So once you do that again, the thing to imagine is that this slate is wiped clean. And all the memory that you allocated to the stack is now free. So once you are back in main, all you have is the memory for main. Okay, now there is a third call to factorial, factorial of n minus k. And it is done in exactly the same manner. So without much elaboration. So it will create n minus k is four minus two, which is also two. And the return address is seven. Okay, here's an n. And once you do that, it will execute the factorial code again and calculate the factorial of two, which is again two, and return to line seven. So two will be copied as the return value. And once the execution finishes, you return to line seven of the main program. Okay, at this point you say that t three equal to two. And you can imagine that the stack allocated to factorial is now erased. Right? So at this point, main has t one equal to 24, t two equal to two, and t three equal to two. You have all the information that you need in order to calculate your result. Okay, so you calculate 24 divided by two, divided by two, and the answer is six, which is four. Choose two. So this illustrates how do you write a function, how do you define a function, and how do you call it? And what actually happens when you execute a function? So the execution of a function can be visualized as a stack. A stack is a part of memory that is allocated as private to a new function that is being called. Once that function finishes execution, the stack is erased, and you go back to the previous function, and you go back to the calling function.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 27 Some examples on functions.mp3,"So we have been talking about designing programs using functions, and the general philosophy is that you have a large task that you want to accomplish and you break it into subtasks. Maybe each of those subtasks are split into smaller subtasks, and so on. So break them until some subtasks can be easily solved by a single function, and then you put all these functions together in order to solve the whole problem. So design your program from top down, big task decomposing into small tasks, and so on, and debug your program or make sure that they are free of errors from the bottom up. So, test each function thoroughly, and then test the overall program. In this, we will discuss a few technical details about how c executes its functions. In particular, we will see how c passes arguments to its functions, and also how does it return values when passing arguments, we'll talk about issues like evaluation order. In what order are arguments evaluated if there are multiple arguments? And we will discuss what are known as side effects. So let's start by considering a very simple example. I have a very simple function called sum, which just adds up two variables, x and y, which are integers. Therefore, the return value is also an integer. Now, inside the main program, I will call a equal to sum of ab. A is one and b is two. And then you will sum these up, and the return value is assigned to a. Okay, so this is supposed to do one plus two three, and a is assigned the value three. Okay? So after passing the parameters, sum is called with xsa, which is one, and y as b, which is two. So sum returns a three. So the return value is three, and the three is assigned back to a. So when you print it, the output will be three, followed by two. So this is simple enough. Now let's try a slightly more tricky example. So here is the novelty. In this example, sum, instead of being declared with x and y, are now being declared with two variables called a and b. The main program also has two variables named a and b. So what will happen here? The output is the same as before. So three, two, if you compile the program and execute it, it'll be the same as before. So what really happened here? After passing the parameters, sum is called with a s, one and b as two. And so it returns a value three assigned to the a of main. Now, these variables are called a and b in main, and they are called a and b in sum as well. Now, the variables a and b inside sum are different from the variables a and b inside main. So the scope of these variables is main and the scope of these variables a and b is the sum function. So in other words, the a and b inside sum has scope, just this function. They are not visible or addressable outside, especially in main. So if you want to think of it, you can think of them as sum a and sum b. Okay, so they are the a variable belonging to sum and the b variable belonging to sum. Okay, so even though you would think that this a and this a might get confused, they are actually different variables. One is the a variable belonging to main and the other is the a variable inside sum. And they are different even though they have a common name. Okay, so now let's try a slightly more elaborate program. What happens if you have sum of sum of ab and then sum of that with comma b? Okay, so this is the program. In this case, what will happen? So first, evaluate the inner program inner function sum of ab. So a is one and b is two, so that will return three. Then you add b again to it. B is two, so you have five as the total sum. So the complete output is a will be assigned five and b is still two. So this is similar to evaluating a normal mathematical expression. One thing that we need to take care of is to handle expressions with side effects. Now, what are expressions with side effects? So let's classify expressions into two kinds. One is what are known as pure expressions. So they are the normal mathematical expressions like a minus b star, c, d, and so on. Similarly, evaluating functions, these normally don't have any effect other than returning you the value. So they will be correctly evaluated and they will return some value other than that they have no effect. Now, expressions with side effects change the state of the program. For example, when I execute an expression a equal to a plus one. Now this is an expression. It has a value. So let's say that a was one before a equal to a plus one. A plus one has value two, and a is assigned the value two. The state of the program involves, for example, what values are stored in the variables. When you execute the expression a equal to a plus one, the value of the variable a changes. Contrast this with previous expressions like a minus b star c d. You can see that unless you assign it to something, no variable's value is changing. It will just be evaluated and the value will be returned. Okay, here the value will be returned. Also, the variable a is changing. Here in the second function, you have two arguments to function f. The first is an expression a equal to b plus one. The second is an expression b equal to a plus one. This might sound like a very strange way to code, but you know that any expression can be given as arguments. So in particular, assignment expressions can be given as arguments. For example, a equal to b plus one is an assignment expression which is given as an argument to the function. Now, such expressions are called expressions with side effects because they change the state of the program. When you have side effects, you should be careful. For example, what will happen. In the following program, you have a function int minus int a int b, and it returns b minus a. Now in this program, main calls the minus function with two expressions as arguments, a equal to b plus one and b equal to a plus one. They are expressions with side effects. Because once you evaluate these arguments, you know that the variable a will change in the first expression and the variable b will change in the second expression. So what will happen in this program? Okay, so how should we evaluate it? The general rule is that all arguments are evaluated before the function call is made. So before the function is executing, we know that a equal to b plus one and b equal to a plus one both will be executed. Okay? And here is the major problem. We know that both have to be executed, but c does not specify in which order they have to be executed, so it is left to the compiler. So let us evaluate it first in left to right order. So this expression first and then b equal to a plus one. So what will happen then? A equal to b plus one b is one, so a will get the value two. B equal to a plus one will be executed after that. A is now two. Okay, so b will get the value three. Now you execute minus, so you will return three minus two, which is one, and b has value three. So this is the expected output. But when you run it on some machines you may get the output -13 okay, so what happened here? Now this happens, for example, when the compiler would evaluate it right to left, okay, so when you evaluate it right to left, what will happen is that b equal to a plus one will be executed first, so b equal to a plus one. So b gets the value two plus one three, and then you will execute a equal to b plus one. B is now three, so a gets the value four. Okay, so when you call minus of four, comma, three minus will return three minus four, which is minus one. So in this case you know that b gets the value three, a gets the value four, and the result will be minus one. Okay, so what was the mistake? The mistake was that we assume that both arguments will be evaluated before the function is called. But we assume that it will be evaluated left to right, and the first expression will be evaluated before the second expression. That's a reasonable assumption to make, but c doesn't guarantee you that. Okay, c leaves these decisions to the compiler. Now, compilers may evaluate arguments in different orders. For example, a very common order is right to left. So both answers, like one and three and minus one and three are both consistent with the c specification. Now this is a very troubling scenario. What should we do? Right, so we should write these functions in such a way that they don't depend on whether the arguments are evaluated left to right or whether they are evaluated right to left. Okay, so write expressions in such a way that they are free of side effects when you pass them to functions. Okay, so how do we do that? We can do the following. For example, if we really wanted the left to right order, that is, if you want a equal to b plus one to happen first, and then b equal to a plus one, why not write them explicitly in that order in the main function? So first this will be executed, then b equal to a plus one will be executed. So a will get the value two, and then b will get the value three. So minus of a comma b will execute as three minus two, in which case you will get one. So the important thing to note is that in this particular function call, the arguments do not have any side effects because we explicitly coded them up before to specify that this is the order in which I want. If I put it here, then it's up to the compiler. The compiler can do whatever is best for several criteria. Okay, so now let's come back to what the functions were. We have the function definition, which is the entire function. The logic of the function is what is known as the function body, and the heading is what we call the declaration, the type signature. The type signature has, for example, two arguments, a and b. These are called the formal parameters. Now we focus on the return expression. So return, followed by some expression is the only mechanism for returning the value from a function. If the type of the return expression does not match the declared type of the return. So if, for example, a is of a variable which is different from int, okay, in this case they are the same, then it's fine, but otherwise the return expression is converted to this type and then returned, so it might lead to some undesirable behavior. Now we have discussed parameter passings. When passing parameters in c, the values from the calling function are copied to formal parameters in the called function. So the actual parameters are converted to the formal parameter type and a separate copy is made. So this is known as call by value. So, formal parameters and local variables of the function are accessible only within the function. We have already seen this, and memory for the formal parameters and the local variables of the called function will be erased as soon as the function returns. So executing return anywhere inside the function will immediately return from the function and transfer control back to the calling function at the specified return address. Okay, so when you execute, there are a few things to keep in mind. Whenever you execute any return expression, it will cause the function to immediately return. Now, main is a function, so we can use return statements inside main. What that means is that main will immediately stop execution. That is, the whole program will stop execution. Now, when you return a particular value, the calling function may choose to ignore the value. For example, let's say that I write some dummy function int f, and it takes two arguments, float a and int b. Okay? And we have some code here. And then I have the main function in which I have two variables, int x and float y. And then I have some code. And here is the interesting thing. I call f of y comma x. Y is a float x is an int, so I'm fine. But this function returns an integer value, but I am not assigning it to anything. So I'm not saying something like x equal to f of y comma x. So this is not required. So if this is the case, then why call the function in the first place? This is because the function also may have side effects. So remember that side effects are something some expressions which change the state of the program. Okay, so functions may have side effects. You have already seen one such function which has a side effect. For example, scanf. So the side effect of calling scanf is that the input from the keyboard is copied into some variable. So functions may have side effects. This is why you can call the function and choose to ignore the output or the return value. Now, just for curiosity's sake, executing return will cause the function to immediately return to the return address. Now the return value, if you omit it, then the return value is unpredictable. So here is an example. You should in general avoid doing things like this. But just for completeness, I am supposed to return a float value instead. If I just say return, the program will compile. But when you execute, some unpredictable behavior may result. Okay, so the printed value in this case can in general be not predicted.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 28 Some examples on functions.mp3,"You okay with the concepts we have seen so far? Let's design a sample program. So the problem that we want to solve is we want to write a program that reads the input line by line and counts how many lines has the user input program should terminate when the end of file character is encountered. So we will try to solve this problem. By the way, the end of file is a character which you can enter using control D if you're running Linux. So the flowchart at the very top level can be envisioned as follows. So we will just check has the end of file been reached? If the end of file has not been reached, you read the next line and check again. If the end of file has been reached then you halt. Otherwise you read another line. Okay, so here is the very top level picture of what we want to do. So this design is just meant to read the input line by line. So it's a very vague flowchart, but at the top level this is what we want to do. So let us say more details about how we are going to accomplish this. In particular, we want to see how we can read input line by line. Okay, so here is the top level design and now we are going to essentially expand this box. We want to say how do we read the next line? So let us design the read next line box. So the read next line box. First you read a character and then you check whether the character read is new line character. That means that the user has pressed an enter, so the line is entered at that point. Or the user can enter a bunch of characters and instead of pressing enter, press ctrl d. Okay, so the user can enter end of file. If either of these are true, then the line has ended, so you halt. Otherwise, if the character is neither new line nor end of file, then you read the next character. So here is the design for the function to read the next character next line. So you read character by character. After every character you check whether a new line or an end of file has been encountered. If either of them happen, then the line has ended. Otherwise you go back and read another character. Okay, so let's start by writing the top level function. So let's translate the top level function into code. So here we will introduce a new concept called what is known as a forward declaration. Okay, so when you define a function, you can either give the logic the full function body when you define the function, or you can just say that here is what the function will look like. Here is the type signature. Basically it is taking no arguments and it will return an integer value, and I will terminate that statement by using a semicolon which says that this function, I will currently just say the type of the function. I'll define the function later. This is done so that we can write a function which uses this particular function. So when we write a function which uses that function, the type of the function should be known. For that we can just declare the type of the function. This is what is known as a declaration of a function. Unless you define the function, you cannot use it. But in order for another function to just see what the function looks like, declaration is sufficient. Okay, so let's design the top level function. So we declare this function that we will use in this function that we are about to write. So this user function will be called read all lines. Now in that we will keep a line count initialized to zero, and then I will keep a flag called east line. Now what this will do is we have to check for whether an endophile has been reached or not. For that I will use the function feof stdin. Okay, we'll see that in a minute. While the end of file has not been encountered, you say that read next line, read next line will return a one if a line has been encountered, otherwise it will return a zero. Okay, so line count will be incremented by one if I read another line, otherwise it will remain as it is. Finally, you return the number of lines read. So this is a realization of the flowchart on the left. Now, there are a couple of things that require explanation. First is that even though the read next line function has not yet been defined, just based on the declaration, I can say that it is going to return an integer, and I can use the integer here. The other thing is, what do we mean by feof stdin? Okay, so what do we mean by the function feof? So feof stdin is a function that is part of the stdio library. We have already used other functions from that library, for example, printf and scanf. Now, the feof function, what it does is it returns a function. It returns a value, one if the end of file has been encountered in the input argument. So stdin means that I'm using the standard input, which is the keyboard input. So if an end of file has been entered via the keyboard, then feof stdin will return one. Okay, so stdin is usually the keyboard input. And usually if the user enters the control d character, then feof will say one because enter file has been entered. Now let us design the function to read a line. We earlier wrote a function which assumed that there is a function which will read the next line. And based on that, I will keep on reading lines until the end of file is encountered. So we are now about to write the bottom function. So we want to read a line. So we have already drawn the flowchart for that. Now let's try to make it into code. So we have to define a few variables. We will have int ch for reading a character. We'll come to that in a minute. Then we'll keep a count of how many characters have been read, and let's write the basic loop. So we'll just write the loop corresponding to the flowchart. Ch will be getchar, so get the next character. And while the red character is neither end of file nor new line, you should keep reading characters. So if neither of these is true, then you should read the next character, which is what the flowchart says. A slight small point here is that Getchar returns an integer. Okay, this is a technicality, because end of file is negative one. Ascii characters, if you remember, go from zero until 127 or something like that, whereas end of File is defined to be minus one. So because of this minus one, you cannot keep the return value of getchar as a character. It technically has to be an integer. This is a technicality, so keep that in mind. Now, we need to do something further in the loop, so we'll complete this in a minute. Okay, so what should we do inside the loop? This should be character. Okay, so what is this function supposed to do? Overall, we have to return a one if the number of characters in the current line that we have read is at least one. So if the current line contains at least a character, then we have to return one. For example, if the user just entered a new line which has just pressed the enter key, then it's a blank line. In that case, we won't say that we have read a line because it was a blank line. So if there is at least one character which is neither new line nor enter file in that line, we have to return a one. Otherwise, let's say we return a zero. Okay, so one way to do that is to keep account of the number of characters we have read. Okay, so for every character read, we'll keep account of every character which is neither end of file nor a new line. We'll keep account of characters. Okay, so, notice the way that the loop has been written. So if the first character is a new line, it will not enter the loop. Hence, count remains zero. Okay. At the same time, the way the loop is written, count will count exactly those characters which are neither new line nor end of file. Okay, so now let's decide what should be the return value. We have to return a one if the number of characters in the current line, including new line, is at least one. So if count is greater than zero, we can return a one. If the last character was end of file without having any other characters, then we return a zero. So how do we do that? We can check whether at least a character has been read by just checking the value of count. Okay, so if count is greater than zero, then at least one character has been entered. Otherwise, for example, we can also say that if the user has just entered a blank line, then also we can say that one more line has been entered. Okay, so that's up to the way you want to do it. You can also take the stance that maybe a blank line doesn't count as a line. Okay, if that is the case, then you don't have to do it. But in this case, let's just assume that if at least a character has been entered, which is either a normal character on a new line, we will say that return one. If the only character entered in that line is end of file, we'll say that there is no more new line. Okay, so what we have to do is return count greater than zero. This tells you how many non new line non end of file characters have been entered. So this should be at least one, or there is exactly one character entered which is a new line. So in either these cases, we will return a one. Otherwise we will return a zero. Okay, so we can put these program together by concatenating all the code that we have written. Notice one thing that declare the function. First we use the function here. So here is a top level function which will use read next line. When read all lines uses read next line. Read next line has not been defined yet, so you can go here. After read all lines has been defined, you can define read next line. So here is the function here. So this is function one, this is function two, and finally you have main read all lines doesn't need any forward declaration because when main uses read all lines, it has already been defined. That was not the case here. When read all lines used, read next line, read next line was not defined yet. That is why we needed a forward declaration. In this program, you can reorder the code such that read next line code can be written before, in which case you don't need the forward declaration, but the concept of forward declaration is useful for later discussions. Okay, so I've just introduced that.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 29 Arrays in C.mp3,"You okay? In this session we'll learn about arrays in C. Now, what does the word array mean? It means a grouping or a collection of objects. So for example, you could say that he couldn't dismiss the array of facts. So that means a collection of facts. And it also implies is a regular order or arrangement that is in the case of a series. So what do we mean by an array and why do we need it? So let's consider that I have a bunch of numbers, say 1234, and I want to consider them as being part of a sequence. Let's say one, comma, two, comma, three, comma, four. So the first element is one and so on. Now I want them to be stored. And one way I can do it is that I can store them into separate variables. For example, I can say that a is one, b is two and c is three and d is four. Okay? But when I do it in that way, they are separate variables. And the relationship between those variables, the fact that b comes after a and things like that, is something that the programmer knows, but it's hard for somebody else looking at the code to figure out. Often we need to store a sequence as a sequence itself. Okay, so an array has the following properties. One, it's a collection of objects of the same type. Second is that it has some size, some finite size, say n. Okay, there are n elements in the array. And the third is that I should be able to selectively update, update only a single element in the array, by which I mean suppose I have four elements in the array. I should be able to say that I want to replace the third element by five. Okay, so three will be replaced by five without touching the other elements. That's what the third thing is about. The first thing says that I want a collection such that it's a collection of objects of all of type, integer and not of any other type. Okay? And the second says that it has some finite size, so it's not an infinite collection. Okay, so that's what an array is supposed to do. Now let's see how we can define arrays. We'll try to motivate why arrays are needed by introducing certain problems. And I'll try to convince you that it's easy to do using arrays. And whereas it was difficult to do without using arrays, using only the facilities in C that we have seen so far. So an array is defined in C similar to how we define a variable. If we had an integer variable, we would say int a semicolon. Instead of that. When we declare an array, we have int a five. Okay, so this would declare that it's an array containing five integers. Now one thing that is certain about arrays in C is that the five integers which make up the array will be allocated consecutively in memory, so they will happen one after the other. Also, one thing to note is that arrays in C start with index zero. So the first element is a zero. So if we have an array of five elements, it will go from a zero to a four. Okay, so have we seen arrays in mathematics? For example, you can think of vectors. Similarly, matrices, these are all arrays. And C arrays will have similarities to mathematical vectors and mathematical arrays. But note that in mathematics it is customary to start from index one. Here it is from index zero. So the boxes are addressed as a zero up to a four. These are called the elements of the array. The array is the whole collection of boxes, and each box in it will be called an element of the array. Now let's consider a simple program using an array. So I mentioned that the third requirement that I want for an array is that the first requirement was that all elements of the array are of the same type. The second requirement is that it has a finite size. And the third requirement is that I should be able to selectively update only one element of the array without touching the other elements. Okay, so let us see a program where we can do all that. So here is a simple program. It declares an integer I, an integer array, a five, and then a for loop. Okay, so let's see what the for loop is supposed to do. So the for loop starts from I equal to zero and then goes from I equal to zero to five, filling in the elements by using the statement AI equal to I. Okay, so let's see what that is supposed to do. So this is the notation, AI is the notation used to address the elements of the array. Okay, so notice the similarity here. A five. When you declare it, it says that it's an array of size five. Okay. A of I is saying that I want the ith element in the array. So when I equal to zero, it will refer to the zero th element in the array until I equal to four. It will go on until the fourth element of the array. So a of I, similar to a of five, the way we declared the array says I want the ith element of the array. Okay, so the variable I is being used as an index for a. That means if I say a of I, I will pick the ith cell in the ith element in the array. Now this is similar to the mathematical notation a subscript I, which is what we normally use for vectors and matrices. Okay, so let's run through the program once to see what it's doing. So first we declare a five, which is phi consecutively allocated integers in the memory. And we also have a variable. I. I starts with zero, and for the zero th iteration a of I is allocated. Let's say I plus one. Okay, so a zero will be one. Then we update I. So this statement becomes a of one equal to one plus one, which is two. And then we execute it. A two becomes three, a three becomes four, and a four becomes five. Okay, so notice that because we have indices, and indices can be numbers, they can also be replaced by integer expressions. This is the trick that we have used here. So aa of I goes from a zero all the way up to a four. Now it is only required that a single array can be objects of the same type. So we have dealt with integer arrays so far. Now we can also deal with floating arrays and float arrays and character arrays and things like that. So in general, you can declare an array of any data type in C. For example, you can say float num 100. So that will declare array of 100 floating point numbers. Similarly, car s 256 will declare a character array of size 256. Okay, so you can declare a floating point array and you can visualize it as 100 floating point boxes allocated consecutively. That is the important part. The consecutive locations in the memory, one after the other, will be allocated for the same array. Now for character array, similarly, 100 boxes are allocated one after the other. Now, depending on the size of the data type involved, obviously the size of the array will be different. So the float array will be of size 100 times the size of a single float, and the character array will be of size 256 times the size of a single character, and so on. Okay, so one thing is we have to take care of the size of the array. For example, if we have an integer array of size five x, this means that five integer variables named x zero to x four are allocated. Okay? Now so the variables x zero to x four are integers and they can be assigned and also they can be operated on. They can be part of other expressions and so on. Okay, now what about arbitrary integers? We know that zero to four are valid indices. What about five and so on? What happens to x five, x 66, something like that? Similarly, what will happen if I write x of minus one? Are these valid? Okay, so the answer is no, you cannot in general assume that indices other than zero to four make any sense. Your program may crash. And this is the most important thing in C programming. When you use arrays, it is the may part of it, because it is not even guaranteed that your program will crash. So you may run the program once with x of five, let's say, and the program will work fine and you will be under the false impression that everything is correct in your program. But the next time you run it, maybe your program will crash. So it's not even guaranteed that it will crash. If it is guaranteed that it will crash, then of course you can know that there is an error and you can go back to the code. In this case, you just have to be careful when you write the code. So x five, x six, and so on are undefined. These are names, but there are no storage locations that they correspond to, so you should not access them. Okay, so if you ask a very specific question, shouldn't I access them or can't I access them? Okay, so what will happen if I write a code like this where I declare an integer array of size five? Then I know that x zero to x four are valid locations. They are the first phi locations. But the problem comes with statements like x of five equal to five or x of six equal to six. Five and six do not refer to valid locations in the array. So what will happen? Okay, so the initial statements up to x of four are all fine, but the last two statements, x of five equal to five, x of six equal to six lead to errors. Will it compile? Yes, if you just give the source code with these erroneous locations, it will compile. But because the C compiler does not check that the indices are within the proper range, so it will compile and the compiler will not tell you that there is anything wrong with it. But when you run a program, the program will give something called a segmentation fault. Okay, it may or may not give that. So this is one of the most notorious errors when you program in C. So we will see this error in greater detail when we understand something called pointers. But in general, when you exceed the bounds of the array, when you go beyond the locations permissible in the array, your code may crash and the code will crash, usually with the error segmentation fault. Okay, so if you run the program and if you see a segmentation fault, this is a good indication that maybe you are referring to locations in your array that do not exist. So you should go back and rectify the code. But the danger is that it may not always crash. So the only way to be really sure is to go through your source code and examine it, your program may crash. So we have seen certain aspects of arrays in C so far. So for example, let's say that I declare a character array str of size five, so it has five characters inside it. And let's say that I use the variable I as an index into the array. So str of zero to str of four can be addressed using the index I. Okay, so if I have the index, I know that I can set particular values as str of I equal to a, since I is zero. This will set the 0th element in the array to character a. Similarly, if I say ch equal to stri plus one, it will take whatever is in the first cell in str of one and assign it to the variable ch. Okay, so we can set a particular element in an array like this. Similarly, we can also read the value in an element and then assign it to something else. So these are possible with the help of an array. Okay, now let's consider a particular example, which is the problem is as follows. We want a character array, let's say of size 100. And then we have to read input which is from the keyboard and store them in the array. After we store it, we should stop once at least 100 characters have been read, because that's our array size. Or when the user pressed end of file, remember that you can press ctrl d to enter the end of file. Now what we have to do is take the array and print it in the reverse order. Now if you think for a little bit, you can see that it is difficult to do this without an array. Instead of an array, if you were storing it in a single character. There is no way to store 100 characters in one variable and then print them in the reverse order. Right? Because the first character has to be printed at the end, the last character entered has to be printed first. So you need to remember all the characters. This is an intuitive reason why arrays are important for this problem. Okay, so what is an example problem? Let's say that we have me or then new line and then mo followed by control d. So when you reverse it, you will have Oom, then the new line then, or em and so on. Okay, so you have to reverse everything input. Similarly, if you have a string, what you have to output is the exact reverse of the string, including the spaces. Okay, so let's design the program. We'll just try to write the program using Main. Now, there are two parts in this program. The first is just to read what has been input into the array. And the second part is to print the array in reverse. So the read into array, that part of the program will read the input character by character until one of two events happens. The first is 100 characters have been input, okay, because you have declared the array of size only 100, so you can read only 100 characters. So once you reach that you should stop. Otherwise, before you reached 100 characters, maybe the user pressed a control d to say that I am done with the input, okay, in that also you have to say that, okay, I've done by reading the input. Now print reverse will print the characters in reverse, okay, so let's design the program for reading into the array. So keep the following variables. One is to keep the count of how many characters I've read so far, and then I'll keep a variable to store the currently read character. Now, we have touched upon this topic once. I am going to declare it int ch instead of care ch. Okay? So I'm not going to do this. This is because Getchar will give you whatever character has been read just now from the input. So in particular, the characters that can be entered can be an ASCII value which is from zero to 255 or something, and then it can also enter the EOF character, the end of file character which is actually minus one. So minus one does not correspond to an ascii character. So Getchare can also read an end of file character. This is the reason why if you are reading characters through Getcare and we are doing this because the user can also enter a minus one, then in order to hold that value, you need an int ch rather than a character ch. Okay, so this is what we just mentioned. The end of file character is usually minus one, so it's not a valid ascii value. So the code at the top level looks like this. We have the logic to read a next character into the ch using getchair. And then we have, let's say a while loop, which says that while the character is not endophile and the number of characters read count is less than 100, you store the character into the array increment count and then read the next character. Okay? So please look at the structure of the loop very carefully. The s is a character array, so technically it cannot hold an end of file. But then if you think about it a little bit, you will see that we will never encounter a situation where you will store end of file into the s array. Because suppose the first character is end of file, then we will not even enter the loop. Now, at any point when we enter end of file, it will be at this point, right. We'll read the character only here. Before storing it into the array, we will actually check whether it is end of file. Okay? So we will not accidentally set the array to minus one at any point. So character array suffices. So think carefully about the way this loop has been written. In particular, if I had just done this as the last line before the loop ended, then you would run into problems because you could store the end of file character into the s array by mistake. Okay, so just think about that issue. Now, here is an initial design. The overall design is that first you have to read into the array and then you have to print in reverse. Okay? So let's make the read into array a little bit more precise. So we have ch equal to getchar. And because you are using the getchare function, we have int ch because it could also be an end of file. Now, the while loop says that while the ch is not endophile and the number of characters red is strictly less than 100, you increment. So you first set s count equal to the character red increment count, and then get the next character. Okay, so this loop keeps on filling characters into the character array until you see either end of file or you have entered 100 characters. Okay, now let's design the remaining thing, which is print in reverse. So suppose the input is, let's say, to be concrete, he Lp and then control d the end of file character. So once you run the read into array part, it will lead to the array looking like this. S zero will be the character h. S one will be e. S two will be l. S three will be p. Okay, at this point, you will read end of file, and you will not store the end of file in the array, right? So s zero to s three are valid characters. And at this point, if you go back to the code, count always keeps track of how many characters have been read. So in particular, count will be four when you exit the array. Now, to print in reverse, all you have to do is to start printing from s three, then s two, then s one, and then s zero. Right? So you read in this direction, and you print in the reverse direction. Okay, so we should be somewhat careful at this point. Suppose you have read the array before you enter this part. Then you declare I, which is the array index that we are going to use now. I should be set to the index of the last character red. So here is the tricky part. Notice that count is four. So four characters have been read. Therefore, the last character read is at index count minus one. Okay, so it is not at count index. If you say s of four, that is an invalid index, whereas s of three is where we should start from. So start from I equal to count minus one. Okay? That way we'll start at this character. Now, while I is greater than or equal to zero. So we'll start from s of three, then print s of I. So we'll print s three, then decrement I because you have to go back to the next, to the previous character. So I becomes two. I is still greater than or equal to zero. So you'll print s two decrement I, so I becomes one. So you will print e, then decrement I. You will come to I becomes zero, and you will print h, you decrement. Once again, I becomes minus one. So you will exit the while loop. Okay, so this is the array that we were doing. So here is the code for printing the characters in reverse. So here is the pseudocode where we said print SfI instead of that. In C, we have a particular function which will print the character which is put care. So this is the dual function of getchair. Okay, so putchair takes a character as an argument and prints it onto the standard output. Okay, so you have int I, I is set to count minus one because that way we'll get the last index of the character in the array. And then you start counting down until you print the first character and until the end of the array. Okay, so putting these two together, you have the read into array part, and then you have the reverse part. Print in reverse part. So when you put these two together, the first thing you do is bring all the declarations together. So this is the declarations for read into array as well as print put together. Similarly, first you have to put the code for the read into array part and then the code for the print in reverse part. Okay, so let's trace the execution for a small sample input. So when we have the input is hello, and then the user presses control d for end of file. Let's see what will happen. Okay, so you start reading into the array. So s count with count equal to zero, starts setting the array. So s zero will be h, and then s one will be e and so on. Okay, so it once ch becomes control d, the end of file character, you will exit the loop. Okay, so the character array is hello,",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 3 The Programming Cycle.mp3,"You okay. Once we have understood what algorithms are, we will start writing a few simple programs in the C programming language. Before we begin, we'll give a brief introduction to the process of programming. When you're programming, you follow typically what is known as the programming cycle, and this contains three part it. One is the process where you write the program or edit the program, and after you're done editing the program, you save it and then you compile your program. If your compilation succeeds, you are ready to run the program. If your compilation fails, then you return to the editing step and correct the errors and compile again. Once compilation process succeeds, then you can run the program and check whether the output is correct. If the output is correct, you are done. If not, you go back to the edit process. Okay, so this is why it is known as the edit compile run cycle. So you edit the program first, then compile it. If there are compilation errors, you go back and edit it again. Otherwise, you run the program. When you run the program, if the logic is correct, then you're done. If your logic is incorrect, then you go back and make changes to the program, compile it, and run it again. Okay, so this is the process that we have to follow. When we are programming. We look at each of these steps one by one. In editing, it's typically done in what is known as an editor. Now, editor is a program that lets you create a text file, make changes to the text file, and update the text file, and later save it. So in order to create a program, pick a particular editor of your choice. If you are on Linux, I would recommend a simple editor like G edit. If you're on Windows, there is a free editor called notepad plus plus. Be careful that this is not the usual notepad that comes along with the system. Write your code in an editor of your choice and save it into a file. Let us call it sample c. Once your code is saved, you have to compile a program. Now why do we have to compile a program? Why is this step necessary? The computer does not understand c per se. It cannot execute a C program or the individual statements in C language correctly. For example, let's say that in C you can write g equal to a percentage b. The percentage operation stands for modulo. So this statement says that you take a modelow b and assign it to the variable g. Now, the microprocessor or the processor in the computer cannot execute this statement because it does not understand this C programming language. So it translates it into an equivalent piece of code consisting of even more basic statements, for example, this is just for the purpose of illustration, and it's not important that you understand exactly what's going on. But a statement like g equal to a percentage b can be translated into a bunch of statements saying load data from a particular memory location into a particular register. Load the second piece of data from another memory location to the second register, divide the contents of these two registers, store the remainder in a third register, and then finally take the result and store it into a third memory location. So the simple statement that we wrote g equal to a percentage b or g equal to a model b becomes a bunch of basic statements that the microprocessor can understand, and then it executes these statements. So why not program in the microprocessor language or in assembly language? Writing programs in machine language is very tedious. One line in a higher programming language like C translates into multiple lines of machine language. Okay, so writing machine language code is very long, it's very tedious, and is particularly prone to errors. Also, they are not portable. If you write machine code for a particular processor, let's say you're writing the code for an intel processor and you translate it into an AMD machine, it might not work, whereas if you take your C code and compile it on another machine, it will run on that machine. So compilers work as a bridge. What they do is take a high level C programming language and translate it into the equivalent machine code. So think of them as a translator. So the input is a C program, and then you give it to a compiler. The output of the compiler will be the equivalent machine program for whichever machine you want to run it on. Okay, so a compiler is a translator which translates from C to machine code. How do you compile? Okay, we have just seen why we bother with compilation. And on Unix systems or Linux systems, you can compile the program using the GCc compiler. So GCc stands for GNU C compiler. So for example, if you have edited and saved your file as sample c, you can just type on the command prompt on the terminal gccsample c. If your code does not have any errors, then the system will silently say that, okay, the compilation is done and it will show you the prompt. If there are errors, the system will list the errors and so you can go back to the editor, edit your code to correct the errors, and come back and compile again. As long as there are compilation errors, there will be no executable file created. Okay, so the executable file is the file that you can finally run. And if there are compilation errors. The compiler will not produce executable code. Okay, so name your file as whatever you want. Let's call it your filename C and then gcc yourfile name c. It will produce the executable file. If you are on Linux, the executable file that it creates is something called a out. If there are no errors and you look at your directory, there will be a new file called a out in your directory and we will explain the directory structures in another session. Let us look at a very simple C program. Open your editor, depending on which system you are in. So let's write a very simple program. It's very short. What it has is, are three lines of code and some punctuation. This is known as the c syntax. And let's examine this code. What this code does is it prints a particular message which is welcome to c, okay? And it has various components. You type it into an editor as it is, make no punctuation mistakes, syntax errors. Now, if you compile the program and you have typed the program correctly, then a new file called a out will be created, okay? So if you type gccsample C and if there are no errors, it will just say nothing. If it says something, then there is a compilation error. Compilation creates an executable a out. And now you can run the program by typing. And this is important. Dot forward slash a dot out. So the syntax is important. What you type is a dot out. And then when you run the program it will say welcome dot welcome to c, because that is what the program is supposed to do. Let us look at the program a little more carefully. What are its components? It had three lines. The first line said hash include stdio h. Okay, so it has multiple components. One is the first symbol, which is a hash. The first symbol, which is a hash. Please do not forget to include that. And actually there is no space between the hash and the first I. Okay, so there is no space here. So hash include std or dirt h. This line is supposed to tell C that. Please include the standard input output library. The standard input output library is what has the print routines which will print output messages onto the terminal. Okay? So if you want to have any input output component of your program, then you should include std or h. Include this line routinely in the first line of your c file because in the course of this class we will often need scanf and printf statements. So we'll often need input statements and output statements. So include this by default. Now if we look at the second line, we will have a function called main. And again, note the parenthesis here that is also part of the syntax. So main is supposed to be a function. All C programs start by executing the main function, and it starts from the first statement of the main function. Now, what does the main function have? It has a single line which says printf. Welcome to C. So printf is the function called to output from a C program. So to print a particular message, you enclose it in double quotes. Okay? So whatever is enclosed in the double quotes will be printed. Okay. So to repeat again, please note the extra punctuation symbols which tell you that these are valid C statements. Okay, so all the underlined statements are, all the underlying symbols are important. Okay, so in the line printf, welcome to c. This is what is known as a statement in C, and statements in C end in a semicolon. So this semicolon is also important because it tells you that this is where the statement ends. What typical errors do we have when we code in C? Let's systematically enumerate a few common errors that could happen in even a simple program like what we have seen. For example, you could forget to include Std or dot h. If you don't include the standard input library, then the compiler will give you an error message. You may forget to include the main function. Then also you will get some error message. You could forget to include the semicolon in the statement. You could forget to include the braces, the curly braces in main, or forget to close the double quote open or close the double quote in the printf statement. So these are a few errors that you could make. Even in a simple code like what we have seen. We have only three lines, but they could also have errors. I would advise you to try deliberately making these mistakes in your code. Try compiling them and study the error message this once you are familiar with the error messages. This will help you later in your coding because when you see the error messages, you can guess what errors did you possibly make in your code. So go back to the code and correct it.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 30 Initializing arrays.mp3,"You. In this lecture we'll just talk about how to initialize arrays. So recall that we have defined arrays as follows. If we declare an array float w hundred, it will declare an array of floats of hundred floats consecutively allocated in memory. And we have all also mention the fact that there is a separate box w which will point to the first location in the array, so it contains the address of the first location. Int num ten will declare an integer array of ten integers, plus one box which will hold the address of the first location, and so on. So the array's names, the cells of the array, or the elements of the array are indexed from w zero through w 99. The indices start from zero. And we have also mentioned that conceptually there is a separate variable called w, the name of the array which stores the address of w zero. Now, it's not important that we use numbers as the size of the arrays. We can also use constant expressions. For example, we can say float w ten star ten. So instead of saying 100, we can give an arithmetic expression which evaluates to 100. And this has the same effect. It will ericate an array of 100 elements starting from w zero through w 99. And there is a separate box called w which holds the address of the first location. But what about using variables or variable size arrays? This is a feature that we often wish we had. So what do I mean by that? I could declare the following code int size and then float w size. Okay. And I could say scanf percentage d and size. Okay, so a user enters the size of the array, and then I can enter ten elements into the array, for example. But here the size of the array itself is a variable which depends on the user input. And we often wish that we would be able to allocate variable size arrays. But this is not allowed in ancc. It is allowed in the latest versions of c, c 99, c eleven, and so on. We will avoid this feature for the purposes of this course. Let's assume that array means they are declared to be of constant size by constant size. You can give the size as a particular number, or you can give it as a constant expression. That is an arithmetic expression involving constants, but not general expressions. Now let us just look at how can we create an integer array num and also initialize it to particular values? For example, I want the num array to look like the following. It contains seven cells having the values minus two, three, five, minus seven, and so on. Now I know that if c did not allow me to initialize arrays when I declared it, I could declare the array as int num seven, and then I'll just write num zero equal to minus two, num one equal to three, and so on until num six equal to eleven. So here is a way that I can create an array and ensure that this state is reached. But is there a more convenient way of doing it? Can I start off the array with these contents? So c allows you two ways to do it. The first is I declare an int num and then specify what are the initial values, so minus two, so on up to minus eleven within curly braces. So this is one way that c allows you to do this. The initial values are placed within curly braces and separated by commas. The size of the array need not be specified. So I did not say that num has size seven. It will allocate an array with enough space to hold seven integers. Array elements are assigned in the order that you specified. So num zero will be minus two, num one will be three, and so on. So it is done in a reasonable manner. There's also another way to do it which is slightly different from the way above. I can declare the size of an array, so I declare an array of size ten and then give these initial values. What will happen in this case is that it will make sure that the size of the array is at least equal to the size of the list that I have given. So I have given seven elements and I've declared an array of size ten. Seven is less than ten, so it's fine. So I can declare an array of size ten. I should give values at most ten in number, so I can give ten or below. In this case I give seven numbers. So what happens is that array is initialized in the order of elements given. Num zero will be minus two, num one will be three, and so on until num six will be eleven. Seven elements are filled. The remaining seven elements are unspecified, so they will be initialized to zero. Now let me just remind you that if I had just declared an array int num ten and then put a semicolon, so I just declared an array without saying any initialization at all, then you should assume that the array contains arbitrary values. You should assume that the array contains junk values. But if you initialize an array of size ten and give only seven initialization values, then the c standard gives you the guarantee that the remaining elements are initialized to zero, so they are not junk. The recommended method to initialize an array is to give the list of initial values and let the compiler, decide what the size of the array should be. So if you give seven initial values, it will decide that the array is of size seven. Okay, now is the following code correct? If I declare an array of size 100 num and give four initial values, so this is correct. It creates num as an array of size 100. The first four entries will be initialized as given. So num zero will be zero, num one will be minus one, num two will be one, num three will be minus one, and then num four until num 99, they are all set to zero. So after the initialization, the array will look as follows. The first four values are what we give and the remaining values are zeros. Okay, now is the following code correct? Num six equal to, and then you give a list of seven values to initialize. Is this correct? The answer is no, it will not compile. So if you write this code and compile it using Gcc, you will get a compilation error. Why is that? We have declared an array of size six, but we have given seven initial values. So there is no way to do this. So the rule of thumb is that either give no size for the array and let the compiler figure out, or if you do give a size, it has to be at least seven, which is the number of values that you gave. It can be ten, it can be 100, but it cannot be less than seven. Okay, now just like size can be not just numbers, it can also be constant expressions. We can also have constant expressions as initialization values. Okay, so for example, I can give num equal to 109. Then the character value, a character value a means it will take the ASCII value of a 65 or whatever it is. So the first number will be 109, the second number will be 65. Let us say if the ASCII value of a is 65, and the third value will be seven star, 25 star thousand and 23 plus the character constant one. So whatever the ASCII value of the character one is, let's say 90 or something, so it will be added to this constant expression and it will be initialized to that value. Num two will be the result of evaluating this expression. So the type of each initialization constant should be promotable or demotable to the array element type. So each value in the initialization list should be compatible with, let's say integer, because we have declared the array of size of type integer. So what do I mean by that? For example, I can initialize an array num with the initialization list 1.9. Then comma a comma 25.5. So this is okay because the floating point values can be downgraded to integers. So maybe this will be initialized to one. Then whatever the ASCII value of a is, let's say 65 and then 25. Okay, now these are about constant expressions. What about expressions involving variables? When we initialize an array, so can we do something like this? Int C-U-R equal to five, and then the num array is initialized with two comma current, star current plus five. Will this work? The answer, surprisingly, is that it will work on most compilers. So the Ancc allows constants expressions and simple expressions for initialization values. Now, simple is of course dependent on which compiler you are using. So if you write your code and compile using gcc with such an initialization, maybe your code will compile, and the moment you compile your code with a different compiler, it may not compile. So earlier I had said that the size of the array cannot be initialized using variable expressions. In ANCC, that is forbidden, but the initialization value, so the value that goes into the array can involve variable expressions. This may or may not be supported, so it is safe to assume that both the size of the array and the initialization value can be done only using constant expressions, even though some compilers allow simple initialization values using variable expressions. Okay, now how do we initialize character arrays? Character arrays can be initialized like arrays of any other type. Suppose we want the following array s equal to I space, a space, m space, et cetera. So I can initialize it just like I initialize the other array. I will not specify the size of s and then give these characters. I am done. So this is another way to specify it. And the last character is a null character. But c also allows you to define what are known as string constants. So we can also write s equal to I am don, but now within double quotes. Okay, so this is known as a string constant. Ah, the null character is an implicit ending character inside a string constant, so it is automatically added to the end. Now, the string constants in c are specified by enclosing it in double quotes. Okay,",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 31 Initializing character arrays.mp3,"In this video we'll talk about initializing character arrays, which are a special kind of arrays and has more features than initial when, when it comes to initialization as compared to arrays of other type, okay? So they may be initialized just like any other array. And suppose I want to initialize an array to the following values. The first is I, the second is a space character, then a, then m, and so on. And the final character is a null character which will be given as backslash zero within single quotes. Now we can write s, so character s equal to and with just the empty pair of square brackets without specifying a size, and then followed by the list of characters. Okay, notice that each character is enclosed in single quotes, right? So the space character is a space enclosed in a single quote, and so on until the last, which is a null character, which is backslash zero enclosed in a pair of single quotes. But c also allows us to define what are known as string constants. So in order to initialize an array, a character array, I can also write character s. Square brackets is equal to I am don, but this time within a pair of double quotes. So imdon is a string constant. In every string constant that is, in a string enclosed in double quotes, the null character is automatically added to the end. Okay, so I want you to note this difference that here we explicitly gave a null character at the end. Here you don't have to give that. Now C string constants are specified by enclosing some text within double quotes. Okay? For example, I am a string within double quotes. Now we'll talk about how do we print strings? We have used string constants many times, okay? So just take a moment to think back to see whether you can figure out where we have used string constants. Okay, so we have used them, for example, in printf and scanf. The first argument of a printf or a scanf was always a string constant because if you recall, we had some text which involved special characters like new line. It involved format specifiers like percentage d. But whatever it was, it was a bunch of characters. So it was a text inside a pair of double quotes. That's a string constant. So the first argument is a string constant followed by what all arguments we want to print. Similarly, even for scanf, we had some say format specifier enclosed in double quotes. So that's a string constant, and then you say and value. So strings are printed using the percentage s option. So any of the basic data types in C can be easily printed using the printf statement. If you give the correct format specifier. So if you have a string constant, you can print it using the percentage s option. For example, if I want to print the string I am don within double quotes, then what I can do is I can say printf percentage s I am don and this will print I space am space don, which is exactly what I wanted to print. Now, what if I initialize a character array character str open close square bracket without specifying the size. I initialize it using a string constant. I am graded on within double quotes. Then I print it using printf percentages str will this work? And the answer is yes, it will work because c will consider this as a string constant, and it will print it using percentages, and you will get the correct output. So state of memory after definition of this string in example two is that it has a list of all these characters, I space, am space, and so on, and node the implicit null at the end. So even though the double quotes ended just after n, when you stored it in an array, there is an implicit null that is inserted at the end of the array. Okay? So when you print it, it will print until the null character. So the null character itself at the end of a string is not printed when you print it using percentages. Now let's look at the following fragment to understand slightly in a deeper way what percentages does when you print it using printf. Okay, so suppose I declare a character array using character str square bracket equal to I am graded on within double quotes. Okay, so this is initialized using a string constant, which means that after the last n there will be a null character in the array. Now I set str four equal to null. Note that there are eleven non null characters in the string constant. So this goes from str zero to str ten, followed by str eleven, which is a null character. So now I set str four equal to null. So somewhere in the middle of the string I put a null character. What will happen if I print it using printf percentages? Okay, so let's see what happens here. I declare the array and initialize it using a string constant. So it has all these letters followed by a null at the end. Then when I set str four equal to null, what it does is it goes to the fourth location in the array and changes that to null. Okay, so what that does is there was a space there before, but now you insert a null character there. After the null character, there are other non null characters, and then there is a second null. So what will happen when you print it will just print I am and stop there. Okay. It will not print the remaining characters. And why does that happen? So a string of, as far as C is concerned, is a sequence of characters terminated by a null. This null is not part of the string. So there may be non null characters after the first occurrence of null in Str, but they are not considered part of the string str, they are part of the character array. But when you look at Str as a string, it is just till the first null character. So when you print it using percentage s, only the part until the first null is printed. So that is considered the string. The character array is bigger, so it will just print I am and stop there. So do I lose the characters after the first null and where do they go? Well, of course they don't go anywhere. They remain where they were. Okay, so what is the new state of the array? The new state of the array is I space am, and then there's a null and then there are some other characters. Okay, so if I print it using percentage s, it will only come up to I am and then stop there. So is there any way to print the remaining characters? Of course there is a way. Right? So if I print it using percentage s, I will get I am, but I could easily write a loop like this. I'll say int I and then for I equal to zero until eleven, I plus plus and then put car stri. So this will print the character str zero, str one, and so on up to str eleven, regardless of whether that character is null or not. If it is null, it will do something, but it will still go on to the next character. If you run this, what you will see is it will print the first character, which is I. Then it will print the second character, which is space. Then it will print the third character, which is a. So these three are printed as they are, and then m, and the fifth is a null character. What do you mean by printing a null character? It may not print anything. Okay, so it may be just skipped, but then it goes on to the next character, gr eight D-O-N and there it stops because it doesn't print the 11th character. Okay, so the null character in this example is not printed. Now the way the null character is treated on different terminals may be different. So on some Linux terminals, if you ask to print null character, it will just not print anything. But other character terminals may print them in different ways, okay,",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 32 Pointers in C.mp3,"Hello. In this video we will start with a topic that is considered one of the trickiest concepts in C. These are what are known as pointers. We will just recap what we know about arrays because arrays and pointers are very closely related. In C, the memory allocated to any array has two components. The first is there are a bunch of consecutively allocated boxes of the same type. And the second component is there is a box with the same name as the array. And this box contains the address of the first element of the array. Okay, so let's be clear with the help of a concrete example. So let's consider a particular array of size ten declared as int num ten. Conceptually, there are ten boxes from num zero through num nine. These are all containing integers. Plus there is an additional 11th box num. So it has the same name as the name of the array, and it contains the address of the first location of the array. So it contains the address of num zero. So these are num zero through num nine are located somewhere in memory. So maybe this is memory location thousand. So num contains the number thousand, which is supposed to indicate that the address of the first location in the array is thousand. Or the num points to the memory location thousand. Okay, so conceptually this gives eleven boxes which are ten integer boxes plus one box which holds the address of the first box. Now we represent the address of a box x by an arrow to the box x. So addresses are referred to as pointers. Okay, and this is all there is to see. Pointers. Pointers in some sense are variables which hold the addresses of other variables. That's an exact description of the concept of pointers. Now we will see what that means. And what can we do with pointers? Okay, let's just step back a minute and say what can we do with a particular box or particular variable in memory which is an integer? Okay, so that's very simple. For example, you can scan f into that box. You can print the value in that box. You can do arithmetic operations on that box like plus division, modulo and so on. And you can do this for each of the boxes from num zero through num nine because each of them by itself is an integer. But we will also see a new operation which is that you can take the address of a box. So we have already done this when we did scanf, so we mentioned, and of a variable. So we'll see this and operator in somewhat more detail. So suppose I want to take the address of num one and store it in an address variable ptr. Okay, so what I'm essentially saying is that you can say ptr equal to and of num one. So num one is an integer box. It's an integer variable, and of num one is the address of that integer in memory. Okay? So you assign it to the variable ptr, but every variable in c needs to have a type. What is the type of ptr? And how do you declare or define such a type? Such a variable. Now, ptr holds the address of an integer in c. You denote that by saying that the type of ptr is int star. Okay? So here is a new type that we are seeing for the first time. We are saying ptr is of type int star. Just like you can say that. If I have int a, you can say that a is of type int. In this case, we can say ptr equal to and of number. We have discussed right now, we have int num ten, int star, ptr, and ptr equal to and of number. So ptr is the pointer to an integer. But what does ptr equal to and num one really mean? Okay, so let's look at the memory status once we declare this size. Once we declare this array. So we have num, which is the address of the first location. And then we have somewhere in memory, we have ten consecutive locations corresponding to the array num zero through num nine. Okay, now I declare int star ptr. So I create a box. Now, this box is supposed to hold the address of some integer variable. So ptr is of type address of an integer box, or more commonly referred to as pointer to integer. The statement ptr equal to and of num one says that now points to num one. Or ptr contains the address of num one. And pictorially, we denote an arrow from ptr to num one, just like I denoted an arrow going from num to num zero. Because the name of the array is a pointer to the first location of the array. The name of the array is a box which holds the address of the first location of the array. Similarly, ptr is a box which holds the address of number. So we say that ptr points to number and we denote it pictorially by an arrow. The program status is like this. State is like this. Now, suppose I add one more statement. After all these three statements, I say scanf percentage dptr. Okay? Now, earlier, when we declared an array and we read into an array directly, I said that you can do the following. I can write scanf percentage d and num one. Okay, so this will value whatever the user input into the first array using the and operator. Now ptr equal to and num one. Okay, so it's a reasonable thing to ask. Can I say scanf percentage d ptr? There is no and operator here because ptr is and number, right. This was our original statement and this is our new statement. And the answer is yes, you can do it. Suppose the input is five. Does num one become five? So scanf percentage d. Ptr really does work like scanf percentage d and num one. So it reads the value input by the user and it looks up ptr. So it's an address. So it goes to that address and stores it there. Okay, so now we can clarify a long standing mystery which is the and operator in the case of scanf. So we can say that scanf's second argument is a pointer which says, where should I put the input by the user? For example, if I have float variable and I scanf as percentage f and then some address of a float variable, it is done. Similar to reading an integer into an integer variable. What scanf takes is an address of int variable or float variable, as it may be. If you have a percentage d, then it takes a pointer to an integer variable and takes the input value by the user and puts it into that address. So as far as canf is concerned, it doesn't matter whether you gave it as anum one or whether you initialized ptr to anum one and then gave ptr it's an address. And it will put the integer input by the user into that location. So num one indeed does become five. Okay, so the location of the num one is now containing the value five. Now what else can you do with a pointer? Num is an array. It is of type int square brackets, pair of square brackets, and in c, the box num contains the address of the first location of the array, which is num zero. So internally, as far as c is concerned, the address of num zero is just like address of any other integer location. So the type int star can be interchanged with int square bracket. So you can think of num itself as just a pointer to an integer. Or you can say that it's a pointer to an array, which gives you the additional information that the next ten values are also integers. If you just say pointer to an integer, the next location may be something else. But internally, as far as c is concerned, an array name num can also be treated as pointer to an integer. Okay, now here are some other interesting things that you can do with pointers. Whenever you declare a data type, you also define what all operations can you do with the data type. So two and three are fairly simple. We have already seen it with integers, floating points and so on. You can do simple arithmetic plus and minus. With pointers you cannot do star and divide, you cannot do that, but you can do plus and minus. Similarly, if you have two pointers, you can test for equality, you can test for less than, you can test for greater than, and so on as though you were comparing ordinary integers. So two and three are what we have seen before, except that in two you can't do multiply and divide and modulo. All these things are not done with pointers, but addition and subtraction can be done. But there is a new operation which is dereferencing a pointer. We have not seen this operation before with earlier data types. What is dereferencing? Let me pictorially represent what it does. Suppose you have instar ptr and int a. So a is an integer variable and ptr is a pointer to int. If I want to store the address of a in PTr, I do it as follows. PTr equal to and a. Okay, so this means that take the address of a and store it in PTR. So now you can say that PTR points to a. Now I can also think of a reverse operation which is pTR contains some address. Go look up that address so that will be an int and store that value in a. So that is what is known as the star operator, a equal to star ptr. This means that PTR is an integer pointer. So PTr will point to a location which contains an integer star. PTr will take the contents of that location and store it in a okay, so this is known as the dereferencing operator. So the address operator takes an integer variable and stores the address in a pointer. The dereferencing point operation takes a pointer, looks up that address, and stores the value in a. Okay, so you can visualize the and operator and the star operator as sort of reverse operations of each other, and takes an integer and takes the address of that star, takes the pointer, and takes the value of the address pointed to that dereferencing. A pointer therefore gives you the value contained in the box pointed to by the pointer. The dereferencing operator is star. So if I say printf percentage d star pointer, what it will do is look up the location pointed to by ptr. In this case it is this integer box. The contents of that box is five and it will be printed so the output will be five. Not, for example, the content of pTr. So the content of ptr may be like 1004. It will not print thousand and four. But what it's supposed to do is look up the location 1004. It contains the value five. Print that value. So Star pTR is the box number one, and printing it gives you the output, five. Now, can I consider a statement like star ptr equal to star ptr plus five? This is perfectly legal. What this will do is Star PTR is an integer value, right? It is equal to five because look up this location. Ptr, that's an integer. Take that value, which will be five. So this will be five plus 510. And where do you store it? You store it in the integer variable corresponding to star ptR. The integer variable corresponding to star ptr is num one. Okay? So I would have normally said num one equal to star ptr plus phi. But num one is the same as star ptr. So I can say star ptr equal to star ptr plus five. So this will look up that location, add phi to its contents and store it in that location. So one will now become ten. Similarly, you can consider other examples. For example, I can consider a statement like num of two equal to star num plus star ptr. Okay? The novelty here is that.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 33 Pointer arithmetic.mp3,"In this video, let me show some cool stuff, which is pointer arithmetic, which helps you to understand the relationship between pointers and arrays in C. So let's consider an array declared as follows. Int num. And then it has five numbers in the initialization list. So the array will be initialized follows. There are five consecutive integer locations in memory with the given elements. Plus there is a 6th cell which points to the first location in the array. So Num points to the first location in the array. If Num points to the first location, then you can do the following operator num plus one. Okay, so num plus one would point to the integer box right next to the integer box pointed to by num. And we also know that arrays are consecutively located. So the integer box next to num is exactly num one. So num plus one points to num of one. Similarly, num plus two points to num of two and so on until num plus four equal to num of four. So this particular box, for example number four, can be accessed in two ways. You can write num of four, or you can write star of num plus four. Okay, can you tell me the output of the following printf statement? So think about this for a minute. You have three integers to print using percentage d, percentage d, percentage d, and what are to be printed are star of num plus one, star of num plus two, and star of num plus three. So think about it for a minute. Okay. Num plus one is the address which is the second integer box in the array. Right? Num points to the first location. Therefore num plus one points to the second location. Star is the dereference operator on a pointer. So star of this pointer means go to that location, which is this location, and get the value in that location, which is 22. Similarly, num plus two is the box two boxes away from the first box in the array. So two boxes away from num. So that happens to be num plus two, and then get the value there, which is 16. Similarly, star of num plus three will give you minus one. So the output would be 20 216 minus one. So in this printf statement, we have used two concepts. One is getting to a different pointer from a given pointer using pointer arithmetic. Operator plus. Okay, so we have used plus here. The second operator that we have used is star on a given pointer. So plus will tell you go to the next integer location and star will tell you for a given integer pointer, give me the value in that location. Now let's look at a slightly different array. What happens if you have a character array? So I have care Stree, which is initialized to, let's say, a given string. Bunty is a nice girl. And then I have a character pointer. So care star, PTr, and it's assigned str plus six. It is initialized to str plus six. What will happen here? What is different about this example is that earlier I said that in an integer array, plus one, for example, would go to the next integer location in memory. So wherever num was, num plus one would go to the next integer location. Here, STr is a character array, so it has to go to the next character location. And that's exactly what it does. Okay, so what is printed? Let's first consider the state of the memory. So you have an array which is a character array. It starts from str zero and goes on up to str 20. So there are 19 characters followed by the null character. Why is the null character there? Because I initialized it to a string constant. Every string constant has a null character implicitly at the end. So this is the state of the stree. Now I say that I declare a pointer. The pointer is pointing to a care, right? So it's a care star pointer. And what is the location it points to? It points to str plus six. STr is a pointer to the first location of the character array. And plus six would jump six character locations away from str zero. Okay, so you would reach this character. The important difference between this example and the previous example is that if you declared an integer array plus one would jump one integer location, plus six would jump six integer locations. Here, since it's a character array, str plus six would jump six character locations. So how the plus operator is interpreted in the case of a pointer depends on what array am I pointing to right now? Now, what will happen with the printf statement? So if I say printf percentage s ptr, what will happen? So PTr points to str six. So printf will print whatever string is starting from that location until the first null character. So it will start printing from this I and then go on printing till it reaches the null character. So the output will be just, is a nice curl. So when you want to printf, it's not important that you start from the absolute beginning of the array. You can start from an arbitrary location in the character array. And if you say printf percentages, it will start from there and go on and print until the first null character. So let's look at it once more here's. The code that we had. And let's say that the one dimensional array, for the sake of convenience, I'll just show it like this. It is actually in a row, but here is the first part, here's the second part, and so on. So when I see str, str is a character array. And ptr plus six would go six locations away from the first location. So STr is pointing to the first location in the array. It will go to the 6th location in the array, Ptr. And PTr is pointing to the 6th location. Okay, so you can ask more expressions, do they make sense? Can I say str plus five? Is this location? Similarly, can I say str plus ten? Is this location? And so on. Okay, so these are all correct expressions. Now, can you tell the output of printf percentage ptr minus five? We have talked about plus operator on pointers. So whatever the nature of the array that the pointer is pointing to, it will jump n locations away from it. So if I say ptr plus n, it will jump n locations of that type away from it. So by the same logic, can I argue that if I do minus five, ptr minus five, can I say that it will go five locations previous to what PTr is pointing to right now? And the answer is yes. Okay, so it will behave exactly as you expect. So PTr is pointing to this location. Here is the previous location. So it will jump to five locations before the location pointed to by PTr. Okay, and happens to be a. So the location which is str, one that is equal to ptr minus five. So if you printf on that location, it will say ante is a nice curl. So that's the output. Before I proceed, there's one thing that I want to emphasize, and it's often not emphasized when you see online material on pointer arithmetic. C pointer arithmetic is not supposed to be meant for navigating the array, meant for navigating arbitrary locations in the memory. So you cannot take a pointer, let's say a character pointer and just say pointer plus thousand. It will give you some location in the memory, but the behavior of the program will be undefined. Okay, so the c pointers are well defined. Pointer arithmetic using c pointers are well defined only when the pointers are pointing to locations within an array. So within an array, plus n will take you n locations away from the given pointer. Minus n will give you minus n away from the behind the given pointer, and so on of whatever type the character of whatever type the given pointer is pointing to. For example, if you have int num ten, and then you have num plus eleven. You know that num plus eleven is not a valid location in the array. Okay? Similarly, num minus one, the num array starts at num of zero, which is equivalent to num plus zero. So num minus one is also out of the given array. Therefore, these two locations are actually undefined because c doesn't guarantee you that if you try to dereference these pointers, you will get any meaningful information. So plus and minus on pointers are well defined, and their behavior is easy to predict exactly when you are navigating within the bounds of an array. So the main point of the lecture was that if you have, let's say, for example, an integer array int num ten, then num of I, which is the array notation, is exactly equivalent to star of num plus I. Okay? And I'm not saying this that you can think of num of I as star of num plus I. It's not an analogy. This is exactly what c actually does. So num of I is translated to star of num plus I. So arrays and pointers in C are very intimately related.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 35 Example   Function to copy a subarray into another.mp3,"Okay, since pointer arithmetic is a tricky concept, let's solve one more problem to try to get comfortable with that notion. So the problem here is copying a subarray into another array. Now let's explain what that means. Okay, suppose I have written a function copy array which has three arguments, and array an integer array a, an integer array b and n, which is the size I want to copy n successive index elements from a and put it into b. So a zero through a n minus one have to be copied to b. I can easily write it in the following function as int copy array int a int b int n. And then I have one variable to keep track of the index, and that variable goes from zero to n. For I equal to zero I less than n, I equal to I plus one. And then I simply say bi equal to AI within the loop. So this would copy whatever AI is into the location bi. So once the loop executes, I would have copied n elements from the array a to the array b. But this is not general and I want to solve the following problem. I have two arrays, let's name them from and two, and I want to copy n numbers from the array from two. But I have an additional requirement. I want to copy n elements from index I. So the earlier code solved the problem from index zero. In general, I want to copy from index I of from n elements into the location starting at index j into. Okay, so the earlier function assumed that I and j were both zero. In the general function I want arbitrary I and arbitrary j. So I need a declaration like the following. I have int copy array two. So this is the second function I'm writing and I have from I to j, and then n is the number of elements to copy. So what I have to do is from I from I plus one, so on up to from I plus n minus one have to be copied to two of j, two of j plus one, so on up to two of j plus n minus one. Okay, so for the purposes of this lecture, let's just assume that from and two are big enough so that you will never overshoot the arrays by taking I plus n minus one and j plus n minus one. Can you write this function? Okay, now obviously you can write a separate function to solve this. Now the trick is can you use the copy array function? The copy array functions copied n elements starting from index zero of a to index n minus one to the array b, starting at index b of zero to b of n minus one. Okay, so that's what it did. And this should be strange, because if you think about it in a mathematical way, you are saying that a general function is being solved in terms of a particular function, so you're reducing a general case to a special case. That sounds a bit strange, but we can do this with pointer arithmetic. Okay, so let's try to solve it using our own function. And here is the guess that I'm making, and then I will justify that this works. Okay, so I'll just say here is my function from I to j n that will be defined as copy array from plus I to plus j, comma n. Okay, so copy array will start from a of zero and copy n elements afterwards to b of zero, so on up to b of n minus one. And that function I'm calling using the address from plus I two plus j, and n n is the number of elements I want to copy. Now I'll justify that this works. So here is the problem that I have and I want t of j equal to f of I t of j plus one equal to f of I plus one. So on up to t of j plus n minus one equal to f of I plus n minus one. So let's try to see what happens in this function. Suppose I call copy array two from main using the arrays ftij and n, and that function merely calls the old copy array function using f plus I, t plus j and n. Okay, so the state of execution at the start of copy array two, let's say that f is an array with say ten elements and t is an array with say ten elements arbitrary. And what I want is, okay, I also assume that I is two and j is four. So I want to copy five elements starting from the second location or the third location in f f of two onwards to the fifth location in t onwards. Okay, so here is what I want to so I want to copy this minus one minus one minus one minus one minus one to t of four onwards. Okay, so I'll copy them here. So five elements are to be copied. Let's see how our function is able to do this. So t plus four is this location, f plus two is this location. So what I'm calling is the old copy array function with f plus I. So f is the address of the first location of the array. Therefore f plus two, using pointer arithmetic, is the second integer box after that. Right, so it is pointing to f of two. Similarly, t plus four, t plus j in this case is pointing to the fourth location after the location pointed to by t. T is an array, so t points to the first location in the array. Therefore, t plus four will point to the fifth location in the array. Okay, so when I say f plus two, f plus two is a pointer to here and t plus four is a pointer to here. And I'm calling copy array function with these as the arguments, and n is the number of elements I want to copy. Okay, so here's the state just before I call copy array function. Now, for example, this particular box has several names. The most common name for it will be f of three, but I can also write it as star of f plus three. This says jump three integer boxes after f and then dereference that address. Okay, now if you are comfortable with the notion that let's say f of I is the same as star of f plus I, if you are comfortable with that notion, then it should be easy to see that f plus two of one is just star of f plus two plus one. Okay, it's the same formula that I'm using, and this happens to be f plus three, which happens to be f of three. So star of f plus three would be f of three and so on. So this formula that f of I is the same as dereferencing the address f plus I, f of I is star of f plus I is applicable even for more strange looking expressions. Okay, now here is a trivia about c that because of the way it is defined, so if you say that f of I is the same as star of f plus I, then you could think that this is the same as star of I plus f. So I can write this as I of f. Never do this, but it will actually work. So f of I, you can also write it as I of f, for example, three of f. And it will also work because internally c translates it to star of f plus I. And we know that star of f plus I is the same as star of I plus f. Okay, so never do this, but this helps you to understand that f of I is being translated by C into this format. Okay, so now that we know this, similarly, you can argue about star of t plus four and t plus four of zero and so on. All of them refer to the same box. Now let's see what happens when we call copy array. So we have the stack space for copy array two and copy array two calls copy array. The formal parameters are a and b. A copies the address that it was passed to. Right. It was passed the address f plus I. So a points to f plus two. Similarly, b points to t plus four. So b points to this. Now, as far as copy array is concerned, it is not too bothered by the fact that it was not passed the absolute first address of the array. It will think that whatever address it has been passed is the start of an array and it will work from there. Okay, so copy array does not bother the fact that I was given the second element of the array rather than the first element of the array and so on. It will work as though the array started from there. And here is where we are exploiting that fact. So you now copy n elements from this location to this array. Okay, so n is five. Now when you execute that, you will have copy array two should copy five elements starting from here to phi locations here. So that's what it will actually do. And when you execute the loop, it will start from this location copied to t plus j. Then f plus I plus one will be copied to t plus j plus one and so on. So it will copy these five locations to here in the t array. Okay, and after you do this, copy array returns and every variable that was allocated to copy array is erased. But then because of pointers, it was actually working with the arrays in copy array two. Right. So even when you erase all the memory allocated to copy array, once you return, these arrays would have been changed. These phi locations starting from f plus two have been copied to these five locations starting from t plus four. So changes made to b by copy array is still maintained after you return to the calling function, copy array two.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 36 Programming using arrays and pointers.mp3,"Hello. Okay, in this lecture, we will see some more pointer arithmetic operators, and we will introduce those by talking about them through a problem. Okay, so the problem that I have is that of reversing an array. So we have to write a function to reverse an array. And let's say that the declaration of the function is void. Reverse array int a int n. Okay, now if you have to reverse an array, what is one way to do it? You take the array, copy it into another array, and then copy it back in the reverse fashion. So you have an array, a, copy all the values into b, and now you copy those values back to a in the following way, that the b's last value will go to a of zero, b's second last value will go to a of one, and so on. Okay, now let's try to do it slightly more cleverly. We want to take an integer array and reverse the array in place. That means that essentially using no extra space. So don't use an extra array in order to reverse it. Reverse it within a itself. Okay, so the array, before calling reverse array will look like a zero up to a and minus one in this way. And after calling reverse array, it should look like a n minus one, a and minus two, et cetera, up to a zero. And in doing that, we should not use an extra array. So how do we do this? Let's look at a couple of concrete examples to see how do we do it by hand. And then we'll try to code that algorithm. So in this, there are two cases. So, for example, what happens when you have an even length array? When you have, let's say, six elements, then a zero and a phi have to be exchanged. Phi goes to the zero th location. A zero goes to the 6th location or the fifth location. And then a one and a four have to be exchanged. A two and a three have to be exchanged. After this, you should stop. Right. That will correctly reverse the array. Now, what happens in the case of an OD length array? Suppose you have an array, b, which has only five elements. In that case, to reverse the array, you have to exchange b zero and b four, b one and b three. And you can stop there because there's no need to exchange b two with itself. Right. So the case of an OD length array, you will end up with an element which does not need to be touched. In the case of an even length array, you have to exchange until you reach the middle of the array. Let's try to code this up. Okay, so how is the reverse array written first, I need. So, remember how we did this by hand, we exchanged the zero th location with the last location. Then we exchange the first location with the second last location, and so on. So, it's easy to code if you have two pointers. Initially, one pointer starts at the beginning of the array. The second pointer is to the last of the array, exchange those values, then the first pointer goes to the next location, and the second pointer goes to the previous location. That's how we did it by hand. So let's try to code that up. I'll have a pointer b, which points to the last element of the array, a plus n minus one. Okay, now the loop is as follows. I'll discuss this in a minute. While b is greater than a. So remember in the example by hand, we had to exchange till we reach the middle of the array. Now, how do we find the middle of the array? I'll just write it as b greater than a, and I'll explain it in a minute. So, while this is true that you have not yet reached the middle of the array, you exchange, swap a and b. Here we use the swap function, which we have seen in the previous lecture. So, for example, it will swap the zero th element with the n minus first element. After that's done, you increment a and you decrement b. Okay, so the design logic is that a initially points to the first element of the array, the left end of the array, and b points to the right end of the array. In general, while the algorithm happens, then a is moving forward and b is moving backward. Inside the loop, you exchange star a with star b. Okay? That's what is accomplished by calling swap of a and b, because swap a and b will dereference those locations and exchange the values there. So do this repeatedly until a and b crossover. Because when a is moving forward and b is moving backward, then the middle of the array is the point where a and b cross over or the point where a and b meet. Okay, so this is the very simple logic for reversing an array. Now, I've left one thing unexplained. What do I mean by b greater than a? B and a are pointers. So what do I mean by pointer b is greater than pointer a. We need to explain that we are introducing an operation, an operator, on two pointers. What does it mean? Okay, so we are seeing a new concept, which is relational comparison between two pointers. If a and b are pointers to variables of the same type, like instar a and instar b, we can compare these pointers using equal to and not equal to. Okay, this can be done for arbitrary locations a and b, as long as those locations are of the same type. So a equal to b is true if and only if a and b are pointing to the same location. That's natural to expect. Otherwise, if they are pointing to different locations, a not equal to b is true. Now, there is another case. If a is pointing to an integer, let's say, and b is pointing to a float, then equal to and not equal to are undefined. So notice that even though this behavior looks natural, it is natural only if they are pointing to the same type. Okay, so here are operations equal to and not equal to. What about less than, less than or equal to, greater than, greater than or equal to and so on. And this is surprising, okay? Because here is something that you don't expect. You cannot compare less than, less than or equal to on arbitrary locations in the memory. Okay, we can compare a and b using less than. For this, they must be pointing to the same locations in the array. Earlier, when we discussed plus and minus, we were saying that plus and minus are well behaved only when you are navigating within an array. Similarly, when we are comparing two pointers using greater than, greater than or equal to, less than, less than or equal to, then they should all be point. Then a and B should be pointing to the same array, different locations in the same array. If that is true, then a is less than b. If a is pointing to a location which is before b in the same array. Okay? Similarly, a less than or equal to b is true if a is pointing to a location which is b or before b and so on. So for example, we can say that if we have an array int a ten, then a plus one is less than a plus two. That's clearly true because a plus one is pointing to the location one in array and a plus two is pointing to location two in the array. Okay? So if you have an array, for example, let's say a zero through a nine and PtRA is pointing to location one and PtrB is pointing to location three, then PTRA is less than PtrB. Here the comparison is well defined and it's true. But on the other hand, let's say that PTRA is pointing to a of one and PtrB is pointing to b of one. In this case, PTRA less than PTrB is undefined because they are pointing to two different arrays. So maybe in memory a is laid out before b and so on. But that's not what the less than or equal to operation is supposed to do. It is supposed to compare pointers only within the same array. Okay, so with this understanding, let's understand how the reverse array works. So in the first iteration you have an array a. Let's say that the array is 100 and 121 and so on. It has six locations. And we'll run through the trace of the execution for an even length array. And I would encourage you to create an Od length array and trace through the execution to ensure that the code works for Od length arrays as well. So in this lecture, we'll do it for an even length array. So a is initially pointing to the beginning of the array. B is pointing to the end of the array. A plus n minus one will go to the end of the array. Correct. Now, b is greater than a. That is true. So we will enter the loop, and in the first iteration we will swap a and b. Okay, so it will go to the swap function. And this is the swap function that actually works from the previous video. So you can assume that a zero will be swapped with a one. So they were initially 10, one and zero, and after swap there will be zero and 10, one. Okay, now once that happens, a advances by one integer location, b goes back by one integer location. Okay, so this is the state after the first iteration. In the second iteration, you start with a at 21 and b at minus 10, one. Again, b is greater than a, so you swap, okay, so 21 minus 10, one becomes minus 10, one and 21. Okay, so they are swapped and you advance a by one, and you take back b by one. Again, b is greater than a, so you go to the third iteration. In the third iteration, this is the state at the beginning of the iteration, and you swap these contents. So you swap minus one and 121. This becomes the state of the array. And once that is done, b overshoots. So b goes before a and a goes after b. So I've denoted that with two colored arrows. So here is the b arrow. It goes to location 121, and the a arrow goes to location minus one. When this happens, b is now less than a. So this means that you have crossed the middle of the array. Therefore you should stop now. So now b is less than a and the loop terminates. And we have seen that this correctly reversed the array. So here is how the reverse array works. We have seen the concept of relational comparison operators using pointers, how they make sense when they are pointing to locations within the same array, and how that can be used to write code using arrays.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 37 sizeof operator   how pointer arithmetic works.mp3,"In this video we will see the size of operator, which is a slightly advanced topic in relation to pointer arithmetic. This is explaining how pointer arithmetic really works. And it is also important to understand one topic that we will see later on called Malloc. So, the size of operator, and note that it's an operator. And I've highlighted that in red. It looks like a function call, but it's not. The operator gives the number of bytes that any value with the given type occupies. So, size off is an operator which takes the name of a type as an argument. It can also take other kinds of arguments. We will see that. So you could ask what is the size of an int? What is the size of a float, what is the size of a character? And the answer, the value that it will come out to be will depend on some particular machine. So the reason why you use the size of operator is that it helps you to write the code. That's general enough for any machine. We'll see what that means. So right now it just returns you the size of any given data type. So the size of operator has an effect on the way data is allocated. And the way data is allocated depends on the machine. We'll see that. So for example, if we have a character array, the cells are one byte apart. So size of operator returns you the number of bytes that a data type occupies. Okay? So in the case of a character, a character occupies one byte. So if you have a character array declared as care s eight, what you have are eight cells, and each of those cells occupy a width of one byte. So let's say that the character array starts at hexadecimal address thousand. Okay? So the next cell will be at the next byte, which is byte address hexadecimal thousand and one. And this goes on until the last cell, which is hexadecimal thousand and seven. Okay, so this contains a null terminated character array with the letters su c and then followed by null. What happens with an integer array? So in an integer array, size of an int is four bytes. So the successive elements of an integer array are four bytes apart. So let's say that I have declared an integer array as int a four, okay, this means that a zero, let's say, starts at hexadecimal address 2000. Then a one will start four bytes away because the size of an int is four bytes, right? So it should start at address hexadecimal 2004. Okay? And I've sort of indicated it pictorially. I want to say that a character is a narrower data type than an integer. An integer occupies four bytes. So the next integer cell, the next integer element in the array will start at hexadecimal address 2004. The third element will start at hexadecimal address 2008, and the last at hexadecimal address 2000 and c. Okay, so notice that I should have started it at 2012. But twelve in hexadecimal address addressing scheme is c. So in base 16, c is the same as decimal twelve. Okay? So that's why I've written it as hexadecimal 20 zero c. Now let's look at pointer arithmetic in greater detail with our current understanding of the size of operator. So suppose you have an instar pointer. If you have an instar pointer, and then you want to say that ptr plus I is equal to what. So notice that plus makes sense when you are navigating within an array. So ptr is, let's say, pointing to some cell within the array. And ptr plus I should go to the ith cell after ptr. That's what it should do. Now, the ith cell after ptr means the ith integer after ptr, okay? So we should skip four I bytes in order to reach the ith integer cell after ptr. So this is what we have written here. Ptr plus I is the byte numbered ptr plus I star size of int. Okay? The machine addressing goes in terms of bytes. So in order to jump to the ith integer cell, we have to know how many bytes to skip. Okay? And the size of an integer is four bytes. So this means we have to skip ahead four I bytes in order to reach ptr plus I. Now, if had you declared character star ptr, then ptr plus I is supposed to jump to the ith character after ptr. Okay? Size of a character is one byte. So ptr plus I star size of character would be ptr plus I star one. It's the same as ptr plus I. So notice that let's say the machine understands only byte addresses. So in order to execute ptr plus I correctly, we have to tell which byte should I go to, should the machine go to. And in order to do that, you utilize the size of operator. So since you had declared character star ptr, you know that it is size of character I star size of character those many bytes I have to skip. In the previous case, I had declared int star ptr. So in that case, I had to skip I star size of int in order to reach the correct cell. Okay? So here is the actual reason why ptr plus I would magically work correctly whether it was an integer array or it was a character array. This is because at the back of it all, you translate everything to byte addresses using star size of whatever type. Okay, so in general, if you have type star ptr, then ptr plus I is the byte numbered ptr plus istar size of type. So this type is the same as the declared type of pointer. Ptr is a pointer to that type. Therefore you multiply it with size of type. And this is the general formula for pointer arithmetic. Now, one of the side effects of that, or one of the consequences of this kind of addressing is that array plus I is star of array plus I, and it will correctly jump to the ith location in that array regardless of whatever type the array was. Why is that? Because array plus I is then translated to array plus I star size of whatever type the array has been declared to be. So you will correctly jump to the byte address corresponding to the ith element in the array. So here is how array arithmetic in C works in full. What do we mean by this? Let's see that with the help of an example. Suppose you have an integer array declared as int a ten, and it starts at the address 2000. And I want to know how is it that you get this third element of the array a of two. So a of two we know is star of a plus two. A is a pointer to the first element of the array, and we have to now understand how plus two is executed. So plus two should be the content located at byte address a plus two star size of int. Why is this? A has been declared as integer array, and in C integer array has the same type as int star. So a is a pointer to int. Therefore we know that we have to do a plus two star size of int. Whatever the argument is, it will do two star size of the type pointed to by that pointer. So we will do a plus two star four, which is hexadecimal address 2008. A was 2000. So if you have an array int a four, let's say, and it started at address 2000, then you will jump to array address 2008. And this is the reason why C arrays start at index zero, because it's a very easy formula. A of zero would be star of a plus zero, which is simply star of a. In that case, you have the consistent explanation that the name of the array is a pointer to the first address of the array. First element of the array. You don't need a special rule to do that. Think of what would have happened. If arrays started at one, then a of two would be a plus one star size of n. So a of n would be a plus n minus one times size of whatever. And that's an uglier formula than what we have here. So it is better for arrays to start at location zero because it makes the pointer arithmetic easier. So in summary, the size of operator is used in pointer arithmetic, and we'll see one more common use of the size of operator very soon. Okay, so the general usage is you can give size of an expression. What will it do is it will take the type of that expression. So if I say size of ten, then ten is an int. So it will execute size of int. And let's say that on a particular machine it is four bytes. Similarly, you could also say size of type name. So for example, I could say size of int. Rather than giving an integer as an argument, I could also say size of int where int is the name of the type and it will return me four on some particular machine. A less common usage is you could give size of array where array is some particular array and it will return you the size of the array in bytes. And this is important, it will not return you exactly the number of elements in the array. It will return the total size of the array in bytes. What do I mean by that? If I say int num ten, and then I say size of num, it will return me 40. Because there are ten integers, each integer occupying four bytes. So in order to calculate the number of elements in the array, for example, you could do the following. You could say size of num divided by size of num zero. Okay, so this would evaluate to 40 divided by four, which is ten. So size of the operator on the array doesn't exactly give you the number of elements in the array, it will give you the total number of bytes in the array. But if you also know how many bytes a particular element in the array occupies, then you can easily figure out the size of the array in terms of the number of elements. So also note that c doesn't say that an integer is bytes or float is four bytes and so on. What it specifies is the relationship between the sizes of various types. And we will not get into it right now, but just keep in mind that the size of a particular type is dependent on which machine you are running the code on.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 38 Returning pointers from functions.mp3,"Hello. In this video, we'll discuss a slightly advanced usage of pointers. Even though the title of the first slide is how to return pointers from a function. That's just a motivation for introducing a slightly more advanced topic in pointers. So let us just see what is the problem with returning a pointer from a function. You know that any variable can be passed as argument to a function, can be declared as a local variable within a function, and can also be returned from a function. So, is there something, and we have already seen that in the case of the swap function, how we pass pointers to a function, and what new kinds of functions does this enable us to write? So, in this slide, in this lecture, let's talk about what will happen when we return pointers from a function. I've written a very silly function here. You don't need a function to do this, but this illustrates a point. Okay, I have a main function in which I have an integer pointer p, and I will make it point to the return value of increment one, okay? And the increment function, what it does is it takes an argument. It increments the value, makes a pointer, and points to the incremented value, and returns that pointer. We'll see a pictorial representation in a minute. Now this leads to a very notorious error in c known as a dangling pointer. Let's examine that in slightly greater detail. What happens when we call the increment function. Inside the main function we have an int pointer p, and when it's declared it's not pointing to anything. And immediately you will call increment one. So you call increment one. N is a local variable in increment. It's the argument. So n is one, and then you declare a temp. And then you declare a pointer to temp. So there is a ptr. Let's say that temp is at address hexadecimal thousand. So ptr contains thousand and it points to temp. Temp is at address thousand. Now in the next statement, you increment temp. You set temp to n plus one, so n is one and temp is two. Now ptr points to temp, and now I will return ptr, so the return value is thousand, which is the address of temp. Now, what happens when you return to main as soon as increment finishes, and we have said this several times before, as soon as any function finishes, the memory that is allocated to the function is erased. Okay? So when you return to the main function, what happens is that you have p and p will contain the address thousand. So it is meant to point to temp, but the space meant for temp has already been erased. So p is pointing to a junk value in memory. It is pointing to an arbitrary location in memory. So this is known as a dangling pointer. Hopefully the picture is representative of a dangling pointer, the fact that it points to a location which is no longer meaningful. Notice that what I'm talking about is the ideal situation when you code it in c and try to run it. Maybe p does point to the location with address two. This is because c may not be aggressive in reclaiming the memory, but you should always assume that. The safe thing is to assume every location that was allocated to increment is erased immediately after increment returns. In practice, it may not be the case, but you should never assume that you still have the temp variable. In general, what you will have is a dangling pointer, because p points to a location which no longer contains any relevant information. So when you print p you will have a danger. So how do you return pointers from a function? So we have seen what a dangling pointer means, and here is a very silly function which will create a dangling pointer. Now what's the problem with this function? It returns the address of a local variable temp, but temp is erased as soon as increment n returns. So the return value is not a meaningful address to the calling function, which is mean. Can we get around this? Okay, so the main problem here is that anything that is allocated to the called function on the stack is erased as soon as it returns. Now, is there any way at all to meaningfully return pointers to new variables? We'll use a new concept, that of a globally accessible memory called heap. We have already seen a stack. Now we'll understand what a heap is. So roughly, the idea is that if we allocate value on the global memory, it is not erased when the function returns. I'll explain this with the help of a slightly broad analogy. Hopefully this is indicative of what actually happens with a heap. So think of executing a function as writing on a classroom blackboard when a lecture is going on. Once the function finishes execution, this is like the class is over, everything on the blackboard is erased. Okay, suppose you want to retain a message after the class is over. Now, the solution could be that you can post things on a notice board which is global to all classrooms, so it is common to all classrooms. So things on the notice board are not removed as soon as a class is over. If you write something on the blackboard, which is similar to storing something on the stack. As soon as the class is over, it will be erased. So if you have something to communicate back to another class, maybe you can post it on a notice board. Now, the notice board is globally accessible to all classrooms. The blackboard is like a stack, and the global notice board is like a heap, and contents on the heap is not erased when a function finishes. So how do you allocate things on the heap? There is a standard library function called malloc in the file stdlib h, which can be used to allocate space on the heap. Roughly, this is what it does. If you ask for malloc n, where n is a positive integer, it will allocate n bytes of memory on the heap, and it will return a pointer to the first location of the allocated space. Now that pointer can be converted to pointer of any type. Malloc just allocates n bytes. Now you may want to interpret those bytes as n divided by four integers. Okay? In that case it will return a pointer, so you convert that pointer to an int pointer. Let's see an example. I may have an int pointer. Ptr and now I want to allocate ten integers on the heap. How do I do that? I will allocate ten star size of int. So this will allocate on some particular machine, let's say 40 bytes, and it will return an address of the first location. Now that address, I want to treat it as an integer address. So I'll convert it to an int as instar and then malloc ten star size of int. So this style of writing code makes the code portable, because suppose you write the code and you on a machine where integer was four bytes, okay? And you take your code and go to a bigger machine which has eight bytes as the size of an integer. Then you compile the code on that machine, and your code will still allocate ten integers. Why? Because on the new machine, size of int will be automatically eight, so it will allocate 80 bytes. So in order to write portable code, you can use size of int instead of assuming that integer is four bytes. So I want to allocate malloc ten star size of int. This will allocate ten integers, no matter which machine you do it on, and it will return you the address of the first byte in that allocated space. That address you convert to an integer integer pointer. Here is how you allocate memory on the heap. Okay, so when you think pictorially, think of heap as a separate space in the memory, in this case ptr will be allocated some space on the heap, let's say ten integers. So on some particular machine it will say 40 bytes and it will return the address of the first byte. Now that first byte, you treat it as a pointer to int that is done through the conversion int star. Now it is nice that you can allocate space on the heap, but in order to be hygienic you should also remove the allocated space once you're done with it, right? There should be a reverse operation to allocate and that is free. It is in the same library stdlib h and if I just say free ptr and ptr was originally allocated using malloc, then it will correctly remove however many bytes were originally allocated. So let's say that I have instar ptr and then ptr. I allocate ten integers on the heap, and ptr is the address of the first allocated location. Now I may do a bunch of processing here, and once I'm done, it is just nice of me to deallocate things on the heap. This is like saying that things on the notice board. Once some condition occurs where you know that that notice is no longer needed, you just remove that posting from the notice board, right? For that you use free of ptr. Now notice the asymmetry here. Malik took the number of bytes to be allocated free. Just wanted to say which pointer is to be freed. It doesn't ask for how many bytes to free. So you can imagine that Malloc does some kind of bookkeeping where it says that I allocated 40 bytes and that was returned to PTR. So if I just say free ptr, it automatically knows that 40 bytes are to be freed. You don't have to give the extra argument saying how many bytes to free. Once you free the pointer, you just set it back to null. This is just a safe practice and it's not absolutely necessary, but it's recommended. So let's solve our earlier problem using malloc. Our earlier problem was that ptr was pointing to some location within the stack. So as soon as the function returned, the return address no longer meant any meaningful address. So let us now solve this problem. I have included std leap h because I will allocate memory on the heap. So the increment function is modified as follows. Strictly speaking, I don't need a temp variable anymore, I have an int pointer, and I will use the pointer to allocate one integer on the heap. This is a really wasteful practice, but it just illustrates a point so it will allocate one integer on the heap and then return that address and treat that address as an instar. Now I will use star ptr equal to n plus one to dereference that location on the heap and increment the and set the value to n plus one. Once I am done, I will return the ptr. I will return the address on the heap. The difference here is that the return address is on the heap and only the stack is erased. So things on the heap are not erased unless you explicitly ask it to be erased via free. So returning a heap address so p will point to a meaningful location on the heap. When you print it, you will get two, and once you are done, you can say free p. Okay, so here is a strange use which you have not seen before. Something was done. The malloc was done in the increment function, and the free is being done in the main function. Now if you think back to the fiscal analogy, it's not really surprising somebody can post something on the notice board and a different person can remove it. What happens here is that the increment function ptr points to some location on the heap using malloc. So one integer is allocated on the heap, and when you say star ptr equal to n plus one, then the location in the heap will contain two. And here's the catch. Earlier, p was just dangling. It was just pointing to an arbitrary location in the memory. But increment allocated something on the heap and returned that address. As soon as increment returns, the stack is erased. Okay, so everything that was allocated on the stack for increment is erased, but things that are allocated on the heap remain. So p points to a meaningful address on the heap. Then once you're done, you can say free p and things will be erased. When you print it, the output will be two. Malloc and free are prone to a lot of errors, and a lot of programming errors in c can be traced back to incorrect use of malloc and free. So there are some categories of errors. For example, you may forget to malloc in the first place, so you will lead to dangling references or dangling pointers, as we saw in the first example. Now you could allocate some space, but you may not allocate enough space. That's a very common error. Commonly, you could allocate off by one error. I wanted to allocate really len plus one number of bytes, but instead I allocated only len number of bytes. Another very common error is something known as a memory leak, which is that you allocate things on the heap, but you forget to free memory after use. This is called a memory leak. Notice that if you allocate space on the stack, it will always be cleaned up as soon as the function returns. So memory leaks usually happen when you malloc space on the heap, but you forget to free them once you're done. And a lot of software ships with memory leaks, and this is a major concern in the industry. There's also an obscure error which is freeing the same memory more than once. This is uncommon when a single programmer is working on a code, but when multiple programmers are working on the same piece of code, you may end up freeing the same memory twice. This will lead to some runtime errors.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 39 Example for returning pointers   return the duplicate of a string.mp3,"In this lecture, let's look at an application of Malloc and free to solve some problem that we are interested in. So the problem that I'll define is to write a function to return the duplicate of a string. A string is given as the argument, and you have to return the duplicate of that string. So we have to write a function to take a string as input and return a copy. Now let's assume that the input string is s and it ends in a null character. Assume that we can find the number of non null characters in the string, so this will be referred to as the length of the string. What we will do is allocate length plus one characters, so there are length non null characters, and then one more for storing the null characters. So we will allocate length plus one characters on the heap using Malik, and we will copy the contents of s to that space on the heap, and finally return the address of that location. So that will be the t, the new array. So notice that the original array may be on the stack, and the new array, the duplicate array, will be on the heap. Let's write this function so I'll call it duplicate. It takes one array which is the same as a pointer, so I can declare it as care star s or care s with square brackets. It doesn't matter. So I'll just declare it as a character pointer s. And what will it return? It will return another array, and array is the same as a pointer, so I'll return character star. So the input argument is an array, and the output is also an array. I'll declare three variables I, which is for the loop len, which will store the number of non null characters in S. So let us be very specific. I don't want to store the number of characters in S because I want to say that I don't want to count null. Now, if you want to count null as well in the length, then you will have to modify the code. But typical convention is that when you mention the length of a string, you don't count the null character. I will also declare a care star t. Now, the code proceeds in stages. First I have to write a loop to find the length of the string. I can write a very simple loop to do that. I can say for I equal to zero as long as s of I is not null, do increment I so as soon as I see the first null in s, I will stop. When I exit out of the loop, I will be the number of non null characters in s, so I can say len equal to I. So in the first step of the function, you just find the length of the string, excluding the null character at the end. Now comes the important thing. We have to copy that array to somewhere. If we copy that array to the stack itself, that is, if I copy that array to some space within the duplicate function stack, it will be erased when I return. So I should allocate the space on the heap. I can allocate space on the heap using the malloc function. So let's look at the malloc function. I want to allocate a bunch of space on the heap. How much do I have to allocate? I have to allocate len plus one number of characters. In other words, I have to allocate len plus one times size of a single character, these many bytes on the heap. Notice that it's not len times size of care, because if I allocate only that much, then I will not have space to copy the last null character. So the input is a null terminated character. Its duplicate should also be null terminated. So I should make space for all characters, including the null character on the heap. So I will allocate len plus one times size of care many bytes on the heap. It will return me an address of the first byte, and that address I will convert to a care star. So Malak returns a kind of an unsorted so here are these many bytes. Now it will return you the address of the first byte that was located. Now I want to treat that as a character pointer so I can do that using the casting operator. Why do you have to do that? Think about it for a minute. Because you want pointer arithmetic to work. When I say t of I, I should correctly execute star of t plus I. So go back to that lecture and understand why it is important that you know that it's not just a byte address, it's a character pointer. Once you do the allocation, you can copy s array into t array. We don't really care about the fact that t is not on the stack. T is on the heap because copying is done exactly the same way. So I can say I equal to zero, I less than length, I plus plus ti equal to si. And then finally this will copy all the non null characters. And finally I will say t of I equal to null. The last character will be the null character. Now, if you want to understand it in slightly greater detail, understand why the character star cast was required in order for T of I to work properly. Once I'm done copying the array, I can just return t and it will not lead to a dangling pointer because t is allocated on the heap. So let's pictorially understand what happens during the execution of this program. I have main function and I allocate a care array. Now, this is allocated on the stack. As soon as I declare a character array and initialize it within main, it's allocated in the stack corresponding to main. So s is a pointer to the first location in the array, and I declare another pointer, t. And then I call t equal to duplicate of s. I should return a separate copy of s. Let's see what happens. In the duplicate function. We do allocation for all the local variables, all that. But the important thing is that we have s and t, which are new pointers. Now, s is the input argument to duplicate, and it will be pointing to the array in the main function because I call duplicate of s. Right? So duplicates, s will point to the same array as the s of main, so it's pointing to the array on the stack. Now, as soon as I allocate memory for t on the heap, which was step three of duplicate, I would say t equal to character, star, malloc, len plus one times size of care. What is Len here? Len is six. There are six non null characters. Len plus one is seven. So I allocate seven characters on the heap and its return address will be cast to a character pointer. So t is now pointing to this space on the heap. Now, once I'm done creating the space on the heap, what I can do is I can copy the s array into the t array on the heap. So once that loop executes, it will look like this. Here is the s array inside main. Here is the heap, the array allocated by duplicate, and you will just copy t of I equal to s of I. So you will copy sampl that's within the loop. And then finally I will say that t of six equal to null. Okay, so here's an array of size seven. It has six non null characters, and the last element is null. And then once I am done, I will return from duplicate again. Keep in mind what is erased is the stack. Everything that was allocated to duplicate on the stack is erased. Those st and the local variables in duplicate no longer exist. But the work that was done by allocating on the heap, that still remains. Okay, so the return value, t return value, which is the address of the array in heap, will be assigned to t. So t now points to heap. Notice how it executed. S was allocated on the stack. And the effect of the duplicate function will be that the duplicate of the array will be created on the heap. So notice what we understood about the size of operator. Size of operator was used to know the number of bytes needed to store a data type. It is used in pointer arithmetic, it is used in array index calculation, and it is also used when allocating memory on the heap. Because Malloc needed to know how many bytes to allocate. And suppose I wanted to allocate ten integers, instead of me saying that on this machine I know that an integer is four bytes, so we'll go ahead and allocate 40 bytes. The problem with doing that is you take your code to another machine, and on that machine integer is eight bytes, and your code will no longer allocate sufficient space. So the real way to write portable code would be to say ten times size of int. That code will work regardless of which machine you execute on. So here is the use of size of operator. When you call Malloc, it helps you to write portable code which will execute on any machine. So we have seen that allocating memory on the heap can be done using malloc. We have understood what it means to allocate memory on the heap. The difference between stack and heap stack is erased as soon as a function returns. Heap is not erased when a function returns. You have to explicitly say that I'm now freeing that using free function again. Remember the asymmetry between malik and free? Malak needed to know how many bytes to allocate. Free just needed to know which pointer to de allocate, which pointer to free. It didn't want to know how many bytes to free. It does that automatically and to repeat common errors using malloc, you could forget to malloc. Now you could not allocate enough space in heap. For example, in the code that we have just seen, suppose you had allocated just len number of characters instead of Len plus one. Then you wouldn't have enough space on the heap to copy the last null character, so you will violate that. T is an exact duplicate of s. Now you could forget to free memory after use. This is called a memory leak, and you could have this obscure error of bringing the same memory twice. That leads to runtime errors.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 4 Tracing a Simple Program.mp3,"You in this session. Let's see another simple program and try to study what is going on in there. Okay, so here I have a slightly more complicated program than what we just saw. This has two printf statements. One says welcome to, and the second says C programming. So it is slightly more sophisticated than the code that we have seen. So, to recap, the first line hash include stdio h tells the compiler to include the standard output library. Then we have the main function. The open and close brackets immediately after main show that main is a function. Execution always begins at the first line of the main statement. Then the body of the function, the logic of the function is enclosed within two curly braces. The first Curly brace signals the beginning of the function, and the last Curly brace says that the function is over here. This particular main function has two statements. Earlier we had just one statement. Each statement, as I said before, is terminated with a semicolon. So this is the first semicolon, and this is the second semicolon. The first semicolon says that the statement printf welcome two ends at that point and then followed by the second statement. And the second statement is also terminated by a semicolon. Every statement in C is terminated with a semicolon. Curly braces enclose a set of statements, and each statement in a sequence is executed in the exact sequence that we wrote in the code. Now, once we edit this in an editor, save the file. Now compile and run the file. So let's call it sample C, or you may rename it any file you want. And then once the compilation is successful, you can run it using a out, and then it will print welcome to C programming, which was essentially the same message as we've seen before. Let's trace what happens when we execute the program. By tracing, we mean step by step looking at each statement and see what happens when the program executes. We have what is known as a program counter, which says here is the currently executing line of program. The program counter starts executing at the first statement of main. For ease of reference, I have given line numbers in the code. Now this is given just for clarity. Now let us just see what happens when we run the program line by line. Okay, so first we execute the first line of the code. After we are done executing the line four. So after we are done executing lines three and four, the message welcome two will be printed on the terminal. This will be followed by the next line. So the next line says C programming. Okay, so after the next line executes, it will print C programming percentage I've given this in two different colors to highlight that one was printed by the first line and the other was printed by the second line. Otherwise the colors have no special meaning. The program terminates when the main finishes execution and this is what is typically known as returning from the function. We will see this terminology later in the course. Now when you code, in addition to the statements which are actually executed, you may also give a few additional remarks. These are what are known as program comments. For example, the lines a simple C program, first print and second print. These are the comments in the code. Okay, so whatever is highlighted in red in the code is what are known as comments. Any text between forward slash star and then later followed by a star forward slash. So any text between successive star and star slash is a comment and it will be ignored by the compiler. So as far as the compiler is concerned, a code with comments is the same as a code without comments. It doesn't affect the logic of the code, so comments are not part of the program. However, it is highly recommended that any program you write you should comment the code. Okay? This is so that other people can understand your code. Also, you yourself looking at the code four months later or five months later, it may be difficult to understand what you wrote much before and comments help you understand the logic of the program. Now it is a very good idea to comment your programs, and for larger programs it is a must to comment the programs. This is standard industry practice, and even if you are participating in large programming projects like free software projects, comments are highly encouraged because it will understand other developers, other programmers to understand your code. Okay, so we will try to follow our own advice. Most of the programs that we will see in this code, we will comment it so that it's easy to follow the logic of the code. Now a few notes. Just as main is a function, printf is also a function. Printf is a library function, which means that it is given by the C programming language, and we wanted to tell the compiler to include this library function. The statement which said that is this hash include stdio h. So hash include stdio h is a line telling that I want the standard input output library because that is the library from which I would get the function printf. Now, what does printf do? Printf takes two arguments, just like arguments to mathematical functions. So it takes an input argument, which in our first case was welcome to. So this was the first printf statement in the program that we just saw. Now this was enclosed in double quotes, right? So it was enclosed in an open double quote and then ended with a closed double quote. A sequence of characters in double quotes is what is known as a string constant. Now we can call the functions that we define, or we can call the functions that the libraries provide. Okay, this is how once you define a function, you can call a function. Now we'll see an additional concept, the printf statements that we have seen so far. We will print a message and it will print there, and then the terminal prompt will come immediately after the print. Now typically what we want to do is we'll print a message, then tell the prompt to appear on the next line. Okay, so for this we need what is known as the new line character. All letters, digits, comma, punctuation symbols, these are all called characters in the C programming language. There are a total of 256 characters. In C, 256 is two to the eight. So for example, the small letters a to z, capital letters a to z, zero to nine, the at symbol. Other punctuation symbols like dot, comma, exclamation mark, and so on are all characters in C. Now in addition to this, there are certain things called special characters. So there is a special character called new line. In the C programming language, it is denoted as Backslash n. Okay, so notice that there are two kinds of slashes, forward slash and backward slash, on your keyboard, and the new line character is denoted as Backslash n. So even though it is a single character, it is denoted by two letters. When used in printf, it causes the current output line to end, and then printing will start from the new line. Okay, so it is something which says the current line has ended. Now, whatever you have to print, print it on the next line. The new line character backslash n is like any other letter and can be used multiple times in any particular line. Okay? For example, if you have something to print followed by backslash n followed by c, followed by something to print. Now, this will be treated as so many characters and then a new line followed by c. So let's see a particular example. If you have the old program that we just wrote, but we end each message with a backslash n. So we have printf. Welcome to Backslash n. Printfc programming backslash n. Okay, when we compile and execute, we will see something new. So when we run this as dot, a dot out, it will print welcome to. And then the next thing to print is a backslash n, which is a new line. So printing will start from the next line, and then it will print the next message, which is c programming. So it will print that followed by a new line so the prompt will appear on the line afterwards. So a new line character is something that is used to make your output messages a little more prettier. So let's just conclude by saying one more thing about new lines. The new line character, backslash n, is like any other character, and you can use it multiple times, even within a single message. For example, if I do the same program, but let's say I have welcome to Backslash n. Backslash nc, backslash n. Okay, so I have repeated occurrences of backslash n in the same message. What it will do is it will print the message welcome to. Then it will print a new line, and then it will print another line, and then it will print c followed by a new line. Okay, so when you run the program, you will have welcome to new line, then a blank line, then c, and then another line. So new lines are just like any other characters. The difference is that because it's a special character, it is represented by two letters. So it is not represented by a single letter. It is represented by Backslash n. So they are together. One character in ah C new, called the.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 40 Recursion Linear recursion.mp3,"Hello, today's video. We'll talk about an important concept in computer science, which is recursion. And we will slowly approach this by looking at various kinds of recursion. Now, recursion is usually something that is completely new. It's a new way of thinking about problems that might sound unfamiliar at first, but eventually it is a more natural way of solving problems than other techniques. So we will carefully examine what recursion means. So this is the video of a media player having itself inside, having a copy of itself inside the video, and it goes on forever. And we'll see, what does this have to do with recursion? So recursion in English means roughly say again. And functions defined in terms of itself are called recursive functions. Now, this is not completely accurate. We want to say that functions defined in terms of itself in a particular way, these are valid recursions. Recursion is a powerful tool for program construction and for thinking about and reasoning about functions in general. So it's a general purpose technique of programming, and you can do any kind of program using only just recursion. We will not see such general types of recursion in this course, but we will see fairly common examples of recursions. Okay, so for example, let us consider a very simple function which will search for a key within a given array, okay? And we know how to write this. What I will do is I'll take an integer, initialized it to zero for I equal to zero to n. N is the size of the array. I will increment I, and if at any I I find the key, I'll return one, indicating that I have found the key. If I have not found the key and I've reached the end of the array, I will return minus one. This is a typical way to search for a key inside a given array. Now, we will approach the idea of recursion by looking at a recursive solution to this. Hopefully, while seeing this program, we'll get an idea of what recursion means. Okay, so what do we mean by a recursive solution to this? Right? Rather than defining it and describing abstract properties of recursion, why not LEt's WRite an actual program which is defined in a recursive manner. And through these kind of examples, we'll eventually get the hang of recursion. So we have to write a function search. It will return whether a key is found or not. If the key is found, it returns a one. If the key is not found, it returns a minus one, and you have to search an array a of size n for the key. Now we have written this function just now using loops. Now let's write this using recursion. Now, what do We MEan by solving it in recursive, recursive manner? We have to think of the function search in terms of the same function applied to a smaller instance of THe problem. So we have to solve the problem of searching for a key in an array of size n. Can we think of this in terms of solving the sub problem for a smaller array? Okay, this is the basic question that you have to ask when you want to design a recursive function. So let us try to, in very abstract terms, think of how to solve this in recursive, in a recursive manner. So let's say that in SoME unspecified syntax. Okay, this is not going to be valid C. But this is just so that we see the idea in a very clear manner. I have to search for an array of Size a of size n for key. Now, if the array is empty, that is n is equal to zero. You can have more conditions here. N can be less than zero as well. But let's say that empty array is n is equal to zero. Then you say that I have not found the key because it's an empty array. So you give back the value minus one. So n equal to zero implies the value to be returned is MINus one. That's what this notation is supposed to stand for. Suppose n is not zero. So this means that the array is non empty. Now how do we solve this recursively, right, so we look for the first element, whether it is the key or not. If the first element is the key, we don't have to do anything further. We know that the key is present in the array. So you return one. So the key has been found and you return one. And now is the big step for recursion. How can we search for the key in an array of size smaller than n? Okay, so if a zero is not equal to key, then this means that key can be somewhere in a one through a n minus one, or it's not absent in the array. In any case, what we now have to do is search for the array starting at a one. So by a one. This is not strictly c notation. What I mean is the subarray starting at a plus one. Okay, so search in the subarray starting at a plus one. Now, the subarray has one element less because we already know if we are here that a zero is not equal to key. So there are only n minus one elements in the smaller sub problem. And what do we have to search for? We have to search for the key. Okay, so this says that either the key is present as the first element of the array, or you have to solve the sub problem of searching in the subarray of size n minus one for the same key. Okay, so here is the key to thinking about a problem in recursive terms. What you first do is consider the case when you have the trivial array, which is the empty array in this case. So we have the base case, and then these are the recursive case. Okay? So the recursive case consists of doing something at size n. So in this case it is search whether the first element is the key or not. If it is true, then we don't have to do anything further. We have found the key. Otherwise solve the sub problem. Now, the sub problem is a smaller copy of the old problem. So this is what is known as the inductive case or the recursive case. Okay? And the reason I'm calling it as inductive case is that recursion has very tight connections to the idea of mathematical induction. If you know how to write a proof by mathematical induction, what you normally do is you consider a base case. So you have a theorem, and you want to prove this by mathematical induction. You consider the base case, probably n equal to one or n equal to zero. These will be the base cases for an assertion about natural numbers. And then if the base case is true, then you say that I assume that the problem is true for size n. And now I want to prove that the theorem is true for size n plus one. Okay, this is how a mathematical induction proof looks like. And in the case of a recursive program, there is a very tight analogy. Recursion, in faCt, is just mathematical induction in the context of writing programs. Okay, we have to solve a problem first. We will see what is the problem in the base case. And the base case is a Very trivial case usually. But it's important that you think about the base case. You say that if the array is empty, then I'll return minus one because the key cannot be in the array. Then you say that I will now define the problem of size n in terms of a sub problem of size n minus one, for example. Okay, so we'll solve the bigger problem in terms of a smaller copy of itself. And this is the key to thinking about recursive programs. Okay, let's code this in C. So we code this in a very straightforward manner. I'll write int search int a int n, which is the size of the array. A int key, which is the key we are searching for. If n equal to zero, then return minus one because the key is not found. This is the base case. And if otherwise n is greater than zero. So you can search for a zero is equal to key or not. Okay, so you can search for whether the first element is the key. If it is, then you have found the key. Otherwise what you do is you call search a plus one, which is the subarray starting at size one. The subarray has size n minus one and key. Okay, so when you write a recursive program, there are a few things that you want to check. The first is that the Base case is properly handled. The Second is that when you define the sub problem, you want to ensure that it really is a SuB problem. Because if you solve the problem in terms of an equal size problem or even a bigger size problem, your program may not terminate. We will see this in a moment. So this part which is highlighted in green, which is calling search itself, but on a smaller sub problem, this is a plus one, n minus one. This is what is known as a recursive call to the same function. So we have seen functions that can call other functions. Now we are seeing functions which can call themselves. And this is what is known as recursion. Let's see how this function behaves. Okay, now before we go into the execution trace of this function, I want to add a word of caution. The actual way to understand recursion is not to think about the stack and how functions are calling other functions. Okay, the real way to understand recursion is to think about this program as a problem defined in terms of sub instance. But in any case, we will just see the execution of this function through the stack trace. Just to get comfortable with what happens at the back of all of this. So let's do a quick trace. Suppose we have an array 31, 410, 35, 59. It's an array of size five named a, and we are searching for the key three. Now we know that this key is not present in the array, but let's see how the function executes. So first we call search a 53. A zero is 31, which is not the key. So it calls search a plus one four, because now we are searching in the subarray of size four for the same key. Okay, so that's in effect the same as calling the same search function on this subarray highlighted in gray. This is because the answer to search in the whole array is now the same as answer to the search in the subarray. That is what the recursive statement is. Now, a plus one of zero is four. This is the first element of the subarray. Now, four is not three, okay? And at this point, you call the sub sub problem, which is search a plus two, the subarray of size three for the key three. Here is the subarray of size three, and you're searching for three in this subarray. Again, the first element of the array is ten, which is not three. So you call the sub problem of this, which is a plus three. Now, the array is of size two, and you will search for three, okay? And this goes on until you find that you have exhausted the array. And finally, the array is of size zero. And you will finally say that since the array subsize zero, I have not found the key. So you return minus one. Now, let's just look at this stack of function calls and see how it looks like. Search a 53 is called by main, and let's say that it has some return address. We don't care about it right now, but search a 53 calls search a plus one, four, three, and the place to return is some line. In search function. This calls the sub sub problem a plus two three, that calls a plus three two, that calls a plus four one, and that calls a plus 50, at which point you realize that their sub problem now is empty. And then you return a minus one. So at this point you have reached the base case. If n equal to zero, return minus one. So that will return a minus one. Where will it return to? It will return to the function which immediately called it, which is search a plus four one three. So this guy gets a minus one, therefore, and it just returns that minus one. Return the value of whatever is returned by the sub problem. So it's minus one. And that minus one gets returned. So it gets bubbled up all the way back to main. And main you can realize that the element is not present in the array because the return value of search a 53 was minus one. At this point, the call stack terminates. So what was special about the recursion call stack? It was just that most of the stack was involved by a function calling itself over and over. But each time the function called itself, it was calling on a smaller version of the problem. And here is how you think about a very simple program in terms of recursion. Earlier, we saw how to solve this using iteration, which was using a loop. And we have seen the problem how to be solved using recursion. Now a word of caution, we will see this in further examples. It is very important that you handle the base case properly. Now this is something that we are not used to in normal way of thinking. When we think about solving a problem, we are thinking about solving substantial sizes of the problems. We are not concerned too much with what happens with an empty array, what happens when n is minus one, and things like that. But even in this problem, we know that when we called search a plus 50 three, we know that the function terminated because we had a base case which said that if n equal to zero, then return minus one. If we did not have this case, you could see that probably it will go on calling itself infinite number of times. So just like when you are writing a for loop or a while loop, you have the case of infinite loops. In the case of recursion, you can have an infinite recursion and you have to guard against that. The only way to guard against that is to get the base case correct. So here is something uninterintuitive about program grammar. Recursive functions almost half of your intellectual effort is in handling the base case properly, and only the remaining is involved in solving the recursive case.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 41 Recursion Linear recursion 2.mp3,"Hello. In this video, we'll look at linear recursion in a bit more depth. I'll describe what I mean by linear recursion. We have mentioned earlier that when designing recursive programs, think about the problem in recursive times. Don't think in terms of the stack that is used in execution. When it is actually executed, there will be a stack created and used for the execution. And the depth of recursion is a term which means the maximum size of the stack while you execute the program on a given input. The memory used by the programs includes the local memory of the function plus the depth of the stack. So let's look at linear recursion in a bit more detail. By linear recursion, I mean problems which can be solved by calling an instance of the subproblem. Okay, exactly one instance of some subprobleble. We will see more general kinds in later videos. Let's look at an example that we have seen before, which is reversing an array in place. So we had to reverse an array a with n elements, and it is supposed to reverse the values contained in the first n indices of a. That is, a zero is exchanged with a n minus one, a one is exchanged with a n minus two, and so on. So we have to do n upon two exchanges approximately. So, let's look at the problem recursively. We had earlier solved it using loops. Now, the basic idea of the recursive solution to in place reversal is the following. If n is zero or one, if this array is either empty or it contains exactly one element, then we don't need to do anything to reverse the array. Otherwise it contains at least two elements. In this case, exchange a zero with a n minus one. That will be the first layer. Now call the sub problem. We have to solve one more sub problem which is reverse on an array which is from a one through an minus two. Notice that we had already solved the problem of swapping a zero and a n minus one. So earlier we had seen a program which involved linear recursion which just went left to right. Okay, in the case of reversal of an array, it is still linear recursion in the sense that there is only one call to a subproblem. But the way in which you call the subproblem is slightly different. Let's see with an example. We'll consider actually two examples, one for an even length array and another for an OD length array. Let's say that a is an even length array with six elements, and we want to reverse it using the function reverse a six. And we have to do it in a recursive way. So what you do is first swap a zero with a five. And now what is the sub problem left to be solved? We have to solve reverse of this intermediate array which starts from a one and contains four elements. So we have to reverse the array which starts from a plus one and there are four elements to be reversed. So in one step, even though we have only a single call to a sub problem, we have actually reduced the size by two. Okay, and now you reverse, or rather swap an a one and a four. And now the sub problem that remains is to reverse this subarray which is a plus three and you have two elements to reverse. Okay, so you do this and at this point you have a subarray which starts at a plus three and has zero elements to reverse. At this point there is nothing left. Okay, now for an OD length array, let's take a very small array which contains three elements and we have to reverse it. What you do is you swap b zero with b two. At this point you have a sub problem which has exactly one element and you don't need to reverse that array. That array is its own reverse. So the problem just stops there. So notice the difference between the even length array and the od length array. In the case of an even length array, the step just before the last step involved an array of size two and you still had to reverse that array. In the case of an OD length array, the last step involves a single length array which is its own reverse. So you don't have to do anything. So there are two base cases to worry about. One is where the subarray is of size zero, and another is where the subarray is of size. 10 corresponds to even length arrays, and one corresponds to od length arrays. Let's write this code now. Okay, so we have reverse a containing n elements and we have return type void, which means that this function is not going to return you a value, but it is going to do something. Okay, so if n equal to zero or n equal to one return, because in that case a is its own rubles. Otherwise, you swap the first element with the last element. That is this operation, a and a plus n minus one. So notice that swap is a function that takes two pointers to int and exchanges them. Once you do that, you call the sub problem, which is reverse a plus one, n minus two. Notice that unlike the previous examples we have discussed, the sub problem reduces by two in size even though you have only a single call, the sub problem is not of size n minus one, it is of size n minus two. So look at the case of the od length array and the even length array that we have seen before. And you can notice that the sub problem reduces by two in size for every step. Now what is the depth of the stack? You know that roughly n upon two calls will be done because you start at a size n. The next call will be of size n minus two, and so on until you hit either one or zero. So you can work out that there will be about n upon two steps before you reach one or zero. The accurate expression is ceiling of the expression n upon two plus one. So many calls will be there before you hit one or zero. So each function call will take, let's say constant amount of space and there are about n upon two function calls. So the stack depth is n upon two, and therefore the whole space, which is stack depth, times the number of variables at each function. That will be about n upon two. So now let's consider a third example which is computing the size, the maximum of a particular array. For concreteness, let's consider an integer array and we have to compute the following function. Int max array. It takes two arguments. One is the array itself and the second is n, which is the number of elements in the array. Again, let's think about the problem recursively. We have written loops to solve the problem earlier, but now let's think about it in a recursive manner. If the array contains zero elements, then what is the maximum? So here it may be slightly counterintuitive. If you're seeing this for the first time, the maximum of an empty array is some large negative value. Think of it as minus infinity. Why do we do this? This is because let's take maximum of, let's take a concrete example. One, two, three. Okay, we know that the maximum of this array is three. Now what happens when you take a larger array, a larger array, or list of numbers? So what happens if you take, let's keep this unspecified, okay. A is an int. You know that if a is less than three, then the maximum of this array is going to be three. If a is greater than three, then the maximum of this, the second one, is going to be greater than that. Okay? So in any case, whatever be the nature of a, you can always say that maximum of one, two, three, a is going to be greater than or equal to the maximum of one, two, three. Now what that means is that if you take a larger set, its maximum is always going to be greater than or equal to the maximum of a subset. Okay, this is, note that this is independent of a, because you can analyze by cases. If a is less than or equal to three, then this maximum will be three itself and three is greater than or equal to three. If a is greater than three, then this maximum is strictly greater than the previous maximum. Okay? So maximum is always monotone according to the subset relation. Now this means that what will be the maximum of the empty set? Okay, the empty set is a subset of every set, right? So no matter which s I pick, maximum s has to be greater than or equal to maximum of the empty set. This means that a reasonable value for maximum of empty set is minus infinity. Okay, so we set. So this is a reasonable convention. That's why when n is of size zero, we return some really large negative value, okay? By which I mean the absolute value of the number is really big, because we are trying to say that it's essentially minus infinity. If n is of size one, then you just return a of zero. Because the array contains only one element, its maximum will be a zero if n has size at least two. Okay, now we are in business. We have to solve the problem in terms of a sub problem. So here was an example where the base case had to be really thought of. But now we are at the case where we are thinking about the recursion. So what is the recursive step here? So let's take a concrete array. We have array a, which contains the numbers 243-7523 minus three and nine, some concrete array. And we want to say that I want to calculate the maximum of the array a in terms of some sub problem. The natural sub problem that we can think of is the sub problem of finding the maximum of this subarray, which starts from a one and goes on until the last element. Okay, so the cursive call should be something like max array a plus one. And there are n minus one elements in it because we omit the first element. Now, maximum value. How can we solve the whole problem in terms of the sub problem? Suppose we know what is the maximum value in the tail a plus one, two containing n minus one elements. The maximum of the whole array will be the greater of the two numbers. Which two numbers? The maximum of this subarray and a zero. Okay, so maximum value is the larger of a zero and the maximum of the tail subarray, which is a plus one to a plus n minus one. Now, in order to compute the sub problem, we call a recursive call to the same function. It looks for the max array from a plus one containing n minus one elements. Okay? So in this example, the maximum of the tail subarray will be 23, okay? And let's say that a zero is 25. So the maximum of the whole array will be the greater of the two numbers 25 and 23. So in this case the maximum value will be 25, which is a zero. So now let's write this code. Okay, so the recursive function is very simple. And this is one of the reasons why people like to write recursive functions. Because from a recursive function it's very clear what the function is going to do. Usually recursive functions are shorter than their loop versions and they are easier to understand when you read someone else's code. So let's solve max array using a recursive function. In c we have int max array because it's finally going to return an int value, which is the greatest value in the array. Now you have an int array, a, and n is the size of the array. Let's say that we set some max value. If n is zero, then the maximum is simply something like minus infinity. Let's keep it at a very large number, minus nine, nine, so minus phi, nine, some large value, it doesn't matter. And then if n minus one, if n is equal to one, then the array contains only one element and therefore it is the maximum. Okay, so you just return a of zero, otherwise n is at least two. So in this case, you say that the maximum value of the sub problem is max array, a plus one, n minus one. So this is the maximum of the tail array. Now once you have the maximum of the tail array, the maximum of the whole array is the greater of the two numbers, which is a zero, and Maxwell. Okay, so we return max of a zero, comma Maxwell. Now max is a function that is already there in the standard math library in C. But if you want to write it, it's not a difficult function to write. You can take two integers and return the greater of the two integers. Now we can think about is it better than the loop version of the program? The advantage of the recursive program is that it's easier and in some sense it contains fewer number of lines than the loop program. The disadvantage is that it takes up more space while executing. Okay, so the questions are how much time does the function take? How much space does the function take? So these are things which are concrete and can be measured. There is also a softer question which is how easy is it for a programmer to look at this function and understand what it does? In the second criterion, it is the recursive function that scores. In the first criterion, it is often the iterative function, the loop function, that scores. So please think about these questions and you can work through it and say that in order to solve max array of an array of size n, let's take an array of size eight. You will see that these are the recursive calls. It will make a plus one seven, a plus two six, so on up to a plus seven one. And when you hit an array of size one, you get to one of the base cases, which is that when you have an array which contains a single element, the maximum is the only element in the array. So once you hit here, you will start returning. So the maximum depth of function calls in. This will be the size of the array. So you can say that stack depth is n. Now, recursive programs are general programs, just like loop programs are general programs. You have written loops even before you saw water arrays in C. Similarly, you can write recursive programs which deal with general data, not just array data. And in all of these questions you can ask the following questions. How much time does the function take? And how much space does the function take? Okay, we'll see an example for a recursive function that will read n numbers and returns their maximum. Before we came to know of c arrays, this is the kind of loop functions that we use to write. We would take n numbers. So first you will read how many numbers to read. Then you will read exactly those many numbers and find their maximum using a loop. Now let's try to do that using recursion. We are not going to use any arrays, okay, so what we have to do is write a function read max. It takes n elements and the logic is the same as finding the maximum of an array. But we will do it without using arrays. How do you do this? If you have zero numbers to read, then you return minus infinity or some approximation, some large negative value. Otherwise you read the first number. If n is equal to one, that is, we had to read only one number. Then you just say that x is the maximum. Otherwise n is greater than or equal to two, and we have read one number. So you say that return the maximum of the two values, which is x. Okay, and what goes inside? Inside, you have to solve a sub problem, which is the sub problem of reading n minus one numbers and returning their maximum. Go back and compare the program with finding the array maximum and the recursion works exactly in the same way. So we'll read n minus one numbers and return the maximum of those. And then you compare maximum of the first number and the maximum of the sub problem. This is exactly as before, except that we did not use any arrays. And how do you call this function? You just declare a main function with n. You scan of how many numbers to read and call the function read max n. Finally it will return the maximum of the n numbers read and you just print that value. Okay, so think about this for a minute and see why we did not need to use arrays. Now there are other functions which are typically written in a recursive manner. We just saw that you can use recursion with arrays. We saw problems where you don't need to use arrays, but you can still write a recursive routine. Now we'll come to arithmetic functions, and many arithmetic functions are often recursively defined. For example, let's take the GcD function Euclid's algorithm, and you can write the GCd function as follows. You first ensure that a is greater than or equal to b using the swap function, and then you just call gcd of a comma b and gcd of a comma b is defined recursively as follows. If b is zero, then gcd of a comma b is a. If b is nonzero, then you just return gcd of b comma a modulo p. Okay, so this is how you write the recursive GcD routine. And I will make the claim that this routine is cleaner than the iterative routine. In the iterative routine, remember we had to use an intermediate variable which will store the value of, let's say a, and then did a careful three way exchange in order to accomplish B comma a model of b. Here the code is very simple. If B is zero, then we know that Gcd of a comma B is a. If B is nonzero, then we know that Gcd of a comma B is GcD of B comma a modulo b. So it's a very concise way of writing the function. Now you can ask the question which is better, is it the recursive formulation or the iterative formulation? Logic is the same, so it will take the same number of steps, so the time taken will roughly be the same. And we have also made the claim that the recursive version is easier to understand. The disadvantage may be the following, that the recursive function may use a very deep stack, so you can ask a question, like how deep will be the stack in the case of the recursive program? So in the following video, we'll talk about more general kinds of recursion. In this video and the previous video, we have seen recursive problems which can be solved by one call to a sub problem. Okay. And we'll see more general kinds of.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 44 Multidimensional arrays and pointers.mp3,"Hello. In this video we'll look at the relation between multidimensional arrays and pointers. And this is by far one of the trickiest topics in the entire course. And you can code multidimensional arrays without actually understanding the exact relation between dimensional arrays and pointers. But understanding this gives you a better grasp of how C treats multidimensional arrays. So we'll now discuss how pointer arithmetic works with two dimensional matrices. Because as soon as we had discussed one dimensional matrices, the next thing we did was we discussed 2d matrices. We discussed the relation between pointers and 1d arrays. So let's try to see what is the relation between pointers and 2d arrays. Now this is more complicated than it looks at first sight, and you can do a lot of matrix computations by not understanding this, except that understanding this gives you a better grasp of what is happening. We have seen that when you declare a 2d array as a parameter to a function, then you should specify the number of columns, but not the number of rows. So let's look at a function which makes an identity matrix. An identity matrix is a matrix that has one along its diagonal and zero everywhere else. So we have void make identity ten, and it takes a matrix of size double, and the number of columns is ten. Since identity matrices are squared matrices, this essentially says that the code will work for a ten by ten matrix. Then I have a for loop going from I equal to zero to ten, a for loop going from for the columns going from j equal to zero to ten. And the code just says that if I am at a diagonal element, that is I equal to j, then mij is one. For all other elements, mij is zero. Okay, so this creates a matrix of size ten by ten. Now this is a very strange code because it's a function that essentially makes exactly one matrix. It would have been nice if I would have a function that can create arbitrary size identity matrices. For example, if I wanted a 20 by 20 matrix, it looks like I have to write another function, make identity 20 double m 20, right. The rows are unspecified, the number of columns is 20. Yeah, this is the standard way to do it. But there is a slightly more complicated way to actually accomplish a function which can take an arbitrary size. So let's see how these things can be done by understanding how pointer arithmetic works with 2d arrays. Okay, so let's go back to how do I address the Ijth element in a 2d array? Now we can view it as a three by five matrix of integers, something like this. So it may be an array 01234, that's row zero. And 56789. That's row 110. 1112. 1314. That's row two. So this is the matrix view, which is three rows each with Psi columns. This is the standard view, but internally, c views this as a long linear array of size 15 in what is known as the row major form. So let us just look at what it is. Internally, c looks at the array in the following form. It is basically zero through 14 laid out in a single row. Okay, so this is the row major view. It's called row major because first all elements of row zero will be laid out, then all elements of row one will be laid out, and finally, all elements of the last row will be laid out, but it's laid out as a linear way. Now the natural question to ask is, in that case, is a 2d array really at the heart of it, just a 1d array? So the difference between a 2d array seen in the row major viewpoint and an actual one dimensional array will come in the pointer arithmetic. Okay, so as I just mentioned, there are two views, the matrix view and the row major view. And both views are correct. Okay, so if I have the matrix view, mat is a pointer to the first row. So mat plus one will be a pointer to the second row and mat plus two will be a pointer to the third row. So row number three or row indexed with two in the row major viewpoint. Here is the difference. Mat points to the first row and mat plus one should point to the second row. Right? So we cannot say that mat is pointing to the first element here and mat plus one should point to, therefore one. No, that's not what happens. It has to be consistent with the matrix view. So the pointer arithmetic mat plus one should point to the same element regardless of whether you are looking at it using the matrix viewpoint or whether you are looking at it using the row major viewpoint. Okay, so mat plus one will still point to five and mat plus two will still point to ten. So these two viewpoints are consistent. Now here is the difference with one dimensional arrays. So we have just repeated the viewpoints here, the matrix viewpoint and the row major viewpoint. Now had mat actually been a one dimensional array, Mat would point to the first element in the array. Therefore, mat plus one should point to the second element in the array. That's not what happens. It is actually the row major representation of a 2d array, and mat plus one should skip exactly five elements because that is the size of the column. So mat plus one should skip five elements and go to the element mat 10. So here is the gist of why you need to know the number of columns, because in the row major viewpoint, I have to implement mat plus one. So I have to say how many elements should I skip in order to get to the first element of the second row? Okay, and that number is exactly the number of columns in the array. So the number of columns in the array is five. So to get to mat plus from mat, I have to skip five elements. Similarly, to get to mat plus two from mat plus one, I have to skip exactly five elements. Okay, so this is the reason why the number of columns is an important information, because that tells me in the row major representation, how many elements do I have to skip in order to get to the correct entry in the second row or the third row? So here is the pointer arithmetic for the row major representation. And notice that this is considerably different from the pointer arithmetic for a 1d array. In a 1d array. Array plus one will go here, the first element of the array. Okay, now can you try to guess what will be the type of mat? So here are four candidates and let's go through them to see what is the most likely candidate. And we'll see this in greater detail. Instare mat is a pointer to Int. Now we have seen that that is approximately an array of integers. And that is definitely incorrect because this is supposed to be a 2d array, not an array of integers. Pointer to pointer to mat. Okay, we haven't seen that so far and that looks like a likely candidate. So what about the third and the fourth? The third and the fourth looks confusingly similar. What do they mean? So here's a hint. The array indexing operator square brackets has higher precedence than star, okay? The dereferencing operator. So in this case, the first says that. So what does this mean? The first declaration is actually int star mat five. Okay. And the second declaration is int star mat five. Okay, so what does this say? So let's compare it with a standard declaration like float array five, okay, this means that array is ARR is an array of size five, each entry of type float. Okay. Similarly, this means that matrix mat is an array of size five, each entry being a pointer to integer, right? So it will be some matrix like this. It has five elements and each of them is a pointer. So here is the viewpoint for declaration three. Now what about declaration four? So there, let's see this. So let's compare it with a standard declaration like let's take a standard declaration like int ARR five. Again, this says that ARR is an integer array of size five. So it contains five elements each of type int. Okay? Correspondingly, what this means is that star math is an integer array. So here is an integer array containing five elements. Okay? These are integers. Now this means that if you dereference mat. So mat is a pointer to an array of size five. And this is exactly the actual representation of a two dimensional array. So notice the difference between these two representations. The first says that mat five, mat is an array of five entries, and each entry is a pointer to an Int. So it looks like this. So it's an array of five pointers to Int. The last declaration says that star mat is an array of int of size five. So mat is a pointer to an array of integers of size five. So here is the difference. And we will argue that the fourth definition is essentially what we want. And we'll see this in greater detail. So let us understand these type expressions in greater detail and we'll see this in the further video. Also, we'll particularly pick on one representation here. So we have argued that a 2d array is similar to the last declaration. Here I've eliminated the most obviously wrong declaration, which is instar mat. That is basically a one dimensional array. So I've just eliminated that. We'll examine all the others. What I've just said is that a 2d array is similar to the last declaration. But even the previous two declarations do make sense and there may be situations where you need to use such variables. Let's examine them in greater detail. So let's look at the first one, which is in starstar mat. And it means all of the following equivalent ways. So all of these are equivalent ways of looking at the same thing. You could say that mat is of type int, star star. Or you could say that mat is a pointer to a pointer to an Int. Since arrays are pointers approximately, you could also say that Mat is an array of pointers to Int. And this is also commonly called array for is. So you have mat in star, star. Now this is a pointer to an array of integers. Now every pointer to an int is essentially a pointer to an array. You can look at it like that. So you can say that mat will point to an array of pointers, and this array of pointers, each of them may point to a different array. Okay, so you dereference mat once you will get a pointer to an integer, and again you dereference once more. You will get the actual array. Okay, so what happens when I do mat plus one? It will go to the second entry in the array of integers. Now that may be a different array altogether. So mat is similar to star Star mat. This is just the way address arithmetic works. And both of them are addresses. Both of them are pointing to this location. Both of them mean the content of this location. Similarly, star of star Mat plus one is Mat of zero one. Okay? So in the case of one dimensional arrays, we have just mentioned the equation that array of I is the same as star of ARR plus I. And what we are saying here essentially is that mat I j is the same rule applied twice. So I could say mat I is star of mat plus I. So that will give me an array. And then I need the jth element of that, so I can again do star of star mat plus I plus j. So these are two ways of looking at this array. So Mat plus one will be the next element in the pointer to integers, and it's the same as, and when you dereference it, you will get another array. Okay? So in order to get the first element of this array, I could say Mat 10. Or using the pointer notation, I have star of star mat plus one. So these are the same, okay. And similarly for other elements of the array. So one of the advantages of this kind of in star star mat is that I have freedom in both dimensions. You can see these as the rows of a matrix and these as the columns of a matrix. If you see that, then you can see that I have a lot of freedom here. First of all, the number of rows is not limited because it's just in star star mat I could have any number of rows here. Now another main advantage, and the reason why this is somewhat popular is that the length of row zero need not be the same as the length of row one. These are just pointers to integers. So the first pointer to integer may be pointing to a row of size two, the second pointer may be pointing to a row of size three, and so on. So the row lengths need not be the same. So think of an array where row zero is two elements long and row one has three elements in the row and so on. So if you have extremely ragged array, then in starstar mat is a nice representation to pick.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 45 Multidimensional arrays and pointers   continued.mp3,"Hello. In this video we'll look at one of the other expressions. In particular, we'll look at the third one, which is int star mat five. So if I had written int array five, this means that array is an integer array of size five, right? So similarly, I can read this as star mat is an integer array of size five. Okay? So in other words, mat is a pointer to an array of size five, array of ints of size five. Okay, we can look at it in this way and let's see what this really means. So we can picturize in this way. If you dereference mat, that is, if you take star mat, you will get some array of size five of integers. Now let us look at the picture. So math may be pointing to some array of size phi, which means that the next subsequent location will be another array of size phi, if it's a valid address. Now for the first location, we can refer to it as mat. Or it's the same as star mat of zero. Or it is the same as star star mat. So remember the general formula that we had was if I have the notation mat ij, I can look it up as star mat. So first let me translate mat I so that we have seen that this is simply dereferencing mat plus I that address. So now we have one more subscript. So in order to decode that, I'll do the formula for a second time. So this plus j. So remember that this is the general form. So similarly, if we have mat, I can write it as star mat of zero, or I can write it as star star mat because I and j are both zeros. So this is just a special case of the general formula. Okay, mat plus one points to the second row of five integers. So remember that the type of mat is, it's a pointer to an array of size five of integers. So the next pointer location when you do mat plus one, goes to the next array of size five. So mat plus one is another array of size five. In particular, it may be the second row of a two dimensional array where you have five columns. Mat plus two will be similarly the third row and so on. So mat two three. For example, if you apply the formula, it will come out to be star of star of mat plus two plus three. Notice that all boxes are allocated in this example. Now, mat plus I points to the ith row of five integers, and star mat is an array of size five. This is what we have seen. Now, in order to get comfortable with the notation, you can look at these formulas and try to decode, like for example, you could try what is the pointer arithmetic way of representing the location mat eleven. So you can see that it is definitely the first case where it is star of star mat plus one. So that is definitely true because this is just the formula that we just now discussed. But if I don't decode both the subscripts, I decode only one subscript using pointer arithmetic and leave the other subscript as it is. Then I know that it is also equivalent to three. So three is also another way of representing it. And try to convince yourself why the second is not correct. Now let's understand this in somewhat more detail by considering a tricky question. We have a function int search. So here is the function insert int a int n int key. Okay, so what does this function do? It will search for key inside array a of size n. A is an array with n elements and you have to search for it, search inside for it for the element key. If it is found, then you return the index where it is found. If it is not found, you return minus one, because minus one can never be a valid index in an array. So when you return minus one, you know that it's not present in the array. Now can we use this function to search inside a 2d array? So we are using a one dimensional function in order to search inside a 2d array. Now the basic idea is that we can search row by row. Each row of a two dimensional array is somewhat like a one dimensional array. So we'll call search multiple times, once for each row in the array, until we either find it or we are done with all rows. The algorithm is search it row by row. Now the question is which of the following is actually doing that? So we have three expressions, search mat plus one phi key, search star of mat plus one five key, and search mat of one five key. Which of these will do it? Now let's look at second, okay, mat is pointing to an array of size five. Therefore mat plus one is also a pointer to an array of size five. When we dereference that we get an array of size five. Okay, so that's the right type. So the first argument to search the second statement will be an array of size five. So therefore the second call is valid. What about the third call? Again, mat of one is simply star of mat plus one if you translate into pointer arithmetic. So the third line is just the second line in disguise. Instead of using pointer arithmetic notation, we are using subscript notation. So two and three in fact are equivalent. So two is correct. Therefore three is also correct. Now think about why statement one doesn't make sense. So mat plus one is actually a pointer to an array of size in size five. Therefore it is not the right type. It is not an array of size five. It is a pointer to an array of size five. So it's not the correct type and therefore the first call is not valid. The first option is a bit delicate, so I would encourage you to stop here and think about why it is not correct. Okay, now let's utilize the function in order to write our routine to search inside a 2d array. So once again, we are utilizing a one dimensional search routine in order to search inside a two dimensional array. So let's say that we are given this int search function which can search inside a one dimensional array for a key. Now I'll write a 2d function, a function which can search inside a 2d array. Now the correct declaration of the function would be instar mat, five int rows, key, n rows is going to be the number of rows in the array. Key is the key we are searching for and instar row and instar column. Okay, so I want to focus on the first argument and the last two arguments. The first argument says that I will pass you a pointer to an array of size five. Okay, this is exactly what we should do because then a two dimensional array can be just traversed by using mat plus one, mat plus two and so on. Okay, so here is the correct type declaration that should accompany the 2d search routine. N rows is just the number of rows, key is the key. Why are we saying instar row and instar column? We want to return two things. If a key is found, we want to return its row index and its column index. Now unfortunately, a function can return only one value. So how will you return two values? So we will say that, okay, we'll not return two values. What we will do is give me a pointer and I will write you and I'll write in that address the correct row and the correct column if it is found. So here is a standard way in C where you might encounter a situation where you need to return two values and instead what you pass are the pointers. The algorithm is what we have discussed before. You check each row of mat using the function search. If search returns success, then that will be the column index in that row. Because search is searching inside a 1d array. So wherever it returns, that will be the column index in the ith row. So now you say that the column index is that and the row index is the I that I had if it is not found in any of the rows, you return minus one. So, let's write the function. We have an I to go traverse through the rows we have found equal to zero. This will be the flag indicating whether the key is found or not. And initially you just set star row equal to minus one and star column equal to minus one to indicate that I've not yet found it. Found the key. Now you write the main loop, which is going through the rows one by one. You start with row zero, and you go on until both these conditions are true. That is, you have not seen all the rows. I is less than n rows and you have not found the key. So, not found. Okay, what should you do to the ith row? I should say that search the ith row. So the way I say it is search star of mat plus I. This is the same as saying search mat of square bracket I, comma five, which is the number of columns, and key, which is the key that I want to search for. The return value is stored in star call. So you dereference call and store the return value there. Now search can return either if the key is found, it will return the correct column index, or it will return minus one. So you just check for that. If star column is a non negative number, then you say that, okay, it has been found. So you say that the row is I. So star row is I and found is now one. So at the next iteration, you will exit out of the loop because you have found the key. And then the last statement in the loop will be just to increment the I variable. Finally, if you have done with all the rows and if you have exited out of the while loop, you check whether you exited out of the while loop because you exhausted all the rows. So there are two conditions to exit the while loop. One is I is greater than or equal to n rows. That's one condition. The second is that found equal to one. If you exited because found equal to one, then you can return the correct value without any problem. If you exited before, if all the rows were exhausted and you still did not find the key, then you have to say that column is minus one. Okay, so here is a brief code which will do this. So this code utilizes our understanding of two dimensional arrays as basically an array of point as, as a pointer to an array of size five. And here is why the number of columns is important, because in order to do mat plus one correctly, we need to know how many bytes to skip. Okay? And this is crucially dependent on the number of columns. The number of rows actually does not matter because you can keep on incrementing the rows as long as the array is valid. The number of columns is important because that's how you get to the next row.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 46 Multidimensional arrays and pointers   continued.mp3,"Okay, in this video we'll look at the last possibility with respect to multidimensional arrays and pointers. This is known as an array of arrays. In order to understand this, let's just look at something we are comfortable with. If I had just a float array of ten elements, then how would I read this? I'll say that array is ARR is an array of ten floats. Okay, so this is how I would read it if I have a more complicated declaration like Cad star strings. Okay, so notice that the precedence for the square brackets is higher than that of the precedence for star. So this would actually be read as strings is an array of seven character stars. So that's how it would be read because seven would bind closer to strings. So strings will become an array of size seven. And what type is it? It's character star. So you replace float with character star and it's roughly the same phenomenon. So pictorially, you can think of it like this. So you have seven cells in strings and each entry is a character star. So each entry is a character pointer. You can think of it as a string, you can think of it as a character array, whatever. Here is the pictorial representation. Let's look at why we would need such a structure and what is the advantage of it. This is a very popular structure, almost as popular as two dimensional arrays themselves. So let us look at what it means for when we allocate character star, an array of arrays. So we may want to, let's say, store the names of several movies. And one of the things is that there is no maximum limit to the name of a movie. I mean, it can be as long as you want, it can be as short as you want. And suppose you want to store all of this in a data. So let's say that we have character star movies and I declare it as an array of arrays and it contains, the first array is don two, the second is Ravan, and so on. Okay, now how will we do this? So one way to do this is you say that movies is pointing to an array of arrays. So movies plus one is pointing to another character array, movies plus two is pointing to another character array, and so on. So this is how you pictorially represent it. There are three entries and each entry is a character pointer, so it can point to any character array whatsoever. And here you see the distinct advantage of this kind of representation over 2d matrices. Why? Because in 2d matrices the whole point was the number of columns was fixed. That's how the pointer arithmetic worked. Here, the number of columns in one row can be different from the number of columns in another row. So this representation is actually more useful when you have what are known as ragged arrays. That is, one row and the next row may have very different lengths. And here is a natural situation of storing strings when you need such a facility. So let us see what this means. Type of the variable movies is a pointer to, a pointer to character or character star, star. Now type of star movies is character star because you dereference one level. And type of star star movies is character. So let's look at it once more. So star movies has type, character, star. So in particular, star movies will be this array. It's pointing to this array. So star star movies will be, what is it? According to the general formula, this will be star of Star of movies plus zero plus zero. Okay, so this will be the pointer arithmetic version of accessing this cell which contains d. But instead you could also write movies. Similarly, in order to get to the last cell here, you could say Star of Star movies plus five. It's the particular application of the general formula. The second row will be star of movies plus one. Again, try to think in whichever notion you are comfortable with, because you can also write this as movies one. You will get the same result. So Star of movies plus one will come to the second row and you have Star of Star movies plus one that would come to the first element in the second row and so on. So Star of movies plus two would be the third array in this structure. And here is how you access different elements in the third array. So notice the picture is slightly different here. Even the representation suggests that these rows need not be contiguous in memory. So the location after this row ends need not be this row. So the second row can be located arbitrarily far away in memory. The advantage due to that is that these rows can be of different length. They are not packed as in the 2d array. So let's look at this particular thing in detail so that you get comfortable with it. So suppose you have that array, and I consider what is printf percentages? Movies two. Okay. Movies two will be the third character array that is present in the structure. So it will print crush three. Similarly, movies zero will print the first string. And if you say printf percentage as star of movies plus one by pointer notation, this is the same as the subscript notation. Movies square bracket one. So that will print ra one. Now what happens if you have put character, put car. Star of movies. Star movies plus one plus one. Okay, so again, if you are more comfortable with the subscript notation you can translate back into the subscript notation. This will become movies of square bracket one. Square bracket one. So what it will print is this letter which is small a similarly for the last one. So it will print, yeah, whatever, it will print the I. So here's error. Array of arrays now allows us to have a two dimensional structure with different number of elements per row and this is the advantage that it has. Now let's say that we want to write a very natural program, which is it takes a number between one and twelve and it prints out what is the month name corresponding to that number. So I want to store the months. And here is the problem. Different months have different lengths. We right now saw a solution to this problem which is to store arbitrary length strings in one structure. We would make an array of arrays. So you can say that characters are month names. So this is an array of arrays of character and then you can just initialize it to the month names. You do this and then I'll write the code. So you can write the code in any way. So you can say that zero is January and so on up to eleven is December. But maybe it's more natural to say that one is January and so on up to twelve is December. So I'll check. If the given month index is between one and twelve, then I will print the month name, month minus one. So if you give the month as one, you will print month names, zero which is January. If you give the month as two, you will print month names, one which is February and so on. Now if the month is not in this range, it's an invalid month. So you just print that and exit. So here's a very simple program which illustrates what advantage you get out of this kind of array of array structure. You can store within the same data structure different strings of completely different lengths. This is not possible in a 2d array because you have to calculate something like the maximum column length. So the maximum width month name, for example, it could be September. And then all the other names have to have exactly that width. So let's look at this. The array of arrays picture is like this. You have an array of character stars. Now each of those character stars may be pointing to different months. In this, every month is exactly three characters long. But you get the picture basically in this. These rows can be of different lengths. So contrast this with two dimensional arrays where the chief feature of a two dimensional array is the following. You have to specify the number of columns, so the number of columns have to be specified. And no matter what the exact string is. It will occupy seven characters long, so the remaining will be null filled or something. Okay, so also notice that pictorially I've tried to represent it. The very next memory cell after the first row will be the beginning of the second row. So after row zero it will immediately start with row one. Whereas in the case of array of arrays, row zero and row 1 may be located arbitrarily far apart in memory. The only connection is that the pointers to these rows are consecutively located in the array. In the pointer array, that's not the case here. It's actually located together in memory and it is represented in row major fashion where each row will take exactly seven letters. So I hope the limitation of the two dimensional arrays in this case is clear. So you can try a few exercises in order to understand this notation a little bit, this concept of array of arrays a little bit better. So let's look at the types of various concepts. So if I have month, month is actually a character star star, it's an address. So if you want to print out month, I mean, it's very rare that you need to print out month. You would use something like percentage Lu, which is long unsigned for printing the unsigned long int. What happens if you access star month? Now you are dereferencing one level below, so it will be a character star. So now if you print percentages star month, it will print January. If you print star star month, you have dereferenced two levels and you will get the first letter of the first array, which is j. And you can try out a few other things. You can say star of month plus one. So one way you can do it is you translate it to subscript notation and try to see what it will print. Okay, so I would encourage you to try out these examples in order to get the translation between arrays and pointers correct. So in comparison, the comparison between array of arrays and two dimensional arrays, on the one hand, individual array sizes can be different in the case of array of arrays. In the case of two dimensional arrays, all the rows must have exactly the same number of columns. So array of arrays is useful in a lot of string processing routines in representing graphs and things like that. But two dimensional arrays are more advantages when you deal with matrices because mathematical matrices typically have a fixed number of columns. So here is a wrong picture, but it sort of gives you an idea of how to look at these structures. So if I have int, array two, three, you can think of it as the number of rows is fixed and the number of columns is fixed. This is not actually what happens in c. In C, actually the number of rows does not matter, the number of columns matters. But you can for the moment, to make it easier to think about. Think that if you declare it in this way, this is when the number of rows is fixed and the number of columns are fixed. So in particular, if you know beforehand that your data structure has a fixed number of rows and a fixed number of columns, then it's probably better to use a 2d array. Now if you have instar ARR three. Now this means that ARR is a pointer to an array of size three. So here the number of columns is fixed but the number of rows is variable. You can have any number of rows. On the other hand, the third case, instar array three. So it is an array of three elements, each of type instar. So you can see that this is one situation where you have three pointers, but each of them can point to arrays of arbitrary length. So this is a situation where the number of rows can be seen as fixed and the number of columns is variable. And the general case can be in star star which is where the number of rows and the number of columns are both variable. So you can think of it in this way. This is not a correct picture, but when you want to model data, this is probably, and you know that you are in a situation where the number of columns is variable but the number of rows you know beforehand. Probably you should go for rafrs. If you are in a situation where you know that the number of columns is fixed but you don't know how many data there are, then you can go for instar array of size three. So you can go for the second alternative and so on. So this picture is not quite accurate, but it's indicative of the usage.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 47 File Handling.mp3,"In this video we will look at a few basic things about file handling in C. This is a vast topic in itself, and we will see just the basics of this. So let's begin by describing what of files. Now you would think that the most natural way to define what a file is, it is a set of bytes, a collection of bytes sitting in entry storage, like maybe your hard drive, maybe your CDROM drive or DVD drive or something. It's on a secondary storage device. But the actual description is that any addressable part of the file system in an operating system is a file. Now this includes extremely bizarre, strange things. For example, dev null. In Linux this stands for nothing. So if you write to dev null, it's like discarding the data. Similarly, devurand this is the random data device. If you read from here, you will get random data. Div audio is speakers, so if you write some data into that, it will be heard on the speakers and of course plain old data files. For example, in your home directory you may have homedown two input text. So input text is just a collection of bytes. So we'll not bother with defining what a files is, but it's something that can be manipulated using the file system interface. So you can open a file system interface to that file, you can read from that file, you can write into that file, you can close that file, and so on. Okay, now recall that in one of our earlier lectures I said that there are three files which are available by default to all C programs. So these are standard input stdin. This is associated usually with the keyboard, and this is where scanf getchar get s. These kind of functions get their input from. It has file descriptor zero. Similarly, standard output std out is where printf put car put s. All these functions output their data to. This is usually visible on the terminal on the screen. This has file descriptor one. We also have a third file which is known as standard error. This is the standard error console and it has file descriptor two. Usually you can print error messages to std err. We haven't seen how to print error messages to std err so far. We'll see that in this video. Now, how do you read input using standard file descriptors, but from sources other than keyboard and so on? So for example, if you are running a dot out and you want to take the input not from the keyboard, but from an input file, you can say slash a dot out less than input file. This says that the input is coming from the file, input file so this is the input file as the source instead of the keyboard, okay. Similarly, if you want to redirect, so if you want to redirect the output to a particular output file instead of the screen, you can say a dot out greater than out file. So this will use the out file as the output instead of the terminal. And if you want to output something, the error messages to error file, you can say a out two greater than error file two stands for the standard error console. So if you say redirect this to this file, you will say okay, the standard output should get the standard output messages and the standard error messages should go to err file. So Linux gives you some facilities to take input from other files using the standard input and the output. So what you say is that instead of the standard input you can use these less than greater than arrows in order to redirect input from some file or output to another file or error to another file. So this is the facility that Linux gives you. But consider the general situation. When you have a program you want to read the input from multiple files and maybe output to multiple files. So this is the general situation we just saw how to take input from one particular input file, how to output to another output file using the redirection operator. The less than and the greater than operation on Linux. So the redirection mechanism is provided by the Linux shell and is not part of the C programming language. So is there a way to do it in C itself rather than using the facilities of Linux? So can we read from other files other than the standard keyboard? Can we write into other files other than writing onto the screen? Standard output and so on. So we'll look at the general scheme of file handling in C. All these functions that I'm going to talk about are in STDA itself, so you don't need to include any more files. So if you want to open the file for reading or writing, et cetera, we need to first open the file. The three standard files, std out, std in and std err, are available to the program. Any other file you have to open the file and the function to do that is f open takes two arguments, name and mode. We'll see what these are soon. And it returns something called a file pointer. Now, file pointer is a pointer to a structure, and that structure contains a lot of information about the file. For example, where is it situated, the current position being read in the file. So maybe you have read thousand bytes and you are about to read the thousand and first byte. So it has that information and various maintenance information about the file. Now, in order to read or write into the file, you can use f scanf or f printf. These are the analogs of scanf and printf, which allow you to write to arbitrary files. It takes three arguments, at least two arguments. The first is the file pointer where you want to write the file, where you want to read from the file, and so on. And then there's a format specifier just as a normal scanf or normal printf, and then further arguments. Okay, so the difference here is that whereas scanf and printf started with the format specifiers, we have an additional file pointer in the beginning. So compare with the scanf and the printf. The first argument, fp, is missing. This is because canf just assumes that the file it has to read from is the standard input, and printf assumes that it has to print to the standard output. And to close the file. You say f close fp. And notice the way the f scanf, f printf and f close work. They don't take the file name as input, only f open takes the name of the file as input. Whatever f open returns the file pointer. Those are the arguments to fscanf, f printf and f close. Okay, this is because once a file has been opened, all the information that fscanf, f printf and f close need are already in the structure pointed to by fp. Now let's write a very simple program. This takes two files. It takes the names of two files and what it does is it first prints the contents of the first file and then prints the contents of the second file. And these will be output to the standard output. What is the algorithm? It's very simple. You have to first read the file names, then open file one. If open fails, we exit. Now if print the contents of file one to std out after you are done, you close file one, then you open file two. Check whether open has succeeded. If it has failed, we exit, then print the contents of file two to std out close file two and that's it. Okay, so let's see what each of these steps in slightly more detail. How do you open the file? We open it using a standard call called f open. F open takes two arguments, the name and the mode as character pointers, and returns a file point. The first argument name is the name of the file and the name of the file can be given in short form. Suppose you are already in a directory where that file is situated. Then you can just give the name of the files for example, input file. Or you can give the full path name of that file in the operating system. So for example, input file may be in the directory homedown. So in that case you can give the name ashome dawninput file. So this will be the full path name. Either of this is accepted. Now the second argument is the mode. This is the way in which you want to open the file. So what are the common modes? For example, if you give r, this will open the file in read only mode. This is if you want to just read a file and not write to that file. There are also other situations where the medium itself may not support writing. For example, if you have a cDrom disk, then you cannot write to that. So it can only be opened in a read only mode. If you give w, this is the write mode. Now the first write happens at the beginning of the file. So if the file already exists, it will be overwritten if a file does not exist. So this is the name of a new file that we support, commonly is known as the append mode. You specify that by saying the mode is a. So if you open the file for append mode, then instead of writing at the first location of the file, it will write at the end of the current file. So if the file does not exist, then it will start from the first location. If the file exists, it will go to the end of the file and start writing from there. So append does not overwrite the file. We have seen the arguments of f open, now let's look at what it returns. If successful, f open returns what is known as a file pointer. This is later used for f printf f scanf f close. As I just mentioned, if unsuccessful the file maybe you try to open a nonexistent file for reading, or you try to write to a file which cannot be returned to. For example, it's a file sitting inside cdrom drive and you are not allowed to write to it. So if you try to open the file in write mode then you have a problem. So for whatever reason, if the file open does not succeed, then the fopen returns a null. And it's always a good idea to check for these errors. So just try opening a file and always check whether it has returned a null. So let's write the program that we were discussing, which will take two input files and print one file and then print the other file. So the program is fairly simple. We have a main function. You have two file pointers, fp one and fp two, and then two file names, file name one and file name two, you get the file name one from the input. You get file name two from input using get s functions. Now what we have to first do is write the contents of the first file. So try opening the file. So if fp one equal to f, open file name one r because we just need to read from the file, we don't need to write into it. So open it in r mode if it is successful, that is if it is, or rather if it has failed. So if it has returned a null, then you just say printf that it has failed. And here is for the first time we are seeing how to print to the standard error. Okay, since stder is any other file similar to any other file, you can just say f printf std err and then opening file failed file name one so we tried to open file name with file name one as the name, but there was some error. So you print that to the error terminal which is std err. Now once you do that, we'll call the function copy file fp one to std out. So here is a function that we will write which will copy from a source file to a destination file, and what it takes are pointers to those files. Once you are done, you close the file one and then you repeat the whole process, exactly the same process for file two. So try to open it. If there is an error, you print the error message to std err, then copy the file from fp two to std out and finally close the file. Once you are done, you can return from main. So now what is left is what is this copy file function? So let's look at the copy file function. Now there are two ways to start writing any function which takes files as arguments. One is you can take the file name as the argument itself and within the function try to open the file. Okay, so you'll get a file pointer and you can start reading from the file using fcanf and writing to the file using f printf. This is possible. It is somewhat more convenient to say that I assume that the files are already open and I'm getting the file names as the pointer using file pointers. So this avoids duplication of work. The main doesn't have to open the file and then every function has to open the file again and again instead. What you can just say that I assume that the caller function has already the file open and I'll just take the file pointer as the argument. So let's look at this function. It's a void function, so it doesn't return anything, it just performs an action. Its name is copy file takes two arguments from fp, which is a file pointer to the source file and to fp, which is file pointer to the destination file. And what does the function do? We have a character c. And here is a function we'll see in a later video. But right now it just checks whether from Fp has encountered enter file. So feof just tells you whether you are done with the from file. So if you are not done with the from file, what you do is you scan one character from the from file. So f scanf from fp percentage c and c. So this will read one character from the source file from FP and read it into the variable c. Now what we have to do is to print that to two fp. So you say f printf two fp percentage c comma c so this is exactly like scanf and printf, but taking one extra argument. So in the case of scanf it just says what is the source file? That is the file pointer argument. In the case of f printf you have to take the destination file which is two fp. That is the extra argument and that's the function.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 48 Some other file handling functions.mp3,"In this video we will see some more common file operations. These are by no means the only file facilities that c provides you, but in common programming practice, these are the functions that people often use. So we have seen this in the code that we wrote. The first function is Feof and then it takes a file pointer. What it does is it checks whether you have encountered end of file while operating on Fp. So maybe you are trying to read the file and you have already reached the end of file. So if you have already reached end of file, that is, if Eof is set, then feof returns a non zero value. If feof is not set, that is, you have not completed the file yet. By seeing end of file, then feof returns zero. So in order to check whether a file still has some data, you can just say not of feof fp. That will check for the fact that the file still has some data. Now another useful file function is f error. Okay, so the f error function. What it does is it takes the file pointer fp and checks whether you have encountered some error while reading the file. So error may be of many kinds. For example, you are trying to write to a read only medium like CD. Or maybe you are trying to write to a file system and the file system is full. Okay, you are trying to write to a hard drive and the hard drive is full. So then you might encounter an error. So there are various errors that you encounter in file operations and f error checks for some of these errors. So if the error indicator has been set for Fp, then frro returns a nonzero value. Otherwise it says zero. Now here are some couple more interesting functions. They're very useful and quite commonly used whenever we deal with files. For example, we can have something called fseq. Now Fseq is a function which allows you to start reading from or start writing to arbitrary locations in the file. So often we may want to read into the 10,000 python directly, and we don't want to be bothered with reading the first 9999 characters, discarding them, and then coming to the 10,000th character. This may be a lot of wasted time. It would be more convenient if I can directly jump to the 10,000th location in the file. So is there a function that allows you to do that? Yes, there is this thing called fseq. Now what it takes is the file pointer, and it takes two arguments. One is known as an offset and the other is known as the origin. So let's look at the offset and the origin in greater detail. Okay, so suppose I want to read from the 10th byte of the file, so I could say fseek. And suppose my file pointer is fp. I'll just say, let's say I want to read from the 10th point, from the beginning of the file. What I can say is seek set. Okay? So if I do this, what will happen is that it will start from the beginning, okay? Seed set is the beginning of the file. So it will add ten bytes from the beginning of the file and it will start from there. So if I know that I want to read from the 10th byte, then I can say that start from the beginning of the file. Seekset says origin of the beginning of the file plus ten bytes. Okay, so this is ten bytes from beginning. Now, there are other situations. For example, you might want to say that I want to start from the 10th byte from the current location. I've already read many bytes. Now I want to skip the next ten bytes, okay? So is there a way to do that? Again, what you can do is if you say f, seek fp, and let's say ten itself, but seek current. So there is a typo here. This is just C-U-R. So if I say this, then what I need to do is what it will perform is it will say ten bytes from the current position. So I've already read 100 bytes from the file. And then I say fSeq, ten bytes from the current location. What it will do is jump to 110th location. Okay, now I could also say something like, okay, so here is a very common situation. I want to start reading from the 10th byte from the end. So I want to, regardless of the size of the file, I want to jump to the end and then rewind ten bytes and start from there. So in that case I can say the origin is seek end, that's the end of the file. And where do I start from? Seek n plus something does not make any sense because it will refer to something that doesn't exist in the file. So you could say c ten minus ten. So this is ten bytes before the end of the file, okay, so you can use fsec in several ways. And it's a very convenient function because it allows you to jump to arbitrary locations in the file. And it will work as long as the target location, origin plus offset is a valid location in the file. Now there is also something called ftel, which will tell you the current position in the file. So it will take a file pointer as the argument fp and it will return you where in the file you are currently at. So with this, let's take a look at a few more modes in file operations. So when you open the files, we saw that you could open it in mode RwA. Now there are also some other special modes that c gives you. For example, there is something called r plus. This says you can open a file for reading and writing. So this is essentially an update mode. W plus will be write and update. So create an empty file and update that file. And there is something called a plus which is append and update. This is somewhat strange. If you do any fseq after you open the file in a plus mode, then the read will be affected. Okay, so suppose I am at the hundredth location, I've read 99 bytes, I'm at the hundredth byte. If I now do an f seek to ten bytes ahead. So now I will be at the 110th byte. Now there are two possibilities. Now I can read from here, or I can do an f printf. F scanf will start from the 110th byte. It will obey the fseq. F printf will always print at the end of the file. Okay, so that's the append part of it. So f printf is always, output is always at the end of the file. And reading will be dependent on any fseq that you do. So fseq will never affect where you print. It will always be at the end of the file. So a plus is a very special mode. These are some additional file operations that you might find useful while coding in C.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 6 Operators.mp3,"So far we have seen comparison operators like less than, equal to, less than, or equal to, and so on. We will see a bunch of a few more operators in this session. Okay, so let us consider the modulo operator, which we have already seen when we discussed Euclidean GCD. So a percentage b be gives the remainder when a is divided by b. Okay, so suppose we have the following problem. We get a number a, and we want to check whether the given number is divisible by six. If it is divisible by six, a modulo six will be zero, right? The remainder will be zero. So we'll write a simple code. You have inta Asf, type int, then scan the number using scanf percentage d and a. And then you test whether a is divisible by six. To test whether a is divisible by six, you check whether a mod six is zero. If it is divisible, you say that input is divisible by six, percentage d a. Otherwise, else printf the input is not divisible by six. Okay, a very simple operation. Now let's make it slightly more elaborate. Suppose you have to test whether this is slight variant. Suppose you have to test whether a given number is divisible by six and by four, two numbers. Okay, how do you do this? So you scan f the number, and you test whether a is divisible by six. So a modulo six is zero. If that is true, then you also check whether a modulo four is zero. Okay, if both are true, then you print that the given number is divisible by six and four. So percentage d is divisible by six and four a. So you can argue about this program and see that if it is divisible by six but not by four, then it will enter the first if but not enter the second if. Therefore, it will not print that it is divisible by six and four. Similarly, if it is not even divisible by six, it will not even enter the first if condition. So you will in any case not print that it is divisible. So convince yourself that this particular code will print. A number is divisible by six and four if and only if the given number is divisible by both six and four. Okay, now that piece of code was slightly long. Is there any way to write the same code with a fewer number of lines? And for this, c provides what are known as logical operators. Now, there are three logical operators in boolean logic, which are Boolean and Boolean or and Boolean not. Okay, so there are three logical operations and or and not, and c provides all of them. So the same if condition that we wrote before, we could have easily said if it is divisible by six and if it is divisible by four, then print the output. Right. So for this, c provides an operator which is the Boolean and operation. So the Boolean and operation in C is given by two and by now you should be familiar with the fact that certain operations in C have repeated characters. For example, we already have seen the equality operation which was equal equal. Similarly, the Boolean operation and it is actually the and symbol on the keyboard, but you have to have two of them that represents the logical. And so this expression says if a modulo six is zero. So this expression is what tests for a is a multiple of multiple of six. And this is the expression which tests whether a is a multiple of four. Okay, so if both conditions are true, then you say that the given number is divisible by six and by four. Okay, so consecutive ampersand signs, that is the and symbols without any blanks in between, is the c operator corresponding to the mathematical and the logical and function. Okay, so it takes two values as input and returns a zero if any of the values is zero. If both values are one, then it returns a one. Okay, so this is the same as the logical and if either of them is zero, then the result is zero. If both of them are one, then the result is one. So the truth table for the operation and is as follows. If a is a nonzero value and b is a nonzero value, then c considers that both are true. So the output value is of a and b is one. If a is zero and b is any value at all, the output is zero and b is not evaluated. So this is the same as the logical end. The only thing to note is that if in evaluating a and b you already know that a is zero, then you know the result is zero. Okay, so c will not bother to evaluate b because it knows that the result is already zero. Okay, every expression has a type a and b is of type int, regardless of the value of, regardless of the types of a and b. This is because a and b is a logical assertion. The type of a logical assertion is that it is either true or false. It corresponds to a boolean value. Therefore, the type of an a and nb, regardless of what a and b are, the result is always zero or one. So it is of type int. Now you can print the result as an int. You can say printf percentage d a and n b now, there are three logical operations, as I mentioned. So there is also or in C, it is denoted by two vertical bars which are there on your keyboard. So a or b, which is a bar bar b, evaluates to nonzero. If either a is nonzero or b is nonzero. If both of them are zero, then the result is zero. So this is the meaning of a logical or operation. If both of them are false, then a or b is false. If at least one of them is true, then a or b is true. Okay, so you can write the truth table for that. If a and b are zero, then the output is zero. If a is nonzero and b is any value, then you already know that the output of a or b is one. Okay? So the output is one and b will not be evaluated. This is similar to in the case of and if a was zero and b was any other value, then you know that the output of and is zero. Therefore, b will not be evaluated. Similarly here, if a is nonzero, then you know the value is one, so b will not be evaluated. And as before, a or b is of type int. So the third logical operation is not. Okay, now, not in C is denoted as the exclamation mark. So, let's see an example of that. So not is the logical complement and it takes only one argument. This is different from the previous two that we have seen. A or b and a and b both took two arguments. Each not takes only one argument. So, it is called a unary operator. So, not of a is an expression of type integer, and the value is the negation of a. So if a is zero, not of a will be one, and if a is not zero, then not of a will be zero. Okay, so for example, if I want to say that a is not divisible by three, I will just write not of a mod three equal to zero. You know that a mod three equal to zero tests for a being divisible by three. So, negation of that, it will say that the given number is not divisible by three. Okay, let's finish this by slightly complicated example, which is that of leap years. Okay, so, I am given a particular year number, and I want to say whether the given number corresponds to a leap year or not. Now, what is a leap year? It's that you add a few years will have February 29 in February. All other years will have 28 days in February. So what is the logic of a leap year? So, roughly, an average solar year is 365.24, 2375 rotations okay, so in particular, it's not an integer. So we normally say that a year has 365 days. That's not quite true. It's a rounding. So how much are we losing? So you can calculate it as follows. The remaining number after, the remaining number after the decimal point is roughly 00:25. Okay? So at a rough cut, let's say that every four years, because of this 00:25 you will lose one day. So every year you are losing about a quarter of a day. So every four years you will add a day. Okay? Now when you do that, you go back to just a minute. So you have 365 point, let's say 25. So every four years you would lose four years. You lose about a day, approximately one day. Okay? So in order to compensate for that, you add one day every four years. Okay, so in 100 years you would have added 25 days, right? But that is one day too much because remember that this number is only 365.24 something. So in 100 days you should have added only 24 days. But now you added 25 days. Okay? So to compensate for that, every hundred years. So every hundred years, skip adding the extra day. Okay, so every four years you add one extra day. But every hundred years, every hundredth year, you don't add that extra day, you skip it because you would have added one more day than you. And then again, you can look at what remains. What remains is also roughly 00:24 which means that every 400 years if you do this adjustment, you are losing about a day. Because every hundred years you are losing about quarter of a day from this .2375 part. So you do the same logic again every 400 years. So every 400 years add an extra day. So this is the logic of the leap year that we all know. So how do we decide whether a year will be a leap year? Okay, so the logic that I have outlined just now says that if a year is a multiple of four, then it's a leap year. But if a year is a multiple of 100 as well, then it is not a leap year. But if it is a multiple of 400, then it is a leap year. So here is a pretty complicated expression. So every fourth year is a leap year, but skip every 100th year unless it is also a 400th year. And you can write this expression in c. It's slightly complex, as you can imagine. So if the first line, the first expression says that year is a multiple of four. So if year is divisible by four, also the following should be true. It should not be a multiple of hundred unless it is a multiple of 400. So it should not be divisible by 100. That should be true. Or it should be true that it should be a multiple of 400. For example, if you have 400 then it is a leap year, okay? So what will happen is that year model of 4400, model of four is zero. Then what happens is that you have 400 modulo 100, that is zero. So this is equal to zero, that is one, not of one is zero. So this part is entirely zero but it is divisible by 400. 400 divided by 400 is zero. Therefore this part is true. This or zero or one is true. Therefore the whole expression becomes one and one. So it is true. So this logical expression, slightly complicated logical expression encodes the logic for saying that the given year is a leap year. So try this out yourself. This is a slightly tricky expression. And convince yourself that this exactly encodes the logic of a leap year. Okay.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 7 While Loop   1.mp3,"In this session, we will look at loops in the C programming language, and we will start with a very basic kind of loop, which is known as the while statement. So the general form of a while statement is similar to that of an if, which is that there is an expression, and you say while that expression, then do the statement you. So the flowchart corresponding to the expression will be the while expression will be. You test whether the expression is true or false. If it is true, you do the statement. If it is false, you exit out of the loop and execute the next statement outside the loop. So if the expression is true in C, that is, the expression is nonzero, then execute the statement and go to the step outside the loop. If it is false, then directly go outside the next statement after the while loop. This is similar, if you recall, to the if block without the else. So loops are a new thing that explicitly there was no loop construct in a flowchart. We just had this way of going back to the expression. But in programming languages, loops are such a basic programming need that in addition to the if block, you have a loop construct as well. Okay, so a slightly different variant of the while expression will be that while expression statement one and then statement two. Okay, so the flowchart here is easy to follow. So you first test whether the expression is true. If the expression is true, then you execute statement one, and then after you execute statement one, then go back to the expression. If the statement is false. If the expression is false, then you go to statement two. So while the expression is true, execute statement one, and if the expression is false, then execute statement two. So the difference in the if condition will be that if this was an if block, then if the expression is true, you do statement one, and you exit out of the while loop. And that is not done. In the case of a normal while loop, after you execute the statement, you go back to the expression. So as long as the expression is true, you keep executing statement one, and if the expression becomes false, then you execute statement two. So, let's illustrate the use of a while loop with the help of a program. So, we will introduce a very simple problem, which is read a sequence of integers from the terminal until a minus one is encountered. So minus one signals that the input is at an end. Now, what I want to do is that sum up all the numbers until the minus one and output the sum. So it's a very simple program. What you have to do is to read a sequence of numbers until you hit the first minus one, and then add these numbers and output their sum. So let's first introduce a very simple loop, which will do only the basic thing of reading the numbers until a minus one is encountered. So how do you write the loop? You have stdio h, and then you declare an integer variable and read the variable. Okay, so this is supposed to be the first number. If that number is minus one, then you don't have to read any more numbers. Okay, so if the number is not minus one. So if a equal to minus one is false, then you read one more number. Okay, after you read one more number, you don't finish the loop. You go back and test whether the loop condition is still true. Okay, so you go back and check whether the second number you read was minus one or not. And then you keep on reading it until you hit a minus one. At some point when you hit a minus one, you go back to the loop, and the condition that a equal to minus one will be true. So not of that will be false, and you will exit the loop. Okay, so read the first number. If it is minus one, don't enter the loop. Otherwise, keep on reading numbers until you hit a minus one. That is the meaning of the while loop. So let us just trace the execution of the loop on a sample input to understand how it works. So in a box, I will represent the memory location a and its current content. So I run the program after compiling a dot out, and let's say that I enter the number four, okay, now you scan the number four, so memory location a becomes four. Now four is not minus one, so you enter the loop. Let's say that the next number is 15. You read the number into a. So memory location a is now 1515 is not minus one. So you again enter the loop. You enter minus five. Minus five is not minus one, so you enter the loop again. Okay, at this point, you scan the number into a, and a becomes minus one. So you go back to the loop again. And now the test that so a equal to minus one so not of that is false. So the while condition becomes false. At this point, you exit the program. So this is a very simple part of the program that we want to write. Recall that we want to read a bunch of numbers and sum them, and the end of the numbers is represented by a minus one. Until now we have just read those numbers.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 8 While Loop example.mp3,"Okay, so in this session, we'll continue the program that we were writing. Recall that we were writing a while loop, which will read a bunch of numbers and is supposed to sum them up until you hit a minus one. In the loop that we have seen so far, we just read the numbers until a minus one was encountered. So let us now complete the program and compute their sum as well. Okay, so for computing their sum, how do we normally do it? We will add numbers two at a time, so the first two numbers will be added. Then that sum will be added to the third number, and so on until you hit a minus one. Okay, so let us try to do that in the course of a while loop. What I'll declare is, I'll declare a new variable s. So here is the new variable s that I have declared. S is supposed to hold the sum of the variables that I have read so far. Okay, now it is very, very important that when you declare a variable, you should initialize them properly. In the case of a, we did not initialize it because we were reading the first number as soon as a was declared. But in the case of a sum, you would use s to maintain the sum as you read numbers. So it is important that you start with s equal to zero. So the initialization step marked by this arrow is quite important. If you do not initialize it properly, then the sum may not be correct, as we will see soon. So, you keep a variable s, which is supposed to hold the sum of n numbers, sum of these numbers, and initialize the sum to zero. Then the difference from the loop that we have seen so far is highlighted in red. So, earlier, recall that we were reading the number, and just testing whether the number is minus one. If it was not minus one, you read one more number. So that was the loop. Now, inside the loop, what we will do is we will keep a running sum of the numbers that we have seen so far. So initially, s sum is initialized to zero. Then if the first number is not minus one, you add the first number to s. So s will now be the first number. Now read the second number. If the second number is not minus one, you will enter the loop again. So you will add the second number to s. So s is now first number plus second number. And this keeps on going until you hit a minus one in the input. So let's continue with this. Let's try to trace the execution of this program on a sample input and try to understand how it works. Let's say that I compile the program successfully and run the program. Okay, so I run a dot out, and as before, let the first number be four. So, after initialization, when you declare the variable a is undefined and s is also undefined. After the initial statement s equal to zero, s is now zero. And then you scan the variable a. So, a becomes four, because four was the input, and sum is still zero, you enter the loop, and you say s equal to s plus a. So sum becomes zero plus four, which is four. And you read the next number. Let's say the next number was 15, so a becomes 15. A is not minus one. Therefore, you enter the loop again, and sum is now four plus 15, which is 19. So sum, at any point of time is the sum of the numbers that we have read so far. So we have read four and 15. So the sum is 19. Now you read the next number. Let's say the next number was minus five. Minus five is not minus one. Therefore, you enter the loop again, s equal to s plus minus five, so s becomes 14. Then you read the next number, and let's say the next number was minus one. So, since the number red is minus one, you go back to the loop, and this condition becomes false. Okay, so you exit out of the loop and then print that the sum is, let's say, 14. And when you verify it by hand, you would see that four plus 15 plus minus five is 14. Okay, so the program has executed correctly. The important thing to note is that the final minus one is not summed up. Okay, so it is used as the end of the input, and you should not compute the sum of the numbers including minus one. Minus one is excluded and the program executed correctly. We'll introduce a few terminology associated with the notion of a loop. Each execution of a loop is known as an iteration. Okay, so in the above loop, when the input was 415 minus five minus one, the loop runs for three iterations corresponding to the inputs 415 and minus five. Okay, so for input minus one, the loop is broken, so you don't enter the loop. So you don't count an iteration corresponding to minus one. So you entered four numbers, including the minus one, and the loop executed three times. So you say that the loop had three iterations. So this is a technical term associated with loops. And here is a concept that I will introduce to help you argue about the correctness of a loop. So, there is a notion known as a loop invariant. Now, a loop invariant is a property relating values of the variables that hold at the beginning of each loop. Okay, so that's a bit abstract. Let me just illustrate with the example that we just saw. So, loop invariants are a good way of thinking about the correctness of the loops that you have written. So, in our program, what will be the loop invariant? Let's look at the property that we are interested in. There are two variables in the program, s and a, and both of those variables are involved in the loop. But the interesting property that we have relates to s. What is the property that s holds with respect to the loop? So we can see that s holds the sum of all values red so far, except the last value. Is that true the first time that we enter the loop? Yes, because s was initialized to zero and you had actually read the number. So it is true that s holds the sum of all values except the first one. So that is true when you first enter the loop. And at any point when you enter the loop, you sum the last value that was read, and read one more number. So you will see that s still holds the sum of all values read so far except the last one. So this is the loop invariant in the program, and loop invariants help you argue about the correctness of the loops. Okay, so if the loop invariant is correct and the program maintains the loop invariant, then the value of s, when the program stops, will be correct. Okay, why is that? Because the loop terminates because the last value, red, was a minus one, and the invariance says that s holds the sum of all values except the last value. So this means that s holds the sum of all numbers except the minus one. Therefore, when the program ends, that is, you exit out of the loop, s holds the sum of all numbers that you were supposed to add. So here is how arguing about a loop invariant and seeing whether loop invariant holds in the loop that you have written helps you argue that the program is correct.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Lec 9 While Loop example   GCD.mp3,"You. So we will see a few more examples, because loops are really important. Let's go back to the first problem that we discussed, which was the problem of computing the greatest common divisor of two numbers. Okay? Two positive numbers. So the problem is to read the two numbers, find their GCD, and compute the output. Now, we had a flowchart of the problem based on the fact that if a is greater than or equal to b, then GCd of a comma, zero. If b is zero, then GCd of a comma, zero is a. Otherwise, GCD of a comma, b is the same as GCD of b, comma, a modulo b, but a modulo b is a percentage. B is the reminder when a is divided by b. So let us now try to write the program in C using a while loop. So, we have to do a few preliminary things. So let's call it the first half of the program. In the first half, I declare three variables, ab, and there is another variable, t, whose need we will see right now. But let's say that I need an extra variable for now, let us just take it on faith. So, what I'll do is scan two variables, a and b. Now, recall in the GCD equation that we saw right now, we assume that a is greater than or equal to b. Now, what if the user is unaware of this condition and entered the lesser number first? So, he just entered the numbers in such a way that a is less than b. Okay, so we need to correct that. We need to make sure that a is the greater number. So we need to exchange the values of a and b. If it is true that a is less than b. Okay, now how do we do this? So, the first thing to note, to try will be to say that. For example, if I say that, let's say a was three and b was four. And suppose I just said a equal to b. I want to exchange the values of a and b. I just said a equal to b and b equal to a. Okay, what will be the effect of this? Note that this is the assignment statement. So after I execute this line, b is four. So a will be four. A equal to b results in a equal to four. Right? Okay, after the execution of this line. So what, the situation that we will have is that b equal to four and a equal to four, and we will have no memory of what was the original value of a. That is lost, right? So it is just simply lost. So this idea that we can exchange two values by just writing a equal to b equal to a does not work. So what is the correct way to do it? Okay, so we have an idea known as the cyclic exchange. And this is a really neat idea. The idea is that, how can I motivate it? Let us say that you have two rooms, and these two rooms are full of stuff. And I want to change the contents of the first room to the second and the second room to the third. Okay, one way I can do it is that I'll move the contents of the first room to a different room. So have a temporary room, and then copy the contents of the second room to the first and copy the contents of the third room to the second. Okay, so this is a very nice intuition, and it almost is similar to what we need to do. So we have two variables, a and b, that we need to swap. So one thing we can do is I'll keep a third variable, t. First. What I will do is I will copy the value of a to t. So now I have a backup copy. Now then I will say b equal to a equal to b. So at this point, the value of b will be copied to the a. So now a is six. B is six. But still we have a memory of what was a before, because the old value of a was stored in t. So in order to complete the routine, all you need to do is to copy the value of t to b. And that can be accomplished by the equation, by the assignment statement, b equal to t. Okay, so this idea is known as cyclic exchange. So recall the physical intuition of swapping the contents of two rooms, which are almost full. Okay, you have a third room, and you move the contents of the first room to the third room, move the contents of the second to the first, and move the contents of the third to the second. Okay, so this is similar to what we did. In the case of physical contents, we cannot copy. In the case of variables, we can copy. So now let us complete the GCD program. We have just done the first part of the program, which is to ensure that a is actually the greater number. If it was not the greater number, you swap, or exchange. After exchange, we have ensured that a is greater than or equal to b. Now we have to write the main loop for the GCD function. So just by translating that flowchart, what we will do is, while b is not zero, what you do is you say that store the value of a in t. Assign a to b, a equal to b, and b becomes t modulo b. Okay? Recall the equation was written as follows. Recall that the equation was GCD of ab is the same as GCD of b, a modulo b. Okay? So when you assign a to b, the old value of a is lost, and we can no longer do a modulo b. So the way to do that is you use the idea of a temporary variable, store the old value of a in t before you do a equal to b, so that finally a model of b can be done by t modulo b. I don't want the new value of a. I want the old value of a. So let's just trace the execution of this program. Let's say that I scanned two numbers, a and b, and the user was correct in entering it. So he or she entered the greater number first. So we have 16 and nine, a equal to 16, b equal to nine, and t is undefined. Okay? So after you read the numbers, you just say GCD of. After this, you enter a message, which is print a message, which is that GCD of A and B is. So GCD of 16 and nine is. And then you enter the loop. Okay? So in the initial execution of the loop, you have t equal to a, which will store t equal to 16. A equal to b, which is a, will become nine. But you want to compute the model 16 modulo nine. But 16 was lost in a because a is now nine. So you have to do t modulo b. So 16 modulo nine, which is seven. Okay? So you go back to the while loop, and then you see that b is not zero, b is seven. So you enter the loop again. T is equal to a, so t is nine, a equal to b, so a becomes seven, b becomes two. Again, b is not zero. So you enter the loop again, so t is seven, a equal to two, and b equal to one. Again, you enter the loop. B is not zero, t is two, a becomes one, and b becomes zero. At this point, you exit the loop, okay? And at this point, the a that we ended with is the GCD of these numbers. So 16 and nine are relatively prime. Therefore their GCD is one. Now, let's think a minute about what is the loop invariant in this program. What is it that we have a central while loop, which computes the GCT. What was the invariant in that loop? So, for this, I'll just introduce a slight notation which makes it easier to discuss these invariant. So, let capital a and capital b be the original numbers that I input. And little a and little b represent the numbers which are involved in the loop. Okay? So capital a and capital b were the original input, and the invariant that I have is that at every stage, the GCD of the original inputs are the same as the GCD of little a and B. Recall that little a and b are the loop variables involved in the loop. So little a and b keep changing through the loop, whereas capital a and b are fixed. They are the input. So the invariant that I have is that every time you enter the loop, the GCD of the input were the same as the GCD of the variable. Now, this guarantees the correctness, because when you exit out of the loop, you will correctly compute. You exit out of the loop because b equal to zero. And by the original equation, you know that when b equal to zero, a is the GCD of a and B. So this guarantees correctness. Now, you could also ask other questions, like how many times has the loop run? And this question is a bit complicated because you have to compute it based on the input numbers. So such questions are of interest to computer science. But we will not go into computing the efficiency or the performance of this code. But it's also a very crucial question.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Linear Search.mp3,"So we are looking at computing standard deviation. So, standard deviation is mean. We have seen. Now, standard deviation is, if the mean is, suppose the mean is represented by mu, then I take the sum of the deviation from the mean for every element of the array. So the array was a, with every element being called AI. So what I am trying to do is I am taking the difference of AI from the mean. And since the difference can be, suppose there are some values and this is the mean, and the value can be a little away from the mean on this side, more than the mean or less than the mean. So we take the square of the mean, square of the difference, and I do that for all the elements, I equals one to n, right? And then I take the square root of the whole thing. That is my standard deviation, okay, other my variance. So I can compute either this or this, whatever I like. So you will simply understand that in the code that we have given a little earlier, then there we had computed the mean. That means mu has been computed, which was the average that we computed last time. So if I have read the elements in an array, whatever the elements are, 5732 and I've computed the mean, mu has been computed. Mean is twelve. 315, 17 divided by four. So it is four point something. 4.14.25. Right, that's my mean. So now for every element, again in this array, I find out, for I assign zero, I less than equal to three, I plus plus. What do I do for every element? I've got the mu, and let's call it average. Right? So sum was zero. What does it look like? Sum was zero. Sum will be. Now sum plus. I'm getting sigma of mu minus AI, whole square. So sum plus average, minus AI times average minus AI. All right, so that is the square. Average is mu minus AI. So I'm doing this square, and I'm repeatedly doing this and getting the new sum. And at the end of this loop, therefore, I've got this. So I can say std dev, let me call it standard deviation is square root of the sum. All right? In that way, I can find out the standard deviation also. Now let's come to the, now, what is the application? What is the meaning of this? So with these, say in a class, you are supposed to write a program where you want to find out, say in a class of physics, what is the average of the numbers of all the students? So I'll find out the mean and mean of the class marks. Right? Similarly, I can find out that, what is the standard deviation? How much did it Vary that also I can find out. Now let's look at this new another problem. Say a shop stores n different types of items. N different types of items. Now given the number of items of each type sold during a given month and the corresponding unit prices compute the total monthly sell. So what is the scenario? The scenario is this. I have got say five items, item one, item two, item three, item four and item five. And let me call it the item. Let me call it on this side. Let me call it. This array is item price, item cost. Item cost. Suppose the cost here is seven and a half rupees per item of type 00:25 for item of type one. This is zero. This is one, this is two, this is three, this is four. So the item cost for this for item of type two is 12.5. Item of type three is ten. Item of this is item of type four is rs50. Now I want to store how many items of each type has been sold. So I take another array and call it items sold. Suppose five items have been sold of type zero, six items here of type one, two items of type two, four items of type three and two items of type one. Now my question is what is the total cell? So what should I do? You can easily understand that here is the item cost. So I have to multiply this with this, this with this and add all these costs. So it will be 7.5 times five. It will be 7.5 times five plus 25 times six plus so on and so forth. In that way I can find the total cost. So what will the program look like? The program will look like I'll be needing two arrays. Item cost and item sold. And they should be of the same size. Assuming that I know beforehand that there are five items. So I can start with item cost of type five. But this will be cost will be of type float and there will be another. The number of items is items sold. The number of items sold is integer. So I will have this. I am not showing the part that here I'm reading the two arrays. So after I read the arrays I'll have two arrays like this. One is an integer array. Another is a floating point array. This is a float and this is an integer. Now my actual body of the program will be in a loop for. See I'm doing it using for say I assign zero I less than equal to four since the size is five. I plus plus. And what do I do here? What do I do in the body of the for loop I take. Okay, actually only one statement will do there's no harm in putting this bracket. Total cell, which was a variable of type. Float total cell is total cell was initialized to zero. Total cell plus item cost I times multiplied by item sold I. So this will be done in a loop. And so I'll take the first item, item cost zero, multiply with that, with item cost, item sold zero. Add that with the total cell, which was initialized to zero. So here I can have float total sale initialized to zero 0.0. All right, I can do that. So now I am doing it in a loop. So first I multiply these two, add it to total cells. Next, again, in the next iteration, I is incremented. I take these two and multiply them and add it to the total cell. Then I do these two and multiply them, add it to the total cell, and I go on in this way, in this way, by using this array, I will be able to add all these values and I'll get the total cell at the end. So here we could see two very nice examples of application of arrays. Okay, now another problem that I gave you is while comparing the arrays, you can do it in multiple ways that there was two arrays. You must have solved it by now that there were two arrays like this. 7755 here, six here, four, but again three, three. So everywhere they are matching but intermediate, they were affected and I had a flag value. So flag was initialized to one and then in a for loop. Then in the for loop I was checking this was a and this was b. Flag was initialized to one. If AI is equal to bi, this I can do because here I am doing it element wise. Then flag equal to one, else flag equal to zero and I can do exit and I come out of the loop straightway. I come out of the loop because it doesn't really matter at which position the mismatch occurs. As soon as a mismatch occurs, I can say that flag is zero. And so I come out. So when I was comparing this, whenever I find a mismatch, the flag will become zero and it will not be reset to one. Again because of this match, because this part is not being computed, I need not compute it, I need not compute it, because my objective was to see if the two arrays are equal. And here the violation has already occurred, so they are not equal. Okay. However, so that is one way you can try it with while loop. Also you can try with while to solve the same problem. Another point is here that time and again here. Everywhere I'm setting the flag to one. I could have changed that also here, if what did I need to do? I go on. I have set flag to one and the condition I simply change. I just change the condition. If AI is not equal to bi, then make flag zero exit. I could have done this. As long as this condition is not holding, I am going on doing the loop. Is it clear? I'll go on doing the loop as long as there is no mismatch. This condition means mismatch. As soon as there is a mismatch, I'll set the flag to zero and exit. This is another way of solving the problem. So you have to think logically, what exactly you need to do and what exactly you are writing, what is the flow and what is happening with the variables. And I always suggest that you have small pictures of the different variables and see how they are changing in the course of running the program. Okay, now, so we have seen a useful commercial, so called toy commercial problem that how I can find out the cost of total sales or monthly sales. Okay. And here the number of items sold per month are given, then you can do it. Okay, well, next let us look at a very important thing called searching. Searching is a fundamental task in any, and in fact in many computations. In many computations we need to search. What do we search? There are different types of searches, but we'll be now talking about the simplest possible search. That is, we are trying to find out whether a particular element is there in an array, right? So the purpose is to check if a given element, which is known as the key, is there in the array or not. We will first talk about the array is not arranged in any order and we'll do that. So suppose I ask the question that is there any even number in the set of numbers given. Suppose there are some numbers given, 572-9183 like that. I want to see. And suppose this is a huge, this is a list of hundred numbers. I want to find out whether there is any particular number. Forget about even number. For the timing. For the timing, let's assume that I want to see whether in this list any four is there. Is there any four in the list? That is the question that we are asking. The answer can be either yes or no. If it is yes, then the next question comes where in the list is it there? Is it where means in which position it is there? I may ask like to know the position or I may not like to know the position. I'd be satisfied to know whether this list contains, contains any four or not. All right, so 572-9183 so again 572-9183 and my key is four because I am interested in the existence of four. So instead of writing the c which you will be writing, I'll be discussing how to approach this problem. What would the pseudocode be? And I'm sure in the assignments in your practice you can write the program. So I know I need to know beforehand this list. So I need to know a list which may be an integer list of might be here seven numbers. I need to know that. Also I need to know which key I am searching for. Once I know these two. So I know 572-9183 is my list and I know that four is my key. Then how should I go about it? I have got four in mind. I start to look at as if I am looking at through some means at different positions. I look at this position and check this element and compare this element with the key. And I ask, are they equal? If the answer is yes, then obviously I can say that four is in the list. But as you can see, it is not true. So in case of no, I'll shift my focus from here to here and I'll now compare with four, this element seven, are they equal? No. Then I'll again shift the focus and I'll go on. Shift the focus and I'll compare with this element with the key. All right. In that I will go on. How long shall I go on till the end of the list? If suppose here there was a four instead of one, there was a four here. Okay, suppose instead of one there was a four here. Then when my focus changes to this point and then again comes to this point and then I find that this element is matching the key value then I can exit and say yes, four is there in the list. Then if the other question has to be answered that okay, four is there. But where is four? Where is four? In that case, what would be your answer be? Your answer would be this position. And what is this position? This position is nothing but the current index. Current value of the index. Here the index started. This is my index which was shifting. So now we can think of the algorithm. I've got 572-9183 and my key is four. So I'll be doing so. This is a loop, which is list for I equals zero. That means the focus of the index I less than equal to 1234-5676 I plus plus. I plus plus. If list I, that means the ith element of the list is equal to the key. Then I can say found assigned one. And what is found? Found is some variable which I have initialized. At this point, initially, nothing is found. It is not found. So found is zero. Initially, I have not found the key here I'm comparing. As soon as I compare, I put found equal to one and then I can exit or this automatically this loop will go on. Now, if I do it in this way, what is the problem? Suppose my key was. Suppose my key was one, then it goes on. I zero. This is never happening. Found is still zero. It goes on, it comes to here and I count come to found equal to one. And then I can say if found equal to one, I can printf ah, printf key found at position percentage d I. So at that point, I can also print that it has been found here, right? In the worst case, what can happen? Found will remain zero, found will remain zero, and I'll come to the end of this point. When I come here, I can check if found is zero. Printf key not found. Okay, if I don't find it, there can be different flavors of the same problem. The other flavor could be that. Suppose this element one is there at multiple places. Suppose it is also here. Then what will this program result in? What would be its output? I'll go on checking here, I'll check. The for loop is extending up to which part the for loop is extending up to this. This position and this is separate. I should have written it on this side. So I go on checking this. So key is found at position number 01234. Key is found at position four. The list is not exhausted. Ultimately it will come to this point and again it will say the key is found at position six. Twice it is found, it will be told like that, okay, keys, it will print twice. If at the end it comes and still the key, the value of the variable found is zero, then it will say print, it's not found. I could have also say the same thing, same problem. I do say, suppose I have got a list. 579-2131 the question is how many ones are there? The same algorithm will do. The same algorithm will work, right? What is the same algorithm? The algorithm is I start from one point, from the beginning. Let me draw it in this way. If this be an array where all my elements are there, 579-2131 I start from the beginning, I equals zero, and for every element I compare with the key and go on till the end. Now, if I want to do this, what is the additional variable that I'll require? I'll require another variable count which is initially zero other than found, which is also false. So whenever I find a one and my key is one. So whenever I find a one, I'll say found is equal to one. And also I'll do count plus plus and I'll continue here I come and I'll find. I'll have the value of count to be two. I can say that here I could print where found is becoming one. So I can say at which position it is found and how many times it is found. Now, another flavor could be that I have got this, say this array. I have got this array and some array. 632915 and whenever I have been given a key, say the key is two. As soon as I find two, that is enough for me. I just want to know whether two is there in the list. I am not interested to know how many times it is there or in which position it is there. Or at best I may like to know at which position you found it first. So what I can do, I'll go on searching like this. And whenever you find two, then you print that I have found two here and exit. So what will you do? The loop will be the loop inside the loop. You can do it like this. That if AI or list I let's. I was writing list I is not equal to key. All right. For you could have done it by while also n minus one. I plus plus. You go on doing this. If list I is not sorry. If it is equal to the key, what have I done is equal to key. Say found equal to one and printf the position and exit. And you need not go through the entire loop. So that is this sort of search which I am doing in a linear way from one side to the other is known as linear search. It's a simple, very simple search for a particular element. Okay, we'll see a little bit more on this. The next lecture.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
list comprehension.mp3,"So quite often we want to do something to an entire list. For instance, we might want to replace every item in the list by some derived value f of x. So we would write a loop as follows. For every x in L, replace x by f of x. Now we could write a function to do this which does this for different lists and different value of f. So we could say define apply list, which takes a function f and a list l. And for every x and l it just replaces x by f of x. And since a list is a mutable item, this will update lists in the calling function as well. So Python has a built in function map which does precisely this. So map fl applies f in turn to each element of l. Now although you would think that if you take a list, say x one, x two, and you apply map and you get f of x one, f of x two, that the output of map should be another list. Unfortunately, in Python three, and this is another difference between Python three and Python two, the output of map is not a list. So you need to use the list function like we did before. We need to say list of map fl to get a list. And you can however use the output of map directly in a for loop by saying for I in list map fl. Or you can even say for I in map fl. This will work so you don't need to use the list notation if you just wanted to index in a loop. But if you want to use it as a list, you must use the list function to convert it. And this is pretty much what happens with functions like range and d keys and so on. So these are all things which gives us sequences of values. These sequences are not absolutely lists. They can be used in four functions, but if you want to use them as lists and manipulate them as lists, you must use list to convert them from the sequence to the list format. Another thing that we typically want to do is to take a list and extract values that satisfy a certain probability. So we might have a list of integers called number list, and from this we might want to extract the list of primes. So we start off by saying that the list of primes we want is empty. And now we run through the number list, and for each number in that list we apply the test. Is it a prime? If it is a prime, then we append the list to our output list. So we start with the list x one, x two, and so on. And then we apply the test, and some of them will pass and some of them will succeed, some of them will fail, and at the end, wherever the things pass, those items will emerge in the output. So in general, you could write a select function which takes a property and a list, and it creates a sublist by going through every element of the list, checking if the property holds, and for those elements which the property holds, appending it to the sublist. So the difference between select and our earlier map function is that property is not an arbitrary function. It doesn't manipulate l at all. All it does is it checks whether a property is true or not. So, property will be a function which takes an element in the list and tells us true or false. If it is true, it gets copied to the output. If it is false, it gets discarded. So there is a built in function for this as well. It's called filter. So, filter takes a function p which returns true or false for every element, and it pulls out precisely that sublist of l for which every item in l which falls into the sublist satisfies p. So let's look at a concrete example. Supposing we have the list of numbers from zero to 99. We want to first pull out only the even numbers in the list. So that's a filter operation. And then for each of these even numbers, we want to square them. So here we take the even numbers by using the filter, and then we map square. So then we get a list, and then of course, having got this list, then we can add it up. So the sum is not part of this function, but we want to first extract the squares of the even numbers. And that can be done using a combination of filter and then map. So filter first gives us the even numbers, and then map gives us squares. And the square is defined here, and is even is defined. So there is a very neat way of combining map and filter without using that notation. So let's get to it through a more simple mathematical example. So, you might have studied in school from right angle triangles, that by Pythagoras'theorem, you know that if x, y and z are the lengths of the two sides and the hypotenuse respectively, then x squared plus y squared will be z squared. So a pythagorean triple is a set of integers, say three, four, and five, for example, such that x squared plus y squared is z squared, three squared is nine, four squared is 16, PI squared is 20. So let us say we want to know all the integer values of x, y, and z, whose values are below n, such that x, y and z form a pythagorean triple in this sense. In conventional mathematics, notation, you might see this kind of expression. It says, give me all triples, x, y and z such that. So this bar stands for such that, such that x, y and z all lie between one and n. And in addition, x squared plus y squared is equal to z squared. So this is in some sense where we get the values from. This is an existing set. We have x ranging from one to n, y ranging from one to n, z ranging from one to n, and we put together all possible combinations. Then we take out those combinations to satisfy a given property, x squared plus y squared, z squared, and those are the ones that we extract out. So in set theory, this is called set comprehension. This is a way of building a new set by applying some conditional things to an old set. And this is also implicitly applying a kind of a tripling operator. It takes three separate sets, x from one to n, y from one, two, and z comma two. N combines them into triples. So there is a filtering process by which you only pull out those triples where x squared plus y squared is z squared. And then there is a manipulating step where you combine them into a single triple x comma y comma c. But in general, the main point is that you are building a new set from existing sets. So what Python does, and many other languages also from which Python is inspired to, is allow us to extend this notation full list. So this actually comes from a style of programming called functional programming, where this kind of notation is there and Python has borrowed it and it works quite well. So here is how we will write our earlier thing, which we had said the squares of the even numbers below 100. So earlier we had given a map filter thing. So we had said we would take a range and we would filter it, and then we would do a map of square. So in Python there is an implicit perpendicular line below before the four from the set notation. So it says take square of x for I in range 100 such that is even. So we have here three parts. So we have a generator which tells us where to get the values from. So remember that list comprehension or set comprehension pulls out values from an existing set of lists. So we first generate a list, in this case the list range 100. But we could use another list we could use for I and any l, just like a port. Then we apply a filter to which are the values from this list, which we are going to retain. And then for each of those values we can do something to it. In this case we square it and that will be our output. So this is how we will generate a list using map and filter without using the words map and filter in the thing. We just use the for the generator, if for the filter, and the map is implicit by just applying a function, the output of the generator. So let's go back to the pythagorean triple example. We want all pythagorean triples with X-Y-Z below 100. So this, as we said, requires us to cycle through all values of x, y and z in that range. So it's a little bit more complicated than the one we did before, where we already had a single generator, all the values in range zero to 100. So it's simple enough. You write it with multiple false. So you say, I want x comma, y comma z for x and range 100 for y and range 100 for z in range 100, provided x squared plus y squared equal to z squared. So that's written with the if. Now, just to fit on the slide, I have split it up into multiple lines. But actually this will be a single line of python code. So in what order will these be generated? Will it behave exactly like a nested loop? Imagine we had written a loop in which we said for x and range 100, for y in range 100, for z and range 100. So what happens here is that first a value zero will be fixed for x, then a value zero will be fixed for y, then zero. So the first pair triple that comes out will be. Then the value of z will change, the innermost loop changes next. So the next one will be. So this is x. So in this way we'll keep going until we do 99. So when this reach 99, then this for loop will exit and we'll go to one. So I'll get 0101-0199 and so on. So the innermost four. So z will cycle first, then y, and then x will cycle slowest. So just remember that. So let's see how this works in Python. So let's first begin by defining square of x. Turn x times x. Then we can define is even x to check that the remainder of x divided by two is zero. So we have square eight, for example, 64 is even, 67 should be false, 68 should be true, and so on. So now we have list comprehension. So let us look at the set of square x for x in range 100 such that x is equal. So we see now that zero is there. So zero, square two, square four, square six, square. And so this is our discontinued. Now let's do the pythagorean triple one. So we say we want X-Y-Z for x in range 100, y in range 100 for z in range 100. So this is our three generators with the condition that X times X plus y times Y is equal to Z times. Now, you see a lot of things that have come in particular. You should see in the early stages somewhere things which are familiar with like three, four, five and so on. But you also see some nonsense things like 40 four. So we should probably have done this better, but we won't worry about that. But what I want to emphasize is that you see things like, say you see zero 77 77, which is a stupid one. But let us say, for instance, you say you see three four five, right? So we saw three four five somewhere. So three four five. But you will also see later on four three five. Now, one might argue that three four five and four three five are the same triple. So how do we eliminate this duplicate so we can have a situation just like we'd have in a for loop, where a later loop can depend on an earlier loop. If the outer loop says I to some I goes from something to something, the later loop can say that j starts from I and goes forward. So, for instance, we can now rewrite our Pythagoran triples to say that X is in the range 100, but y doesn't start at zero, it starts from x onwards. So Y is never smaller than x and z is never smaller than y. So z is also never smaller than x because y itself is never smaller than x. And this version will actually eliminate duplicates. So here is our earlier definition of pythagoras, where we had x, y and z unconstrained. So what I do is I go back and I say that Y is not in range 100, but y is in range x 200, and z is in range y 200. And now you'll see a much smaller list, and in particular you'll see that in every sequence that is generated, x is less than equal to y is less than equal to z. And you only get one copy of things like three four five. So you see three four five, but you don't see four three five. So three four five is here. Next one is 512 34. Three five is eliminated. So the key thing is that generators can be dependent on outer generators. Inner generators can be dependent on outer generators. So this list comprehension notation is particularly useful for initializing lists, for example, for initializing matrices when you are doing matrix like computation. So supposing I want to initialize a four by three matrix to all zeros. So four by three matrix has four rows and three columns. And I'm using the convention that I store it row wise. So I store the first row. So it'll be three entries for the first row, then three entries for the second row, and so on. So here is an initialization. It says l consists of something for the outer thing, says this is for each row, so it is something for each row. So for four rows. 0123, I do something. And what is that something? I create a list of zeros of size three. So each row, j from zero to three, consists of columns zero, one, two, which are zeros. So this will actually generate the correct sequence that we saw that we would need to initialize such a matrix. So here is that list comprehension notation for initializing the matrix. So it says, for every j in range four, we create a list. And that list itself has zero for integer. And if you do this and look at l then correctly it has three zeros and three zeros and three zeros four times. So these are four rows with three columns. So suppose instead we split this initialization into two steps. We first create a list of three zeros called zero list, which says zero for I in range t. So this creates a list of three zeros. And then we copy this list four times in the four rows. So we say the actual matrix l as four copies of zero list. Now we go and change one entry. Say we change entry one in row one. So from the top it's actually second row. So it's the second row, second column, if you want to think in normal terms. So we take the list one, which is the second list. What you expect is the output of this. So here we have the zero list, and then we say l is four copies of zero list for j in range four. So superficially, l looks exactly the same. Now, we say l one one is equal to seven. And if you look at L now, we'll find that we have not one seven, but four copies of seven. So this is apparently something which we did not expect. So the output after l eleven is equal to seven is. And why is this happening? Well, that's because by making a single zero list and then making four copies of it, we have effectively created four names of the same list. So whether we access it through l zero or l one, or l two, or l three, all four of them are pointing to the same zero list. So any one of those updates would actually update all four lists. So if you want to create a two dimensional matrix and initialize it, make sure you initialize it in one shot. Using a nested range, and not in two copies like this, because these two copies will unintentionally combine two rows into copies of the same thing, and updates to one row will also update another. So, to summarize, map and filter are very useful functions to manipulating lists, and Python provides many other programming languages based on functional programming, a notation called list comprehension to combine map and filter, and one of the uses that we saw for this conclusion is to correctly initialize a two dimensional or a multidimensional list to some default values. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
lists.mp3,"So far we have seen some basic types of values in Python. We began with the numeric types, which were divided into two categories, int and float. So int represented whole numbers or integers, and float represented values which have a decimal point, and for these we had arithmetic operations such as plus minus, times divides, and also other functions which we can import using the math library, which is built into Python. Then we introduced a new type of value which may not be so familiar for logical values, true and false, which are of type bool. We can operate on these values using functions such as not, which negates a value, makes it the opposite and and or and when we do comparisons between numeric values, for instance, the outcome of such a comparison is typically a bool value, and we can combine these comparisons using not and and to make complex conditions. In the previous lecture we looked at strings, so strings are used to represent text. A string is of type str. It is a sequence of characters, and since it is a sequence, we can talk about positions in the sequence. So the positions start numbering at zero and go up to n minus one, where n is the length of the string. If we say s square bracket I for a string value s, then we get the ith position using this numbering convention, and a slice gives us a subsequence a string from position I to position j minus one, written s square bracket I j. The basic operation we can do with strings is to glue them together using the plus operation. So plus means concatenation for strings and not addition in the arithmetic sense. We can extract the length of a string using the len function, and we said that we will look at more complex string functions later on. Today we move on to lists. A list is also a sequence of values, but a list need not have a uniform type. So we could have a list called factors, which has numbers one 2510. We could have a list called names, which has anand, Charles and Muksit. But we could also have a list which we have called mixed, which contains a number, a Boolean and a string. Now, it is not usual to have lists which have different types of values at different positions, but Python certainly allows it. So while we will normally have lists which are all integers, or all strings, or all boolean values, it could be the case that different parts of a list have different types. A list is a sequence in the same way as a string is, and so it has positions zero to n minus one, where n is the length of the list. So we can now extract values at a given position, or we can extract slices. So in this example, if we take the list factors and we look at the third position, remember that the positions are labeled 0123, then factors of three is ten. Similarly, if we take the list mixed and we take the slice from zero to two minus one, then we get the sublist consisting of three and two. As with a string, the length of a list is given by the function len. So len of names is three, because there are one, two, three values in names. So remember that length is just a normal length, whereas the positions are numbered from zero to n minus one. So there is one difference between lists and strings. In what we have seen so far, we said that there was no concept of a single character. So in a string, if we take the value at a single position, or we take a substring of length one, we get the same thing. So if we have the string h, which has positions 12345, sorry, 1234. Set as length five, and if we ask for the zero th position, then this gives us the letter h. But the letter h in Python is indistinguishable from the string h. Similarly, if we ask for the subsequence from zero to one but not including one, then again we get the string h. So in one case it's as though we constructed a substring of length one. In one case we got a single character, but Python does not distinguish. So h of zero is actually equal to as a value, the slice h zero one. Now, this will not happen with a list in general. So if we have a list, a list consists again of positions 0123 say. And now if we take the zero th position, we get a value, we get the value one. We don't get a list one. On the other hand, if we take the slice from zero up to and not including one, then we get the sublist of factors of length one, containing the value one. So factors of zero is one, factors of zero one, the slice is also one. But here we have a single value, and here we have a list. And therefore these two things are not equal to each other. So just remember this, that in a string we cannot distinguish between a single value at a position and a slice of length one. They give us exactly the same type of value and the same value itself. Whereas in a list, a slice of length one is a list, whereas a value at a position is a single value at that position. Now, lists can contain other lists, so this is called nesting. So for example, we can have a nested list. So this contains a single value at the beginning, which is another list. So this is position one. This is position, sorry, position zero. This is position one, and this is position two. So, position one is a single simple value, an integer zero, an integer four. Position zero is a list which in turn has itself two positions zero and one. And the value at position one is itself another list. So it's a third level of nested list, which has a single value 37. Similarly, the value at position two is itself a string, and therefore this is a sequence and it has its own positions. So if we look at this example, then we can see that if we want to look at the zero th position and nested, then as we said, we get this value, and this value consists of a list itself containing two and the list containing 37. On the other hand, if we ask for the first position, position number one, then we get the value four. And now if we look at the position two, which is this list, then in that we look at the zero th position, which is this string, and in that we look for the third character, which is 0123. This l, so, nested of two, takes us to the last value in the list nested in that we look at position zero, which is the first value in the nested list, and in that we look at position three, which is the third character in the sequence contained in that position, and we get the character l or the string l, actually. So in the same way we can also take slices. So we can take the zero th position, which is this list, and then we can ask for the slice starting at one and going up to but not including two. So that means we start with this value. And so we get the list containing the list 37. So notice that the inner list is the value right? So this is the value that lies between position one and up to position two. And the outer list is because when we take a slice of a list, we get a list. So this is a sublist of this list two, comma list 37, which gives us just the list 37. We have dropped the value two, but we get a sublist. So this is what we mentioned before for lists. A slice gives us back a list. So let's just confirm that these things behave as we said. So here we have just loaded the python interpreter with that example. So nested is this list, and if we say now nested zero, we get 237. If we say nested one, we get the value four. Now, if we say nested two, we get this list. So if we say nested 20, then it drops the list and just gives us a string. And if we say nested 20 three, then we get the string l as we said before, and then we said that we can now update, for instance, nested, not update, sorry. We can look at nested zero and take the slice one, colon two, and this goes to the first list and gives us the list containing the list containing 37. So the outer list is because it's a slice and the inner one is because the value in position one of the first item in the list nested is itself a list containing 37. So one fundamental difference between lists and strings, or indeed any of the values we have seen before, is that a list can be updated in place. So if we have a list nested as we had before, and we say nested of one is seven. Remember when we tried to change a position in a string? We got an error. So we can't change the second l in hello to p just by saying that we want position three to be replaced by p. But for a list this is allowed. So if we want the four to be replaced by seven, we can just say nested one equal to seven. And this will give us the list 237 seven. And then hello. And we can do this inside as well. So we can say that we want to go into this list which is nested zero. Then we want to go into this list which is nested zero one. And then we want to go into this value and change this value. So we want to change the value at the position zero of the nested list at position one of this initial value. So we say nested zero 10 equal to 19, and this changes that 37 into 19. So this is allowed. So what we say in python notation is that lists are mutable. Mutable. So mutation is to change. So lists can be transformed in place. We can take a list and change its structure. Unlike a string, if we try to change a string, we have to actually construct a new string and reassign the name. But in a list with the same name, we can update parts of it without affecting the other parts. So once again, let us check that what we have done actually works. So if I say nested of one is equal to, say seven, then the list nested the same name now has a seven in place of the value four. If I say nested of zero, which is the first list at one, which is the second nested list at zero is equal to 19. So this says go in and turn the 37 into a 19. And indeed this does happen. So this is a difference between lists and strings. Lists are mutable values. We can go in and change values at a given position without affecting the name and the rest of the list. It is important to understand the distinction between mutable and immutable values, because this plays an important role in assignment. And as you will later see, it also plays a major role in what happens when we pass values to functions as arguments. So let's look at what happens when we assign names. So suppose we go through the following sequences of assignments. So we initially assign the value five to the name x. Then we assign the value in the name x to the value y, and then we reassign x to seven, right? So we started with x being five. Then we said y is also five because y is the value of x. And now we changed x to seven. So the question we would like to ask is, has the value of y changed? So let us do this and see what happens to y. So let's start with x equal to five, y equal to x. So if we ask for the value of y at this point, it is five, as we expect. Now we change x to seven. The question is y five or y seven? And indeed y is still five. And this is perfectly natural as far as our understanding goes that what we did when we set the value of y to the value of x was that we made it five. We didn't say make it the same value as x forever henceforth. So as we saw, the value of y actually did not change. And the question is, why should it change? After all, it seems natural that when we assign a value to the value of another name, then what we are actually doing is saying copy that value and make a fresh copy of it. So x is five. Well, make y the same value as x currently is. It doesn't mean that make y and x point to the same value. It means make y also five. So if x gets updated to seven, it has no effect on y. So this question actually is not so simple. While our intuition says that assignment should always copy the value, in some cases it does happen that both names end up pointing to the same value. So for immutable values, we can assume what our intuition says, that whenever we assign a name a value, we get a fresh copy of that value. So this applies to all the types we have seen before today's lecture, namely int, float, bool, and string. These are all immutable. So if we do the kind of assignment we did before, where we assign something to x, then make y the same value as x, and then update x, y will not change. So updating one value does not affect the copy because we have actually copied the value however, as we pointed out, lists are a different beast from strings, and lists are mutable. So it turns out that for mutable values, assignment does not make a fresh copy. So let us look at the following example. We first assign, say, the list 1357 to the name list one. Then we say that list two is the same as list one. So if we had this copy notation now, we would have two copies of the list. Suppose we now use the mutability of list one to change the value at position two, namely this value, to four. The question is, what has happened to list two? Is list two the same as before, namely 1357? Or has list two also become 1347 like list one? So let us see what happens in the interpreter. So let us run this example in Python. So we say list one is equal to 1357, list two is equal to list one. So list two is indeed 1357. Now we update in place list one two to be equal to four. So we say that list one is 1347. The five has been replaced by four. So the question we are asking is, has this affected list two or not? And contrary to our intuition that we have that values are copied, in this case, list one has indirectly affected the value of list two as well. So why does this happen? So list two two is also four. And that is because when we actually make assignments like this from one name to another name, and the other name holds a mutable value, in this case, the only mutable type that we have seen so far is a list. Then instead of saying that there are two copies, we actually just say that list one is pointing, if you like, to a value of list 1357. And now we also have another name for the same list, namely list two. So if we go and change this value to four, then list two also has the same value, four at this position. So there's a fundamental difference in how assignment works for mutable and immutable types. For mutable types, we can think of assignment as making a fresh copy of the value. And for immutable types and for mutable types, assignment does not make a fresh copy, it rather makes both names point to exactly the same value. So through either name, if we happen to update the mutable value, the other name is also affected. So this is something which we will see is useful in certain situations. But what if we don't want this to happen? What if we want to make a real copy of a list? So, recall that a slice takes a list and returns us a sublist from one position to another position. The outcome of a slice operation is actually a new list, because in general we take a list and we will take a part of it from some intermediate position to some other intermediate position. So obviously the new list is different from the old list. So we also saw that when we looked at strings, that we can leave out the first position or the last position when specifying a slice. If we leave out the first position as this, then we will implicitly say that the first position is zero, so we start at the beginning. Similarly, if we leave out the last position like this, then we will implicitly assume that the last position in the slice is the length of this list or the string, and so it goes to the last possible value. So if we leave out the first position, we get a zero. If we leave out the last position, we get the length. So if we leave out both positions, we just put a colon with nothing before and nothing after. Logically this becomes zero and this becomes the length. So we have both characteristics in the same thing, and we call this a full slice. Now let us combine this observation, which is just a shortcut notation, with this observation that each slice creates a new sublist. So what we have is that l with just a colon after it is not the same as l. It's a new list created from the old list, but it has every value in l in the same sequence. So this now gives us a simple solution to copy a list. Instead of saying list two is equal to list one, which makes them both. So remember, if I don't have this, then I will get list one and list two pointing to the same actual list. So there will only be one list, one list of values, and will point to the same thing. But if I do have this, then the picture changes. Then what happens is that the slice operation produces a new list which has exactly the same length and the same values, and it makes list two. Point to that. So therefore, after this, list one and list two are disjoint from each other. Any update to list two will not affect list one. Any update to list one will not affect list two. So let us see how this works in the interpreter to convince ourselves this is actually the way Python handles this assignment. So as before, let us start with list one is 1357 and list two. Now let us say is the slice. So now if I update list one at position two to be four, then list one looks like 1347, but list two, which was a copy, is not affected. So when we take a slice, we get a new list. So if we take the entire list as a full slice, we get a full copy of the old list and we can assign it safely to a new name and not worry about the fact that both names are sharing the value. So this leads us to a digression on equality. So let us look now at this set of Python statements. We create a list 1357 and give it the name list one. And we create another list 1357 and give it the name list two. And finally, we assign list three to be the same value as list two. And this, as we said, suggests that list three is actually pointing to the same thing. So we have now, pictorially, we have two lists of the form 1357 stored somewhere. And initially we say that list one points to this and list two points to this. And the last assignment says that list three also points to this. So all three lists are different, are equal, but there is a difference in the way that they are equal. So list one and list two are two different lists, but they have the same value. So they happen to have the same value, but they are two different things. And so if we operate on one, it need not preserve this equality anymore. On the other hand, list two and list three are equal precisely because they point to the same value. They're exactly one list to which they are both pointing. So if we update list three, or we update list two, they will continue to remain equal. So there are two different notions of equality. Whether the value is the same, or the actual underlying object that we are referring to by this name is the same. In the second case, updating the object through either name is going to result in both names continuing to be equal. So Python has, as we saw this operation, equal to equal to, which is the equivalent of the mathematical equality, which checks if x and y as names have the same value. So this will capture the fact that list one is equal to list two. Even though they are two different lists, they happen to have the same value. So to look at the second type of equality, that list three and list two are actually the same physical list in the memory. We have another keyword in Python called is. So when we say x is y, what we are asking is whether x and y actually point to the same memory location the same value, in which case updating x will affect y and vice versa. So we can say that x is y checks if x and y refer to the same object. So going by this description of the way equal to, equal to and is work. Obviously, if list two and list three are the same object, they must always be equal to equal to. So if x is y, then x will always be equal to equal to y because they are actually pointing to the same thing. But in this case, although list one and list two are possibly different lists, they are still equal to equal to because the value is the same. On the other hand, if I look at the is operation, then list one, list two is list three happens to be true because we have seen that this assignment will not copy the list, it will just make list three point to the same thing as list two. On the other hand, list one is list two is false. That's because they are two different lists. So once again, it's best to verify this for ourselves, to convince ourselves that this description is actually accurate. So let us type out those three lines of Python in the interpreter. So we say list one is 1357, list two is also 1357, and list three is list two. So now we ask whether list one is equal to list two, and indeed it's true. But if we ask whether list one is list two, then it says false. So this means that list one and list two are not pointing to the same value physically. So if we update one, it will not update the other. On the other hand, if we ask whether list two is list three, then this is true. So if, for instance, we change list two two to be equal to four like we had done in the earlier example, then list two has now become 1347. So if we ask if list one is equal to list two at this point as values, they are false because list one continues to be 1357 and list two has become 1347. However, if we ask whether list two is equal to list three is true. That is the case because list three is list two in the sense that they both are the same physical list. And so when we updated list three, list two, we also updated list three, like strings. We can combine lists together using the plus operator. So plus is concatenation. So if we have list one is the values 1357, list two is the values 4568, then list three equal to list one plus list two will produce for us the value 135-74-5681 important thing to recognize in our context of mutable and immutable values is that plus always produces a new list. So if we say that list one is 1357, and then we copy this list as a name to list two. So we saw before that we have 1357 and we have two names, list one and list two. Now, if we update list one by saying list one plus nine, this will actually generate a fresh list which has a nine at the end, and it will make list one point there and list two will no longer be the same. So list one and list two will no longer point to the same object. Let's just confirm this. So in the python interpreter, let us set up list one is equal to 1357, and say list two is equal to list one. Then, as we saw before, if we say list one is list two, we have true if, on the other hand, we reassign list one to be the old value of list one plus a new value nine. So this extends list one to be 13579. Now we will see that list two is unchanged, so list one and list two have become decoupled, because each time we apply plus, it is like taking a slice each time we apply plus we actually get a new list. So list one is no longer pointing to the list it was originally pointing to. It's pointing to a new list constructed from that old list, with a nine appended to it at the end. So, to summarize, we have now seen a new type of value called lists. So a list is just a sequence of values. These values need not be of a uniform type. We can have mixed lists consisting of lists, booleans, integers, strings, although almost always we will encounter lists where the underlying content of a list is of a fixed type. So all positions will actually typically have a uniform type. But this is not required by Python, and we can nest lists. So we can have lists of lists and lists of lists of lists, and so on. As with strings, we can use the square bracket notation to obtain the value at a position, or we can use the square bracket with colon notation to get a sublist or a slice. One new feature of Python which we introduced with lists is the concept of a mutable value. So a list can be updated in place. We can take parts of a list and change them without affecting the remaining parts. It doesn't create a new list in memory. One consequence of this is that we have to look at assignment more carefully. So for immutable values, the types we have seen so far int, float, bool, and string. When we say x equal to y, the value of y is copied to x, so updating x doesn't affect y and vice versa. But when we have mutable values like list, we say l two is equal to l one. Then l two and l one both point to the same list, and so updating one will update the other. And so we have to be a bit careful about this. So if we really want to make a copy, we use a full slice. So we say l two is equal to l one with nothing before or after. This is implicitly from zero to the length of l one, and this gives us a fresh list with the exact same contents as l one. And finally, we saw that we can use equality and is as two different operators to check whether two names are equal to only in value or also are physically pointing to the same type. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Logical Operators and Change in Control Flow.mp3,"In the last lecture, we had talked about two different types of operators, relational operator and arithmetic operators. Today, we'll be discussing about the third type of operator, which is known as a logical operator. Logical operators are also known as logical connectives. Okay, so there are two, essentially, there are two logical operators in C. One is logical and the other one is a logical or. Now what do they do? They act upon the operands themselves, which are logical expressions. For example, let us say I am writing a logical expression. Temperature is greater than 50. Now this statement, suppose the temperature now is 40 degree centigrade. Then temperature greater than 40, greater than 50 will result in false value. So, because a relational operator will always generate either true or false, and suppose there is another logical expression. A times b plus C is greater than equal to 25. Now, this is another logical expression. Sorry. This is another relational expression. On the left hand side of this expression, I have got an arithmetic expression, and on the right hand side, I have got a constant, and I am connecting them with a logic relational operator greater than equal to. Now, if a times b plus c is greater than 25 or equal to 25, then this will result in true. Now, I can connect these two, this one and this two together, and write another expression like temperature greater than 50 and a times b plus C is greater than equal to 25. Now, this expression is a combination of two relational expressions and a logical operator or logical connective. This logical and means that this entire thing expression will be true or will result in a one if both of them are true. So if the temperature is 40, then this will become false or zero. And if this is 25, then this is true. But zero and one both are not true. Therefore, this zero and one will result in zero. But suppose if the temperature was 50 and a times b plus C is equal to 25 or greater than 25, then this is true. And also this is true. In that case, these two together, and because they are ended, then this will be true. So the logical and operator, what it does is returns a true value or one, if all the components of the expression logical expression connected by the and operator, logical and operator is true. Okay, now one thing you can note here that since this ampere sand is a character, and we have already used this ampere sand in expressions like and scanf. And we have discussed that this and actually means we are trying to get the address of a particular, I'm sorry, absolutely sorry. Actually, what I write is scan f, et cetera, percentage d and velocity, say, where velocity is a variable. All right? So this, and in that case is used to mean the address of this variable velocity. Okay, so in order to differentiate between this usage of and the logical operator, logical and is denoted as two. Ampere sands two and similarly, logical or means that some expression, say I write it in an abstract way, say x expression one or expression two or expression three. Now, this composite expression will be true. If any one of them, either expression one or expression two or expression three is true. If any one of them is true, then this entire thing will be true. If two of them are true, then also it will return true. If all the three are true, then also it will be true. But if none of them are true, if none of them are true, then it will not be true. Okay, then none of them will be true. So what is the difference between this logical or and logical? And therefore, in logical and if instead of this it was written like instead of this it was written like expression one and expression two and expression three, this composite and expression would be true only if all these three expressions are true. All right, so that is logical, or. Now what do they do? They act upon the operands that are themselves logical expressions. Why logical expressions? Where from did I get logical expressions? I got the logical expressions from relational operators. For example, now I'm writing some time is greater than 20 is a logical expression. What is this? This is a relational operator, but this expression is a logical expression. Why it is a logical expression? Because this will return only true or false. Okay, nothing in between, so t greater than 20 if t is time, or whatever value t might be. If that is greater than 20, then it will return one, or it will return zero. Okay, so the logical connectives or the logical operators, they are acting upon the operands themselves and are connecting them. The individual logical expressions get combined into a more complex condition that are either true or false. Okay, we'll see some examples. So, logical and the result is true if both the operands are true, or for two operands, if for three operands. If all the operands are true, it should be corrected as if all operands are true and logical, or the result is true if at least one of the operands are true. If at least one. This is most important. So let us look at the truth table here. X and y. Any of them can have the value false or true. Accordingly, we can have four combinations. X false, y false, x false, y true, x true, y false, and both x and y are true. Now, if I carry out the logical, and then for all these cases say false false, the result will be false or zero false, and one true. Still it will be false because here I want all operands should be true. One is x is true, y is false, the result will be false. If both of them are true, the result will be true, while in the case of or x or y will result in false. If x is false and y is false. But if x is false and y is true, we'll get a true because I am interested in getting at least one to be true. If this is true and this is false, then also true. If both of them are true, then also it is true. Okay, so I think it's clear to you what is meant by the logical operators and how we can combine logical expressions based on that. Now, we have seen three types of operations. One is actually operators, one is the arithmetic operators, the next is relational operators, and the third one is logical operators. Now, arithmetic operations use of arithmetic operations lead to arithmetic expressions. The use of relational operators lead to logical expressions. Why logical expressions? They lead to true or false value. Right. Logical expressions and use of logical operators will combine and get more complex logical expressions complex or let me not write complex, let me write composite that communicates the meaning better. Composite logical expressions composite logical expressions so we'll see the use of this pretty soon when we'll be looking at the control operators. Right, next, just to wrap up the things, let us come to the input output statements. By the way, besides this, besides the arithmetic expressions, logical expressions, we had seen another type of expression. Those are assignment expressions or assignment operators. But that means the left hand side is an expression and right hand side is a variable. We assign the result of the computation of the right hand. Sorry, I just said the opposite. The right hand side is an expression, on this side is an expression, and here on the left side is a variable, and we compute the expression and assign the value of that computation to this variable. And this is the assignment operator. Okay. Now besides that, we had seen two other statements. One is the printf statement we have seen that performs the output to the standard output device. Typically when we declare stdio h, then by default it is taken as the screen and the other one. And it requires a format string in which we can specify the text to be printed out and the specifications on how to print the values. Like printf number is dash and that dash can be filled up by percentage d. That means the specification is that an integer can come here and then you remember what this means. This means I am going to the new line. All right? And then followed by the number. The format specification causes the value listed to be embedded here. I have discussed that, that you can consider this format to be a placeholder. All right, the number is dash. And how can this dash be filled out the dash, since it's percentage d, some integer value can come and fill it up. Right, we have seen that. The other statement that we saw is scanf. That is for reading the values. So it performs input from standard input device. Normally by default it is the keyboard. And then it also requires a format string and a list of variables, like it is required to put an ampere sand before the names of the variables. We have also explained why that is so. The reason is that this ampere sand essentially means the address of that variable where the value that is being read will be put. Okay, so here are some examples. Scanf, percentage d, and size. That means what? That I am reading in a variable size. Size is the name of a variable and in which I am putting in some integer value. All right, similarly, next cat, say this one is a character variable. So I am specifying that only a character can come in here. And that's why I put in the specification percentage c. Percentage f means some floating point number will come here. But in all these cases, this ampere sand means the address of the corresponding variables. All right, here, percentage d. Percentage d means sequentially, I am going to read two integer variables, a and b. So all these we have seen, and you will be best learning this by practicing it time and again. And we'll see a number of examples. And in this course there will be quite a few assignments, which you'll have to do. Okay, next we'll move to, next we'll move to a new topic, which is the control structures and control statements. Okay, we have seen, if you recall, in a flowchart, let's go back to the flowchart where we have got some computation statements, where we are doing some computations. And we usually carry out one statement after another. Right? That's how we do. And in that way we go on till the end of the program. For example, read number one, read number two, et cetera. Divide, add the numbers and divide the numbers to get the average. So when we computed the average, it was something like this. And at the end we did some printf, and in the meanwhile, there were some reading the numbers. Some of them were input, some were computations, right, but it was a complete sequential thing. But if you recall the other type of flowcharts that we had seen there, we had started, we did some computation, and then we took some decisions. And based on the decisions, I have sometimes gone back to the earlier operation, that earlier thing that I had done, and otherwise I would have followed this path. Typically in the example that we just see the pseudocode, if I write, say, for computing the average of three numbers, I'll be read num one, read num two, read num three, and then sum equals to num one plus num two. Like that, I add them, and then I compute the average to be sum divided by three, right? And then we print the sum, print the average. So this entire thing is going in a sequence, all right, just one after another. One after another, no change in the path. But in this case, for example, when we try to, if you recall, when we are not writing this program in this form of pseudocode, instead I initialize, say, count to be three, then read number one, sum an initial account here, and say sum was zero assigned zero, and then sum is. Let me just make it just num. I am reading one number and sum plus num, and then count, I decrement. So I make count to be count minus one, because I have the one I have already read. Now I check if count is greater than zero, then what I do in my flowchart, I go back to reading the number again. Otherwise, else I come to the computation of the average, right? Otherwise. So if as long as count is greater than zero, I am continuously doing this thing, right, these steps. So here at this point, you check that I am looking at the value of count, and depending on the value of count, I am deciding whether I'll be going in this direction or I'll go back and change the direction of the flow. So that means as if at this point, the execution is undergoing a decision making to decide which part it will go through, this path or this path. As if therefore, you are controlling the flow of the program, either in this way or you change the path, we'll see that we can change the path in two different ways. One is that sequentially I'm coming and I may go ahead, I can skip some of the operations and I can go jump forward. That is also a change of the path. This dotted line is showing the normal sequential execution, or could be that from here I can go back to another path. So these are the two types of change of flow. Change of flow that can be resulted in and that can be resulted in using the control structure. Okay, so we will soon go into the details of the control structure and see how such control structures or change of the sequential flow can be achieved in any programming. We'll exemplify as we are doing for all other examples using the constructs of C, but that does not mean that it is restricted only to C. There are similar control constructs for other languages as well. We'll come to that in the next lecture.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
longest common subsequence.mp3,"It. So we're in the realm of inductive definitions, recursive functions, and efficient evaluation of these using memoization and dynamic programming. So we are looking at examples of problems where the main target is to identify the inductive structure. And once you identify the inductive structure, then the recursive structure of the program becomes apparent, from which you can extract the dependencies and figure out what kind of memo table you have and how you can fill it iterative using dynamic programming. So this is something which comes with practice, and by looking at more examples, hopefully the procedure will become clearer. But the key thing to dynamic programming is to be able to understand the inductive structure. So you need to be able to take a problem, identify how the main problem depends on its subparts, and using this come up with a nice inductive definition which you can translate into a recursive program. Once you have the recursive program, then the memo table and the dynamic programming almost comes out automatically from that. So this is a problem involving words. So what we want to do is take a pair of words and find the longest common subword. So for instance, here we have secret and secretary, and secret is already also inside secretary. And clearly, since secret is the longest word in secret itself, the longest subword that is common is the word secret, and it has length six. If we move to the next thing, bisect and tricect, then actually this should be mistake, which has length five. Similarly, if we have bisect and secret, then sec. So when we say subword, of course we don't mean a word in the sense we just mean a sequence of letters. So sec is the longest common subword. This has length three. And if we have two very different words like director and secretary, then sometimes we might have only small things. For example here re and ec are examples of subwords, but there aren't really very long words which are common to these. So the subword is only length two. So here is a more formal description. So supposing I have two words, u and v, so u's of length m and v's of length n, and the number, the positions using Python notation are numbered zero to m minus one and zero to n minus one. Then what I want to do is to be able to start at Iai and go K steps. So I to I plus k minus one and bj to j plus k minus one, such that these two segments are identical. So this is a common subword, and we want to find the longest such common subword. What is the k we don't even want the subword. We'll find that the subword will be a byproduct. We first need to just find k. What is the length of the longest common subword of u and b? So, there is a brute force algorithm that you could use, which is to just start at I and j in two words in each word, and start with position I in u and j in v, and see how far you can go before you find they are not common. So you match AI and bj. So if AI and bj work, then it's fine. So this should be bj, and if AI and bj work, then you go to AI plus one, bj plus one, and so on. And whenever they find two letters which differ, then the common subword starting at ij has ended. And you say, okay, from ij, I have a common subword of something. Now, among all the ijs, you look for the longest one, and that becomes your answer. Now, this, unfortunately, is effectively an order n cubed algorithm. If we think of mn as being equal, technically mn squared, because there are m times n different choices of inj. And in general, I start at ij, and then I have to go from I till the end and from j till the end. So we have to do a scan for each ij. This scan, in general, adds up to an order order n factor. And so we have order m, n squared, or order n cubed, if you would like to do it. So, our goal is to find some inductive structure which makes this thing computationally more efficient. So what is the inductive structure? Well, we have already kind of seen it. When can we say that there is a common subword starting at ij of length k? Well, the first thing is that we need this AI to be the same as bj. So I need this condition. And now, if this is a common subword of length k at ij, then what remains of the subword, namely this segment from I plus one to this and j plus one to this, must also match, and they must in turn be a k minus one length subword from here to there. So, we want to say that there is a k length subword starting at ij. If AI is equal to bj, and from I plus one and j plus one, there is a k minus one length subword. So, in other words, I can now write the following definition. I can say that the longest common, the length of the longest common subword lcw, starting from ij. Well, if the two are not the same, if AI is not the same. There is no common subword at all, because if I start from here, I immediately have two different letters. So then the length is zero. Otherwise, I can inductively find out what is the longest common subword to my right start my plus one, start from day plus one, find out what I can do from there. And to that word I can add one letter, because this current letter AI is equal to bj. So I get one plus that. And the base case, or the boundary condition is when one of the two words is empty. If I have no letters left, if I have gone I, j, I'm looking at different combinations, I and j. If either I or j has reached the end of the word, then there is no possibility of a common subword at that point. So when we have reached the end of one of the words, the answer must be zero. So this gives us the following definition. So remember that u is actually of length m, so it has zero to m minus one. So what we will do is we will add a position of m to indicate that we have crossed the last letter. Similarly, v has zero to n minus one as valid position. So we will use the indices zero to n. So if I becomes m or j becomes n, it means that that corresponding index has begun beyond the end of the word, right? So this should be m and this should be n. So we have that if we reach m, then lcw of m, comma j is zero because we have gone past the length of u. Similarly, if we reach n, then lcw of I, comma n is zero because we have gone past the length of v. And if we have not gone past the length, if we are somewhere inside the word, in a valid position, then the length is going to be zero if the two positions are not the same. If AI is not equal to bj, otherwise, inductively, I compute the length from I plus one and j plus one, and I add one to it. Okay, this is the case when AI is equal to bj, because that segment, I can extend that. So this is just stating in an equation form the inductive definition that we proposed in the earlier. So here is, for example, for example, this bisectant secret. So we have position zero to five, and then we have the 6th position indicating the end of the word. And now remember that the way our inductive definition was phrased ij depends only on I plus one, j plus one. So actually the dependencies are this way. So the arrows are indicating that. In order to solve this, I need to solve this first. Right? The value at two, comma, three, depends on the value at three, comma, four. So in order to solve this, I don't need to solve anything because everything runs right. So in order to solve this, I don't need to. So anyway, so basically we have this simple thing which says that the corner and actually the right column and the bottom thing don't require anything. And we know that because those are all zeros. So we can actually fill in those values as zeros because that's given to us by definition. And now we can start, for instance, we can start with this value because its value is known. So we will look at whether this t matches that t. It is that. So we take one plus the value to its bottom, right? So we'll get one and then we can walk up and do the same thing at every point. We'll say that, okay, if c is not the same as t, so none of these letters, so if you look at these letters here, right, none of these letters are t. So for all of these letters, I'll get zero directly because it says that AI is not equal to pj. So I don't even have to look at I plus one, j plus one, it directly says it's zero because it's not there. So in this way I can fill up this column. So this is like our grid path thing. I can fill up column by column even though there the dependency was to the left and bottom, and here the dependency is diagonally bottom right. I can fill up column by column and I can keep going. And if I keep going, I find an entry three. So the entry three is the largest entry that I see, and that is the actual answer, this entry three. And now we said earlier that we are focusing on the length of the longest common subword, not the word itself. And the reason we can afford to do that is because we can actually read off the answer once we have got the length. So we ask ourselves, why did we get a three here? So we got a three here because we came as one plus two. So since we came as one plus two, it must mean that these two letters are the same. Similarly, we got a two here because it is one plus one. So these two letters must also be the same. Okay, so these two letters are the same. These two letters, finally we got one here because this is one plus zero. So these two letters are the same. So therefore these three letters must be the same. So if we walk down from that magical value, the largest value, and we follow the sequence, then we can read off on the corresponding row or column because they are the same, the actual subword, which is the longest common subword for these two words. So here is a very simple implementation in Python. So all it says is that you start with the two words u and b. You initialize this Lcw thing at the boundary at the nth row and the nth column. And then now you remember the maximum value. So you keep track by initializing the maximum value to zero, and then you fill up, in this particular case in column order. So for each column, then for each row in that column, you fill up the thing using the equation. If it is equal, I do one plus. Otherwise I say it's zero. And if I see a new value, this is the thing where I update. If I see a new entry which is bigger than the entry which is currently the maximum, I update the maximum. So this also allows me to quickly find out what is the maximum length overall. And finally, when I've gone through this loop, I would have filled up the entire table and I will return the maximum value I saw overall. So when we did it by brute force, we had an order m n squared algorithm. Here we are filling up a table which is of size order m by n, and each entry only requires us to check the I position in the word, the j position in the word, and depending on that, if necessary, look up one entry, I plus one, j plus one. So it's a constant time update. So we need to fill up a table of size order mn. Each update takes constant time. So this algorithm brings us from mn squared in the brute force case to mn using dynamic programming. So a much more useful problem in practice than the longest common subword is what is called the longest common subsequence. So the difference between a subword and a subsequence is that we are allowed to drop some letters in between. So for instance, if you go back to the earlier examples for secret and secretary, there's no problem, because the subword is actually the entire thing. And again, for bisect and trisect also it's the same thing. But if you have bisect and secret earlier, if we did not allow ourselves to skip, we could only match sec with sec. But now we can take this extra t and we can skip these two and match this t and say that sect is a subsequence in the right word, which matches the corresponding subsequence, which is also a subword in the left word, but in the right it's not a subword, it's a subsequence. I have to drop some letters to get SCCT. Similarly, if I have secretary and director, then I can find things like ECTR, ECTR in both of them by skipping over judiciously. So why is this a better problem? Well, we'll see that. But effectively what skipping mean? Skipping means that I get segments which are connected by gaps. So I get this segment, then I want to continue the segment. So I look for the next match. So I skip, but the next match must come to my right. So it must come to the right and below the current match because I cannot go backwards in a word and start a match again. So I cannot, for instance, go here and say that this is an extension because this requires me to go back and reuse the e that I have seen in sec to match the second e in secret, which is not allowed. So I can keep going forwards, which in the table corresponds to going to the right and back, right and down. So I'm going increasing the order of index in both words and I can group together these things. And this is what the longest kind of subsequence is. So we could in principle look at the longest common subword answer and look for these clever connections. But it turns out there is a much more direct way to do it in an inductive way. So the motivations, well, one of the big motivations for subsequence matching comes from things like genetics. For instance, when we compare the gene sequences of two organisms, they are rarely equal. So what we are looking for is large matches where there might be some junk genes in between which we want to discard. So we want to say that two gene sequences or two organisms are similar if there are large overlaps over the entire genome. Not just looking for individual segments which are long, but by just throwing away the minimal things on both sides, you can make them align as they call. Another important example is something called diff, which is a Unix command to compare two text files. So this treats, in fact, line by line, two files as a word. So each line is compared to each line in the other file. If the lines match, they're considered to be equal. And this is a good way of comparing one version of a file with another version of file. So supposing you are collaborating on a document or a program with somebody else, and you send it by email and they send it back saying, I've made some changes. Then diff tells you quickly what are the differences between the file you sent and the file you got back. And diff essentially is doing the same thing. It's trying to find the longest match between the file that you sent and the file you got back, and the shortest way in which you can transform one to the other by changing a few lines. So these are some typical examples of this longest common subsequence problem, and therefore it's usually much more useful in practice than the longest common subword problem. So what is the inductive structure of the longest common subsequence problem? So, as before, we have the words laid out so we can say zero, a zero to am or am minus one. It doesn't matter how you choose it, but in the picture it says am. But if you want, you can ignore these last two entries here. So a zero to am minus one is the first word, b zero to bn minus one is the second word. And now there are two cases, right? The first case is the easy case. Supposing I have these two things are equal. Then like before, I can inductively solve the problem for a one and b one. Onwards and add this. I can extend that solution by saying a zero matches b zero, and then whatever matches. So what is the subsequence? A subsequence actually is some kind of a matching. It says that it will say that this matches this and then this matches this, these are the same, and this matches this, and then this matches this and so on. Only thing is that these lines can't overlap. They must keep going from left to right without overlapping. So this kind of pairing up of equal letters, the maximum way in which I can do this is a longest common subsequence. So now what we are saying is that if I can actually match the first two things, then I should match them, and then I can go ahead and match the rest as I want. And the reason is very simple. Supposing the best solution did not match these. Supposing you claim that the best solution actually requires me to match a zero and b one. Well, if I could match a zero and b one, I can also undo it and match a zero, b zero. And then continue, because a zero and b one, if they match, then a one must be matched to is right. So I can take that solution and change it to a solution where a zero matches b zero. So if the first two letters are the same, I might as well go with that and say it is one plus the result of optimally solving the rest. What if they are not the same? This is the interesting case, right? So supposing these are not the same, then what happens? So then can we just go ahead and ignore a zero and b zero. No. So it could be that a zero actually matches b one, or it could be that b zero matches a one. We don't know. But we certainly know that a zero doesn't match b zero. So we have to drop one of them because we can't make a solution with a zero matching b zero, but we don't know which one. So what we do is we take two sub problems. We say, okay, let us assume b zero is not part of the solution. Then the best solution must come out of a zero to am minus one and b one to bn. B zero is excluded because I can't match it with a zero. And whatever a zero matches must match to the right, so I must throw it away. But maybe this is the wrong choice. So the other choice would be to keep b zero and drop a zero, in which case I do a one to am minus one and b zero to bn. So these are two different choices. Which one do I choose? Well, since we don't know, we solve them both. If a zero is not b zero, we solve both these problems. A one to am minus one b zero and a zero to am minus one b one. Solve both of them, take the maximum one. Whichever one is better is the one we keep. So this in general will take us deeper in the word. So we said a zero b zero will require solid for a one and b zero, or a zero and b one. So in general, we have AI and bj, right? So again, since we have AI and bj, then we will use the same logic. If AI is equal to bj, then it is one plus the rest. This is the good case. If AI is not equal to bj, then what we do is we look at the same thing, we drop bj and solve it, and symmetrically we drop AI and solve it, and take the better of the two. We take max of the solution from I and the solution from j plus one. So if we say like we had before, that lcs of ij is the length of the longest common subwoofer starting from I and j. If AI is equal to bj, it will be one plus the length starting from I plus one, j plus one. If it is not equal, it will be the maximum of the two subproblements where either increment I or increment j. And as with the longest common subword, when we go to the last position, m and m, we get zero. So here the dependency is slightly more complicated because depending on the case, I either have to look at I plus one j plus one or I have to look at I plus one j or I j plus one. So I have, for this square I have to look at its right neighbor, diagonal neighbor, and the bottom neighbor. But once again the ones which have no dependency are clear. So earlier we had for longest common subword, we had only this dependency. This meant that even a square like this had no dependencies because there is nothing to its bottom right. But now for instance, if we look at this picture, since we are looking bottom right and left, if I look at this, its dependencies are in three directions. Two of those directions are empty, but this direction there is a dependency. So I can't fill up this square directly. The only square I can fill up directly is this one because it has nothing to its right, nothing diagonally, and nothing below. So I start from there, so I start from there and I put a zero, and as before we can go down this because now once we have this we have everything to its left. And once we have this and because we are beyond the word, we are at this dummy position, the row and column becomes zero. But the important thing to remember is the row and column become zero, not because they have no dependency, but because we can systematically fill it up exactly like in the grid paths, we can fill up the bottom row and the leftmost column there, here the rightmost column. Now once we have this we can fill up this point. And then again, once we have three entries, we can fill up this, we have three entries, we can fill up this, we have three entries, we can fill up this so we can up this column and we can do this column by column and we propagate it. And then finally the value that propagates here is our longest length of the longest common subsequence. We could also do this row by row. Now how do we trace out the actual solution? Well, the solution grows whenever we increment the number. So we can ask why is this four? So we say that this is four because, not because we did one plus three, because s is not equal to b, which is four because we got the max value from here. Why is this four? Again I is not equal to s, so we got the max value from here. Why is this four? O s is equal to s. We must have got it by three plus one. Why is this? Because e plus c, so we must have got it from here. So we follow the path according to the choices that we made in applying the inductive function in order to generate the value at each point. So in other words, for each cell ij that we write, we remember whether we wrote it because it was one plus the diagonal neighbor, or the maximum of the left and the right, in which case we record whether the left or the bottom was the maximum we picked. Now, in this picture, every time we take a diagonal step, it means we actually had a match. So this is a match. Okay, the first one here is a match, s equal to s. This is a match equal to e. This is a match, c equal to c. Now, after this point, we are flat, and then at this point again, we have a match. So we get scc and t right. So we can read off the diagonal steps along this kind of explanation of the longest number, largest number we got, and each diagonal step will contribute to the final solution. Now, there could be more than one, so because we haven't got an example in this case, but sometimes the max could be one of in both directions. If I'm taking the max of the left, the right neighbor and the bottom, they could be the same. So I could have a situation like this. Supposing I landed up here, then I don't know whether I got it from here or from here. So I might have two different extensions which lead me to a solution. So, the longest common subsequence need not be unique, but you can recover at least one by following this path. So here is the Python code. It's not very different from the earlier one, so we can just see you just initialize the last row and the bottom row and the last column, and then as before, you walk up row by row, column by column, and fill in using the equation. And in this case, we don't have to keep track of the maximum value and keep updating because the maximum value automatically propagates to the value. So just like the longest common subword here, once again we are filling in a table of size m times n. Each entry only requires us look at most three other entries, the one to the right, the one to the bottom, right in the diagonal, and the one below. So it's a constant amount of work. So mn entries, constant amount of work per entry. So this takes time. M times n.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
manipulating lists.mp3,"You. So let's take a closer look at lists. Now, we said that lists are mutable objects. So if we have a list called list one, whose values are 1356, and then we assign list one to the name list two, then we said that both list one and list two, in this case, because lists are mutable, will be pointing to the same list 1356. So now if I take the position two, which is this position, and replace it by the value seven, then clearly list one is 1376. But because list two and list one were pointing to the same object, we have that list two also has the same value, 1376. On the other hand, if we made this change in a more roundabout way, so what we did was we took this list and then we first took its slice 13 from zero up to position one, not two. So I get one three, then I insert a seven, and then I take from position three onwards, which is six, then I also get 1376 in list one. But on the other hand, because I used plus, what I've done is I've created a new list and therefore list two has not changed. In this case, list two remains 1356. So in other words, concatenation using plus results in producing a new list. So let's check this in the python interpreter. So if I say list one is equal, 1357, for example, or five, six, and I say list two is equal to list one, and then I just change the position two of list one, then list one and list two are both 1376. On the other hand, if I say list one is equal to 1356 as before, and list two is equal to list one, and now I change list one in this slice plus concatenation way. So if I say take the first two positions, then put a seven and then take the rest of list one's. So now list one is again 1376, but list two, which was pointing to list one, is no longer pointing to list one because the plus has created a new list. And so the new list is not the same as the old list. So list two continues to point at the old list, so it's 1356. So this is an important point that one has to keep in mind regarding mutability. If we start reassigning a list using plus, we get a new list. This also applies when we do it inside a function. If inside a function we want to update a list, then so long as we don't reassign it, we are okay. But if we put a reassignment using plus, then the list that is being updated inside the function will not reflect outside the function. So we always have to be very careful about this. Now, how would we go about extending a list? Suppose we want to stick a new value 22 at the end of a list. One way to do this is to say l is l plus 22. But as we saw, this plus operator will create a new list. So if we wanted to append a list, a value to a list, and maintain the same list, so that, for instance, if it's inside a function, we don't lose the connection between the argument and the value being manipulated inside the function, this would not do. So we saw this function append in passing when we did gcd in the very first week. So, append is a function which will take a list and add a value to it. So here we have said list one is 1356, as in the previous examples, list two is list one, and now we have said take list one and append twelve. So list one, the way we write it, is list one, dot append. And in append we give the argument the new value to be appended. So what this does is of course, we make list one. Now, a five element list with the original 1356, and a new value, twelve at the end. But importantly, this is the old list one. It's not a new list in that sense. So list two has also changed. So append actually adds a value in place. Both list one and list two point to the new list with twelve at the end. On the other hand, if we had done it like I mentioned, using the plus operator, then we would find that list one changes, but list two does not, because as we saw before, concatenation produces a new list. So, append is a function which extends a list with a new value without changing it. Append takes a single value. Now, what if we wanted to append not a single value, but a list of values? We wanted to actually take a list and expand it by adding a list at the end. We had say one, three, five, and we wanted to put 6810. So we won't take one, three, five, and we wanted to expand this to have three more values. So of course we can append each of these values one at a time. But there is a function which is provided which like append, extends a list. But here this must be a list itself. So, list extend takes a list as an argument. Append takes a value as an argument. So list one extend list two is the equivalent of saying list one is equal to list one plus list two. But remember that this must be a list. Okay, it's not a single value, it's not a sequence of values. So this must be given in square brackets. You must give 6810 as an argument to the extend function. Now this is to add elements to a list. There is also a way to remove an element from a list. So this is one way to remove it by specifying the value. So we are not looking at a particular position, we are looking for a value x and list one. Remove x removes the first occurrence of x in the list. Now you may ask, what happens if there is no occurrence of x in the list? Well, in fact, this will give us an error. So you have to be careful to use remove only if you know that there is at least one copy of x. And remember, it only removes the very first occurrences. It doesn't remove all the occurrences. So if there are ten occurrences of x in list one, only the very first one will be removed. So let's explore these things. So let us start say with list one. So remember from the previous lecture we said we can take range and produce a list. So now if I do this, I have list one is zero, one up to nine. Now if I say list one, append twelve, then list one is appended with twelve. Now if I say list one, extend, say 1314. Then list one now has 1314 at the end, right? So this is how append and extend work. Now supposing, just for the sake of argument, I take list two and I make two copies of list one. So now list two goes from zero to 14, with a gap of course, in between a ten and eleven, again from zero to 14. Now if I say list two, dot remove say five. Now there are two copies of five. Remember the first copy which is here at the beginning, and a second copy which is later. So this will remove the first copy. So now if I look at list two, the first one skips from four to six, but the second copy is still there. If I say it again, then both copies are gone because I don't have this four six, and I also don't have a five. Here again it's four six. Now what happens if I remove it a third time? Now I get an error saying x is not in the list. So remember that remove works only if x is in the list. If it's not in the list, you get an error. Now it's important. We'll see later that when you get an error, it also has a name. It says it's a value error. Okay, so this will be useful because later on we will find that within Python, we can actually examine errors and take alternative action if an error occurs, and we can signal what type of error it is by looking at the value that the error returns. So the append function looks a little bit different from the other functions we have seen so far. We would normally expect a function append to take two arguments, the list and the value to be appended. So we would think that the correct way, or the natural way to write append would be to say append two, list one, the value x. On the other hand, what we have is this funny notation which says to list one, apply the function append with value x. So in Python terminology, list one is an object and append is a function to update the object, and x is first an argument to the function append. So in such a situation we have an object and we then apply a function to it. So we use the function attached to the object by using the dot notation rather than passing the object to the function, which is a more normal way in which we think of functions. So we will come back to this point later on, in maybe two, three weeks from now when we look at what is called object oriented programming within Python. So there is another way to expand and contract lists in place, and this is by directly assigning new values to a slice. So we go back to our old example. List one is 1356 and list two is list one. Now what we are saying is that take the slice from position two onwards and assign it a value 78. So remember the positions are 0123. So what this is saying is take this slice, namely five six, and replace it by seven eight. So what we get is that of course list one, the slice 56 is replaced by seven eight. But this slice replacement happens in place. So it's a bit like assigning a new value at a given position. If I say list two is equal to seven, we said that position two becomes seven. So in the same way, if I say that list one from slice two to the end becomes seven eight, it changes five six to seven eight both in list one. But it also does not change where it's pointing to. So list two also gets affected. So both of them now say 1378. Now here we had a slice of length two and we replaced it by a new list of length two. So we preserved the structure of the list in terms of the number of positions. This is not required. Python allows you to both expand and shrink a slice. So for instance, you could have taken that list. Now let us say we have this list 1378, and again we want to take the slice two onwards, which has two positions, and we can say replace it by a list with three values. So we are saying take this list, take the slice from two to three, the last two positions, and replace with three values. And what we get is the old one three. And this slice has now become 910 eleven. So we had a four element list, it's become a five element list. So this is one way to expand a list in place using a slice. The other thing we can do is shrink a list. We can put a smaller thing. So supposing we want the list to have just one value in the position zero and one. So we take the slice zero to two, which will give us these two positions. So now we have a slice of length two, but we assign it a list of length one. So this 13 is replaced by just a single seven. So now we had a list of length five after the previous expansion, which has now become a list of length four after this contraction. So with slices you can replace a slice in place. This can produce a bigger list or a smaller list depending on what you put in. But as you can imagine, this can be very confusing. So you should be careful that you know what you're doing if you're trying to directly update slices in the list. One of the very common things that we want to know about a list is whether a value exists in a list. So Python has a very simple expression called x in L. So x in L returns true if the value x is found in the list l. Now we can use this, for instance, to make our remove a safe operation. Before we invoke L dot remove x, we first check that X actually is an l. So if x is an l, then the condition will be true and only then will we try to remove it. If X is not an l, then we won't remove x. So in this case we are guaranteed that L dot remove will not be called in an error prone context where it will say there is no x in L. Also recall that remove removes only the first element. So we can replace this if by a while and say that so long as there is a value x and l, keep applying remove. So this will, in one short remove all the X's and l. Because every time we remove an x, we go back and check if there is still an x and l. There's still an x and l, we remove it. So from left to right this loop will remove all the X's and l. Now there are a host of other functions defined for lists. For instance, L dot reverse will reverse a list in place. L dot sort will sort a list in ascending order. You can also sort it in other orders. You can look up and see how to do that. If we only want to know where an element is in l, we set x and L, but if we want to know where it occurs, then we use index. It'll find the leftmost position, but again, it will give us an error if there is no x in the list. So we should first check if x and L, and then find the index of the leftmost position. Now you might want not the leftmost, but the rightmost position. So there is an r index, and there is a host of other functions, and you must look up the Python documentation. There is no way that this course, or any course, can cover every function which is defined in Python for every type. So you do have to look up the documentation. And if you think that there should be a function which does something natural, very often there will be. So try and look it up and see for yourself how it works and try to use it. If you have a question like what happens if I do this? Well, Python is an interactive language. What happens if I do this? Just try it out and see, and try to figure out from what you see in the interpreter how the function works, in case there seems to be some ambiguity in the documentation. But above all, don't be afraid to see the documentation. Only by looking up at documentation will you be able to learn the pipe functions that you need, because it's very difficult, as I said, to say upfront, every possible function that is there. So a final point regarding lists is something we talked about in passing, which is that since names do not have types in Python, we don't have to announce a name. Names just pop up as the code progresses. So every time a name pops up, Python needs to know what value it is. So typically, the first time we use a name, we have to put it as part of an assignment. We have to assign a value to it, and that value has to be something which is computable given the current names. So if we want to assign, for instance, to the name y, the expression x plus one, at this point, implicitly x must have a value, otherwise x plus one cannot be evaluated. So if x has not been seen before, and for the first time in my code, I see it on the right hand side of an assignment, it means that I'm expected to produce a value for x, but no value has been assigned so far, and this will give you an error. So this is quite easy to spot. So when you write something and you see something on the right hand side, and you have not seen it before, then it means that Python will flag an error, and it's not very difficult to understand why this is. So now the kind of list functions we saw now it's a bit more subtle. When I say l dot append v, there is no equal to sign. So it's not immediately obvious that l dot append v requires l to already be having a list value. Why can't I just append v, for example, to an empty list? Well, of course I can append v to an empty list, but how does Python know that l is an empty list? So Python needs to know that l is a list before it can apply this append function. So we saw this small function earlier which computes the factors of n. So essentially what it does is it takes all numbers in the range one to n. So I take one to n plus one, so that I run through the sequence one to n, and if a number divides n evenly, if there is no remainder, I've used the append function now to append I to the list of factors, which I will return. So now the catch with this is that when I come for the first time to this statement, the first factor, which will be one, of course, because one will always be a factor. Python will have to ask why f list has the ability to append a value, because f list has never been encountered till this point. So we were careful when we wrote the code. Of course we use plus because we did not use append in that code, but it's the same thing. So we have to be careful to insert this initialization. So this initialization is only needed to tell Python when this first append happens that it is indeed the case that f list is of type list, and therefore the append function is a valid function to apply to this name. Without this you will get an error. So just remember that you always have to make sure that every name that you use is initialized to a value the first time, so that whenever it appears later on the value is clear. And therefore what operations are allowed for this name are also clear to Python. So to summarize, what we saw is that we can extend lists in place using functions like append, extend, and so on. We can also assign a new value in place to a slice of a list, and in the process expand or contract the list. But this is something to be done with care. You must make sure you know what you're doing on there are several built in functions on list. We will see some of them as we go along and use them and describe them as we see them, but it's impossible to document all of them and to go through all of them. And it's also very boring to just list out a list of bunch of functions. So do look up the tutorial and other documentation which is available, which I mentioned in the earlier weeks, so that you can find out what kind of functions are available. And finally, don't forget that you must assign a value to a name before it is first used. Otherwise, because names do not themselves have types, Python will not know what to do with the given value with a given name.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
matrix multiplication.mp3,"It. So this is a final example to illustrate dynamic programming. So we look at the problem of matrix multiplication. So if you remember how matrix multiplication works, you have to take two row two matrixes with compatible entry. And then we compute a new matrix in which for each entry there, we have to multiply a row here up by a column of the same length and add up the values. So if we have a matrix which is m by n, then this must have n times p, so that we have a final answer which is m times p. So in the final entry we have to make mp entries in the final product matrix. And each of these entries require us to compute the sum of these n entries. So that takes us order n time. So with total work is usually easy to compute as m times n times p. So Abij is this long sum, and this sum has one, two, three up to n entries. So, computing matrix multiplication for two matrices has a very straightforward algorithm which is a product triple nested loop which takes order m times n times p. If all of the dimensions are same. This is an order n cubed algorithm. Now there are more clever ways of doing it, but that's not the purpose of this lecture. But the naive, straightforward way of multiplying two matrices is m times n times p. Our interest is when we have a sequence of such multiplications to do so, supposing we want to multiply three matrices together, a times b times c. Then it turns out it doesn't matter whether we first multiply ab and then multiply c, or we first multiply a and then multiply Bc. Okay, a times Bc. Because this is stated as the associated property, the order in which we group the multiplication doesn't matter. Just for normal numbers, if we do six times three times two, it doesn't matter whether you do six times three first or three times two first. Finally, the product is going to be the same, so the bracketing doesn't change the answer. The final value is the same. But it turns out that it can have dramatic effects on the complexity of computing the answer. Why is this the case? So suppose we have these matrices a, B and C, and a and B have these columns and rows. So A has basically got one by 100. It just has one row and 100 columns, and B has 100 rows and one column, and C has again one row and 100 columns. So these are matrices which look like this. What happens is that when I multiply b times C, then I get something which is 100 into one into 100. So we'll get an output which is 100 by 100 matrix. So that has 10,000 entries. So it's going to take us 10,000 steps. Now when I multiply A by this, I'm going to get one into 100 into 100, that's another 10,000 step. So if I do a, after I do Bc, then I do 10,000 per 10,000, so I do 20,000 steps. Now, if I do it the other way, if I take a times B first, then this whole thing collapses into a one by one single entry. So I get one into 100 into one. In 100 steps, I just collapse this row and this column into a single entry. That's like computing one entry in a matrix multiplication. The resulting thing is exactly that one entry. Now I have this one entry, and again I have to multiply it by this thing, and that will take me for each of the columns in this, I will get one entry, so that will take me 100 steps. So I take 100 steps to collapse this a into b into a single cell, another 100 steps after that to compute that product into c. So instead of 20,000 steps, I've done only 200 steps. So this is the way in which the sequence of multiplications, dome multiplication, is associative. And it doesn't matter what you do, you will get the same answer. The sequence in which you do the associative steps can dramatically improve or worsen the amount of time you spend doing this. So in general, we have a sequence m one to mn, and each of them has some rows and columns. And what we are guaranteed is that each adjacent pair can be multiplied so r one c one r two c two. The first two are such that c one is equal to r two. The number of columns in the first matrix is equal to the number of rows in the second matrix. Similarly, c two is equal to r three and so on. So these dimensions are guaranteed to match. So the matrix multiplication is always possible. Our target is to find out in what order we would do it. So we can at best do two matrices at a time. We only know how to multiply a times B. We cannot take three matrices and directly multiply them. So if we have to do three matrices, we have to do it in two steps, a times b and then c, or b times c and then a. Now, same way with n matrices, we have to do two at a time. But those two at a time could be complicated things. I could do m one two, then I can combine that and do that combination with three, or I can do m one two, m three four, and then do combination of m one two multiplied by m three, four, and so on. So what is the optimal way of computing the product? What is the optimal way of putting brackets? In other words, brackets are what tell us. So when we say m one m two, m three m four, then one way of computing it is to do this, do m one m two, then m three m four. Another way of doing it would be to say do m one m two, and then do that multiplied by m three and then m four. Okay? And so on. So different ways of bracketing correspond to different evaluation orders for this multiplication. And what we want to do is kind of calculate without doing the actual computation, which is the best sequence in which to do this calculation, so that we optimize the operations involved. So what is the inductive structure? So finally, when we do this, remember, we only do two at a time. So at the end we must end with a multiplication which involves some group multiplied by some group. It must look like this. I must have this whole thing correcting to some m one prime, and this whole thing correcting to m two prime. And I'm finally multiplying m one prime by m two prime. In other words, m one prime is some, for some k it is from m one all the way up to mk, and m two prime is from k plus one up to n. Right? So this is my m one prime and this is my m two prime. And this k is somewhere between one and n. So in the worst case I could be doing m one and on the other side I can do, I could have done m two up to n whole thing. So this whole thing is my, the other worst cases I could have done m one to not worst but extreme cases, m into m one to m minus one, I might have already computed, and now I want to finally multiply it by mn, or it could be anywhere in between. So if I just pick an arbitrary k, then the first one has r one rows ck columns. The second one has rk plus one rows cn columns. But we know that ck is equal to rk plus one. So this matrix will work. So the final computation is going to be r one into ck into cn, m into n into p, the rows into the column common number of column, and row into the final number of columns. So this final multiplication, we know how much it's going to cost. And to this we have to recursively add the inductive cost of having computed the two factors, how much time did it take us to take m one prime? How much time did it take us to m two prime. So we have that the cost of m one splitting at k is the cost of m one to mk plus the cost of mk plus to mn plus the last multiplication r one into ck to cn. So clearly this cost will vary for different k's. And there are many choices of k. As we said, there are n minus one choices of k. Anything from one to n minus one, we can choose a sk. So there are n minus one subproblems. So we, then we did the longest common subsequence problem. We had two subproblems. We could either drop the first letter AI or the second letter Bj. And then we had to consider two subproblems. We had no way of knowing which is better. So we did them both and took the max. Now here we have n minus one different choices of k. We have no way of knowing which of these k's is better. So again we try all of them and take the minimum. There we were doing the maximum because we want the longest common cell sequence. Here we want the minimum cost. So we choose that k which minimizes this split. And recursively, each of those things would minimize their split and so on. So that is the inductive structure. So finally we say that the cost of multiplying m one to mn is the minimum for all choices of k. Of the cost of multiplying m one to mk plus the cost of multiplying k plus one to mn plus. Of course, for that choice of k, we have to do one final multiplication, which is to take these resulting submatrices, so that is r one into ck into cl. So now when we take this, so we have m one to mn. So we have picked m one to mk. Then, as before, what will happen is that we'll have to split this somewhere. So we will now end up having some segment which is neither m one nor mn. It starts at some mj and goes to mk. So in general we need to express this quantity. For arbitrary left and right points. We can't assume that the left hand point is one. We can't assume the right hand point is n. So in general, if we have a segment from mi to mj, then we want the smallest value of, among all the values of k from I to j minus one. We want the minimum cost which occurs from computing the cost of mi to mk and mk plus one to mj, and the cost of this final multiplication, which is ri into ck into cj. So this quantity we will write as cost ij. Cost ij is the cost of computing the segment from mi to mj, which involves picking the best k. So mi to mj is called cost I j. And we use the same recursive inductive definition. Choose the best k. So the base case, well, if you are just looking at a segment of length one, supposing we just want to multiply one matrix from one to one, or three to three, or seven to seven, nothing is to be done. It's just the matrix that there's no multiplication of. The cost is zero. So we can then write out this cost I j equation saying the minimum over k of cos I k plus cos k plus one j plus R-I-C-K cj, which is the actual multiplication. And of course, I is always going to be less than equal to j because we are doing it from left to right. So we can assume that the segment is given to us with two endpoints where I is less than or equal to j. So if I is less than or equal to j and we look at cos I j as a kind of matrix, then this whole area where I is greater than j is ruled out. So we only look at this diagonal, and the entries along the diagonal are the ones which are of the form I comma I. So all these entries are initially zero. There is no cost involved with doing any multiplication from position j to position j along this diagonal. Now, in order to compute I comma j, I need to pick a k and I need to compute for that k, all the values. And you need to compute I k. So it turns out that this corresponds to saying that if I want to compute a particular entry I comma j, then I need to choose a good k. And in order to choose a good k, so this I can express in many different ways. So I can say pick. So for example, supposing I want to compute this particular thing, then I have to say, okay, pick this entry I to I, and then I want the entry I plus one to j. So I have I plus one to j this entry. So these two entries I have to sum up. Otherwise I have to take this entry and sum it up with this entry. So in general, if I have a thing there, I'll say okay, if I choose this entry as my k point, then I must add this entry to get it up and take this sum, or I have to take this entry and add this this entry and then add this and so on. So in general we could have order n values. I need to compute for this. I need to compute, I need all the values here and I need all the values here. So I need something to the left and to the bottom. But if I start from the diagonal, then it becomes easy, because I can actually say that if I have initially these values filled in, this is the base case. Then to the left and below, I can fill in this because I know its values to the left. I know this value to the left and below. So I can fill up this diagonal. So in the next step, I can fill up this diagonal because I have all the values to the left and below. Now, at this entry, I have the values to the left and below. So I can fill up this diagonal. So I can fill it up diagonal by diagonal. So this is the order in which I can fill up this table using this inductive definition, because this is the way in which the dependencies go. So this is the code for this particular thing. So you can go through it and just check. The only thing that you need to note is that we have used some. So what we are doing is when we compute, as we said, one entry. So supposing we are computing this one entry, then we want to compute the minimum across many different pairs. This entry, this entry and so on. So, remember what we did when we computed the maximum longest common subword? We assumed that the maximum was zero. And every time we saw a bigger value, we updated it. Here we want the minimum entry. So what we do is we assume the minimum is some large number. And every time we see an entry, if it is smaller than the minimum, we reduce it. So that's what's happening here. When we start the loop, we assume that the value for RC is actually infinity. Now, what is infinity? Well, you can take infinity so that we can take, for instance, the product of all the dimensions that appear in this problem. You know that the total dimension will not be more than that. So you can take the product of all the dimensions. You can take a very large number, it doesn't matter something relative to what you have problem as. So we have defined it in the code. But the important thing is they're computing minimum. So instead of starting with zero and updating it, when you do maximum, you start with a large value and keep shrinking it. So every time we find a sub problem which is smaller than the current value that we have seen, then we replace that value as the new minimum. So that's all that's important here. Everything else is just a way to make sure that we go through this table diagonal by diagonal. And for each diagonal, we scan the row and the column and compute the minimum across all pairs in that row and column. So, as with this lcs problem, we have to fill an order n squared size table. But the main difference between lcs and this is that in order to fill an entry in the lcs thing, we had to look at only a constant number of entries. So order mn or order n squared. But the point was each entry takes constant time. So the effort involved is the same as size of the table mn table or takes mn time. Now, here, unfortunately, it's not the case. Right. So we saw that an entry will take time proportional to its distance from the diagonal. So in general, that will add an order n factor. So though we have order n squared by two entries, actually order n squared entries, we have to account for order n work per entry, because each entry has to scan the row to its left and the column below, not just one entry away from it. And so this whole thing becomes order n cubed and not order n squared. So this is some point to keep in mind that there could be problems where the complexity is bigger than the table size. So all the examples we saw before, that's the reason to do this example. In all the examples we saw before, in Fibonacci, we had a table which is linear in n, and it took time, linear n to fill it up for the grid path. And for longest common subsequence, we had tables which were n by n, but it took only n by n time, or m by n time to fill them up. Here we have a table which is n by n, but it takes n cubed time to fill it up. Because each entry requires more than constant time. It actually takes time proportional to n.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
memoization and dynamic programming.mp3,"You. So we saw earlier that inductive definitions often provide a nice way to get a hold of the functions we want to compute. Now, we are familiar with induction for numbers. So for instance, we can define the factorial function in terms of the base case f of zero, and in terms of the inductive case, saying f of n is n times factorial of n minus one. What we saw is we can also define inductively functions on structures like lists. So for instance, we can take as the base case an empty list. And in the inductive case we can separate the task of sorting a list into doing something with the initial element and something with the rest. So, insertion sort can be defined in terms of the insert function as follows. So isort of the base case or the empty case just gives us the empty list. And then if we want to sort a list with n elements, we pull out the first element and then we insert it into the result of inductively sorting the rest. So this is a very attractive way of describing the dependency of the function that we want to compute the value that we are trying to compute on smaller values. And it gives us a handle on how to go about computing it. So the main benefit of an inductive definition is that it directly yields a recursive program. So we saw this kind of a program for factorial, which almost directly follows a definition saying that f of zero is one and f of n is n into f of n minus one. So we can just directly read it off more or less, and translate it. The only thing we have done is we have taken care of some error case where if somebody feeds a negative number, we will still say one and not go into a loop. So in general, when we have such inductive definitions, what we do is we have subproblems that we have to solve in order to get to the answer we are trying to reach. So for instance, to compute factorial of n, one of the things we need to do is compute factorial of n minus one. So we call factorial of n minus one a sub problem of factorial n. Now in turn, factorial of n minus one requires us to compute factorial n minus two. So actually, if you go down the chain, the factorial n subproblems are all the factorials for values smaller than n. Similarly, for insertion sort, in order to sort the full list, we need to sort all the elements, excluding the first one, what is called the tail of the list. And in turn we need to sort its tail and so on. So in general, when we do insertion sort, we will find that we need to sort things a segment of the list so we can in general talk about xi to exchange. And in all these cases, what the inductive definition tells us is how to compute the actual value of f for our given input y by combining the solutions to these subproblems. For instance, in factorial, we combine it by multiplying the current input with the result of solving it for the next smaller input. For insertion sort, we combine it by inserting the first value into the result of solving the smaller input that is the tail of the list. So let us look at one particular problem which will highlight an issue that we have to deal with when we are looking at inductive specifications and naively translating them into programs. So the Fibonacci numbers are a very famous sequence which were invented by Fibonacci and they occur in nature and they are very intuitive and most of you would have seen them. So the Fibonacci numbers are zero, one, and then you add. So one plus one is one plus zero is one, one plus one is two, three, five, and so on. So you just keep adding the previous two numbers and you go on. So the inductive definition says the zero th Fibonacci number is zero. The first Fibonacci number is one, and after that for two onwards, the nth Fibonacci number is obtained by adding the previous two. So the Fibonacci number two is fibonacci one plus Fibonacci zero. So as before, we can directly translate this into an inductive. Into a recursive program we can just write a Python function fib which says if n is zero or n is one, you return the value n itself. So if n is zero, return zero. If n is one, you return one. Otherwise you compute the value by recursively calling Fibonacci on n minus one and n minus two, add these two and return this value. So here is a clear case of an inductive definition that has a natural recursive program extracted from it. So let's try to compute a value and see what happens. So supposing we want to compute fibonacci of five using this definition. So Fibonacci of five will go into the else clause and say we need to compute Fibonacci of n minus one, namely four and n minus two, namely three. So Fibonacci of five leaves us with two problems. To compute Fibonacci of four and fibonacci of three. So we do these in some order. Let's go left to right. So we pick Fibonacci of four. And this in turn will require us to compute Fibonacci of three and Fibonacci of two by just applying the same definition to this value. Similarly, we go to the left of the two sub problems and fibonacci of three requires two and one, two requires one and zero. Now for one and zero. Fortunately, we can exit without making a recursive call. If n is equal to zero or n is equal to one, we just return the value. So we get back Fibonacci one is one and Fibonacci zero is zero. So with this we can complete the computation of Fibonacci two. We get value as one plus zero. In other words, one. So Fibonacci of two is one. Now we are back to Fibonacci of three. So we have computed for Fibonacci of three, the left case Fibonacci of two. And now we have to compute the right case. And once again we find the fibonacci of one. Being a base case, it gives us one. And now we can combine this and get Fibonacci of three is two. So now we are back to Fibonacci of four and we have computed the left side of Fibonacci of four. So we need to compute the right side. And now what happens is we end up having to compute Fibonacci of two again. Even though we already know the value, we naively have to execute Fibonacci of two, call one and zero again, propagate the values one and zero back up, add them up and get one. Now we can compute Fibonacci of four is two plus one three. And now we are finally back to the original call where we had to compute Fibonacci of four and Fibonacci of three. So we have done with four. So now we want to do Fibonacci of three. So notice that we have already computed Fibonacci of three, but this will blindly require us to call this function again. So we will again have to execute this full tree, go all the way down, go all the way up. And eventually Fibonacci of three will of course give us the same answer, namely two, which we already knew, but we would not take exploit or we would not take advantage of the fact that we knew it. And in this way we get three plus two. And so therefore Fibonacci of five is five. So the point to note in this is that we are doing many things again and again. In particular, in this particular computation, the largest thing that we repeat is Fibonacci of v. So as a result of this recomputation of the same value again and again, though, we in principle only need n minus one subproblems, right? If we have fib of five, we need two fiber, four fiber, three fib of two, and so on. So n sub problems down to fiber zero. But some of these subproblems, like in this case, Fibonacci of three, we compute repeatedly in a wasteful way. As a result, we end up solving an exponential number of subproblems, even though there are only order n actual problems to be solved. So what we want to do is move away from this naive recursive implementation of an inductive definition and try to work towards never reevaluating a subproblem. So this is easy to do. If we could only remember the subproblems that we had solved before, then all we have to do is look up the value we already computed rather than recomputed. So what we need is a kind of a table, a table where we store the values we have computed. And before we go and compute a value, we first check the table. If the table has an answer, we take the table's answer and go ahead. If the table doesn't have an answer, then we apply the recursive definition, compute it, and then we add it to the table. So this table is normally called a memory table to memorize. And from this we get this word memorization. So it is actually memo and not memorization. Memoization, in the sense of write yourself a memo, memo is like a reminder. Write yourself a reminder that this has been done before. So, memorization is the process by which, when we are computing a recursive function, we compute the values one at a time. And as we compute them, we store them in a table and look up the table before we recompute anything. So here is how our computation of Fibonacci of five would go if we keep a table. So this is our table here, right? So we have a table where, in some order, it doesn't really matter for now, in some order as and when we find Fibonacci of k, for some k, we just record it and notice that this table is empty. Even though we know the base cases, fibonacci of zero or Fibonacci of one are zero and one, respectively, we don't assume you know it because it'll come out as the first time we hit the base case, it'll come out of the recursive definition. So let's see how it goes. So we start Fibonacci of five. As usual. It says do four and three. Four says do three and two. Three says do two and one. Two says do one and zero. And now from our basic case, the base case in the function, we will get back that fib of one is one. So we store this in the table. This is the first value we have actually computed. Notice we did not assume we knew it when we came to it. In the base case, we put it into the table same way. Fib of zero is zero. We didn't know it before we put it in the table. Now we come up and we realize that fib of two is now available to us. It's one plus zero is one. So we store that in the table. We say for k equal to two, fib of k is one. Now we come back to fib of three. And now we go down and it asks us to compute fib of one again. Now, although this doesn't take us any work because it's a base case, we don't actually exploit that fact. We first look in the table and say, is there an entry for k equal to one? Yes, there is, and so we pick it up. So we highlight in orange the fact that this value was actually not recomputed, but looked up in the table. So from one plus one, we now have a fibonacci of three is two. Now we go back up to Fibonacci of four, and it asks us to compute the second half of its sub problems, namely fibonacci of two. Once again, we find that there is an entry for two in our table. So we mark it in orange and we just take the value from the table without expanding and computing the tree again, as we had done before when we did the naive computation. So now two plus one is three. So we have Fibonacci of four. So we have to now go back and compute the other branches. Fibonacci of three, but once again, three as an argument. K is in our table, so we have an entry here for three. So we can just look up Fibonacci of three and say, oh, it's two. So once again we mark it in orange. And so now we have fibonacci of three. Five is three plus two and that's five. And then now it's a new value. So we enter that. So notice therefore that every value we computed we expanded the tree or even looked up the base case only once, according to the function definition. Every subsequent time we needed a value, we just looked it up in the table, and you can see that the table grows exactly as much as there are sub problems to be solved. And we never solved a sub problem twice in the sense of computing it twice. We solved it by looking at the table. So this is a very easy step to incorporate into our Fibonacci table Fibonacci function. So we just add this red code. So the green lines are those new ones we already had before. So now what Fibonacci says is the first thing you do when you get a number is try and look up the table. So if there is a value Fibonacci of n which is defined, then return that value. Otherwise we go through the recursive computation. So this is the usual computation which will make a recursive call and eventually come up with a new value, which is the value for this particular n. So before we return this value back as a result of this function, we store it in the table. So henceforth, if this value n is ever invoked again, we never have to look up the thing, we never have to compute it. It will be in the table. So it's very simple. As we said, when you get an argument n for which you want to compute the function, you first store it and check the table. If it is there in the table, you don't do anything more, you just return the table value. If it's not in the table, you apply your recursive definition to compute it just like you would normally. HAvinG computed it, you first store it in the table so that future accesses to this function will work without having to do this recursion. And then you return the value, you compute it. So this can work for any combination of arguments. You just need a table. In PyTHon terms, you just need a dictionary for every combination of arguments. If that value has been computed before, that key will be there in our table. So this table in general in python would be a dictionary and not a list, because the arguments could be any particular values, they could, some could be strings, some could be numbers, they need not be continuous and so on. So we basically forgiven the particular combination of arguments. We look up whether that combination of keys is there in the dictionary. If so, we look it up and return it. OtherwIse, we compute a new value for this combination, store it, and then return it. So we have glossed over a FeW things. For instance, typically, if you want to really write this properly in python, we have to use some exceptions and all that, but this is more or less the skeleton of what we need to do. So this brings us to the main topic that we want to do this week in a couple of lectures, which is called dynamic programming. So dynamic programming is just a strategy to further optimize this memoized recursion. So this memoized recursion tells us that we will store values into a table as and when they are computed. Now it's very clear that in an inductive definition we need to get to the base case and then work ourselves backwards up from the base case to the case we have at hand. That means there are always some values, some base values for which no further values need to be computed. These values are automatically available to us. So we have some problems which have sub problems and some other problems which have no subproblems. So if a problem has a sub problem, we can't get the problem. We can't get Fibonacci of five unless we solve its sub problems, Fibonacci four and three. But if we have a base case like Fibonacci of one or fibonacci of zero, we don't have any subproblems, so we can solve them directly. So this is a kind of dependency. So we have to solve the subproblems in the dependency order. We cannot get something which is dependent on something else until that something else has been solved. But a little thought tells us that this dependency order must be acyclic. We cannot have a cycle of dependency. So one value like five depends on three, three depends on one and one, again depends on five, because there'll be no way to actually resolve this. So there will always be a starting point, and we can solve the sub problems directly in the order of the dependencies. Instead of going through the recursive calls, we don't have to follow the inductive structure. We can directly say, okay, tell me which are all the subproblems which don't need anything, solve them, which are all the ones which depend only on these, solve them and so on. So this gives us an iterative way. So if you look at the sub problem for fibonacci of five, for example, it says that it requires all these subproblems, but the dependency is very straightforward. Five depends on four and three, four depends on three and two, three depends on two and one. Two depends on one and zero, and zero and one have no dependencies. So we can start at the bottom and then work ourselves up. We can say, okay, fibonacci of zero needs no dependency, so let me write a value for it. Fibonacci of one needs no dependency, so let me write a value for it. Now we see that for Fibonacci of two, both the things that it needs have been computed. So I can write fib two in the table directly without even going to it from five. I'm not coming down from five. We are just directly filling up the table, just keeping track of which values depend on which value. So assuming that we know the function, we can calculate this dependency and just compute the values as and when the dependencies are satisfied. So now we have one and two, so we can compute Fibonacci of three, so we just compute it. We have three and four, so we can compute, I mean two and three, so we can compute Fibonacci of four, so we compute. And finally we have two and fib three and fib four, so we can get fib five. So this really, as you can see, becomes now a linear computation. I can just walk up from zero to five and fill in the values. In fact, this is what we do by hand, right? When you ask me for the 10th Fibonacci number, I can write it out. I can say, oh, zero, zero plus one is one, and then one plus one is two. Two plus one is three. 5813 21 34 so clearly it's not a very complicated process as it seems to be. When we have this exponential recursion thing, I can do it on the fly, more or less, because all I have to do is keep generating the values in a sequence. And this is the virtue of dynamic programming. It converts this recursion into a kind of iterative process where you fill up the values that you would normally fill up in the memo table. By recursion, you fill them up iteratively, starting with the ones which have no dependencies. So then the dynamic programming version of Fibonacci is just this iterative loop. So it says that you start from with value zero and one to be the values themselves. What we earlier said was that if n is zero or one, then you return n. So here we just store it into the table directly. We say fib table of zero is zero, fib table of one is one, and then we walk from two to n. So in python notation, the range n is n plus one. And at each stage we just take the ith value to be the sum of the I minus one I minus two values which we have already computed. Because we are going in this particular order, because we have recognized the dependency order goes from zero to n. And finally, the answer we need is the nth entry. So we just return that. So, to summarize, the basic idea to make naive recursion more efficient is to never compute something twice, and to never compute something twice. We store the values we compute in what we call a memo table. This is called memoization, and we always look up the table before we make a recursive call. Now this can be further optimized, so we avoid making recursive calls altogether, and we just directly fill in the table in dependency order, which must be acyclic, otherwise this problem will not be solvable. And this converts the recursive evaluation into an iterative evaluation, which is often much more efficient. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"mergesort, analysis.mp3","So in the last lecture we looked at merge sort, and we informally claimed that it was much more efficient than insertion sort or selection sort. And we claimed also that it operates in time order n login. So recall that merge sort has at its base a merging algorithm, which takes two sorted lists, a and b, and combines them one at a time by doing a scan over all elements. So in order to analyze merge sort, the first thing we need to do is to give an analysis of the merge function itself. How much time does merge take in terms of the input sizes of the two lists, a and b? So suppose a has m elements and b has n elements, and we want to put all these elements together into a single sorted list in c. Remember that we had an iteration where in each step of the iteration we looked at the first element in a and b and moved the smaller of the two to c. So clearly c grows by one element with each iteration. And since we have to move all m plus n elements from a and b to c, the size of c is m plus n. What do we do in each iteration? Well, we do a comparison, and then we do an assignment, and then we increment some indices. So this is a fixed number of operations, so it's a constant. So the total amount of work is proportional to m plus n. Now notice that m plus n is at most twice the maximum of m plus n. So if m is seven and n is 15, then five plus seven plus 15 will be less than two times 15. So we can say that merge as a function takes time of the order of maximum of m and n. And in particular, very often like in merge sort, we are taking two lists of roughly the same size, right? We divide a list into two halves and then we merge them. So if both m and n are of the same, approximately the same size, then the max of m and n is just one of them, n itself. So essentially merge is linear in the size of the input list. Now, having analyzed merge, let's look at merge sort. So merge sort says that if a list is small, it has zero or one elements. Nothing is to be done. Otherwise you have to solve the problem for two half lists and then merge them. As with any recursive function, we have to describe the time taken by such a function in terms of a recurrence. So let us assume for now, since we are going to keep dividing by two, that we can keep dividing by two without hitting an OD number in between. So let's assume that the input n is some perfect power of two. Its n is two to the k. When we break up merge, sort into two lists. We have two lists of size n by two. So the time taken for n elements is two times the time taken for two lists of n by two. And this is the merge component. We have an order n step which requires us to merge the two lists of size n by two. And remember we just said that merge is linear in the size of the input. So we have two subproblems of size n by two, that is the two times n by two. And we have merging, which requires order n. So, as with binary search and with recursive insertion sort, we can solve this recurrence by unwinding it. So we start with a base case. If we have a list of size one, then we have nothing to do. So t of one is one and t of n in general is two times t n by two plus n. So if we expand this out, so we substitute for t n by two, we get two times t n by four plus n by two. Because if we take this as the new input, this expands using the same definition. And if we rewrite this, so we write two times two as two squared, and we write this four as two squared, we will find that this is equivalent to writing it in this form, two into two, two squared, t n by two squared. And now notice that you have two times n by two over here. So this two and this two will cancel. So you have one factor of n and another factor of n. So the important thing is that you have a two here in the exponent, and you have a two here before the n. Now likewise, what we will do in the next step is to expand this two times t n by four. So we expand two times t n by four. That will give us another n by eight, which we write as n two cubed, and this which used to be two squared. Two n by two squared plus two n will turn out to be two cubed, two n by two cubed plus three n. So notice that the twos have become threes uniformly. So in this way, if we keep going after k steps or j steps, we'll have two to the j times t n by two to the j plus j times n. Now how long do we keep doing this? We keep doing this till we hit the base case. So when j is log of n, where log by log, we usually mean log to the base two. Then n by two to the j will be one. And so t by t of n by two to the j will also be one. So after log n steps, this expression simplifies to two to the log n plus log n times n. Everywhere we have a j, we put a log n and take this has become one and so it has disappeared. So we have two to the j, which is two to the login. Plus this j is login and then we have an n and this is two to the login by definition is just n. So two to the login is n and we have n login. And by our rule that we keep the higher term when we do big o n, login is bigger than n. So we get a final value of on login. For merge sort. Merge turns out to be a very useful operation. What we saw was to combine two lists faithfully into a single sorted list. In particular in our list, if we had duplicates, if we merge, say one three and two three, then we end up with a list of the form 1233. So this is how merge would work. It doesn't lose any information. It keeps duplicates and faithfully copies them to the final list. On the other hand, we might want to have a situation where we want the union. We don't want to keep multiple copies, we want to only keep one copy. So in the union case, here is what we would do. So let us assume that we have two lists, and in general we could have already duplicates within the list. So let's suppose that we have 1226 and two three five. Then we do the normal merge. So we move one here. And now when we hit two elements which are equal, then we need to basically scan till we finish this equal thing and copy one copy of it. And then finally we'll put three and then five and then six, right? So when a and AI is equal to bj, we increment both sides and make sure that we go to the end of that block. The other option is to do intersection. So supposing we want to take one two six and two six eight and come out with the answer two six as the common elements. Then if one side is smaller than the other side, we can skip that element because it's not there in both lists. So if AI is less than bj, we increment I. If bj is less than AI, we increment j. And if they're equal, we'd like union. We keep one copy of the common element. So merge can be used to implement various combinations, combination operations on lists. It can be used to take the union of two lists and discard duplicates. It can be used to take the intersection of two lists. And finally, as an exercise to test that you understand it, see if you can use merge to do list difference. So list difference is the following operation. If I have, say, 1236 and I have 2468, then list difference is all the elements in the first list which are not there in the second list. So two is there here and it is here. So you remove two six is there here and it's here. So remove two six. So you should get one three. So if this is a and this is b, then this is the so called list difference a minus b. See if you can write a version of merge which gives you all the elements in a which are not also in b, also known as list difference. So merge sort is clearly superior to insertion sort and selection sort because it is ordered n login and can handle lists, as we saw of size 100,000 as opposed to a few thousand. But that doesn't mean that merge sort does not have limitations. One of the limitations of merge sort is that we are forced to create a new array every time we merge two lists. There is no obvious way to efficiently merge two lists without creating a new list. So there is a penalty in terms of extra storage. We have to double the space that we use when we start with a list, and we want to sort it during merge sort. The other problem with merge sort is that it is inherently recursive. So merge sort calls itself on the first half and the second half. Now this is conceptually very nice. We saw that recursive definitions, recursive functions are very naturally related to inductive definitions, and they help us to understand the structure of a problem in terms of smaller problems at the same time. Now, unfortunately, a recursive call in a programming language involves suspending the current function, doing a new computation, and then restoring the values that we had suspended for the current function. So if we currently had values for local names like ijk, we have to store them somewhere and then retrieve them and continue with the old values when the recursive call is done. So this requires a certain amount of extra work. So recursive calls and returns turn out to be expensive on their own time wise. So it would be nice if we could have both the order n log and behavior of merge sort, and we could do away with this recursive thing. But this is only a minor comment. But conceptually, merge sort is the basic order analog and sorting algorithm, and it's very useful to know because it plays a role in many other things, indirectly or directly. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
mergesort.mp3,"You. Last week we saw two simple sorting algorithms, selection sort and insertion sort. These were attractive because they corresponded to the manual way in which we would sort items by hand. On the other hand, we analyzed these to see that the worst case complexity is order n squared, where n is the length of the input list to be sorted. And unfortunately, n squared at sorting algorithms are infeasible for n over about 5000 because it will just take too long. And on the other hand, 5000 is a rather small number when we are dealing with real data. So let's examine a different strategy altogether. So suppose we had the example where you were a teaching assistant and you were supposed to sort the answer papers for the instructor. Supposing the instructor had not one teaching assistant but two teaching assistants, and the job is distributed to the two teaching assistants. So each one is told to go with half the papers, sort them separately and come back. And then the instructor has to put these two lists together. So in other words, you divide the array initially, the unsorted array, or list, into two parts, and then you hand over these two parts to two different people or two different programs if you want to sort. So you sort these two halves separately. And now the key is to be able to combine these two sorted things efficiently in a single sorted list. So let's focus on the last part. How do we combine two sorted lists into a single sorted list? Now, this is again something that you would do quite naturally. So supposing you have the two outputs from the two teaching assistants, then what you would do is you would examine, of course, the top paper in both. Now, the top paper on the left hand side is the highest mark on the left hand side. The top paper on the right hand side is the highest mark on the right hand side. So the maximum among these two is the top overall. So you could take the maximum, say, this one, and move it aside. Now you have the second highest on the right hand side and the first the highest on the left hand side. Again, you look at the bigger one and move that one here and so on. So at each time you look at the current head or top of each of the lists and move the bigger one to the output. And if you keep repeating this until all the elements are over, you will have merged them, preserving the sorted order overall. So let's examine how this would work in a simple example here. So we have two sorted lists. 32, 74, eightynix. So we start from the left and we examine these two elements initially and pick the smaller of the two because we're sorting in ascending order. So we pick the smaller of the two, that's 21. And now the second list has reduced to two elements. So at the next step we will examine the first element in the first list and the second element in the second list, because that's what's left. So among these, 232 was smaller, so we would move 32. Now 55 is the smaller of the two at the head. Now 64 is the smaller of the two at the head. Notice we have reached a situation where the second list is empty. So since the second list is empty, we can just copy the first list as it is without having to compare anything, because those are all the remaining elements that need to be merged. So having done this, now that we have a procedure to merge two sorted lists into a single sorted list, we can now clarify exactly what we mean by merging the things using merge sort. So merge sort is this algorithm which divides the list into two parts and then combines the sorted halves into a single part. So what we do is we first sort the left hand side. So we take the positions from zero to n by two minus one, where n is a length. So this is left and this is the right. Now, one thing to note is in python notation we use the same subscript here and here, because this takes us to the position n by two minus one. And this will start at n by two. So we will not miss anything, nor will we duplicate anything. So it's very convenient. So this is another reason why Python has this convention that the right hand side of a slice goes up to the slice minus one. So if we write something like this, we don't have to worry about whether we have to do plus one minus one. We can just duplicate the index of the right hand side and the left hand side, and it will correctly span the entire list. So what we do is this is a naturally recursive algorithm. We recursively use this algorithm to sort the first half and the second half, and then we merge these two sorted halves into the output. So the important thing is we keep repeatedly doing the same thing, we keep halving, sort the half, sort the other half, and merge. And when do we reach a base case? Well, when we reach a list which has only one element or zero elements, there's nothing to sort. So in such a situation we can just return the list as it is and then rely on merging to go ahead. So once again, let's look at an illustrative example. Supposing we have eight items to sort, which are organized like this. The first step says divide it into two and sort each separately. So we divide it into two groups. We have the left half and the right half. Now these are still things which you don't know how to sort directly. So again we divide into two. So the left half gets divided into two further subdivisions and so does the right. Now we have lists of length two. We could sort them by hand, but we say that we don't know how to sort anything except a list of length one or zero. So we further break it up. So now we have trivial lists 43 and 32 on the left, 22, 78 and so on. So we end up with eight lists of length one which are automatically sorted. At this stage, the recursion comes back and says, okay, you have sorted the sublist 43. For example, for this list we have sorted the left into 43 and the right into 32 in a trivial way. So we need to combine them by merging. So we merge 43 and 32, applying our merge procedure, and we get 32 before 43. When we merge 22 and 78, they remain in the same order. Here, 57 comes before 63 and finally 13 comes before 91. So now at this level we have two lists of length two which are sorted and so they must be merged. And similarly, here we have two lists of length two which are sorted and they must be merged. So when we merge the first pair, we get 22 followed by 32 followed by 43 followed by 78. And similarly here we get 13 followed by 57 followed by 63 followed by 91. So after doing these two merges, we have now two lists of length four, each of which are sorted. And now we will end up picking from this 13 and then, so this is 13, and then we'll pick 22, and then we'll pick 33, 32, and then we'll pick 57 for 43, then 57, then 63, then 78 and then 91. Right, so this is how this recursion goes. You first keep breaking it up down till the base case, and then you keep combining backwards using the merge. This strategy that we have just outlined for merge sort is a general paradigm called divide and conquer. So if you have a problem where you can break the problem up into subproblems which do not have any interference with each other. So here, for instance, sorting the first half of the list and sorting the second half of the list can be done independently. You can take the papers assigned by the instructor, give them to two separate teaching assistants, ask them to go to two separate rooms. They don't need to communicate with each other to finish sorting their halves. So in such a situation, you break up the problem into independent subproblems and then you have an efficient way to combine the solved subproblems. So that is the key that how efficiently you can combine the problems. If it takes you a very long time to combine the problems, then it's not going to help you at all. But if we can do it in a simple way like this merge sort where we do the merging by just scanning the two this from beginning to end and assigning each one of them to the final thing as we see it, then you can actually derive a lot of benefit from divide and conquer. So let us look a little more in detail at the actual algorithmic aspect of how we are going to do this. So first, since we looked at merging as the basic procedure, how do we merge two sorted lists? So as a base case, if either of them is empty, as we saw in the example, we don't need to do anything, we just copy the other one. So we are taking two input lists, a and b, which are both sorted, and we are trying to return a sorted list c. So if a is empty, we just copy b into c. If b is empty, we just copy a into C. Otherwise what we do is both are not empty. So we want to take the smaller one of the head of a and the head of b and move that to C, because that will be the smallest one overall in what is remaining. So we compare the first element of a and b and we move the smaller one into c, and we keep repeating this until all the elements in a and b have been moved. So this is a python implementation of this merge function. In general, the two lists need not be the same length. So we are merging a of length m and b of length n into an output list of length c. So initially we set up m and n because we need to keep track of how many elements we have moved in order to decide when to terminate. So we set up m and m to point to the lengths of a and b, respectively, and we initialize the output list to be the empty list, because remember that in python the type of C will only be known after it's assigned a value. So we need to tell it that initially the output merge list is an empty list, so that we can then use append to keep adding items to it. Now what we are going to do is essentially start from the left hand side of both a and b. So we're going to start here and walk to the right as we go along. We're going to move one of the two elements, so we need an index to point here. So we use the index I and j to point into a and b, respectively. And initially these indices point to the starting element, which is zero. So as we move along, if we move I from zero to one, that means we have processed one element in a. If we move it to three, we have processed three elements in a and so on. So at any given time, I plus j will tell us how many elements have been moved so far to the output. Eventually, everything in a and everything in b must be moved to the output. So this will go on so long as I plus j is not reached the total m plus n, which was the total number of elements we had to move to begin with. So while I plus j is less than m plus n, we have to look at different cases. So the first two cases are where one of the two list is empty. Either we have reached the end of a, so I has actually reached. So remember, the indices go from zero to m minus one and zero to one n minus one. So if I has actually gone to m, that means that we have exhausted the elements in a. So we append the next element in b, and we keep going by incrementing the pointer in b or the index in b. Similarly, if we have reached the end of b, we append the next element a and we go back. Now remember that at this point, because I plus j is less than m plus n, if we have finished m elements but m plus n has not been reached, there must be some element in b. Similarly, if we have finished m plus, I mean, if we have finished n elements in b but I plus j is not yet m plus n, there must be at least one element left in a. So these two things will definitely work just by checking the fact that we haven't finished all the elements but one of the list is exhausted. Now, if neither list is exhausted, then we have to do a comparison. So we come to this case and we check whether the element in a is smaller than or equal to the element in b. So at this point we are in general looking at some AI and some bj. So we have to decide which of these two goes into c next. So the smaller of the two, if it comes from a, we append that to c and we increment the I pointer. Otherwise we append the b value, increment the j pointer. So at the end of this loop, what we would have done is to have transferred m plus l elements in the correct order from a and b into c. So let's just verify that this code that we have described works in Python as we expect. So here is a file merge py in which we have exactly the same code as we had on the slide. So you can check that the code is exactly the same. It goes through this loop while I plus j is less than m plus n, and it checks the four cases and according to that copies either an element from a to c or b to c, and finally returns the list c. So the simplest way to do this is to try and construct two lists of suppose we take a list of numbers, say the even numbers from zero to 100. So we start at zero and go to 100 in steps of two. And we might take the odd numbers from say one to 75. So we don't have the same length here, right? So the length of a is 50, the length of b is 37, and a has, it's in ascending order, zero to 98 in steps of two, b is one to 73 in steps of one. In steps of two again. So now if we say merge ab, then we get something which actually returns this merge list. Notice that up to 73, which is the last element in b, we get all the numbers. And then from here we get only the even numbers because we are only copying from a. And if you want to check the length of the merge list, then it is correctly, 37 plus 50 is 87. So if we go back and look at this code again, then it appears as though we have duplicated the code in a couple of places. So we have two situations, case one and case four, where we are appending the element from b into c and we're incrementing j. And similarly we have two different situations, case two and case three, where we are appending the element from a into c and appending and then incrementing I. So it is tempting to argue that we would have a more compact version of this algorithm if we combine these cases. If we combine these cases, then we can combine case one and four. So remember, one and four are the ones where we take the value from b. So we combine one and four and say either if a is empty or if b has a smaller value, then you take the value from b and append it to c and say j equal to j plus one. On the other hand, either if b is empty or a has a smaller value, then you take the value from a and append the index in I. So let's see what happens if we try to run this code. So here we have a file merge wrong py. The name suggests that there's going to be a problem where we have combined case one and four where we append the element from b into c, and two and three where we combine the element, append the element from a into c. So let's run this and see. So now we take merge wrong as our starting point, and let's just do a simple case. So supposing we take a is two, four, six and b as one, three, five, then we'd expect 123456. So let's try to merge a and b. And now we get an error which says that we have a list index out of range. So a list index out of range suggests that we are trying to access some element which is not present. And it so happens that this isn't the case if I equal to m, or AI equal to pg greater than pg. So let us see if we can diagnose what's going on. So one simple way of diagnosing what's going on is to just insert some statements to print out the values of the names at some appropriate point. Now here, since we are having an error inside the while loop, what we have done is we have added this statement print, which, as I said, we have not formally seen. We will see it in the next week. But it does the intuitive thing. It takes the names mninj and prints them out in that sequence on the screen so that we can see what's happening. So let's now run this again. So we run the interpreter load this updated version of merge. Wrong. Set up a and b as before. So a is two, four, six, b is one, three, five. And now we run merge. And now we see what's happening. So m and n are the initial lengths, three and three. And these are the values, zero and zero are I and j the pointers. So I becomes j becomes one, then I becomes one and so on. So at this point, this is where the problem is. So what we have found is that if I is equal to m or AI greater than bj, so I is not equal to m, right? So I is not yet three. So then it is trying to check whether AI is bigger than bj. But at this point, unfortunately, j is n. So if we had had these cases in order, we would have first checked if I is three. Then if j is three, and only if neither of them are three would we have tried to compare them. Whereas now we are only checking if I is three, since I is not three. We are going ahead and checking the value at AI against bj. But unfortunately j has become three already and we have not checked it yet. So by combining those two cases, we have allowed a situation where we are trying to compare AI and Bj, where one of them is a valid index and the other is not a valid index. So although it looks tempting to combine these two cases, one has to be careful when doing so, especially when we have these boundary conditions. When we are indexing lists, we must make sure that the index we are trying to get to is a valid index, and sometimes it is implicit, and sometimes we have to be careful. And this is one of those cases where you have to be careful and not optimize these things. Otherwise you have to have a separate condition saying if I is equal to m or j is less than n, and which becomes more complicated than the version we had with four explicit cases. So you may as well go back to the version with four explicit cases. So now that we have seen how to merge the lists, let's sort them. So what we want to do is take a list of elements a and sort it into an output list b. So if n is one or zero actually, so if it is empty or it has got length one, we have nothing to do otherwise. We will sort the first half into a new list l and sort the second half into a new list r, l for left and r for right. And then we will apply the earlier merge function to obtain the output list b. So this is a very simple function, except that we are going to be sorting different segments or slices of our list. So we will actually have merge sort with an input list and the left and right endpoints of the slice to be sorted. So if the slice is a slice of length one or zero, then we just return the slice as it is. So it's important that we have to return that part of the slice and not the entire part of a, because they're only sorting. So remember when we broke up something into two parts, for example? So then at this point we have to return the sorted version of this slice, not the entire slice. So we have to return a from left to right if it's a base case. Otherwise we find the midpoint, then we sort recursively sort the portion from the left hand side of the current slice to the midpoint and put it in l. Then we take the midpoint to the right, put it in r, and we use our earlier function, merge, to get a sorted list out of these two parts, l and r, and return this. So this is a very straightforward implementation. There are no tricks or pitfalls here. The only thing to remember is that we have to augment our merge sort function with these two things, the left point and the right point. We had a similar thing, if you remember, for binary search, where we recursively kept having the interval to search, so we had to keep telling it in which interval we are searching. So let's look at a Python implementation of merge sort. So here we have a file merge sort py. We start with the function merge, which we saw before with the four way case split in order to shift elements from a and b to c. And then we add at the bottom of the file the new function merge sort, which we saw in the previous slide, which takes a slice of a from left to right and sorts it. If it's a trivial slice, it returns the slice as it is, otherwise it breaks it into two parts and recursively sorts them. So let's see how this would actually run. So we take Python and we say from merge sort, import all the functions, and now let's take a larger range. So supposing we take all the OD numbers followed by all the even numbers. So we say range one to 10 in steps of two. So those are the OD numbers, and then all the even numbers the same range. So a has now od numbers followed by even numbers. So you would imagine that if I sort this from zero to the length of a, then you get the numbers sorted in sequence. Now what if I take a larger list thousand? Then I get again the thing sorted. Now our claim is that this is an order n login algorithm, so it should work well for even bigger lists. So if I say 10,000, which remember, would take a very long time with insertion sort or selection sort, question is how long it takes here, and it comes out quite fast, we can go further and say 100,000, for example, and even here it comes reasonably fast. So we can see that we have really greatly expanded the range of lists that we can sort by moving to an n log n algorithm, because now merge sort can handle things which are 100 times larger, 100,000 as opposed to a few thousand than insertion sort or selection sort. Another small point to keep in mind is notice that we didn't run into this recursion limit problem that we had with the insertion sort, which we defined recursively. So there, for each element in the list we were making a recursive call. So if we had 1000 elements, we were making 1000 recursive calls, and then we had to increase the limit. Now here, even for 100,000, we don't have the problem. And the reason is that the recursive calls here are not one per element, but one per half the list. So we're only making login recursive calls. So 100,000 elements also requires only log 100,000. Remember, a log thousand is about ten, so we are making less than 20 recursive calls. So we don't have a problem with the recursion limit. We don't have any pending recursions of that depth in this function. So we have seen Merzot in action, and we have claimed, without any argument, that is actually order n login, and demonstrated that it works for inputs of size 100,000. In the next lecture we will actually calculate why merge sort is order n login.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
more about range().mp3,"You. So we have seen the range function, which produces a sequence of values. So in general, if we write range I comma j, we get the sequence I, I plus one up to j minus one. Now, quite often we want to start with zero. So if you give only one argument, if you just write range j, this is seen as the upper bound and the lower bound is zero. This is like a slice where if we don't write the first argument of a slice, if we write, for instance, l colon n, then it will run from zero to n minus one. So in the same way, if we just write range j automatically, we will get zero one up to j minus one. Often we may want to generate a sequence where we skip by a value other than one. So you want a kind of arithmetic progression, if you are familiar with that. So we want I, I plus k, I plus two k, and so on. So we do this by giving a third argument. So the third argument, if we give it to range, tells the range function to skip every k items. So we have I, then we go directly to I plus k. So implicitly, if we don't say anything, it's like we put a one here. So the default value is one I, I plus one, and so on. Now, how far does this go? Well, we want to go until we reach normally j minus one. In general, we don't want to cross j. So what we will do is we will get I plus n k for the largest n such that I plus nk is smaller than j. But if I go one more step, if I go to I plus n plus one times k, then I will cross j. So if we have a step, then we will keep going until we cross j, and we will stop at the last value, that is, before j. Having a step also allows us to count down. All we have to do is make the step negative. So if we say I comma, j, comma minus one, then, provided we start with a value which is bigger than the final value, we will start with I produce I minus one, I minus two, and so on, and we will stop with j plus one. So the general rule for the range function is that you start with I and you increment or decrement if k is negative in steps of k such that you keep going as far as possible without crossing j. So in particular, what this means is that if you are going forwards, if you're crossing, if your increment is positive, then if you start with a value which is too large, then you will generate the empty sequence, because you can't even generate I, because if I itself is bigger than j or equal to j, then that would not be allowed. Conversely, in the negative direction, what happens is that if we start with a value which is smaller than the target value, we are already below j, and so we can't proceed. So we get an empty sequence. So this idea about not crossing j, so it's not the same as saying stop smaller than j, because if we're going in the negative direction, you want to stop at a value larger than j, so you can think of it as before. And before means different things depending on whether you're going forwards or backwards. So just to see an example, suppose we want to have a range which starts from twelve, and whose limit is one, but the increment is minus three. So we will start with twelve and then we'll go to nine, then we'll go to six, then we'll go to three. And if we were to go one more step, we would go to zero. But since zero crosses one in the negative direction, we would stop at three itself. We wouldn't cross over to zero. So it's often confusing to new programmers that range, I comma j, is actually from I to j minus one, and not to j itself. So there is no real reason why it should be this way. It's just a convenience. And the main convenience is that this makes it easier to process lists. So remember that if we have a list of length n, the positions in the list are numbered zero, one up to n minus one. So very often what we want to do is range over the indices from zero to n minus one. And if we don't know n in advance, we get it using the length function. So we would like to range from zero to the length of the list. So if the range is defined as it is now, where the actual values stop one less than the upper limit, then range zero, comma length of L will produce the current range of valid indices. If, on the other hand, it did what we perhaps think is more natural and will do ii plus one up to j. If this were the case, then every time when we wanted to actually range over the list positions, we would have to go from zero to length of l minus one. So we have to awkwardly say minus one every time, just to remind ourselves that the position stop one shot. So it is mainly for this convenience that we can freely use the length of the list as the upper bound that the list stops. The range stops at j minus one. As I said, this is not required. You could easily define a range function which does the natural thing, which is ii plus one up to j. But then you have to keep remembering to put a minus one whenever you want the indices to stop at the correct place. So a range is a sequence, and it's tempting to think of range as a list. So we saw that four comes in two flavors. We can either say for I in a list, or we can say for I in range something. So range zero to ten generates the sequence zero one up to nine, right? So is this the same as saying for I in the list 01234 up to nine. So in other words, if we ask Python, the following comparison is range zero comma ten equal to the list 0123 up to nine. Then the question is, is the result of this comparison true or false? So here we've encountered a difference between python two and Python three. So in Python two, the output of range is in fact a list. So if you run this equality check in Python two, the answer would be true. But for us in Python three, range is not a list. So range produces something which is a sequence of values which can be used in context like a four. But technically the range is not a list. We can't manipulate the output of range the way we manipulate a list. Now, it is possible to use range to generate a list using the function list. Okay, so the name of the function is actually list. So what we would do, for example, is give the range as an argument to list. So the sequence produced by range will be converted to a list. So if I want the list zero to four, I can say give me the range zero up to five. Remember, the range will stop at four because five is the upper bound, and this sequence will be converted to a list by the function list. So this is an example of a type conversion. We are converting the sequence generated by range, which we said is not a list, into a list, by saying make it a list. So the function list takes something and makes it a list if it is possible to make it a list, if it is something which doesn't make sense, it will not give you a valid value. Now this is a general feature, so we can use the names that Python internally uses for types, also as functions to convert one type to another. For example, if we have the number 78 and we want to think of it as a string, then the function str will take its argument and convert it to a string. So str will take any value and convert it to a string representing that value. This happens implicitly, for instance, as we will see when we want to display a value using a print function. So what print will do is take a value, convert it to a string, and only strings can actually be displayed. Because strings are text, what we see on the screen or when we print out something is text. So str is implicitly used very often. Sometimes we want to do the reverse. We want to take a string and convert it to a value. So for instance, if a string consists only of digits, then we should get a value corresponding to that string. So if we give it the string 321, then it should give us back the integer 321. So the value remember, the name of the function is the same as the name of the type to which you want the conversion to be done. So we want to take a string and make it into an int. So we use the name int. Now in all these things, the function will not produce a valid value if it cannot do so. So if I give the function int a string which does not represent a number, then it will just give me an error. So so long as the type conversion is possible, it will do it. If it doesn't, it returns an error. We will see later on that actually the fact that you get an error is not a disaster. There are ways within Python to recover from an error, or to check what error it is and proceed accordingly. So, to summarize, what we have seen is that our simple notion of range from I to j has some variance. In particular, if we don't give it a starting point, we just give it one value. It's interpreted as an upper bound. So range n is a short way of writing zero one two up to n minus one. Also, we can use a third argument which is a step in order to produce sequences which proceed in steps I, I plus k, I plus two k, and so on. And in particular, if k is a negative step, then we can produce decreasing sequences. And the last thing to remember is though, range produces a sequence which can be used exactly like a list in things like four. In Python three, a range is not a list, so we want to get a list from a range output. We must use this type conversion called list. So in general we can use type names to convert from one type to another type, provided the value we are converting is compatible with the type we are trying to convert to.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
More on Functions.mp3,"We have seen what a function is and why a function is required. What are the advantages of using a function? We have also seen what is a parameter and what is an argument, and the types of the parameters and the arguments must match. Otherwise the system will of course give you error. And the reason is because there'll be a type mismatch and the data will not be passed properly. Okay. Because this is essentially a parameter is being assigned to an argument. Okay, now in this lecture we'll look at some more detailed nuances, detailed points of a function. So, to start with, let us revise what we have seen. A function. What is a function? A function is a self contained program segment. This is very important. This is not the whole program, but it is self contained and it is a program segment. Part of a program that is a main task, and a part of that is being execute is being implemented by this function and this self contained, because this can be independently tested, giving data and finding out whether the task for which it has been designed is actually being fulfilled or not. Okay, it carries out some specific and well defined task. Now that is a general concept of a function. Now, in C, any C program can consist of one or more functions. At least one should be there. Why? Because we need always the main, right? We have seen that we need main. Any C function must have a main, and main is nothing but a function. And why did we put here this empty bracket? Because the structure of a function is always a function name and a place for the arguments. Right? Now you can say that, well, when we are starting a main function, we are writing a main function that will do the task. It is not taking data from anywhere outside. Therefore, why there is no argument. Yes, you are right. There is no argument. That's why we to put two braces and there's an empty space here. This is empty, right? But still it looks like a function. Moreover, in the earlier lecture, we have seen that the result of the function is returned in its name. And since this is like a variable, it will have a type. So some type, like for average, we found float. So this main can also have a type. So we'll see later that this main can have a type. We'll have a set of empty arguments and the body of the function. And there can be type, say, sometimes the type can be int. If this main function, that means this main function will return an integer. And when we say that it does not return anything, we can say also that this function is of type void, that means it does not return any value. Okay, void so we'll see this later. But this is the reason why we say that every c program must consist of one or more than one function. One of this function must be called the main, and the execution of the program always begins by carrying out the instructions in main. That is the entry point. Any program, I mean, I cannot say that main will be somewhere in the middle. No, when I start, the gateway is the main, and then from within main I can go out and use some function f one. And from f one I can go out to another function, f two. Another function, sorry, another function, f two, like that. But the gateway, the entry should be main and ultimately the exit. Say f two will return here, then f one will return here. Ultimately, the exit will also be through main. All right. A function will carry out its intended task whenever it is called or invoked. So we have encountered with this term called or invoked. Right. You. So, in general, a function will process information that is passed to it from the calling portion of the program from where it has been called or invoked. And then the function will take the data. That is, if some data is to be passed, then it will be passed from the calling part, and it will return a single value. So what are these points? Information is passed via special identifiers called arguments and parameters, and the value that is returned is returned by the return statement. Some functions do not return anything. For example, let's say this. Say I am writing a function, say my function, maybe it is not taking any parameters, because in the body it is simply nothing, doing nothing, just printing. Printf hello. That's also a valid function. So in this case, the main function, where it was, it was just here, and it just called my function here with nothing. This is also possible. So my function, it goes there and does not. So I do not need to give any return. But if I give a return, that's also fine. It does not return anything. So this is of type void. It's not returning anything but the control. In any case, it does not return any value, but the control will come back here, and from here it will be executed. So there may be some functions which do not return any value, like it's just printing some data. Okay, that's possible. For example, I can make it even more realistic. Say here main is here, and there is int a five, int b six. All right. And here I call average a comma b, right? And here I write average int x int y. And here I just compute average is equal to x plus y by two. Printf avg equals backslash avg equals, I'm sorry, percentage f. Percentage f. Backslash n comma feg, that you understand now. And I can write return, or I may not write return. So what will happen? This will come here, five and six. Five will be passed on here. X will be five, y will be six. The value will be 5.5. That will be printed here. But I have to give a type to this average. Because here the average type is not defined. So I have to say this will be float average because there is some value, some type to this value, some type to this variable, which will hold the value. So this is also possible here. You can see that I don't need to write a return, but there is no harm if I write, just simply return. That's a good practice. That means my return, my control will come back here. And that is the last statement. That will be the end. Okay? So let's move forward. So, some function may not return anything. The return type is specified as void. So here is an example of factorial. We start with. So here, first I have written the function here, and then I have written the main. But however, in whatever way we write the main, the program, while execution will enter the main first. All right, so the execution will be something like this. That will enter from here, main. It takes the variable n, which is an integer. Then n one to less than ten, n plus, plus printf percentage d. Okay? And n and then factorial. All right, so factorial n. Now, when this factorial n is encountered, then this function is called, this function, what is doing? It has got int m. So m is the argument, and it's being called with a parameter n, which has been, which is being taken. First one, then two, then three like that till it is ten. So I'm taking it n. And then here, let's see what we are doing. Int I. Now this I, this variable I, and this variable temp. These two variables are purely internal variables. That means these variables are internal to the body of the function. Now, each of the functions have got a life. Each has a life, right? So, factorial, as long as factorial is running, factorial is live. And when factorial is live, whatever variables are defined within factorial, they are live. As soon as we exit from factorial, that function is dead. And the variables associated solely, I repeat, the variables associated solely with the function also dies with the death of the function. So let's see here. I and temp. Then for I equal to one to m, temp equals temp times I. So one times two, times three times four. So what is being computed one times two times three times four, like that, whatever is the value of m, that is being up to that, we are computing a factorial. All right, so if I call it now here I have called it with n, the value of n, all right, with a value of n, I am calling it and I am getting the factorial, and the temp is being returned. Why it is being returned? This temp is being returned to factorial. Temp is being returned to factorial, and that is being printed through this percentage d. All Right, so this is being printed. So return temp, because why it's different here? I did not write return because I have named it as factorial and I have returned temp. Then temp is going to this value factorial. If I had not done return, then ultimately, because here I am keeping the result in temp, not in factorial, has not been used as any variable inside the function. Now, when I go there and suppose if I had used some other temp here, this temp and this temp would have been different. We'll come to this later. But this is just an example of a function being invoked. We are just recapitulating why we need functions. This term may be new to you. It is modularizing a program. It is breaking down a program into small, small parts. Each part, independent part is called a module. That's why breaking down a big program into smaller parts is known as modularization. So it is modularizing a program. All variables declared inside function are local variables, very important, which are declared inside functions are local variables. That means they are known only as long as the function is remaining running. As soon as the function completes its execution, they also cease to exist. Therefore, a value variable, I, for example, can be used as an internal variable of a function and can also be used in some other function or in the main function. They will actually physically be mapped to different memory locations. So we have also seen what parameters are the parameters communicate information between functions, parameter and argument. Okay? They also become local variables. The arguments are local variables. The parameters means the arguments are also local variables. The benefits are divide and conquer. We know. We have devoted one complete lecture on that manageable program development software reusability. All existing functions can be used as building blocks for new programs. And this is another thing that you may realize later, that inside a function, how I am implementing or how somebody has implemented it may be very complicated, and I need not bother about that. I know what it asks for, what variables have to be put in through this, and what output I'll get out of it. Therefore, whatever is there inside is abstracted out from me, is hidden from me, the internal details are not needed. That is another big advantage of using functions and of course avoids code repetition, something which somebody has written or say, for example, in a main program. Let's take another example to understand this better. Say I have got a program in which I am doing some computation, say computing the standard deviation here. I'm computing the standard deviation here, and maybe so at both these places. Write this, write this, but that is not needed. If I have a function for computing standard deviation, then here is my main program and there is one function for standard deviation here. And from this point I can simply call this, get the value again, continue from wherever I need. I can again call this and I can get the value, and in that way I save in the number of lines of code that I write. So that is known as avoiding code repetition. Now, defining a function, how do we now we are. Till now I was trying to explain you some things. Now we are looking at the syntactic details of a c function. Now that can vary from language to language, but more or less the ideas are same. So a function definition has got two parts, the first line, first line and the, sorry, the first line and what's happening here? First line and the body of the function. Okay, now what is the first line? Typically, what can we have in the first line? First line, we have got the function name. I don't know why it's not coming in the first line. We have got the function name and the parameter list. I call it argument list, but whatever you. So a function has got the first line, and we can see what the first line is. The first line will contain the function name and a return value type. What type of value is being returned? Followed by this is the body of the function. The second part is the body of the function. Where there are declarations and statements, some internal values can be declared, internal variables can be declared here, and the other statements are also here. This one I actually am calling them argument. Some people also call both of them to be parameters. Okay, now, so the first line contains the return value type, the function name, and optionally a set of comma separated arguments enclosed in parentheses like say here I am defining a function called gcd, greatest common divisor. It has got a type int and has got two arguments. One is a and one is b. I have written the types of them in this parenthesis itself, int a comma, int b. They are comma separated. The arguments is possible that I can declare the arguments also on the next line, for example, I can say, instead of writing it in this way, I can write in this way, int gcd a comma b, and in the next line before the body, before the bracket, probably in an earlier example, I did a mistake. I had put the bracket inside the bracket. It should not be inside the bracket. Immediately after that, you can write int a comma b. That means you are declaring that these are a and b either inside or immediately after that. Both of them are fine. Now, these are called the formal arguments, or some people also call it formal parameters. Now, what is the body of a function? The body of a function is actually a compound statement. I'll just take, just as I had statements like for loop or so let's take or say while loop, or if conditions where I write if some condition, then some statement, else some statement like that. So now this whole thing is a compound statement. Similarly, here, the entire body of the function can be assumed to be a complete compound statement where we are passing on two arguments and is giving us some value. Let's look at what is being done here. Int gcd, int a, int b. So from the calling function must be, I'm supplying some values, p and q, maybe two integers of type integers which are mapping to this p and q, a and b. Now here, you know, we have seen this algorithm earlier. We take a variable temp. Now that is, now the body of the function is defined by this braces temp, while b is not divided by a. As long as that doesn't happen, we divide b by a and take the remainder and then go on. That classical way of finding the GCD, you find the remainder and make the remainder the divisor, right? So that's exactly what we are doing in a loop. Ultimately the final divisor, which divides and gives us a zero. That will be the GCD. So that GCD, now that GCD is coming in this a. Therefore, I cannot here just write, simply return. I have to say that return a. And maybe from the main function I had something like, say, hcf is equal to GCD, p comma q. Now this a is being returned to this GCD. And because it was a GCD function, this was called. And that's where it is going to a is coming to here. And then by this assignment statement that is going to HCF, that is how the function is being connected. Okay? And we also see what is the body of the function. So when a function is called from some other function, the corresponding arguments in the function are called actual arguments or actual parameters. That means what I am calling parameter. Some people call them actual parameters. So just in the earlier example, pq were actual parameters. And what was there ab or xy, whatever was there is ab, are the formal parameters or formal arguments. Now, as we had said, the formal and the actual arguments must match in their data types. The identifiers used as formal arguments are local, not recognized outside the function. The names of formal and actual arguments may differ. As we have seen here, they are differing. My actual arguments were Pq, and here it's a and b. Of course they are differing. Now, this a and b, whatever it is here, this a and b, will not be reflected anywhere outside this function. Suppose here there is a main. The main will not get the value of a and b. This completely local here. And as soon as it ends, the a and b vanishes. A and b will no longer be available to you. Same is true for temp, because temp has been defined internally within this function. All right, so this is a very key thing that you must understand. So. So when a function is called from some other function, the arguments are passed. Points to. Note that the names and of the normal and actual arguments may differ. Right. So here, I'll conclude with this lecture. I'll conclude with this example. So here we are computing the gcd of phone numbers. In the main function we have got n one, n two, n three, n four. Four values have been read here. You can see that they are being read as and n one and n two and n three and n four. They have been read now. The result is now gcd of n one, n two, gcd of n three, n four. So there is one function gcd, which takes int a int b. Right? That's what we saw. Now, first, when within this parenthesis, we'll first compute this gcd, n one and n two. So a will have n one, the value of n one. B will have the value of n two, and the function will return something, return a, as we saw in the last example, return a. And so the body of the function ultimately ends with return a and that a will come here. Suppose that value was three, say. So three comes here. So what do I have now? I've got gcd of three, comma, gcd of n three, n four. So now this same function will be called with a having the value of n three and b having the value of n four. And suppose I compute them and I find ultimately that the gcd is five. So the five will come here. Then what happens to this? Then we'll compute again. Call gcd with three and five. So again here now, a will have three and b will have five. And the return, of course, the three and five will be the result. The hcf of three and five is one. So return a that will come here and the result will be one. That is how the gcd is computed in cascading of the function calls. The same function, you see is being called time and again repeatedly from this single statement in the main function. We'll continue looking at functions more.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Parameter Passing in Function Revision (Contd.).mp3,"So we had looked at parameter passing, and we have looked, we have seen the difference between call by value and call by difference. And we have seen quite a few example s, to be specific. Three examples on call by value. Okay. And also another thing that was supposed to be noted. I hope you have noted that that is the scope of variables, that whenever there is an x in the main function and the x in the called function, then these two x's are different. The x that is defined in the called function is a separate location than the x in the main function, and that the life of that variable ends with the end of the function. Right. Now let's look at this example. You yourself will be able to trace this. So I give you some time to trace this through and then we'll continue. Look at this function carefully. And do not look at this green part. Do not look at the green part yourself. And try to, without looking at that, try to find out what the values will be for the different printf statements. Let's start. So we have got x assigned to ten and y assigned to five. X and y. X is ten and y is five. Now, so when I printf, do this. Printf, x is printed to be ten, y is printed to be five. Fine, no issue. Then I call a function interchange xy. Look at the type of this function interchange. The type of this function interchange is void because that immediately tells us that it is not going to return anything. It is going to do something. As the name implies, it is going to interchange x and y. And what are the parameters? Parameters are x and y. This is the argument. So here I have got another set of x and y. Again, note that this x and Y are different. Now I initialize temp. So temp is another variable here. Temp. Now, what I am doing here, the first printf. What is being done here? Printf x equal to x and Y equal to y. Which x and which y? This x and this y. Now, when I entered this function, these values have been copied here. So the printf will simply print ten and five. No issue. Now, temp is getting x. X was ten. So I put ten here and then x assigned y. Sorry, y assigned x. That means the value of y. I am still within the function. I am within the function. So this value is being assigned. So by this statement, what happens? This becomes five and this remains five. Right. And then what is being done here? Y assign temp. That means this temp is becoming five. Right. Temp is becoming. Sorry. I'm sorry. Absolutely sorry. This was ten now, for this statement, temp is going to y. That means y will be changed to ten. So here I find five and ten. So when it entered here, I could see ten and five. And so when I come and print from here, x will be five and y will be ten. I come out of the program and printf x and y, what will be printed? My God. What I find is x is being printed as ten and y is being printed as five as it was here. So no change has actually taken place. Why did it happen like this? You can immediately see the reason that whatever change took place took place here inside the function. And this actually tells you the importance of the scope of variables. These variables scope ended with this function, and their change was not reflected in the main here. That's why, although I did it here, it would not change. Okay? However, suppose, suppose, let's do some intellectual exercise here. Suppose x was ten and y was five and there was a temp. Now, temp is inside the function, so I'll use different colors for that. Okay? Now, although I remind you that c does not allow call by reference, but just to see whether you have understood call by reference properly, suppose we are allowed to use call by reference. Then my main program has got this x and y. So it comes here, prints, say prints x and y. So ten and five are printed. X equal to ten, y is equal to five, and it calls interchange. All right? It calls interchange. And suppose, just suppose that this call has been done by call by reference. So what has been passed here? The address of this and the address of this, not the values. So no other copies have been made. So now I have got the local variable temp, and here I do. Temp is assigned x. So temp gets ten, then x assigned y. Now, what is my x and what is my y? The content of this address which have been passed will go to the content of x. So this will be five, and then y will be assigned temp. What will happen? This temp, this value will go to the. Suppose I can make a call by reference, then this will go to this address. But if I just simply write in this way, that does not mean it really does not tell me whether I am saying that I am copying from the address or actually copying the value, but I'm just telling a hypothetical case. So this ten will go there and this five would be changed. In that case, when I come back from here and I print here, then I would have got the change scenario reflected. Okay? But the mechanism, writing simply like this in c means it is call by value, not call by reference. So what is being passed is actually the value. So if I could do that, then it was possible to have that interchange. And there is a mechanism for passing the addresses and not the actual values by using a concept called structure called pointers, which are nothing but addresses. We'll see that later if time permits. But in general, remember that this interchange has not been possible by call by value in the way we wrote the program. Okay, so with this we complete our discussion on parameter passing. Normally distinction between parameter passing by call by value and call by reference. And we now start another very important point, that is passing arrays to functions. Now let's try to think here. When we were having a variable x, another variable y, in the caller function, and I was having in my called function two other variables, a and b, then the value of this would be copied here and the value of this was copied here. But suppose x is not an integer. X is an array of 20 elements. Then all those 20 elements I have to copy here. And suppose this is an array of another 20 elements. So another 20 elements I'd have to copy here. Right. C allows only for arrays. The parameter passing by reference. Now, in order to understand that, let us try to look at the structure of an array. Suppose I have got an array, a ten. Now, I am not making a distinction between the size of the array, actual size of the array, and the dimension of the array. I'm assuming that the array a has got ten elements, so I have got 1234-5678 910. All right, and these are a zero, a one, a two, up to a nine. Right. These are the locations we know that. We also know that an array is allocated contiguous memory locations by the compiler, so all these are contiguous. Therefore it is sufficient to know the address of the starting location. Suppose this is thousand, if this is thousand, and if it be an integer. And I assume that an integer integer takes two bytes, say 16 bits, and then this will be 1002, this will be 1004, et cetera. I can compute any particular address, any particular address of this. So if I say a five, the address of this, a five address of a five, can be easily computed as the starting address. Thousand, whatever is the starting address, plus the index is five. That means and the size of integer, which I know in a particular machine, say two bytes times how much will be 106, 108. So what will be two into whatever is the index minus one. Sorry, a five. A five will be the 6th element. Right. So five times whatever this is. Suppose this I times I, right size. Of the integer times I. So it will be thousand plus two times 5010. So this a zero, a one, a three will be thousand and six, a four will be thousand and eight, and a five will be thousand and ten. Since it is contiguous, it is sufficient for me to know the starting address of the array. Therefore, it is good enough to establish the correspondence between the name of the array and the starting point of the array. What I mean by that is, again, I draw this. Now, I name that a differently. A. And suppose it has got five elements, all right? Now, a and a zero are treated to be synonymous, okay? When I say a, that means I am actually referring to this element, this address, not this element, this address. And since I know that, therefore AI, depending on the value of I, I can compute where the actual location will be. This is the fundamental concept we need to understand, all right? Therefore, we can pass an array to a function as ordinary arguments. For example, is factor, whether x I is a factor of x zero. Suppose I want to do that. So you see, is factor. Earlier I did x or y. Here I am writing X-I-X zero. So x I is what? Suppose x is an integer array. So x I is an integer. X zero is another integer. So I can simply pass this sine of a particular angle. Where is that angle in an array, x an array x is there. And in that, the fifth or 6th element I am taking. So this element is coming as the parameter. So let's proceed a little further. Now, that is for the individual elements, xi or x five, x zero. I'm just passing an element. And if it is an integer array, then an integer is being passed. If it is a floating array, floating point array, then float will be passed. But what if I want to pass the entire array to a function? That's what I just now explained. That is, an array name like a can be used as an argument to a function because a essentially means a zero. And if I can pass a zero, the address of a zero is known. Then all the elements are known because they are contiguous. Now, the way it is passed differs from that of the ordinary variables. Why here, when I have got an array, an array, a with a zero, when I am passing the array, suppose somewhere in my function f I am passing the array a. And just to say that it is an array, I just do something like this. This is not the correct syntax. I'll show you the syntax a little later. Now you see, I write it in this way, all right? Now that means I am passing a zero. But if I pass the value of a zero, which might be 50. I have got no clue about the other values. I am not passing all the values. So what do I have to pass if I pass the address of a zero, address of a zero. So this is what is being passed, is address of a zero. Then I can get access to all these elements, AI, a one, a two, anything, because I can compute the address very easily, as I have shown just now. All right, I can do that. So this is an example. This is a case where we call by reference. We actually will pass the address and not the value of a zero. We are passing the address of a zero, and the address of a zero is the same as the name a. This is a very fundamental concept, and let's try to understand this. How is it passed? The array name must appear by itself. So now we are talking about the sum syntaxes. The array name must appear by itself as argument without brackets or subscripts. The corresponding formal argument is written in the same manner. Let's look at an example. Say here, I am going to pass the whole array as a parameter. So I've declared constant int a size five. So something, some variable, a size, is assigned five. Now, float average, average is a function which will, which is taking as parameter, sorry. Which is taking as parameter, an array b. All right, just the name of the b. Only array name or address of b is passed. Now this symbol is mentioned to indicate that this is an array. Right. Now let's see what is happening. Int I total zero for I equals zero. I less than a size. That means less than five. I plus plus total equals total plus bi. So what is happening? So here is an array b. Here is an array b. The array size is five. And all these elements are being added. Now all these elements are being added in this loop. So bi will be b one, b two b zero b one, b two, b three, b four. They are being added to total. And then I am returning, what am I returning? I am returning total divided by a size. Now, there's a new thing here also. It's better to look into that. Now, the array, now average will be a floating point number, okay? And b is an integer array. So sometimes, so when I, what has been done here is float a size. When we do this float some variable x, that means this variable is being typecasted, is being made to be represented as a float. So if it was five, five, suppose, then float a size. So since it's five, float a size will make it 5.0. And suppose the array was 12045 so 9211 twelve total was twelve. So float total will make it 12.0. So I'm casting twelve, forcing it to be represented as a float. So then 12.0 is being divided by five with divided by 5.0. And I am getting the average and that average is being returned here. So that was not our main contention here. That is the purpose of this float. But the main contention here is that I have passed this array b. But who passed it? The main function. Let's study the main function. The main function x is an array of size si's that's five. And x average is of some variable. And x has been assigned as 1020, 30, 40, 50 x average. I'll compute, but I am calling this function average from here. And I am passing x. What is x? X is an array and that's appearing just as a variable here. And that is being accepted as b. So what is the correspondence between x and b? X is somewhere. Suppose starting with location 5000 and there are five elements. As has been said here, 1020, 30, 40, 50. Now when this x is passed to b, this function now knows that b is an array because it had this thing. And this 5000 is passed to b. So now b knows where is b. B is the same array. Now whatever change I do here, suppose in this function, instead of computing the total, if I had written this function in a different way. For example, let's do that. And suppose I have got this function x. I have got this function x, this array. Sorry, I'm sorry. X where 1020, 30, 40, 50 are there. And in my function change, I can also say void change int b this. And in the body of the function, what I do is for. Please try to understand. I assign zero to this. I less than equal to a size or five, whatever it is. I plus, plus, bi plus, plus. Say this, what will happen inside this function change. I'll take the first one, change it to eleven. This one will be 21. This one will be 31. This one will be 41. This one will be 51. And when I return, I made a change in B. But b and x are the same because this address 5000 was passed to the function change. And this b got 5000. And so whatever change has been done here will be reflected in the main function when I return. Clear. So that is the importance. So here I have called it with the actual array name here. Of course I computed a total and returned some other value. But if I had just changed it inside this function, I could have made it void function and the change would have been automatically reflected in the main function. So here you see, we don't need to write the array size. It works with arrays of any size. For example here void this, et cetera, where list is an array of 100 elements and average. I'm calling here float average int a is an integer and float x is mapped to list. All right, x is an array because here, how is the correspondence done? This list is being mapped to, this same address is being passed and n is being passed to a. How many elements are there? All right, so I need not specify the size because the size is already specified here. I have got 100 element added. This is my list. This is list, right? So I've got 100 element here. I know what I have passed to x is just the address. So whatever it is, 100 or 150, that be true for x also, right? So we don't need to write the size of the array. Now similarly, arrays used as output parameters. So suppose I am going to do vector sum. That means I have got two arrays, a and b. So what I'm doing here, I've got two arrays, a, an integer array, another integer array b, and I am adding them. So I'll add this element, say five with this seven. And I have got another array, v sum, v sum where the sum will be stored. So this will be twelve if it was six and this was five. Here we'll store, I'll add these two and I'll store eleven. Okay, so let's see how the vector sum now vector sum will be void, you know, because it is doing the addition and the addition is remaining in this vector sum. So I have got, let's start with the main function. X is an array. So this is actually x a. Or let me say, let me put the main function first. So it will be x in the main function and a in this function Y-B-I am writing slash b because these two are the same because the address is shared. All right? And vector sum will be z, so z or vector sum now, so x is one, two, three, y is four, five, six, and z has not been initialized because, so that you are not confused, let me do it like this. I have got an array that is x having values one, two, three, another array, y having values four, five, six, s. And another array, um, another array, z, which will have the final value and z. All right, it is three elements, but we don't know the value. Now I'm calling vector sum and what am I passing? X is being passed to this. X goes to this. So this is known as a for the function y goes to this. So this is known as b. So x and a locations are shared. Z and v sum. The locations are shared. All right, now I'm calling vector sum. So all these are being added in a loop. Five, seven, nine. Then I come out. I come out. Now you see, when I come out of this function, these are already reflected because it was passed by reference. Now let's look at the print print vector. What is happening here? Void print vector. That's another function that I'm calling here, z three. That means three elements will be printed from that z array. The z array was here, which had that elements like five, seven and nine. Now with that print vector, it's just in a loop, I equal to zero, I less than length. What is length? Length is three. And what is the array? Z is a. Now this a and this a are different. Again, this a and this a are different. This a was this function say. And this a is this function say. So they are different. So here they are printing five, seven, nine. So that is as an output parameter. So you see, actually, whenever I am reflecting on an array, I need not pass it because essentially automatically passed. Right? So that is what is very important. So I hope you have understood this. The actual mechanism is when an array is passed, the array elements are not passed, but what is passed is an address. And the argument becomes a pointer to the first element or a pointer to the first element. That means the address of the first element. Okay? And when an array element is accessed inside the function, the address is calculated. I have already explained the formula that is used for finding the array. So this is known as call by reference. So I think you have understood this. We'll continue our discussions in the future, lectures on some other important issues.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Parameter Passing in Function Revision.mp3,"So, in the last lecture, we have discussed about function prototype. Before moving to some other topic, let's look at an example of function prototype so that we can understand it better. Here. You see, here is a program where I have got a function ncr, okay? N choose r, and another function fact. Now, the functions are actually written later. Here you see, n choose r is like the standard n choose r that we do here. That is a factorial n by factorial r. So factorial n divided by factorial r into factorial n minus r that we know from our school, right? So that is one function. That is one function. The other function is the factorial. Okay? So here is another function. This is one function. This is another function. Now look at the beauty of this function. This function is in a simple one return statement. I have written everything. So here you see, the body of the function is merely a computation of an expression, fact n divided by fact r divided by and fact n minus r. Okay? And this will be computed and that will be returned as an integer. Now, what will be the input? The input will be the n and the r. Both of them are integers. Another point to note here is this function itself. This function itself, when it's running. First, say I get into this function and I try to compute the return value. First I find fact n. And from here I am calling another function. That is the factorial function. And the factorial function is taking only one input, one integer n. And based on that, it is computing the factorial. Computing the factorial. You must be remembering by now, or knowing by now, that is, I am starting with one and one times two times three, et cetera. I am going on doing, and that's what is being done here. Temp is one, and temp is equal to temp times I. This is wrong. This should be small. I. Okay, temp is temp times I, whatever the I value is, one times one, one times two, one times three. It goes on till I reaches n, okay? And then I return temp. So the point to that, you know this thing, you know. So what is being done here is when I am computing this function, then I come to this, I call this function return temp. I return here, and then I move here, and again I find again a call to this fact, again, this time with a different parameter, r. And so again, fact r is computed. After this is computed second time, I return back here, and then I again call this fact using n minus r. So, just to make the things clear, so the first time I am calling this from here and returning back here. Second time, I am calling this from here, the same thing and returning back here. And third time I am calling from here and returning back here. Now for the third call. So here is one n and that this n, and here what I am passing, I'm passing n minus r. I am first computing this and that is being passed here, and that is being computed. So here you see, it's an example of nested call. This was called from the main, and this in turn call another function, and in this way it goes on. That is about the beauty of these two functions. But now here is my main function. Here is my main function. So the compilers comes from in this way and recognizes at this point that okay, ncr is a function. How does it know? It looks at int, but how does it recognize that it is a function? It recognizes Ncr to be a function because of this parameter argument list. Here it is said there are two integers coming in as parameters. Next, it understands that, okay, fact is also a function. So it's expecting to encounter ncr and fact somewhere down the line. And it proceeds here, it takes m and n reads m and n. Then it is in a loop where it is calling NcR. So it is a series, you can understand. Ncr is computing some with some value. I initially one. So it is basically nc one plus nc two plus n, c three plus, et cetera. It will go up to m. All right, so that's what is being computed here. And so from here a call is made to this. And as we have seen earlier, while this is being executed, this one is calling here, this is returning back here, then again, this one. Now we are making a journey in this line. So this one is calling this, and we are returning back here, as we have seen just now. Now ultimately, when this entire thing is computed, then we'll come to this last bracket here. Sorry, I should not, this bracket here, that means it's the end of NcR. So I had called NCR from here. So I'll return back here, and whatever Ncr value is that will be added to sum, and that will go to this sum, and then we'll proceed in this way. I hope this clear. Now here, I have not written ncrs. I could have written this earlier. In that case, this prototype would not be needed. Okay, but since I decided that I'll be writing it later, so I decided to just introduce them as prototypes here. Now you should be very careful about the syntax of writing the prototypes. It should have the function type, just like a function name. And the parameters. Now you will see later that it is also possible that I could have written something like int ncr, int comma int. That would also mean that this Ncr takes two integers as arguments. That's also allowed, but it's nice to write this in this way. Okay, now next we'll move to a very important concept. So let's quickly have a look at this. The prototype declaration and the function definitions are actually here. Now we are moving to a very important concept of passing the parameters. How do we pass the parameters from the calling function to the called function? Okay, there are two distinct ways in which it can be done. One is calling by value, other is calling by reference. So right now let us think of calling by value. All right, now let's try to understand it in a simple way. Say here is my main function or the calling function. Let me not call it main function. As we have seen, there can be nested functions. So this is the calling function. Now, inside the calling function I have got some variable x and which may have the value, say somewhere five. It's an integer. Now somewhere here I am calling a function. Let's call a simple function decrement or not decrement, add two, or say add two, okay? That means whatever is a value will add two to that simple thing. So here I say y is add to x, and then semicolon and I go on. And here is my function add to int a. All right, and add two is also a type integer. Now, so a, we know is a local variable to the function. So here I'll take. So what will happen? Suppose it was five. So this will result in a will get five. And here maybe here I declare another variable, say b, although it was not necessary. But I am just saying b is a plus two because its task is to add two. And then I say return b. So this b, which an integer is being returned, so b, which will be, in this case it was five. It will be going back here. I hope this is clear. Now, when you know the scope of variables, that b is a variable or a or b, whatever the life of those, or the validity of those, are restricted only during the life of this function. But however, in the case of looking from the point of view of compiler, I have got a variable a and I have got another variable b. And here I have another variable x. Now this variable x was having the value five. So here in x I had five by this statement. This statement made it five. Now, since x is five and this one is expecting the value a now, this five will be copied in a, what is being copied? Not x, but the value of x. So this one will be, will be getting five, right? So the copy value is being copied. The value is copied in this variable, five. Now it takes b was something. But here. So b becomes five plus two. B becomes seven. Seven comes out. Now suppose I change this program a little bit. Okay. I erase this b and make it, sorry, I make it a. So this b is no longer there. This is not required. All right. This variable has not been defined. I say that this line is also not there int a, and I just do a plus a assigned a plus two. So now when it was called add x, then from here, from here, this x was copied here. And a will be incremented to seven. So this will be incremented to seven. And obviously this will be return a, not return b because b is not there anymore. So seven, that seven will be returned here. But you see, if here now seven has been returned and seven will be y. Now suppose if I say I am not following the syntax. I'm just saying because there is no space here. Printf something x, what would be printed for x? What would be printed? Five will be printed because x is still five. X has not changed. I have simply copied the value to the argument variable and have played with that, changed it. Whatever I wanted to do, I have done. Okay? So take a little time to understand this. This means that the variable that I have in the calling function, the value of that will be copied to the argument of the called function. Okay? So there are several advantages to this. One is so it passes the value of the argument. Execution of the function does not change the actual parameter. Like the actual parameter was x, which was five, it remains as five. Okay. Although the function added two to that and it came back, all changes to a parameter done inside the function are done on a copy of the actual parameter, not the original parameter. The copy is removed. When the function returns to the caller, that entire variable location that was given for the variable a in our example is returned back to the pool of memory locations. Okay. The value of the actual parameters in the caller is not affected. Consequently, it also saves us from some accidental changes. Programming that can come copying due to programming errors. Okay. On the other hand, the other thing that is, another type of parameter passing is known as call by reference. Call by reference. Here we are not copying the variable. We are passing the address of the original argument. So let's take the earlier example again. If I had my main function here and I had similarly intex and here y was add to x. Here printf something x. And here I had that function add to int a. And here in the body I did a assigned a plus two and return a. Okay, return a. Now here is a variable x and that has got an address. Say that address is whatever, 5000. So now its value here somewhere, x was five. So its value is five. Okay, so here what I am, in the case of reference, I am not copying the value of five to a. Instead in the parameter passing, I'll write it in a different way, not in this way, which I'll discuss later. If I assume that this one a is not taking the value but the address of the parameter. Address of the parameter means what means that this time, this a here I am passing not the value five, but I'm just simply saying that whatever data you want to work with, that is the data is in this location, 5000 and it accepts that reference, okay, that, okay, the data that I am working on, my a is actually staying in 5000. So what it does, when it computes a assigned a plus two, this is not looking nice. So let me write it a. A assigned a plus two. It now knows that it is not the value a is here. I have to get the value from this location. So it gets the value from this location, but no other variable location has been allocated because I know where there is only one commonplace, okay? Only one commonplace. You have done given something here and you have told me where you have kept the data. And I am also working in that vessel itself. Okay? So what is happening here is this five will be changed to seven here only and return. I need not return a. It was just return would be sufficient. So changes have been done here. So in this case, when I come to this printfx, what will happen, what will be printed? Seven will be printed because the actual data has changed here. Okay, let me show you another example. Here is my calling function and I think this vessel analogy will be fine. Now, it says that here is the data where I have port, it only tells you where it has port. The name of the vessel. Suppose the name of the vessel is a. There are many other vessels, ABc, and only this vessel name has been passed. And when this one is doing something, it knows the vessel name a. So it comes here and takes the data from here, does something, and returns the data from here and here. This program, when it is computing, when it returns, and then ultimately it returns there. And while it returns, it takes this value, this value, the change value, and continues. So in the case of calling by reference, we are not copying the value. On the other hand, what would have happened in the case of call by value? Using the same vessel analogy, say this program was running, okay, the value was in a vessel. The value was there in a vessel. But sorry, but my function, don't bother about the interchange of colors. My function was also having its own vessel. And when the function has been called, the main function calls this a calls or say x calls y, right? Then also x copies, y copies the value of the variable. Suppose that was a that is copied in the vessel that is belonging to the function. It may be b. So this one does whatever it does here and returns this value over here. Okay, so this one is not disturbed. Whatever changes are being done, are done here. So that is a very fundamental concept in parameter passing. There are two types of parameter passings. One is called by value, another is called by reference. Okay, so here you see, execution of the function may affect the original because I'm sharing the same vessel. Now this in c. In c we actually, we are in c, we actually carry out only call by value, only call by value, except for the case of arrays, except for the case of arrays. Okay, there is a reason for that, you will understand. And for arrays, we are not passing the values, we are passing by reference. Otherwise it's always called by value. Okay, so let's have a look at some of the examples here. First example, we have got the main. Let's see what is happening. A has been initialized to ten and b is not initialized. Printf initially a. So what will be printed? Look at this. This will print this first line. Initially a equals the value of a, which is ten. So here there is a variable a which has got the value ten. Then b is being assigned change a. What is change a? Change a is a function. Okay, so one mistake is here. I should have declared this change prototype here. However, the function prototype should have been defined earlier. Now I come here. Printf before. What does the function do? Prints before x. X. So before. So this point before x equal to x, whatever x was, it has got the copy of that x. It has got the copy of that x. So this, it was a a. And that has been copied here for its own x. X is also ten copied because when it called, you actually copied this. When this call was made, when this call was made first, then before that, before that, it was also copied here. And then only this was done. So it was printed. Then x divided by two. So x becomes five by this statement done. So what is being printed after here. This line is being printed here. After x equals x. So what will be printed? I am still inside the function. Please remember, I am still inside the function. So five will be printed. And then I return, return x. So what is being returned? Five is being returned. Where it is being returned? Here a has been changed and that is going to b printf a assigned. So this printf is this printf a. Sorry, a equals here I'm printing a. A is a. So a is not changed. So it's being printed as ten and b is being printed as five. So you see, a has not been changed. The reflection of the change has been reflected in this function and is being assigned to B. Clear. Now let's take another example. And you will yourself try to look at this example. And a little change has been done here. Let's altogether try to follow this example. So we are starting again. A mistake is I should have declared the function prototype here. So those things have not shown here. But you should do it. Now let's see here again. Int x equals ten. So x is a variable to the main function. X is having ten. Printf m here, main function printing. Initially x is ten. Okay. Then it's calling the function. So here the function is being called. And whenever this function is being called, there is a local to the function. There is an argument x where this ten is being copied. Okay, now printf here. This printf in the function, it prints before x was x before changing. So x was x. So what will be printed? Ten will be printed. Then I change x here. So at this point x is becoming five. All right. Then I am saying print after the change. This is this printout after that change. X is what? It has been changed. Five. And then I return to the main function with the change value of x. So b gets five. Now I am printing in the main function. X is ten and b is five. Okay, so it has been changed. That is being reflected in this printf and b is also five. B was here. B is in the main function. So that b has been assigned after this change. And that is also five. Now the distinction I think will be clear. So these are the two cases that we have shown. So now it here, let's see. There is another example here. The slight change that has been done is that the change value I am keeping in x. Now this was x and x was ten. Now note, x was ten. So initially x is ten. Fine. From this line. Now I have called change x. So it is coming here. But its parameter is also x. But that really does not matter. This x from here I'll create another x. This who is the owner of this x? The owner of this x is only this function. As long as this function is running, this x has got a meaning. It is existing. After that it's not there. But since I called it, the value ten was copied in this. But you see, these two are two different memory locations. Consequently, what is happening when I print it here before x was ten. Now see which x is being printed. This x is being printed because this x is not known to this function. This function only knows its own x. Then x is changed to five. That's also done to done locally here and is being said here. After that the x is five because this x is known. Then I return x. So five is returned and five is assigned to x. Now, whenever I have gone out of this function, this x is no longer existing, vanishes. That means the compiler returns it to the memory pool. Now, so which x is this x? This x, so this value that's five that is being changed will come here. Now here I am doing printfx. That means both b is, so x will be printed as five and b equals x, so x is also five. Here you see that the same value is the variable is x, so both will be five. So I hope you could understand this difference. Let's take another example, or we'll come back to this in the next class and we'll start with a new example and continue with parameter passing. So what we learned in today's lecture is a very important concept of call by value and call by reference. And we could see that in c in general, call by value is adopted, except for arrays. And what is call by value? Call by value means the calling function copies the value of the parameter to the variable corresponding to the argument. Okay, whatever change is done is done locally inside that argument, and when it's returned, it goes back to the main function. The value goes back to the main function. Okay? Whereas in case of call by reference there is only one vessel, one variable, and I am not creating another variable, I am simply passing the address of that variable to the called function, and the called function changes in that particular variable, and whatever changes are happening, they are reflected in the main function, a calling function as well. Okay, we'll continue with this.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
paste del and none.mp3,"You. So, for the last lecture this week, we look at some useful things which will crop up and which don't fit anywhere else specific. So we just combined a couple of them into this one single presentation. So we had an example when we were doing the input and print about how to prompt the user in case they had an invalid entry. So we were trying to read a number, and what we said was that we would input some string that the user provides. So we give them a message saying enter a number. They provide us with a string, and then we try to convert it using the int function. And this int function will fail if the user has provided a string which is not a valid integer, in which case we will get a value error. And if we get a value error, we print out a message saying try again, and we go back. And finally, if we succeed, that is, this try succeeds, the int works. Then we will exit from this try block, go to the else, and the else will break out of the loop. So this we had already seen. Now the question is, what if we want to change this so that we do nothing? We don't want to do this. So in other words, if the user does not present a valid value, instead of telling them why, we just keep saying enter a number. I mean, we have seen this any number of times, right? You go to some user interface and you type something wrong. It doesn't tell you what's wrong. It just keeps going back and back and back and asking you to type again. So how would you actually program something as unfriendly as that? So what we want to say is, if I come to this value error, do nothing. Now the problem with python is that wherever you put this kind of a colon, it expects something. After that you cannot have an empty block. So if I put a colon, there must be at least one statement after that. This is a syntactic rule of python cannot have an empty block. But here I want to do nothing. I want to recognize there is a value error and then go back here. That's fine, but I don't want to do anything else. So how do I do nothing in python? So the answer is that there is a special statement called pass. So pass is a statement which exists only to fill up spaces which need to be filled up. So when you have blocks like accept, or else, if you put the block name there, you cannot leave it empty. In this case, you can use the word pass in order to do nothing. So supposing I have a list and I want to remove an element from the middle of the list. So one way to do this of course is to take the slice up to that position, the slice from that position, then glue them together using plus and so on. But what if I want to directly do this? So it turns out that there is a command called Dell. So if I say dell l four, what it does is it effectively removes l four from the current set of values. And this automatically contracts the list and shifts everything from position five onwards to the left by one. So let's just verify that this works the way it claims to work. So supposing we set our list to be the range of values from zero to 100 to nine, say, and now I say del l four, then l becomes 012-35-6789 because l four was the value four. Remember the position start from zero and so it has actually deleted the value at the fourth position. So this also works for dictionaries. So if you want to remove the value associated with the key k, then you can use del dk and it'll remove the key k and whatever values associated with it and remove from the. So the key will now be considered to be an undefined key. So in general we can take a name like x and say del X. And what this will do is make x undefined. So supposing we wrote some junk code like this, we set x equal to seven and then we said del X. Then we ask Y equal to x plus five. Now at this point, since x has been undefined even though it had a value of seven, this expression x plus five cannot be calculated because x no longer has a value. And what you'd end up with is the error that we saw before, namely a name error saying that the name x is not defined. So how would you go about checking if a name is defined? Well, of course you could use exception handling. So supposing we want to assign a value to a name x only if x is undefined, then we can say try x. So this is trying to do something with x. Remember that names can be anything, they could be functions. So you can just write x because if it is currently name of a function which takes no arguments, it'll try to execute that function. So it's perfectly valid to just write x. But x, if it has no value, it will give a name error. So you can say try x, and if you happen to find a name error, set it to five, otherwise leave it untouched. So if x already has a value, this will do nothing to x. If x doesn't have a value, then it'll update the value of x to five. Now, usually what happens is that we want to check whether something has been defined or not. So far, it's not a good idea to just leave it undefined and then use exception handling to do it, because you might actually find strange things happening. So Python provides us with a special value called none, with a capital n, which is a special value used to define nothing, an empty value or a null value. So we will find great use for it later on when we're defining our own data structures. But right now, just think of none as a special value. There is only one value, none, and it denotes nothing. So the typical use is that when we want to check whether a value name has a valid value, we can initialize it to none, and later on we can check if it is still none. So initially we say x is equal to none, and finally we go ahead and say, oh, if x is not none, then set y equal to x. In other words, y equal to x will not be executed if x is still none. Now, notice the peculiar word is not. So we are using is and not equal to. So there is exactly one value, none in Python in the space. So all nones point to the same thing. So remember is was checking. When we say l one is l two, we are checking whether l one and l two point to the same list object. So we are asking whether x and the constant none point to the same none object, and there is only one value, none. So x is none is the same as x, equal to equal to none. So x is not none is the same as x, not equal to none. So x is not none is much easier to read than x, not equal to none. So that's why we will write it this way. So what we have seen are three useful things which we will use from time to time as we go along. One is the statement pass, which is a special statement that does nothing and can be used whenever you need an empty block. Then we saw the command dell, which takes a value and undefines it. The most normal way to use Dell is to remove something from a list or a dictionary. We would not normally want to just undefine a name which is holding a simple value, but from a dictionary or a list we might want to remove a key, or we might want to remove a position. And Dell is very useful for that. And finally, we have seen that there is a special value, none, which denotes a null value. It's a unique value. And this can be used to initialize variables to check whether they have been assigned sensible values later in the code.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Pointer (Contd.).mp3,"So we were discussing about pointers, and we have seen that pointer is a variable. So since it's a variable, but a variable that points to some other variable. But naturally, the question that can arise is, since pointers are variables, we should be able to do some sort of operations, like arithmetic operations on them. So the answer is, yes, we can do that. And in today's lecture, we'll look at exactly that. Pointer expressions. Now, this concept of pointers is a very strong component of the C language, and it's not the case that in all languages, this pointer is there. But we are discussing pointers specifically because it will give you a very good idea about what indirection is. We had mentioned about indirection, right? So, for example, I'm just, before moving into the actual discussion, let me come to this that what is an indirection? Somebody asks you the address of Tom's house. You can do two things. You can either give him the address of Tom's house, or you can give him the address of John's house, so that he goes to John's house and asks John to get the address of Tom's house. So I do not know Tom's address, but I know John, who knows Tom's address. This is indirection, one level of indirection. Another level of indirection could be that second level of indirection. You can go to Ram and Ram will know the address of John, who knows the address of Tom. So that is second level of indirection. So in our case, we have got a particular variable, p. Let me just call this variable x, and that x has got some value. I am not saying, and x has also got an address, but I am not saying, what is the value of x? What is x? That is my question. And instead of answering that, I am giving you a pointer to x. And I am asking that, okay, I tell you, I give you the answer, go to p and find x, right? So then p must be assigned the address of x. So I go to this. Then I come to p and get the value of x as I want to have that in some other variable, v, where I want to have star p. So indirectly, I could have done simply v assigned x. These two are equivalent. That's what we discussed in the last class. Right. That's why it is an indirection that often comes in very handy, very useful when we carry out many computations. So, like other variables, pointer variables can also be used in expressions. Okay, if p one and p two are two pointers, the following statements are valid. Star p one plus star p two so what is being meant by that? Suppose p one. P one is pointing to something where there is 50 and p two is pointing to something which is stored as 60. Then what is sum? Sum becomes 50 plus 60. Star p one plus star p 250 plus 60. So that should be 110. All right, next. Similarly, I can have this, but here it would be nicer if I had. It would be easier, nicer to read if I had put parenthesis so that I am not confused about this. Asterisks and this asterisks, these have got completely different significance. This is the multiplication. And this is saying. This asterisk is saying it's a content of a particular pointer. All right, so similarly, these two are equivalent. Of course, I have already shown that. Now this is also possible. Star p one. So in my earlier drawing, p one was 50 50 plus two. That is being coming over here. So this one looks like that. Whenever you're finding difficulty, as I suggested, just draw a simple diagram. P one. P one is pointing to some other variable which has got the value 40. So p one. Star p one is what? Star p one is that particular variable, x and plus two. That's equivalent to x plus two, which is 42, right? And so that is coming to. So this one is being modified to 42. Clearly, I can do other operations like this where you must understand that this is actually talk just like another variable, that an integer variable or whatever type p one is that type of variable. And it's simple. No other complications in that. Now, what are allowed in C? The certain things are allowed in C and some things are not allowed in C. I can add an integer to a pointer. I can subtract an integer from a pointer. I can subtract one pointer from another and say if p one and p two are both pointers to the same array, then p two minus p one gives the number of elements between p one and p two. For example, suppose here there's an array, so p one is pointing here and p two is pointing here. Then the number of elements p two minus p one will be just the subtraction of these addresses. Suppose this was 5500, 501, if it be a character, 501, five and two, five and three. So I have got three elements in between, right? So these are all allowed. I can subtract an integer from a pointer. I can add an. Add an integer to a pointer. So if I add an integer to a pointer, that is p one, p one plus one. So that means it will point to this point, this element, right? What are not allowed? The things that are not allowed are you cannot add two pointers. The reason is obvious. P one is a pointer and p two is a pointer. Now, these two are two different locations. So say p one is in location 7000 pointing to some variable, and p two is in location 10,000 pointing to some other variable. So what does p one plus p two mean? 7000 plus 10,000 17,000. That does not mean anything. That can point to some garbage value or something else. So that is not allowed. Compiler will hold you for that. Multiply or divide a pointer in an expression. That is also not allowed. You cannot multiply. You can just add an integer, subtract an integer, or subtract one pointer from another. These three you can do. And here is something which is known as a scale factor. Let's see whether you understand this or not. We have seen that an integer value can be added or subtracted. So here, let's look at this. P one and p two are two pointers of type integer. I mean, p one is pointing to an integer. P two is also pointing to an integer. All right, now, I jr. Two integer variables. P one is p one plus one. That means what? P one was pointing somewhere, but I am just adding some constant to that. So here is a memory location and say p one is pointing to this. All right? And suppose it's an integer. So this pointing to an integer. Now, p one plus one means this will point to the next integer. Now, I am not saying whether, if an integer takes two bytes, each of them are of two bytes. So it just comes to the next integer. So the pointer arithmetic is. That's why the type is important. Depending on the type, it is updating, either by two or by one. But p one plus one means I am going to the next p two is assigned p one plus j, where j can be something. So it goes to the. So p two was pointing somewhere. Here I am upgrading that with the j value going to the jth. Next. Similarly, p two plus plus p two assigned any arithmetic operation I can do. All right, next. In reality, it is not the integer value which is added or subtracted, but rather, the scale factor times the value. That is, one means one times the size of the integer. If it were so j times the size of an integer. Two bytes, four bytes. That's what, that's why it's called the scale factor. Okay, so this is not this one, but next one. Next two. Next here, j. It's next like that. So for character, the scale factor is one integer is four. If four bytes take one integer, float four. Now, this could be two. That depends on what the scale factor is, depends on the particular machine. So if I write for an integer pointer, assuming my computer is actually doing this, that each of them is four, then p one plus plus is adding p one by four. That's going to the next integer, going to the next integer. Now, in between there are four bytes. Okay, so I'm going to the next integer. So there is one quick way of finding out how we can find out what is the representation. In my system there is a nice inbuilt function called size of. So if I give size of int, the system returns me the value four or two, depending on how many bytes does int consume. Similarly, I could have given size of float. That will tell me how many bytes does the float consume, so and so forth. So that is one way to find the scale factors. So, number of bytes occupied by float is size of float. If you give that, the system will give you the size of returns that value, okay, the number of bytes required for that representation. So if in a system you would run this and you find that it is float is four, int is four, then you know what my scale factor is. Now, just like for every case we are thinking of how do we pass an array to a function? How do we pass a structure to a function? Here again, we look at how do we pass a pointer to a function. Pointers are often passed as parameters to a function, and if you have thought about it, you must have already discovered it. Now, always it allows the data items within the calling programs to be accessed by the function altered and then returned to the calling function in the altered form. This is the calling by reference. Okay? Normally arguments are passed to a function by value. We had discussed this. Now this is called as call by reference or call by address. Now you can see this, how this is done, because in call by value, we have seen that in the swap function, for example, it was swapped within the function, but that x y and the main functions xy were two different entities. Therefore, whatever change was there, that was lost. Therefore here. But if I had just passed on the pointer, then whatever change I do in the pointer in that particular location, I simply pass on the address and make a change over there. Then the change is deflected. It's because it's the same location that is known as call by reference. Now here is an example of you have seen this passing by value. I am repeating this. A was five and b was 20. I called swap ab here. What happened? It took x was five, b was 20. I changed it. Now x was therefore, now x was 20 and b was five. But when I returned and printed this a and b, they were completely different. So swapping was not reflected. Therefore here x and y are swapped. A and b do not swap, but instead. So the output would be the same, five and 20. But if I had done through reference here, you see how I pass it on here, what are you, am I passing? You must have thought about it. So up, instead of sending that value, what I am sending is the address of that address of a and address of b. And here inside the function, what am I accepting? I am accepting the pointer. So here, x and y. I know that what is coming to me is a pointer. So what happened here? A was five. We discussed it earlier also. But let me repeat, because it's a very fundamental idea. B is 20 and now I swap. Okay, so here I have got, do I have x? No, I have got this x which is nothing but and a. And I have got this y which is nothing but and b. Therefore they are pointing to these points. Now when I swap, I am actually swapping the content of x. So the content of x, that means here that is going to t and then content of y, content of y, indirection. I go from here, follow my cursor. I go here, and that one is going as the content of a, content of x. So here it is becoming 20, and then t is coming as the content of y. What is y? Y is here. So this is coming as five. So when I come out and print here, a and b, as you can see, has changed. So you see, how did I pass on the parameter? Look at this. I have passed on the address and I have accepted them in my function as the pointer. Okay? So with this we'll get the correct answer. X and Y swap. A and B also swap. So the answer is, that is the correct one, as we expected. So now let's skip this a little bit and let's go to something else. As pointers and arrays. When an array is declared, when an array is declared, the compiler allocates a base address and sufficient amount of storage. You know that when I declare something, an array, int a ten, and if I say that int, I have discovered using size off that int takes four bytes. Then for every element, four bytes are kept and 40 such locations are allocated. For me, for me means for the array a. Now this, all right. Now when I refer to this array a, because we saw that we pass on an array by reference to a function. When we pass an array, we call it by reference. The reason behind that is that this name array a is the same as a pointer to the first location of the array. So it's as if equivalent to a is a pointer that is pointing to the first location of this array a. All right, they're equivalent. So the base address is the location of the first element of the array. The compiler also defines the array name as a constant pointer to the first constant pointer when I declared it. The compiler also keeps a constant pointer. That pointer you cannot change. Okay, for example, when I say x 512345, then suppose the base address is 2500. Each integer requires four bytes. Then the elements will be x zero will be 2500, x one will be 2504, so and so forth. And the pointer will be 2500 if you go up 2500. So there is a pointer x means and address of x zero, which is 2500. All right, so p assigned x and p assigned end of x zero are equivalent. Okay, so we can access successive values of x by using p plus plus or p minus minus to move from one element to another. So I have got the p, I have got this pointer is pointing to the array. I cannot change that pointer, but if I do p plus plus this pointing to the first element, then I go to the next element of the array, accord by the scale factor. Okay, so this is if I do p plus plus, I am actually doing p plus four, say in that way I can move across. Okay, so the relationships should be clear here. So p plus one is the next one. P plus two is the next one that we have already explained. So here is a function to find average. Here you see we have got a main program where I have got an array, hundred elements for k assigned k to n, for k zero to n. I am reading k and then I'm calling this average x. I am calling average x n. Now here what goes average xn. You have seen this. Now I am passing the pointer. When I'm saying I am just passing the array, actually I passed on the pointer. So whatever I do, I am doing here, I am taking another star p which is local, which is pointing to the array. So my array was here and I am putting another pointer p which is pointing to this array. And array means what? Array means the first location of the array. Then I carry on the sum here I carry on with p. Here you see what I do? I take p and then I change p. Sum assigns star p plus I. So I'm p plus one, p plus two, p plus three, and star p plus one p plus two means the content of this, these contents. So here in this way, I'm getting the sum and returning. What do I return? Return float sum by size. So I get sum. Obviously the array was integer, but now this is something called typecasting that I can make it. Although it was float, I put it in a bracket. That means whatever is coming here, I am converting that to float. All right, sum will be the array. Sum of all integers will be an integer. But when I divide by that, although I did not declare sum to be floating point number, just by this sort of typecasting, I can make it. I'll first do this and convert it, make it a floating point number, and then how do I return it? Yes, you might have guessed correctly that I don't need to return it because whatever I have done here, when I passed an array, whatever was done that is being done here, and this sum, what I am returning, I'm returning this to the average. So I'll get this value. All right? So this should be clear, so clarified now, next thing that I'll be discussing a little bit is on dynamic memory allocation. I'll take little time to explain that. That's a very important concept. And after that we'll move to some discussions, basic discussions on file.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Pointer in Structures.mp3,"We have seen how structures are represented. We have also learnt about pointers. So today we'll be looking at the structure us once again in a different light. As you can see here, a structure can be declared as is shown here, the student structure struct stud is consisting of three members or three fields. So they are the role, the department code which is a character array and CGPA, which is a floating point number and ABC are three variables of the type stud stud. The individual structure elements, you know, can be accessed by a dot role. So a is this field or b roll, c dot, CGPA. So with this dot operator we can access them. This was known to us. Right now we can also, we have seen that we can define an array of structures where class is an array of students, class sizes hundred and each element is a structure of type stud. The structure elements of the individual records can be accessed with this dot operator like class I. Any particular element of that, say for example here, any particular element I take. So this is class I where I is this index. I come over here and get a particular field of this. So this has got a number of fields. So I'm coming to the role field or the department code field or the CTPA field. This was also known to us. Okay. So here we are trying to apply that through an example, sorting by role numbers. So here we have got a set of students. Look at the declaration here. Student or struct stud is the structure having role department code and CGPA. Now in the main function, what are we doing? We are defining struct student class hundred. Now, struct stud has been declared, it has been declared globally even before main. That's possible. Okay. And here I am saying that class hundred is one array and t and there are some integers. T is again a structure. T is also a structure of type stud. Now I'm reading the number of students. Okay, how many students are there in the class? The array can accommodate at most hundred. But I am reading the value n now for each of the elements. Look at this. This is our familiar for loop here. For k is equal, k zero to less n. I am scanning the class, the role number of that particular student, the department code and the CGp. So in that way I read here, I am reading the array. All right. The array is being read here. Array is read at this point. Right now. What I am doing now, next, let's look at this loop. What are you doing here? For some value of j if the role of that student. So here I have got my array I am coming to any particular j, a particular element, and looking at the role number field of that. If that is greater than some other value, k. If is greater than the role value of k, then I am exchanging them. Just as we sort. Now, what are we sorting here? In the example earlier that we had done, we are sorting integers or sorting real numbers here, what we are doing, we are sorting the entire structure. As you can see here, the entire structure, the j is coming to t. So t is again a structure. K is coming to j. And so this is a swap operation. Swapping structures. Swapping the structure structures. All right. And this I am doing for k is the internal variable and j is the external variable. So my diagram should be a little different. The diagram should be. So for every j, I'm looking at one j and I'm varying k from here. This is k. K is varying from this point to this point to the end of the structure and comparing with this j value. If this is any element that is less, that is coming over here and it is being swapped. So you have seen this swap algorithm earlier. So that is being swapped here. And then I update j and I go on doing this. So this is how I can apply the sorting algorithm that we had learned that can be applied for sorting student records. All right, next, the other thing that we have to look at is pointers and structures, how they can be intermingled. You may recall that the name of an array stands for the zero 8th element of the array. So if this be an array, then if the name of the array a is name of the array is a, then the name a and a zero are synonymous. And so a is also a can be considered to be a pointer that is pointing to a zero. All right, now consider the declaration this. This is also true for the names of arrays of structures. So if I have a declaration like this, you look at the declaration yourself. So you can see student is a structure. And I have declared of the type student an array class hundred and star PTR. Now what is star PTR? What does it mean? You know, by now, just as we had done this, keep it side by side in star p, what does it mean? It means that P is a pointer that points to integer data type. Here it means that PTR is a pointer that points to stud type of structures, this type only to this type of structure. PTR points to that. So now what do I have? I have got an array called class, each element of which is of type student structure. And I have got a pointer PTR, which can point to such structures. Okay. It can point to such structures, any of these. I have not yet initialized this. Okay. The name class therefore represents the address of the zero th element of the structure array. So if we go back, so if I have this, then this class means it's a pointer that is pointing to this element, class zero. All right. Just like an array and PTr is a pointer to the data objects of type struct that we have seen the assignment class assigned to PTR. What will it make? It will make ptr now to point to the first element of the array. Here is class and PTr is now pointing. When I do this assignment, note that they are of the same type. So when I do this assignment, this is pointing to this element. All right? So it will assign ptr to class zero. Understood. When the pointer PTr is incremented by one, that is ptr plus plus, you should be able to tell me what will happen. The PTr will be incremented to the next element of the array. So the actual increment will be by a scale factor. And what is that scale factor? That scale factor is size of stud. Size of this structure stud. And you know that it has got a role number, it has got CGPA. So depending on the different data types that are housed inside that structure, it will vary. So the value of ptr will point to the next element will be incremented by size of stud. Fine. This much is clear. So it's permit to point to the next record once ptr points to a structure variable. Now this is something new. The pointers can be accessed as ptr role. That's possible. So let's see what is happening. You are being introduced to this operator, the arrow operator. So here, or this only comes if the left side of this operator is a pointer. So it is if. Suppose I have got some structure and pointer p or ptr is pointing to this structure and it has got different fields, says CgPA is a field. If I write ptr arrow CgPA, that means that I am now pointing to this, I am actually accessing this element of the structure. Just as suppose this structure is class and this element is class one. Say I could have written class one CGPA. And here what I have done is I have already done that ptr, the pointer ptr was assigned to class zero and then I did ptr plus plus. That means now where is ptr pointing to? Its ptr is pointing to class one. So I can also do ptr now ptr arrow cgpa these two are equivalent. This and this are equivalent. Okay, so here also you can understand this. So let's move ahead. Similarly, I can go to another field by ptr department code. I can go ptr cgpa, ptr role the symbol, this symbol is naturally called the arrow operator. Okay, example, you can read this typedef. Now here I am defining a type. The name of the type is complex. And what is this type complex. It's a structure with real and imaginary parts. This is what we saw earlier. Right. Next I have got a function print complex star a. What does it mean? A is a pointer to type complex. So printf whatever. There are two placeholders, a real, a imaginary. So why is it possible? A is a pointer, so it is pointing to some complex number. It is pointing to some complex number, some complex number, whatever that is. A is a pointer pointing to that. And I'm going to the real part, I am printing a real and this one, this part is a imaginary. Okay, so this is what is being done by this piece of function code. So now swap reference. I have got complex a and complex b. That's not, I'm sorry, it is not being visible here. There are two a and b. There are two pointers in complex. So there is Tmp. I take another structure named Tmp of type complex and I swap the pointers. Here you can work it out. That means that a was pointing to some structure and that a is pointing to this structure, and this particular structure is copied to another structure, temp. And b then b was pointing to another structure. B and a are swapped. So now b is pointing to this and a is pointing to this. Next I am making b to point to this. So that is how a swap operation can be done and how we passed on the parameter to this. So the main program can define complex x, ten and three. Y is -20 minus ten. Because of the resolution it's not visible. So print x and y, then swap reference. Print x and Y. Now can you guess and tell me whether the swapping will work in this case or not? The answer is yes, it will work because it is a call by reference. So here, whatever I am swapping here, that will be reflected in the main program also. Okay, so here's an example. So let's move ahead. Now, one warning is there that when using a structure pointers, we should take care of the operator precedence because here we have seen the star symbol as well as dot symbol, right? We have seen the star symbol as well as the dot symbol. Now this dot has a higher precedence than star. What does it mean? It means that if I have got something like PTr role then and Starptr role, what will happen? This dot has got a higher precedence. So these two are the same thing. PTr role PTr is a pointer and the role is that particular field and star PTr is what? Starptr is the star PTr is that particular structure and I am going to the role field of that structure. So starptier role, that is these two are equivalent. But if I had done this, that would be an error. Why? That would be an error because this dot operator has got higher precedence than this star operator. So basically I'll try to get the role field from the pointer ptr, but that is not the case. I cannot get that there is no role field inside the pointer ptr. The role field is there in the content of the pointer ptr, that is star ptr. So I must make first star ptr within bracket then dot role. So this is correct to mean this, but this is wrong and the operator arrow enjoys the highest priority among operators. Among all these operators it has got the highest priority. So we have learned. So here in this case what will happen plus plus ptr arrow role as we have said that this has got the highest priority, we'll go to where the ptr is and go to the role field of that and after that we will increment this plus plus although it is shown as a pre increment so that will not have higher precedence than the arrow operator. So if I want to first increment the ptr and then get the role, then I should do plus plus ptr arrow role will do the intended thing. This will not do the intended thing. I hope this is clear. This part now structures and functions structures can be passed as argument to a function and a function that we have already seen a function can also return a structure. So we have seen that using two complex numbers, how we can do that? So here again we look at that example that we have got a complex number complex structure with two fields. I've now changed the names float rd and float im and in the main function I am scanning and a dot re real part of a real imaginary part of a, then real part of b, then imaginary part of b and then I call the function add ab. What is happening here? When I call this add ab, what am I passing? Ab and here xy so it is a call by value, right? So here this is copied. Now struct complex x y. There's no problem here. It's not like swap, I just want to add. So I've got two internal variables, x and y and t. That new structure, t is taking x's real part and y is real part. Then I am getting the real part of t. And in the imaginary part of t there is nothing here. There's an excess space in the imaginary part of t. I take the imaginary part of x and the imaginary part of Y. Then I'm returning this t to C where c is also of type complex. Since the types are matching, I can pass it on over there. Now this is one way of adding the complex numbers. Now if this is clear. Now let's look at an alternative way of using the pointers. Here. I just change this. Other things are same. What I am doing here is I have called them. Now passing the address. Now I am passing the pointers. In the earlier case I was passing the value here and now I am passing the pointers. I am passing address of a, address of b and address of c. Now inside this add function, what am I doing? I am taking x and Y. So these are pointers, I'm taking them and t. T is real. So t is a type pointer. So t, sorry. So t is a pointer that is pointing to another structure of the type complex. And t's re t arrow re means the real field of this t will be taking the real part of X-E-X and real part of y. So here x plus y, the sum will come, the real part of x and real part of Y will come here. And here the imaginary part. Here the imaginary part of x and Y will be added. Okay, now when here, I am not returning any t because this t is nothing but this c. So this t and c are mapped. It's a call by reference. So c is also actually pointing over here. So I get the result here. So this is another way in which in structures we can use pointers also. So these are relatively more advanced aspects. And you will gradually practice this and you will get familiar. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Pointer.mp3,"In today's lecture we will look at very important concept of programming. It's are required to conceptualize and understand the thing very well so that you can have more flexibility with programming. We have visited this idea, the concept of pointers earlier in the context of our discussions of call by value and call by reference. So if you recall at that time we had talked about the variables which are in the memory, right? So suppose I am talking of a variable. X-Y-Z is the name of a variable. So that variable has got some address, that address maybe say 5000 in the memory. And who has allocated this address, that address has been allocated by the compiler. Now if I have another memory location, another memory location, say a part of this, part of this which I'm just drawing separately, whose address is say 7000, say this one 7000. And inside this location 7000 as its content, I write 5000 and I say that whatever is the content of this location 7000, that is the variable I am interested in. So can I say that if I now give a symbolic name p to this 7000, I can say or say this is p, that this p is pointing to X-Y-Z because p is containing the address of X-Y-Z. Therefore p is a pointer to a variable. Xyz, we also say that p, right now it is pointing to X-Y-Z. But if I just change the value of this location 7000 and make it say 6000, then it will probably point to some other location here. So p is therefore a pointer variable. But when I say that it is a pointer variable, then it is not pointing to any particular data, it can point to a type of data. So instead of making this statement that p is a pointer variable to a variable, X-Y-Z say this one is pqr, say now as I change this now p is a pointer, pointer variable to a variable PQR. So if I generalize it, I'll say that p in this situation where I have got X-Y-Z at 5000 and pqr at 6000, I can say and 7000 is a pointer p. And I can say p is a pointer variable pointing to say X-Y-Z and pqr are both integers to an integer. Or it could be a float, or it could be some other data type. So pointer to a particular, a particular data type. Why I specify the data type will be clear in some time from now. So we have got a pointer. The concept, the most important concept here is that p is a pointer. P is a variable, that variable is holding some value and that value is nothing but an address of another variable. All right, address of another variable. So now let's look at this. The basic concept. Every stored data items occupies one or more memory cells. Whenever we declare a variable, the system allocates memory locations to that variable. We know that very well, so need not spend more time on that. The number of memory cells required. Now, this is important. You already know that the number of memory cells required to store a data item depends on its type. Typically for care, we need one byte. For int, we need two bytes. For float, we need four bytes, et cetera, et cetera, et cetera. Okay, so since every byte in memory has a unique address, this location will also have its unique address. Every element will have a unique address. So let's see here the same example. Consider the statement int xyz assigned 50. This statement means that the compiler will allocate for this xyz some location and put the value 50 in that location. Suppose the address is address of XYz is 1380. Here, XYZ is a variable and 50 is the value, and 1380 is the address of that variable. We know that we have discussed it earlier. Now, during execution of the program, when the program is being executed, the system always associates the name xyz with the address 1380. So whenever in the program we find xyZ, the variable xyz being referred, it will go to the memory location 1380 and fetch that. Okay? So the value 50 can therefore be accessed by going to the location 1380 and accessing it. Now, the variables which are holding these addresses are known as the pointers. Now, memory addresses are just numbers, so I can also store them in some variables. And these variables which are, for example, the address of the variable that will hold the address of variable xyz is the pointer to xyz. So it is also naturally stored in some MA location. So this is just the example that I was discussing right. Now. Suppose we assign the address of xyz to a variable p. Then p is said to point to the variable X-Y-Z. Now how do I. I was just drawing this. I was comfortably drawing this, that there is 5000 here, X-Y-Z and 5000 here. And I was simply saying that this variable, which was in location 7000 was pointing to this. That means this was being loaded with 5000. How is that being done? How is 5000 being written inside this location? The statement is just like any other assignment will be that this variable's name is p. P is assigned the address of xyz. So p assigned and xyz right now. So here we can see that the variable xyz, its address is 1380. Value is 50. P is a pointer variable whose value is 1380 because it's pointing to xyz. In our diagram that I was drawing by hand, this p was holding the value 5000. Okay? And its address here is say, 2545. In my diagram, it was 7000. Okay, so this is the picture. 1380 is the address of 50 and p, which is located as 2545, is holding the address 1380. Clear. Now this concept, whenever you find difficulty in dealing with pointers, my suggestion always to the students is draw a piece of diagram and then you make the whole picture clear in front of you. Testing the address of a variable. Now, you know that if I put the operator and ampere sand immediately before the variable, that will return the address of the variable like and xyz will give me the say, the value 1380, which is the address of xyz. The address of xyz is assigned this operator and can be used only with a simple variable or with an array element, for example, and distance and x zero. That means the address of the first location of the array x and of x I minus two. All these things are possible. Now what is illegal? This is illegal. The reason is obvious. 235 is not a variable. It's a constant. So it doesn't have any fixed position in the memory. So it is not a memory location. Therefore, it does not have any address. That's meaningless. Pointing to at a constant, that's not possible. Say int, I cannot say. And air because this shows that ARR is a particular variable, but it's an array, therefore I cannot show it like this. It's just pointing at an array name. It's not pointing at the array. Okay, we cannot also do this. And a plus b, that's also not possible because this will be, again, if I have a as some value and b has some value, then I add that and that will be a value. And a value does not have any address that's pointing at an expression. So here is a quick example. I think I had shown this to you earlier. Say I have got three variables, a number of variables, one character, one double floats. So if I put, say I am assigning some values to these, here I am putting some values and printf a particular variable. A is stored in the address and a b is stored in address and b c is stored in address and c so and so forth. Therefore, if we run it, we'll get the addresses coming out. So ten is stored in location, so and so 2.5 is stored in location so and so. All right, now here, incidentally, it's just incidental that just for the sake of example, all these are contiguous locations, but they may not be contiguous locations also. All right, so ten is stored in location. A is a was having the value. Ten is stored in location so and so. Like that, it goes on. So, pointer declarations. When we declare some variable as a pointer, the typical, the standard form is this data type shown in red. That's very important. And this star, this is something new that you also saw this when we were discussing call by reference. For example, int is a type star. Xyz. X, what does it mean? It means that x is a variable of type integer. X is a variable. Sorry, I'm sorry, absolutely sorry. X is a pointer which is enabled or which is allowed to point to variables of type. Integer only integers can be pointed out, pointed to by x. So this is similarly, I could have said float star p. That means p will be a pointer that can only point to floating point numbers only. All right, so three things are specified in this declaration. One is that the star tells that the variable pointer name or p, whatever you call it, is a pointer variable, not a normal variable. And asterisks is telling that it is a pointer variable. Pointer name is a variable. Therefore it needs some memory location and pointer name. Type points to a variable of the specified data type. So these three things you must remember when you are handling with a pointer. So here is an example. Int star count, what does it mean? That means count is a pointer variable. Why a pointer variable? Because this is preceded with a star. And where can this pointer variable point to? To all data variables of type. Integer speed is again a pointer because it has got this asterisk. And where can speed point to? Speed can point to variables of type float. Once a pointer variable has been declared, it can be made to point to a variable using an assignment statement like this. In star P-X-Y-Z. So in star p is a point. P is a pointer variable. Xyz is an integer. So you see by the same declaration I have declared two things. One is a pointer to an integer and an integer. So if I make such an assignment like p is assigned and xyz, so xyz is here and its location can be 5000 and p is a pointer variable. And so when I do this assignment, this might be in the location 7000. But when I do this, what it does is it loads this 5000 here. So now p is pointing to X-Y-Z-I hope it is clear now. All right, so this is called pointer initialization. The things to remember is the pointer variables must always point to an item of the same type. One pointer variable. Either it points to an integer or it points to a float, or it points to an array of characters, whatever it is. Assigning an absolute address. Now. So here, for example, this is an error. Why is this an error? X is of type floating point x the variable, and p is a pointer which is allowed to point to only integer. But here I have made an assignment where I am assigning to p the address of the floating point number. That is not allowed, so therefore, I am forcing p to point to x. But the type of p and the type of x are different. So assigning an absolute address to a pointer is prohibited. You cannot do this. You cannot do this, okay? You cannot force a pointer to a constant value that you must keep in mind. So how do I access a variable through a pointer? Once a pointer has been assigned the address of a variable, the value of the variable can be accessed through the indirection operation. Now, here you have to think of again, we are talking of star. So let's give an example first. For example, a b are two integers. Let us draw this. I'm sorry. Suppose a is a location. B is another location. Both of them are integers, and p is a variable which is allowed to point to integers. And what I do, I assign to p the address of a. So the address of a, let's say it's thousand or hundred. So hundred is written here. So it comes here. Now I say, so what did this statement do? Hundred was the address of a that has been assigned to p. Now, what is being done by this? B is being assigned star p. That means whatever is b is getting the content of where p is pointing at. Suppose this was 50. Then b is getting 50. So a little bit of confusion can occur because of these two star p's. Please understand that this star is just telling you that p is a pointer because it is coming in a declaration statement. On the other hand here, it's not a declaration statement, it's an assignment statement. I have already declared p to be a pointer. So p is a pointer. So once a pointer has been assigned the address of a variable, once the pointer has been assigned the address of the variable, that is done. In this step, the value of the variable, value of the variable can be accessed using the indirection operation. That means which variable? Say I could have done this, p assigned a, but I am not doing the sorry, b assigned a. Instead of doing that, what I am saying if I make just note my two english statements. One is the value of a is being assigned to value to b. Statement number one. Statement number two is, or b is being assigned the value of a statement number one. Statement number two is b is being assigned the value of the variable that is being pointed at by p. Clear? So here, one is b is assigned the value of a. One statement here. That is this statement. And this statement is b is assigned the value instead of off. A, I am saying, is being assigned the value of the variable pointed by p. So this is an indirect way of saying that, okay, so this is something that you must very clearly understand. Look at this once again. So I can now say that this thing is equivalent to b assigned a, but I have done in an indirect way. If you have understood this, then pointer should be clear to you. Here. Look at one example. Integer ab, c assigned five. And p is a pointer to integers. Now, in this statement, what has been done? A is being assigned four times c plus five. So c is being added to five. So it is becoming ten. And four times ten is 40. 40 is being assigned to a. Here, what is being done? P is being assigned C's address. So wherever c was, c was, say address, thousand. So that is being assigned to a variable p. So p is becoming thousand. All right, now, b, what is b being assigned? B is being assigned four times star p plus five. What is star p? Star P. Sorry. C is star p is nothing but the variable c. It's pointing to that. And whatever was its value, suppose it was ten. Sorry, it was five. So that value is being taken. And five is being added to that. So it becomes ten times this. So these two are essentially equivalent. All right, so here is another example. You have seen this example very similar to this, that I am defining a pointer. PTr is a pointer. X is ten. You just think of what it should print. X is ten. Ptr is the address of x. Ptr is the address of x here. And y is being assigned star ptr. What does this mean? Ptr is pointing to ten and y is being assigned to star ptr. That means y is being assigned to ten. Or y is being, rather, I should say y is being assigned x and x was ten. So y is becoming ten. Now, if I print percent is told x instead of x, what will be printed instead of x? The value of x will be printed. Ten is stored in the address. This similarly, now what is this star and x, what does this mean? Index is the address of x. And where that is pointing to these two should be same. So if you look at, if you look at the result, this is equivalent. Y and x is the address of x and star, just like star p. That means the content of where the pointer is pointing to. So these two are same. Right? So ptr is andex, ptr is the same and x is nothing but ptr. So these two are all equivalent. Okay, if I say and x, that means I am taking the address of start ptr. So this is something you can toy with yourself, and you will get a printout like this. So these two are the same. Okay, now here we are coming to something more, which is known as pointer expressions, and we'll deal with that in the next lecture. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
priority queues and heaps.mp3,"You. So let's look at a data structure problem involving job schedulers. So, job scheduler maintains a list of pending jobs with priorities. Now, the job scheduler has to choose the next job to execute at any point. So whenever the processor is free, it picks the job, not the job which arrived earliest, but the one with maximum priority in the list, and then schedules it. So new jobs keep joining the list, each with its own priority, and according to their priority, they get promoted ahead of other jobs which may have joined earlier. So our question is, how should the scheduler maintain the list of pendant jobs, pending jobs, and their priorities, so that it can always pull out very quickly, the one with the highest priority to schedule text. So this is like a queue, but a queue in which items have priority based on some other characteristic, not on when they arrived. So we saw a normal queue as a first in, first out object. The ones that arrive first leave first in a priority queue, they leave according to their priority. So there are two operations associated with the priority queue. One is delete max. In delete queue, we just said we take the element at the head of the queue. In delete max, we have to look through the queue and identify and remove the job with the highest priority. Note, of course that the priorities of do different jobs may be the same, in which case we can pick any one. And the other option which we normally called add to the queue, we will call insert. An insert just adds a new job to the list, and each job, when it is added, comes with its own priority. So, based on linear structures that we already studied, we can think of maintaining these jobs just as a list. Now, if it's an unsorted list, when we add something to the queue, we can just add it to the list, append it in any position. So this takes constant time. However, to do a delete max, we have to scan through the list and search for the maximum element. And as we have seen in an unsorted list, it will take us order end time to find the maximum element in list. Because we have to scan all the items. The other option is to keep the list sorted. This helps with delete max. For instance, if we keep it sorted in descending order, the first element of the list is always the largest element. However, the price we pay is for inserting, because to maintain the sorted order, when we insert the element, we have to put it in the right position. And as we saw, in insertion sort insert will take linear time. So as a trade off, we either take linear time for delete max or linear time for insert. So if we think of n jobs entering and removing, leaving the queue, one way or another, we end up spending n squared time processing these n jobs. So this is a fundamental limitation of keeping the data in a one dimensional structure. So let us look at two dimensional structures. The most basic two dimensional structure that we can think of is a binary tree. So a binary tree consists of nodes, and each node has a value stored in it, and it has possibly a left and a right child. So we start at the root, which is the top of the tree, and then each node will have one or two children. A node which has no children is called a leaf. And then with respect to a child, we call the parent node, the node above it, and we refer to the children as a left child and the right child. So our goal is to maintain a priority queue as a special kind of binary tree, which we will call a heap. So this tree will be balanced. A balanced tree is one in which, roughly speaking, at each point, the left and right side are almost the same size. Because of this, it turns out that in a balanced tree, if we have n nodes, then the height of the tree will be logarithmic. Because remember that the height doubles with each level. And as a result of this, we can fit n nodes in login n levels, provided it's balanced. And because it is of height login, we will achieve both insert and delete max in order login time. This means that if we have to add and remove n elements from the queue, overall we will go from n squared to n login. And another nice feature about a heap is that we don't have to fix n in advance. This will work as the heap grows and shrinks. So we don't need to know what n is. So what is a heap? So a heap is a binary tree with two properties. The first property is structural, which are the values which are stored in the tree. Remember, that leaves nodes in a binary tree may have zero children, one children or two children. So we could have, in general, a very uneven structure. Heaps have a very regular structure. When we have a heap, we have a binary tree in which we fill each level from top to bottom, left to right. So in other words, at any point a heap consists of a number of filled levels, and then in the bottom level we have nodes filled from left to right, and then possibly some unfilled nodes. The other property with the heap. So the first property is structural. It just tells us how the values look in the heap. So in this node, for example, in this picture, the blue nodes are those which have values, and the empty nodes are indicated with open circles at the bottom. The second property about heap is the values themselves. So the heap property, in this case what we call the max heap property, because we are interested in maximum values, says that every value is bigger than the values of its two children. So at every node, if we look at the value and we look at the value in the left child and the right side right child, then the parent will have a larger value than both the children. So let's see some examples. So here is a four node heap. So because it has four nodes, we fill the root, then the first level, and finally at the second level, we have only one node which is the leftmost. And notice that the values are correctly ordered. 24 is bigger than eleven and 711 is bigger than his only child, ten. Seven has no children, so there are no constraints. Here is another example where the bottom level is actually full. Here we have seven nodes, and once again, at every point we see that eleven is bigger than ten and five, seven is bigger than six and five. So we have the value property, the max heap property, along with the structural property. Here is an example of something which is structurally not a heap. So because it is a heap, we should have it filled from top to bottom, left to right. So we should have a node here to the left of seven before we add a right child. Therefore this is not a heap. Similarly, here, the node eight could not have been added here before we filled in the right child of seven. So once again, this has not been filled correctly, left to right, top to bottom, and therefore this is not a heap. This particular tree satisfies the structural property of a heap in the sense that it is filled from top to bottom. But we have here a violation of the heap property, because seven has a child which has a larger value than it, namely eight. So our first job is to insert a value into a heap while maintaining the heap property. So the first thing to note is that we have no choice about where to put the new node. Remember that heap nodes are constructed top to bottom, left to right. So if we want to insert twelve, it must come below the ten to the left, because we have to start a new level since the previous level is full. The problem is that this may not satisfy the heap property. In this case, twelve is bigger than its parent ten. So although this is now structurally correct, it doesn't have the right value distribution. So we have to restore the heap property in some way. So this is what we do. We first create the node we put the new value into that node and then we start looking at violations with respect to its parent. So we notice that twelve and ten are not correctly ordered. So we exchange them right now. This is a new node, so we have to check whether it is correctly ordered with respect to its current parent. So we look and we find that it is not. So again, we exchange these. Now notice that because eleven was already bigger than 512, will remain bigger than five. So there is no need to check anything down from where we got. We only have to look up. So now we have to check whether there is still a problem above. In this case, there is no problem. Twelve is smaller than 24. So we stop. So let's add another node. So supposing we add 33 now to the heap that we just created. So 33 again creates a new node at this point. Now 33 being bigger than eleven, we have to walk up and swap it. Then again we compare 33 and its parent twelve. And we notice that 33 is bigger than twelve. So we swap it again. Then we look at the root, in this case 24, and we find that 33 is bigger than 24. So we swap it again. And now 33 has no parents and is definitely bigger than his two children. So we can stop. So how much time does insert take? Each time we insert a node, we have to check with its parent swap, check with its parent, swap, and so on. But the good thing is we only walk up a path. We never walk down a path. So the number of steps we walk up will be bounded by the height of the tree. Now, we argued before, or we mentioned before, that a balanced tree will have height login. So you can actually measure it correctly by saying that the number of nodes at level I is two to the I. So initially we have one node, two to the zero. Then at the first level we have two nodes, two to the one. The second level we have four nodes, two to the two, and so on. So if we do it this way, then we find that when k levels are filled, we will have two to the k minus one nodes. And therefore, turning this around, we'll find that if we have n nodes, then the number of levels must be log n. So therefore insert walks up a path. The path is equal to the height of the tree. The height of the tree is order of login. So insert takes time order login. The other operation we need to implement in a heap is delete packs. Now, one thing about a heap is that the maximum value is always at the root. This is because of the heap property. You can inductively see that because each node is bigger than its children, the maximum value in the entire tree must be at the root. So we know where the root is. Now the question is, how do we remove it efficiently? So if we remove this node, first of all, we can't remove the node because it's a root. If we remove this value, then we have to put some value there. On the other hand, the number of values in the node in the heap has now shrunk. So this node at the bottom right must be deleted, because the structural property of the heap says that we must fill the tree left to right, top to bottom. So we're going top to bottom and we have run out of a value. The last node that we added was the one at the rightmost end of the bottom row, and that must go. So we have a value which is missing at the top, and we have a value at the bottom named eleven, whose node is going to be deleted. So the strategy now is to move this value to eleven and then fix things. So we first remove the 33 from the root. We remove the node containing eleven and we move the eleven to the position of the root. Now the problem with this is we have moved an arbitrary value, not the maximum value, to the top. So obviously there is going to be some problem with respect to its children. So here it turns out that eleven is bigger than seven, which is correct, but unfortunately it's smaller than 24. So to restore the property, what we do is we look at both directions and we exchange it with the largest child. So suppose this had been 17 here. Then we could have swapped eleven with 17 or eleven with 24. Both violations are there. But if we move the smaller child up, then 17 will not be bigger than 24. So we move the largest one. So in this case, we move 24 up. And now we have eleven again. And now we have to again check whether it is correct with respect to its two children. So again it is not. So we move the largest one up, namely twelve, and then we see now whether it is correct with respect to its children. At this point, eleven is bigger than ten. So we stop. So just as insert followed a single path from the new node of the leaf up to the root, delete max will follow a single path from the root down to a leaf. So once again, the cost of delete max will be proportional to the height of the tree, which, as we said earlier, is login. So let's do another delete. So we delete, in this case 24. Now we remove the node for 1010 goes to the root. We compare ten with its two children, twelve and seven, and find that it's not satisfying heap property. So we move the larger of the two up, namely twelve. Now we look at its children, new children here, eleven and five, and again we see it's not satisfying the property. So the larger one moves up, and once it reaches the leaf, there are no properties to be satisfied anymore. So we stop. So one very attractive feature of heaps is that we can implement this tree directly in a list or in an array. So if we have an n node heap, we can represent it as a list or an array with position zero to n minus one. So the position zero represents the root. Then in order, one and two represent the children, then 3456 other nodes at the next level, and so on. So just as we said, we filled up this heap left to right, top to bottom. In the same way we number the nodes also top to bottom, left to right. So we start with zero at the root, then one on the left, two on the right, then 345678, 910 and so on. So from this you can see that if I have a position labeled I, then the two children are at two I plus one and two I plus two. So the children of one are two into one plus one which is three, and two into one plus two which is four. Similarly, children of five are two into five plus one which is eleven, and two into five plus two which is twelve. So just by doing index calculations for a position in the heap, we can figure out where its children are. And by reversing this calculation, we can also find the index of the parent. The parent of j is at j minus one by two. Now j minus one by 2 may not be an integer. So we take the floor. So if we take eleven, for example, eleven minus one is 1010 by two is five. If we take 14, for example, 14 minus one is 1313 by two is 6.5. We take the floor and we get six. So this allows us to manipulate parent and children nodes by just doing index arithmetic. We go from I to two, I plus one, two I plus two to go to the children, and we go from j to j minus one by two, floor to go to the parent. How do we build a heap? A naive way to build a heap is just to take a list of values and insert them one by one using the heap operation into the heap. So we start with an empty heap. We insert x one, create a new heap. Concerning x one, we insert x two, creating a heap of x one, x two, and so on. Each operation takes login time. Of course n will be growing, but it doesn't matter if we take the final n as an upper bound, we do n inserts each login and we can build this heap in order n log n time. There is a better way to do this heap building. If we have the array as x one to x n, then the last half of the nodes correspond to the leaves of the tree. Now, a leaf node has no properties to satisfy because it has no children. So we don't need to do anything. We can just leave the leaves as they are. So we go one level above and then we can fix all heap errors at one level above, right? And then again we move one level above and so on. So we do the kind of up top to bottom heap fixing that we did with the delete max while we are building the heap. So as we are going up the number of steps that we need to propagate, this error goes higher and higher because we need to start at a higher point. On the other hand, the number of nodes for which this happens is smaller. So let's look at this here. So what we are saying is that if we start with the original list of, say, elements zero to 14, then the numbers seven to 14 already satisfied the heap property. So whatever values there, we don't have to worry. So then we go up and we may have to swap this with its children, we may have to swap this with its children and so on. So for four nodes, we have to do one level of shifting, perhaps to repair the heap property. Then we go up. Now one and two are the original values, so they may be wrong. So again we may have to shift it down one value and then another value. So now we need two levels of shifting, but we have only two nodes for it. So the number of nodes for which this is required is shrinking, is halving ACTuallY, and the number of steps for which you have to do it is increasing by one. So we will not do a careful calculation here. But it turns out that as a result of this, this particular way of doing a heapify by starting from the bottom of the heap and working upwards rather than inserting one at a time into an empty heap, actually takes us on the linear time order n. A final use of heap is to actually sort. So we are taking out one element at a time, starting with a maximum one. So it is natural that if we start with a list, build a heap, and then do n times delete max, we will get the list of values in descending order. So we build a heap in order n time, call delete max n times and extract the elements in descending order. So we get an order n log n algorithm for heap. Now the question is where do we keep these values? Well, remember that a heap is an array. So initially we have a heap which has n elements. So we build this heap. Now we said that delete max will remove the element at the top because that's the root, but it will also create a vacancy here. This is the value that will go to the top. This is the last leave which will go to the top when we fix the delete max. So since there is a vacancy here, we can actually move this to this position. So the maximum value will now go to the end of the heap. But the next time we process the heap, there will be only n minus one values. So we will not look at that value. We will just use from zero to n minus two. Right? So again, this value will come here, this value will go there, and now you will have two elements fixed and so on. So one by one, the maximum value, second maximum value, and so on will get into the same list or array in which we are storing the heap. And eventually the heap will come out in ascending order. So this is actually an n login sort. So it has the same asymptotic complexity as merge sort we saw before. And unlike merge sort, which forced us to create a new array every time we merge two lists, this is actually creating a list in place. So to summarize, heaps are a tree based implementation of priority queues in which both insert and delete max can be done in login time. We can do a bottom up heapify to build a heap in order end time. And these are trees, but they can be manipulated very easily using an array. Now, in this case we are looking at max heaps. We can also do a dual construction where we change the heap condition to say that each element must be smaller than its children, in which case we have what is called a min heap. And then instead of delete max, the operation we perform is delete min. Everything is exactly symmetric to. The other case is when we move something up, we have to move it down according to the min condition, and when we insert something at the bottom, we have to move it up. Right? So the insert and delete min work exactly like insert and delete max, except that the comparisons are reversed because we now have a min condition rather than a max condition locally. And finally, we saw that with a heap we can do sorting in order n log time in place. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Prof  A  Basu.mp3,"Welcome to the course of problem solving through programming. The name of the course emphasizes problem solving, and the means of solving problems will be through programming. And in particular in this course we will adopt the language C just as a vehicle to show how programming is done. The major emphasis of this course will, however, be on the general concepts of programming, the different constructs that are used in programming, and how the tool, the programming tool and technique can be used to solve different types of problems that we encounter in our life. Now, when we say that we will be trying to solve problems, the question that naturally arises is what type of problems are we going to solve? We are not going to solve all sorts of problems that are there in the world. Of course we are. Through this course, we do not even dare to say that we'll be solving the problem of hunger in the world, for example. Instead, we'll be focusing on solving some mathematical problems, solving some problems which can be approached through logical ways and means, and some problems which we can solve by properly representing data and then working on that, sort of working on that organized form of data. So those are the types of problems which we'll be trying to solve. And at the same time, the emphasis is to introduce you all to the logic and flow of programming. What is programming? How we can program a computer, how we can write a nice program, and what are the different constructs and techniques by which we can program. Although we'll be focusing on the C language because in order to explain some concepts, in reality we need to adopt some particular language for expression. The concepts that we will be discussing in this course are general enough and are applicable to a vast repertoire of other languages as well. Other languages means a particular class of languages which are known as imperative languages, like if anybody programs in Fortran, if anybody programs in C, later Java. Some of the concepts that we'll be dealing with in this course will be applicable there as well. So I very much hope that for the beginners it will be a nice starter with which you can delve into the area of problem solving through programming.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Program using Arrays.mp3,"So we saw a program where we are finding the minimum of a set of ten numbers. So here the program is restricted, as you can see, to ten numbers. And accordingly I have declared the array a to be of size ten. And also this iteration values are also iteration limit has been kept to ten. Now when we did that, just a quick recapitulation of what we did in the last lecture, that here is the array declaration, and this is where we are accessing the array elements. Here you can see I am accessing the array element AI, a particular array element here, and assigning that to another variable mean. Now here is very important. How am I reading the element? Now, since an array consists of a number of elements, sorry. Since the array consists of a number of elements, I have to read them in a loop. That is a very fundamental thing that you should understand that at a time I cannot read the entire array in one shot, except for the case where I initialize it. And when I declared the array, I gave int a so and so values within curdy bracket. That is one way. But if you have to do it at runtime, that means whenever you are asking, the program is running and you are asking from the user that you enter the values. Then you have to take one bit of value at a time, just like this and store it in the array. So that has to be done in a loop. For by varying this indexes one after another. As the index moves, I load the different locations with the values. Now given this, we can have an alternate version of the same program. You can see that here we have added one line, that is this line. Define size ten. This is again the use of hash define that we had learned when we defined PI to be three point, we had encountered this define PI 3.15, et cetera, et cetera. So similarly, here I am defining size a variable size to have the value ten. Therefore I now can write this dimension as size. Now please note that the compiler look at it from the angle of the compiler. The compiler will try to allocate some memory location, some amount of memory location. Okay, now if there be a variable size, it really does not know how much memory location to allocate. But since I have defined it earlier, it now knows. Okay, size means ten. So it will replace int size with int a size to be int a size ten. Okay, now next thing you do is wherever I had I less than ten, I make it size. I less than size. Here also for the for loop I make I is less than size. Why did I do that? What is the advantage of doing it. Now suppose you have got this program and how many places is size being used? It is being used in one, two, three places. In another program it could have been used in more number of places. Here we have not printed the array. Okay, I've only printed the minimum. So there could be more places where size could be used. Now suppose I want to modify this program or reuse this program for an array of size 100. Only thing I need to do is I change this ten to 100. And please note that after define, any hash defined does not have a semicolon because these are not part of the program. These are commands to the compiler or preprocessing commands. Okay, so if I could make it 100, then this would be replaced by 100. It would be a hundred. And here it should be I less than 100. Automatically I less than 100. I need not change it at all the places. That is the advantage of the hash define. So we can change only one line to change the problem size, the problem size from ten to 100 to thousand we can change by just changing one line. Here is another version of the program. Here we have not defined hash defined, but I have kept a large size hundred now. So I have got an array space of 100 elements, right? 100 elements. So much space is kept for me by this line. Now what I am doing is I am asking from the user, you please tell me how many elements you are going to input. Suppose here, and that I am taking as a variable n. N is a variable where I'm just asking the user give the number of elements n. And when the user is typing, say, 25, then that goes as n. So out of now this 25 is of course less than the size of this, which is 100. It's less than that. So now I will just work not for 100 elements, but for 25 elements. Why? Because the user has already told me that I want to input 25 elements. Therefore, what modification should I do? Again here, I want to make it interactive. So I again tell the user on the screen, you will see this message input all in integers, and the user is entering them one after another. Okay, he can type in 25, enter 35, enter 42, enter like that. Or he can give space and gone typing that. So for I less than zero to n. Now what is n? N is 25. So now it is for I to I zero to 25. I read the number. So I'll be reading 25 numbers here. 520, 1612, nine, et cetera, et cetera. I go on and I'll go up to 25, not 100, all these. So this space will be wasted. There's a wasted space. Why wasted space? Because I had deserved 100 locations. But the user has just agreed to give only 25 numbers. And then the remaining part remains the same. Here also, I'll be dealing with n. Okay, y n. I'll be searching. So when I did this, the array that I got is actually, although there were hundred elements, the array was actually of 25 elements. Right. The array was of 25 elements. So I'll have to find the minimum within this zone. And I need not go here. Okay, so that is another version of the same program. So here what is done is we define an array of largest size and only use the required amount out of that. All right. Now let us do a programming ourselves. Suppose I want to read the sum integers and I want to find out the sum of all the integers. That old example that we had done earlier. How did we do it earlier? Let's recall we did. Let me write it in this way. Sum. Do something like sum assigned zero. Then printf, enter the number. Then scanf, percentage d, and num. Sum equals sum plus num. And then this has to be done in a loop. Okay, so how can I make a loop out of this? So I also read another variable, the number of numbers. So some n was read here. So I had done some scanf or say, let's say of ten numbers. So I need not scan f. So this thing I have to loop, right? This part I have to loop. How long? So what should I put here at the beginning for doing the loop for I, since I know beforehand that there are ten numbers, I assign zero, I less than ten, I plus plus. Then I put a parenthesis here and a parenthesis here. So the fourth statement comes here. Okay, confusing. Should I write it again or is it clear so I can write for I assign zero, I less than ten, I plus plus printf, please enter the number backslash n. Then here I had done sum, assign zero, scanf, percentage d, and num. Sum assigned sum plus num. That's how the loop will go on. But here I am not remembering the number. Okay, so what I can do using an array, what I can do is let me now do it using an array int num set n comma I is another integer variable now. And also I need sum, sorry, sum is also another integer sum. Now I'll first read the array. The first is reading the array. So let me put a comment. Read the numbers, all the numbers earlier you see the scanf. Every time I was doing scanf, I was reading the number. Here I am reading the numbers and storing them. So what should I do? For I zero to I less than ten. I plus plus. Let's increment the array. What am I doing? Printf. Enter number backslash n. Scanf. Now, what should I do? I am reading an integer. So percentage, d, and ampere sand. What should it be? What am I reading? First, here is an array whose name is num. So what is the first thing that I'll be reading? First thing that I'll be reading is num, zero. This element. So scanf, percentage, d, and num. I. Why I? Because I is the index. And I can see that initially I is zero. So whatever is being scanned will be stored here. Then I'll go back in this loop. Then the next one will be stored. Then the next one will be stored. In this way, the entire array will be stored. After that, I am trying to find the sum. So now add. The next part that I do is add the elements. Okay, now in this here, I'll have to again add the elements. So suppose the array that has been formed has got some elements, like, say, 5713, twelve, six, so on and so forth. So this, I have to add this with this. Then I'll get a sum. And with that, twelve, I'll be adding 13. So I'll be getting 25. Then 25 and 1237. In that way, I'll go on. So here I initialize sum to be zero. And then for again, I assign the same index. I can use. I could have used other index. Also, I less than ten. Sorry. I plus plus. I hope you remember that after each of these, we put a semicolon right in for loop. Sum assigned sum plus num I. So what will happen? Sum was zero. Okay. Sum is zero. First, in the first iteration of the loop, what will happen? I take. My value of I is zero. So num, I will be taken. And what is num I? The first element of the num array. So that is five sum plus five. So sum will be five. Now, next, I go back here. I becomes one. So I come to the second element and I add that with sum. So sum becomes twelve automatically. Go there. I take. The index is updated. I is being updated here. So I take the third element and add with sum. So it becomes 25. And in this way, I go on adding them. All the elements in an array. So the same thing I could do using. But in this case, what is the advantage that I am getting? I have not forgotten the numbers that I have read. So I can do that. And again, I can print all these numbers I can say. Now the sum of these numbers is so much. So that is how we can use an array. Now, suppose I had to find the average of the elements. What should I do? I have got the sum here and then find average. What should I do here? Here. Of course, I'll need another variable, average. And so I can say, and average is sum divided by ten. There's a mistake. That is there. What is the mistake? Can you find out here? Okay, I found sum. That's okay. And then I am finding the average. And while I am finding the average, I am dividing sum, whatever sum I got here by the number of elements, which is ten. I knew beforehand that these are ten elements. Where is the error? Where is the mistake? The mistake is that the average cannot be, need not be an integer. Right? Suppose my sum was 25 and I divide by ten, so it will be 2.5. Therefore, this average should not be kept here. I should have declared it as a float average and not with the int, right? So you must be very careful about it. So this is how, what we have shown here is how we can read an array and how we can use an array. So let's look at this example of computing the grade point average of the students. Let us try to understand what this program does. We have defined a variable n sub to be six. This n sub means number of subjects. All right? Now, there are six subjects. So zero one subject zero, subject one, subject two, subject three, subject four, subject five. Now, for each of them we are taking a great point, which is nothing but a mark. Six, an integer three or five or six, whatever, for every how many? Six. Here, you see, I've used defined. So this line essentially means grade .6 for six subjects and credit for each subject. So suppose I've got the subject and the great point, and each subject has got a credit and I've got six subjects. The subject zero has got a great point. He has got a grade point of three. Maybe he has got a b grade or whatever. And the credit, that means the importance of that subject is five. Subject one, he has got a great point of five. He did really well here. And the credit of that was also five. There was another subject, two, in which his great point was four and the credit of that subject was four. That's the importance weightage. The subject three, he got five and the credit was three. Like that. Okay? And since we have got six subjects, let's do that. Subject four, he got three and the importance was four. And this one, he got five out of five. And the credit was again four. Now, the credit point is, the great point is computed here as for each of them, we will multiply the great point with the credit. So it will be three times five. That means 15 plus five times five. That is 25 plus four times four. That is 16, then 15, then twelve, then 20. And all these are added up. So 4056-6671 and 1271. And so he got 103 points. And how many credits were there? 5510 and 717 and 825. So his grade point average GPA will be, when I divide this by 25, his thing will be four point something, 4.1, et cetera. So 4.15 or something like that. So this is what I want to compute. Therefore, what I need is to find out that I have to find the sigma of the sum of the credit for a course. I times the grade point of that course. I I'll do it for all the courses. And then the whole thing should be divided by the total number of credits. Okay, total number of credits. Now let's see how we can do this program here. We can find that the grade point for six and credit for six. And there is I, the grade point sum. So I have to do this. Sum is zero, credit sum is zero, and I have to find out a GPA. So what I am asking from the user here, input grade points and credits for the six subjects. So where are those being stored? Those are being stored in two different arrays. Here is the great point array, this thing, and there is another credit array, six subjects. So I read for each of the subjects, I less than I, zero to n sub. I read the grade point, say three, and the credit for that subject, say four. And again I go and store the great point of that subject. Great point that has been obtained is five and say credit is three. In that way, I go on filling up, reading two arrays. So here I am reading two arrays. You see here I am reading two arrays in one scanf statement and through one for loop, through one for loop. I am filling up these two arrays. So the reading part is complete here. Next I come to the computation great point sum will be. You now know what is meant by this. This means great point sum is equal to great point sum plus great point I times credit I. So it is GP sum is whatever is the GP sum. Initially, GP sum was made zero. GP sum plus great point I times the credit of I. And that has to be done in a loop, just as we had added the elements of an array and credit sum. Also I am also finding out the credit sum, the credit sum was zero. So whatever the credits are, I'm also adding them. So by adding this array, I am getting the total number of credits here. And here I am getting the point sum. Now the great point average is great point sum by credit sum. And then I print out the GPA. So please try to understand this part. What I am trying to do is sigma great point I times credit I divided by sigma of credit I. So the sigma of credit I is being computed here. This is computing sigma of credit I. Why? Because this is being done in a loop. And here I am doing this part, sigma of grid point of I times create I and adding that with grid point sum. So this is a very useful program which illustrates a number of things. And in the assignments you will be given more number of programs to do which will give you a very good practice.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
python intro.mp3,"Welcome to the NPTEL course on programming data structures and algorithms. In Python, computational thinking has become one of the buzzwords that we read about these days. Computational thinking is supposed to be the way that we can cope with the technology that we see around us. However, computational thinking is not something exactly new to us. A lot of the mathematics that we learn in school is computational. For instance, when we use the long division method to find a square root or to do other calculations, we are executing algorithms even in day to day life, when we arrange books alphabetically so that we can search for them easier. This is an example of setting up a data structure, or when we try to optimize the route from where we are to where we want to go. So what we need to worry about now is how to make this implicit idea of computational thinking more explicit. How do we describe new algorithms? How do we convey an algorithm to another person? Or increasingly, how do we convey an algorithm to a mechanical device such as a computer? For this, we need a precise notation for conveying instructions. And this is what we call a programming language. So, the key to getting into programming is to choose an appropriate language. Traditional languages like C or C plus plus or Java are very powerful, but also have a heavy overhead to learning. So a lot of time is spent learning the keywords in the language, and lot less is spent on learning how to program in the language. In this course, we are going to use a new language called Python, which is much simpler to learn and hopefully without having to get into too many technical details before one starts programming, we can overcome the fear of programming and start writing real programs from an early stage. So what is programming all about? Well, it essentially boils down to two things. One is algorithms. These are techniques to do things faster and more effectively. The other thing is data structures. So how do you organize information to make it easier to process? In fact, a long time ago, a very famous computer scientist called Nicholas Worth, who designed the programming language Pascal, wrote a book called algorithms plus data structures equals programs, which emphasizes the fact that programming is nothing more than a combination of these two concepts. So in this course, we will learn Python, but side by side, we will also learn basic algorithms and data structures. There will be eight weeks of lectures, with about 2 hours of lectures per week. And there will be regular weekly quizzes and programming assignments to ensure that you keep up with the class and gain confidence as we go along. So, I hope you will join this course, and I hope that you will overcome any fear of programming you have and become part of the new generation. Thank.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
quicksort analysis.mp3,"You. So, in the previous lecture we saw quicksort, which works as follows. You first rearrange the elements with respect to a pivot element, which could be, say, the first value in the array. So you PartitioN a into the lower and upper parts, those which are smaller than the pivoT, those which are bigger than the pivot. You rearrange the array, so the pivot lies between the smaller than the bigger parts. And then you recursively sort the two partition. This. And this was the actual python code which we ran, and we saw that it actually behaved not as well as merge sort. Even for a list of size 7500, we saw it took an appreciably long time. So what is the worst case behavior of QuicKSOrT? So, the worst case behavior of QuIcKsOrT comes when the pivot is very far from the ideal value we want. So the ideal value we want is the median. The median would split the list into two equal parts and thereby divide the work into two equal halves. But if the pivot happens to be either the minimum or the maximum value in the overall array, then supposing it is the maximum, then every other value will go into the lower part and nothing will go into the higher part. So the recursive call, which consists of sorting n minus one elements. So if one partition is empty, the other one has size n minus one. So this would happen if the pivot is one of the extreme elements. And if this happens, and this is the worst case, then in order to sort n elements, we have to recursively sort n minus one elements. And we are still doing this order n work in order to rearrange the array, because we don't find this until we have sorted or gone through the whole array and done the partitioning. So this says t n is t n minus one plus n. And if we expand this, this comes out to be exactly the same recurrence that we saw for insertion sort and selection sort. So t n would be one plus two up to n, and this summation is just n into n plus one by two, which would be order n square. The even more paradoxical thing about quick sort is that this would happen if the array is sorted either in the correct order or in the wrong order. Supposing we are trying to sort an ascending order, and we already have an array in ascending order, then the first element will be the smallest element. So the split will give us an array of n minus one on one side and zero on the other side, and this will keep happening. So the worst case of quicksort is actually an already sorted array. Remember, we saw that for insertion sort, an already sorted array works well because the insert step stops very fast. So quicksort is actually in the worst case, doing even worse than insertion sort, and specifically on already sorted arrays. However, it turns out that this is a very limited kind of worst case, and one can actually try and quantify the behavior of quicksort over every possible permutation. So if we take an input array with n distinct values, we can assume that any permutation of these n values is equally likely, and we can compute how much time Pixort takes on each of these different n permutations, and assuming all are equally likely, if we average out over n permutations, we can compute an average behavior. Now this sounds simple, but mathematically it is sophisticated. And sorting is one of the rare examples where you can meaningfully enumerate all the possible inputs and probabilities of those inputs. But if you do this calculation, it turns out that in a precise mathematical sense, Pixot actually works in order n login in the average. So the worst case, though it is order n squared, actually happens very rarely. So the worst case actually arises because of a fixed choice of the pivot element. So we choose the first element as the pivot in our algorithm. And so in order to construct the worst case input, if we always put the smallest or largest element at the first position, we get a worst case input. This tells us that a sorted input, either ascending or descending, is worst case for our choice of pivot. Supposing instead, we wanted to choose the midpoint. We take the middle element in the area as our pivot. Then again, we can construct a worst case input by always putting the smallest value and working backward so that at every stage the middle value is the smallest or largest value. So for any fixed choice of pivot, if we have a pivot which is picked in a fixed way in every iteration, we can always reconstruct a worst case. However, if we change our strategy and say that each time we call Quicksort, we randomly choose a value within the range of elements and pick that as a pivot, then it turns out that we can beat this order n squared worst case and get an expected running time. Again, an average running time, probabilistically, of order n login. So as a result of this, because though it's worst case order n squared, but an average order n login, Quicksort is actually very fast. What we saw is it addresses one of the issues with merge sort, because by sorting the rearranging in place, we don't create extra space. What we have not seen, which you can see if you read up another book somewhere, is that we can even eliminate the recursive part. We can actually make Quicksort operate iteratively over the intervals on which we want to sort. So Quicksort, as a result of this, has turned out to be in practice one of the most efficient sorting algorithms. And when we have a utility like a spreadsheet, where we have a button which says sort this column, then more often than not, the internal algorithm that is implemented is actually quicksort. We saw that Python has a function l sort, which allows us to sort a list built in. So you might ask, for example, what sort is sorting algorithm is Python using? Very often it will be quicksort, although in some cases some algorithms will decide on the values in the list and apply different sorting algorithms according to type of values. But default usually is quicksort. So before we proceed, let's try and validate our claim that Quicksort's worst case behavior is actually tied to the description of the worst case input as an already sorted list. So here we have, as before our Python implementation of Quicksort, in which we have just repeated the code we wrote before. Now we are going to write another function which will do the following. It will shuffle the elements of the list by repeatedly picking two indices and just swapping them. So this will allow us to take, say, a range output just sorted and create a suitably random shuffle of it. So here is the code for it. So it's very simple. You use a Python library called random, which allows you some functions to generate random numbers. And one of the things that this library has is this function rand range. So rand range generates an integer in the range zero to length of l minus one. So we pass it a list, and we repeatedly pick two indices, j and k, in the range zero to length of l minus one, and we exchange lj and lk. And how many times we do this? Well, we just do it a large number of times. In this case, say if we have 10,000 elements in the list, we'll do this 5000 times. We do it length of l by two times. So let's see how this works. So we load, as usual, the Python interpreter, and then we import quicksort. And then we import randomize. So you can do this, you can write python functions in multiple files and import them one after the other, and they will all get loaded. Now, as before, we will say l, for instance, could be the list. So let us also import sys and finish off that recursion limit because we know this is ridiculous. So set a large recursion limit. And now we set up a fairly large list we had done last time, for instance 7500 down to zero. And what we saw was that if we try to quick sort this list, it takes a long time because it's 7500 and it's a worst case input. So what we are going to try and do now is, and the same thing will happen even after it's sorted. Because even after it's sorted it's still a worst case input. Except now it's an ascending order. So both descending order and ascending order take a long time. So now supposing we randomize l. So if you look at l now, you can see that the numbers are no longer an order. You see some 6000 between the 7000 and so on. So our claim is that this will go faster. And indeed you can see that if you run quicksort on this, it returns almost immediately. And it's not because quicksort has become any faster, it's because the order is in. Because again, if you run quicksort on the sorted list again it's going to be slow. So this just demonstrates in a very effective way that if we randomize the list and we run quicksort, it comes out immediately. But if we don't randomize it and if we actually ask sort the sorted list, then it takes a long time. So you could actually check that. For instance, if we go back to this list and we make it say even something bigger, like 10,000, maybe 15,000, and then we randomize it and then we sort it, it comes out really fast. So this validates our claim that quicksort on an average is fast. It's only when you give it these very bad inputs, which are the already sorted ones, that it behaves in a poor manner. Now there is one more criterion that one has to be aware of when one is sorting data. So very often sorting happens in stages on multiple attributes. For example, you might have a list of students who are listed in alphabetical order in the role list. After a quiz or a test, they all get marks. Now you want to list them in order of marks. But where there are ties, where two or more students have the same marks, you want to continue to have them listed in alphabetical order. So in other words, you have an original order in alphabetical order. And then you take another attribute, namely marks. And sorting by marks should not disturb the sorting that already exists in alphabetical order. So what this amounts to saying is that if we have two items in the original list which are equal, then they must retain the same order as they had after the sorting. So I should not take two elements that are equal and sort swap them while sorting. And this would be crucial in your using something like a spreadsheet, because if you sort by one column, you don't want to disturb the sorting that you did by another column. Unfortunately, Quicksort, the way we have described it, is not stable because whenever we extend a partition in this partitioning stage or move the pivot to the center, what we end up doing is disturbing the order of elements which were already there in the unsorted list. So we argued earlier that disturbing this order does not matter because anyway we are going to sort it, but it does matter if the sorting has to be stable. If there was a reason why these elements were in a particular order, not for the current attribute but for the different attribute, and we remove them around, then we are destroying the original sorted. On the other hand, merge sort, we can see is actually stable if we are careful to make sure that we always pick from one side consistently if the values are equal. So when we are merging left and right, when we have the equal to case, we have to either put the element from left into the final list or right. So if we consistently choose the left, then it will always keep elements on the left to the left or the ones on the right, and therefore it will remain a stable sort. Similarly, insertion sort will also be stable if we make sure that we move things backwards only if they are strictly smaller. When we go backwards and we find something which is equal to the current value, we stop the insertion. So insertion sort merge sort are stable sorts. Wixsort as we have described it is not stable, though it is possible to do a more careful implementation and make it stable.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
quicksort.mp3,"So we saw that merge sort is an order n log n sorting algorithm, but it has a couple of deficiencies which make it sometimes impractical. The main problem is that it requires extra space for merging, and we also saw that it's difficult to implement merge sort without using recursion, and recursion carries its own cost in a programming language. So let's address the space problem. The extra space required by merge sort is actually required in order to implement the merge function. And why do we need to merge? The reason we need to merge is that when we do a merge sort, we have the initial list and then we split it into two parts. But in general there may be items from the left which are bigger than items from the right. So for instance, if we had, say, the even numbers on the left and the Od numbers on the right, then we have to merge by taking numbers alternately from either side. So if we could arrange that everything that is on the left side of our divided problem is smaller than everything on the right side of the divided problem, then we wouldn't need to merge at all. And this perhaps could save us this problem of requiring extra space for the merge. So how would we do divide and conquer without merging? Assume that we knew the median value. Remember, the median value in a set is the value such that half the elements are smaller and half are bigger. We could move all the values smaller than the median to the left half and all of those bigger than the medium to the right half. As we will see, this can be done without creating a new array in time proportional to the length of the list. Having done this rearrangement, moving all the smaller values to the left half and the bigger values to the right half, then we can recursively apply this divide and conquer strategy and sort the right and the left half separately. And since we have guaranteed that everything in the left half is smaller than everything in the right half, this automatically means that after this divide and conquer step, we don't need to combine the answers in any nontrivial way, because the left half is already below the right half, so we don't need to merge. So if we apply this strategy, then we would get a recursive equation exactly like merge sort. It would say that the time required to sort a list of length n requires us to first sort two lists of size n by two, and we do order n not for merging, but in order to decompose the list so that all the smaller values are on the left and the right. So the rearranging step before we do the recursive step is what is order n, whereas merge was the step after the recursive step, which was order n in the previous case. But if we solve the recurrence of the same one, so we get another order in login algorithm. So the big bottleneck with this approach is to find the median. So remember that we said earlier that one of the benefits of sorting a list is that we can identify the median as the middle element after sorting. Now here we're asking for the median before sorting, but our aim is to sort. So it's kind of paradoxical if we are requiring the output of the sorting to be the input to the sorting. So this means that we have to try the strategy out with a more simplistic choice of element to split the list. So instead of looking for the median, we just pick up some value in the list a and use that as what is called a pivot element. We split a with respect to this pivot so that all the smaller elements are to the left and all the bigger elements are to the right. So this algorithm is called quicksort. It was invented by a person called Tony whore in the 1960s and is one of the most famous sorting algorithms. So, we choose a pivot element, which is usually the first element in the list of the array. We partition a into the lower part and the upper part with respect to this pivot element. So we move all the smaller elements to the left and all the bigger elements to the right with respect to the choice of pivot element. And we make sure the pivot comes between the two, because we have picked up the first element in the array to pivot. So after this, we want to move it to the center, between the lower and the upper part. And then we recursively sort two partitions. So here is a high level view of how quicksort would work on a typical list. So, suppose this is our list. So we first identify the beginning of the list, the first element as the pivot element. Now, for the remaining elements, we have to figure out which ones are smaller and which ones are bigger. So without going into how we would do this, we end up identifying 32, 22 and 13 as the three elements which are smaller and marked in yellow, and the other four elements which are marked in green are larger. So the first step is to actually partition with respect to this criterion. So we have to move these elements around so that they come into two blocks so that 1332 and 22 come to the left. 63, 57, 91 and 78 go to the right, and the pivot element 43 comes in the middle. So this is the rearranging step. And now we recursively sort the yellow bits and the green bits. And assuming we can do that, we have a sorted array. And notice that since all the yellow things are smaller than 43 and all the green things are bigger than 43, no further merging is required. So let us look at how partitioning works. So here we have the earlier list and we have marked 43 as our pivot element and we want to do a scan of the remaining elements and divide them into two groups, those smaller than 43, the yellow ones, those bigger than 43, the green ones, and rearrange them. So what we will do is we will keep two pointers, a yellow pointer and a green pointer. And the general rule will be that at any given point we will have at some distance the yellow pointer, which I'll drawn orange to make it more visible, and the green pointer. So these will move in this order. The orange pointer or the yellow pointer will always be behind the green pointer. And the inductive property that we will maintain is that these elements are smaller than or equal to 43, these elements are bigger than 43 and these elements are unknown. So what we are trying to do is we are trying to move from left to right and classify all the unknown elements. Each time we see an unknown element we will shift the two pointers so that we maintain this property, that between 43 and the first pointer we have the elements smaller than or equal to 43. Between the first pointer and the second pointer we have the elements strictly greater than 43. And to the right of the green pointer we have those which are yet to be scanned. So initially nothing is known. Then we look at 32. Since 32 is smaller than 43, we move the yellow pointer and we also push the green pointer along. So the unknown thing starts on 22 and there is nothing between the yellow and the green pointer, indicating we have not yet found a value bigger than 40. The same happens for 22. Now when we see 78, we notice that 78 is bigger than 43. So now we move only the green pointer and not the yellow pointer. So now we have these three intervals as before. So remember that this is the part that is less than equal to 43. This is the part that is greater than 43. And this part is un, we continue in this way. So now we look at 63. So again 63 extends the green zone, 57 extends the green zone, 91 extends the green zone. Now we have to do something when we find 13. So 13 is an element now which has to be put into the yellow zone. So one strategy would be to do a lot of shifting, we move 13 to where 22 is, or after 22, and we push everything from 78 onwards to the right. But actually a cleverer strategy is to say that, okay, 13 must go here, so we need to make space. But instead of making space we can say it doesn't matter to us, we are eventually going to sort the green things anyway, so how does it matter which way we sort them? So we'll take 78 and just move it to 13. So instead of doing any shifting, we just exchange the first element in the green zone with the element we are seeing so far that automatically will extend both the yellow zone and the green zone correctly. So our next step is to identify 13 as smaller than 43 and swap it with 17. So now we have reached an intermediate stage where to the right of the pivot. We have scanned everything and we have classified them into those which are the smaller ones and those which are the bigger ones. Now it remains to push the yellow things to the left of 43. Now, once again, we have the same problem we saw when we included 13 in the yellow zone. If we move 43 to the correct place, then we have to move everything here to the left. But instead we can just take this 13, the last element in the yellow zone, and replace it there and not shift 32 and 22. So this disturbs the order. But anyway, this is unsorted. So it just remains unsorted. So we do this and now we have the array rearranged as we wanted. So all of these things to the left are smaller than the pivot, the pivot is in the middle, and everything to the right is bigger than the pivot. So here is an implementation in python. So remember that quicksort is going to have like merge sort and like binary search be repeatedly applied on smaller and smaller segments. So in general, we have to pass it the list, which we will call a, and the endpoints of the segment, the left and the right, with the assumption that we are doing a slice l to r minus one. So if this slice is one or zero in length, we do nothing. Otherwise we follow this partitioning strategy we had before, which is that we are sorting from l to r minus one. So the position l. So this is the pivot. So we initially put the yellow pointer here, saying that the end of the yellow zone is actually just the pivot, there's nothing there. So yellow is l plus one. And now we let green proceed. And every time we see an element in the green, the new green one which is smaller than the one which is the pivot so remember, this is the pivot. If ever we see a green, the next value to be checked is smaller than we exchange, so that we bring this value to the end of the yellows. So this is what we did with 30. And then we move the yellow pointer as well. Otherwise, if we see a value which is strictly bigger, we move only the green pointer, which is implicitly done by the for loop, and we don't move the yellow pointer. So at the end of this we have the pivot, and then we have the less than equal to pivot, and then we have the greater than. So this is that intermediate stage that we have achieved at the end of this loop. So now we have to find the pivot and move it to the correct place. So remember that the yellow is pointing to the position beyond the last element, smaller than that. So yellow is always one value before beyond this. So we take the yellow minus one value and exchange it with the left. And now what we need to do is we have now less than p p and greater than p. And this is where yellow is. So we need to go from zero to yellow minus one. We don't want to sort p again because p is already put in the correct place. So we quick sort from l to yellow minus one and from yellow to the right end. So here we have written the python code that we saw in the slide in a file. So you can check that it's exactly the same code that we had in the slide. So we can try and run it and verify that it works. So we call Python and we import this function. So remember that this is again a function which sorts in place. So if you want to sort something and see the effect, we have to assign it a name and then sort that name and check the name afterwards. So let us, for instance, take a range of values from say 500 down to zero. And now if we say quick sort, then we have to of course give it the end. Then l gets correctly sorted. So you can't see all of it, but you can see it from 83 84 up to 102 down to five. Now we have the same problem that we had with insertion sort. If we say 1000 and then we try to quicksort this, we will get this recursion depth. Because as we will see in the worst case, actually quicksort behaves a bit like insertion sort and this is a bad case. So to get around this, we would have to do the usual thing. We have to import the sys module and set the recursion limit. Something suitably large, say 10,000, maybe 100,000, and then if we ask it to quicksort, there's no problem. So this is another case where this recursion limit in Python has to be manually set. And one thing we can see, actually, is that quicksort is not as good as we believe, because if we were to, for instance, sort something of size, say 7500, then it takes a visible amount of time. So we saw that merge sort, which was n login, would do 5010 thousand and even 100,000 instantaneously. So clearly quicksort is not behaving as well as merge sort. And we will see, in fact, that does not have an order n log and merge sort behavior as we would have liked. And that's because we are not using the median but the first value to split. So we will see that in the next lecture as to why quicksort is actually not a worst case order m log in L.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
recursion (1).mp3,"So for the last lecture of this week, we will look at recursive functions. So, recursive functions are typically based on what we call inductive definitions. So in arithmetic, many functions are naturally defined in an inductive way. So let's explain this by some examples. So the first and most common, an example of a function defined inductively is a factorial function. So we say that zero factorial is one, and then we say that n factorial can be obtained from n minus one factorial by multiplying by n. So remember that n factorial is nothing but n into n minus one into n minus two, this product all the way down to one. So what we are observing is that after n, what appears can be rewritten as n minus one factorial. So inductively, n minus one factorial can be extended to n factorial by multiplying by the value n. So we can also do this for other functions. You may remember, or you may not, that multiplication is actually repeated addition. When I say m times n, I mean m plus m plus m plus m n times. So how do we define this inductively? Well, we say that m times one is just m itself, and m times n plus one is m plus inductively, applying multiplication to n. Right. So we could equivalently write this if you want to be symmetric with the previous case, as m times n is m plus m times n minus one, the same thing. So what you're saying is that you can express m times n in terms of m times n minus one, and then adding n. So in both these cases, what we have is that we have a base case. So we have like zero factorial or m plus one m times one, where the value is given to us explicitly, and then we have an inductive step where f of n is defined in terms of f of n minus one. And in general, it can be defined in terms of even more smaller arguments. So one example of that is the Fibonacci series. So if you have seen the Fibonacci series, the Fibonacci series starts with 11235 and so on. And this is obtained by taking the previous two values and then adding them. So the general rule for Fibonacci is that the first value is equal to the second value is equal to one, and after the second value, fibonacci of n is fibonacci of n minus one plus fibonacci of n minus two. So in general, a recursive or inductive definition can express the value for n in terms of one or more smaller values of the function for smaller inputs. So our interest in inductive definitions is that an inductive definition has a natural representation as a recursive computation. So let us look at factorial. So here is a very simple python implementation of factorial as it is defined. It takes the value n and says if n is one, n is zero, then return one. Otherwise, return the value n times the computation recursively of factorial n minus one. So this is very clearly what we said before. We said zero factorial is one, and otherwise if n is not zero, n factorial is n times n minus one factorial, right? So this is exactly what we wrote before, directly translated as recursive computation. We can say the same for multiplication. We can say if you want to multiply m by n, if n is one, we return m. Otherwise we add m to the result of multiplying m by n minus one. So again, we had written that before as m times one is m and m times n is m plus m times n minus one. So if you have an inductive definition, it immediately gives rise to a recursive function which computes the same definition. The advantage is that we don't have to spend much time arguing that this function is correct, because it directly reflects the inductive definition, the mathematical definition of the function we are trying to compute. Now, what may be less obvious is that we can do the same thing for structures like lists. So a list has an inductive structure. A list can be thought of as being built up from an empty list by adding one element at a time. So we can think of decomposing a list. Reversing the step so we start building a list from an empty list by adding one element at a time. Say we add them to the left, so we add the last element, and we add the second last element, and so on. But conversely, we can say that given a list, we can decompose it by taking, say, the first element and looking at that first element and the remaining list after removing the first element which has one less element. So this gives us our induction. We have a smaller structure on which we can try to express a function, and then we can combine it with the first element to get the value for the larger thing. So we will have a base case where the function is defined either for the empty list or for a simple list of size one. And in the inductive step f of l will be defined in terms of smaller sublists of L. Again, this is best understood through some simple definitions supposing we want to compute the length of a list L. Well, the base case is if the list is empty, it has zero length. So if l is equal to zero, l is equal to the empty list. We return zero. Otherwise what we do is we have a list consisting of a number of values. So we pull out this first value and we say it contributes one to the length. And now inductively we compute the length of the rest. So we return one plus the length of the slice, starting at position one. So this is an inductive definition of length, which is translated into a recursive function. And once again, by just looking at the structure of this function, it's very obvious that it computes the length correctly, because this is exactly how you would define length inductively. Now here is another function which does something similar, except instead of computing the length, it adds up all the numbers, assuming that the list is a list of numbers. So again, if I have no numbers to add, if I have an empty list, then the sum will be zero because I have nothing to put into the sum. On the other hand, if I do have some numbers to add, well, the sum consists of taking the first value and adding it to the rest. So if I have a list called x one, x two up to x n, then I'm saying that this is x one plus the sum of x two up to x n. So I can get this sum by this recursive or inductive call, and then I just add this value to that. So insertion sort, which we have seen actually has a very nice inductive definition. If we have a list of size zero or size one, it is already sorted, so we don't have to do anything. So this becomes the base case. On the other hand, if we have a list of length two or more, we inductively sort the slice from the beginning up to, but excluding the last position. So this is the slice from zero to the length of the list minus one. Then we take the last position, and then so this should be minus one. So we take the value at the last position and we insert it into the sorted slice. So we insert the last position into the inductively slotted slice, excluding the last position. So here is a recursive definition of insertion sort in Python. So the natural thing in python, or in any other thing, would be to say that we want to insert the last position into the result of sorting the sequence up to, but excluding the last position. But the way we have written our insertion sort, this function does not return a list it sorts this thing in place. So this call would not have the correct type because insert will take a sequence and a position and insert this value at this position to its left. So we write it now as two separate things. So first of all, we have an overall insertion sort, which takes a sequence, and it'll call this auxiliary function which says sort this sequence up to this position. Right? So isort sorts the slice from zero up to k minus one. So what does isort say? Isort checks if it's a base case, if k is zero or k is one. If I'm sorting up to the first position, or I'm not sorting anything at all, then I will just return the sequence. So this is telling me sort from zero to k minus one. So if it is zero, then I have an empty list. If I have zero to one, then I have a list of one position. It's only if I have zero to two that I have at least two elements. And if so, what I do is I sort k minus one positions and I insert the last position into this sequence. And what does insert? Do? Insert does exactly what we did when we did the regular insertion sort. It sets a position variable or name to the last position and walks left and keeps swapping so long as it has not reached the left hand side edge and so long as it finds something to the left which is strictly bigger than the one that you're looking at now. So this is what we did earlier. And what is new is this part, which is this recursive call. It says sort the sequence up to this position recursively using the same isort, but change the index from k to k minus one, and then insert the current value into the sequence. So as before, let us run this in Python. So here is the code isort rec py, which contains recursive implementation of insertion sort. So if I now import this and then as before, if we say l is a range of 500 values, say in descending order, then if we insertion, apply insertion sort to this, it then l produces the ascending order one to 500. So last time we said that for n squared sort we should look at larger values. So supposing we take range 1000. Now, if we take range 1000, then something surprising happens. So we get an error message from Python saying that it could not sort this because it reached something called the maximum recursion depth. So what happens when we make a recursive call is that the current function is suspended. So we try to sort something of length 1000. So it will try to insert the 1000th element into the result of sorting the first 999. So we suspend the first call and try to sort 999. This in turn will try to insert 999 element into the sorting the first 998. So it will suspend that and try to sort the first 998. So at each time we make a recursive call, the current function is suspended and a new function is started. So this is called the depth of the recursion. How many functions have we suspended while we are doing this process? Now, unlike some other languages, Python imposes a limit on this, and the limit, as we can see, is clearly less than 1000 because we are not able to sort a list of 1000 using this particular mechanism. So how do we get around this? Well, first of all, let's try and see what this limit is, right, so we know that we can't sort 1000, but we could sort 500. So can we sort 750? For example, it turns out that we can sort 750. It'll turn out that, for instance, we can sort 900, so we can actually find this limit by doing what we did earlier, binary search we can keep halving. Although I did not strictly have after 750, I know it fails at 1000. It doesn't fail at 750. I should have tried 875. But I will spare you this binary search and I can show you that if I use 997, then it will work. But if I use 998, then it will fail, right? So somewhere around 998 is the recursion limit that Python uses by default. Now fortunately, there is a way to get around this so you can set this recursion limit. And the way you do it is the following. You first have to import a bunch of functions which are called system dependent functions by saying import sys. And then in SYs there is a function called set recursion limit, and we can set this to some value bigger than this, say 10,000. And now if we for instance, ask it to sort a list of 1000, then it doesn't give this error same way I could even say 5000 because 5000 will also only create the same kind of limit because it's well under 10,000. Remember that in this we are basically doing recursion exactly the number of times as there are elements, because we keep inserting, inserting, inserting, and each insertion requires us to recursively sort the things to its left. And that's why we get this stack of nested recursions. But the thing to remember is that by default, Python has an upper bound on the number of nested recursions which is less than 1000. If you want to change it you can by setting this recursion limit explicitly, but Python doesn't allow you to set it to an unbounded value. You must give it an upper bound. So you can't say let recursion run as long as it needs to. You have to have an estimate on how much the recursion will actually take on the inputs you are giving, so that you can set this bound explicitly. Now the reason that PythOn does this is because it wants to be able to terminate a recursive computation in case you have made a mistake, a very common mistake with recursive computations. It's a bit like we said for while loops. If we do never make the condition false, a while loop will execute forever. Same way, if we don't set the base case correctly, then a recursive computation can also go on forever. So the way that Python stops this and forces you to go and examine the code is by having a recursion limit, saying beyond a certain depth it will refuse to execute the code. So what we have seen is that we have this recursion limit, and we can raise it manually by importing the Sys module and setting the set recursion limit function inside sys. So how would we analyze the complexity of recursive insertion sort? So as before, we use t of n to denote the time it takes to run insertion sort on an input of length n. So insertion sort at the highest level consists of two steps. We first have to sort the initial slice of length n minus one, and by definition this will take time t of n minus one, and then we need n minus one steps in the worst case to insert the last position into the sorted slice. So this gives rise to what we call a recurrence. We saw this when we were looking at how to analyze binary search, which was also a recursive algorithm. We have that t n in general is n minus one plus t of n minus one, and t of one when we come to the base case is one. So as with the binary search, we can solve this by expanding or unwinding the recurrence. So we have t of n is n minus one plus t n minus one. So if we take t n minus one and apply the same definition, we get n minus two plus t n minus two. Then we take t n minus two and apply the same definition. We get n minus three and t n minus three, and this will keep going on until we get t of n minus k is equal to t of one. So in other words, when k becomes n after n steps, we will have one. So we will have n minus one plus n minus two down to one, which is the same thing we had for the iterative version of insertion sort n into n minus one by two. And this is order n squared. So we have seen two order n squared sorting algorithms, both of which are very natural intuitive algorithms, which we do by hand when we are given sorting tasks to perform selection sort and insertion sort. We have also seen that both of these will not work in general if we have large values of n, and not even so large if we have values of n over 5000. But we also saw in the previous two lectures that insertion sort is actually slightly better than selection sort, because selection sort, the worst case, is always present because we always have to scan the entire slice in order to find the minimum element to move into the correct position. Whereas insertion sort will stop as soon as it finds something which is in the correct order. So if we have a list which is already sorted, then insertion sort will actually work much better than n square. But we can't rely on this in any way. We are counting worst case complexity. So we have to take the fact that both of these will in general not work very well for list larger than 5000 attempts. What we will see next week is that there are substantially more efficient sorting algorithms which will allow us to sort much larger lists than we can sort using selection sort or insertion sort.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Recursion(Contd.).mp3,"So we were looking at recursion, and that's a new style of programming where we can express the particular function in terms of itself, like I can express factorial n in terms of factorial itself, factorial n minus one and n into factorial n minus one. Okay, another very common example of, an easy example of recursion is Fibonacci numbers. We have already told you what a Fibonacci sequence is. The Fibonacci sequence can be expressed as f zero Fibonacci zero. Th fibonacci number is zero. The next one is one, and henceforth all other ones are sum of the previous two. So. 011235 813 21, so on and so forth. Therefore, we should be able to define it in terms of a recursive function, because you can see this function f and this function f are the same. Only variations are in these parameters, right? I'm expressing the same function in terms of these parameters. So the function definition will be very simple. F int n, some integer. If n is less than two, then return n. If n is less than two. If it is zero, then zero. If it's one, then it's one. Otherwise, what would you return? Return f n minus one plus f n minus two sum of the previous two Fibonacci numbers. Now this is interesting, because again, if you see how this will be computed, it will be first expanding, what are the things I have to compute? And when it meets the stopping condition, then it starts collecting back and come back. So how many times, say, if I, say, if I want to compute Fibonacci of four, how many times will that function be called? Let's look at the expansion of this. So how will it happen? Fibonacci of four will be, I want to compute Fibonacci of four. Is Fibonacci of three, Fibonacci of two. These two should be added. So I have not yet found out anything. I am just decomposing the problem. Okay, this is a very, very important concept that in order to solve the problem, I want to decompose it into smaller subproblems. For f four, I have to solve it by solving f three and f two. Okay, now for solving f three, I have to solve f two and f one. I further decomposed it. Now, for solving f two, I have to solve f one and f zero. Fortunately, and for solved. Now, even now, the entire thing has not been broken down. F two. For that, I have to solve f one and f zero. Now I have expanded the whole thing. Now I know that f one is one, f zero is one. So f two will be one plus one two. This is known. All these endpoints of this structure are known 101101. So I go on adding them and ultimately I'll get f four. Now, it is in a way inefficient because the same thing is being computed repeatedly. Okay. But it will make, to a practiced programmer, it will make your programming, writing the program much more, less lines of codes, if you can express it in much more better way. So you can see here how many times the function was called. 123-45-6789 times nine times the same function was called in order to compute a four. Okay, so the quote for the Fibonacci sequence will be if. Now the stopping condition or the base condition is very, very important. Is very, very important. So if n is zero or n is one, then I return one. This is the base case. Unless I reach at this point, I'll not be able to compute the entire solution. Otherwise, return Fibonacci of n minus one plus Fibonacci of n minus two. That is the code for the Fibonacci number. Now this sort of, whenever I'll have too many calls, in that case I should avoid them as much as possible. What is the difference between recursion and iteration? In recursion, we have the repetition. Sorry, in iteration, it's both repetition. In iteration, there's an explicit loop. Explicit loop for I equals zero, I less than equal to n minus one, I plus plus. So there is an explicit loop, whereas in case of recursion, it's a repeated function calls. All right, termination iteration. If the loop condition is no longer satisfied, while this condition do, if that condition fails, then we come out of the loop. In the case of recursion, the base condition must be recognized whenever we are getting the base condition. Factorial one or factorial zero, fibonacci of zero or fibonacci of one. So those are the base conditions. Both can have, if wrongly programmed, both can have infinite loop. So the performance wise iteration often gives faster result. But it's a good software engineering practice to gradually get accustomed to recursion. As you do more and more programming, you will see that you will be able to express the things in a much subtler way. So whenever there is a performance issue, try to avoid recursion. It will require additional memory. Also, there is a particular type of storage that is required in recursion that is known as stack. Stack is a last in, first out type of structure. So those things briefly, let me tell you how this thing is done, because stack is nothing but a structure where we can push in data from one side. Say I put, say five. First I push, so five comes here. Then I push four, then I do n minus one. Three is pushed, then two is pushed, then n minus one again, and one is pushed. Now, when I take out the data, the data will come out as one, then two, then three, then four, then five in the reverse order, okay? So the two operations are push and pop, okay, popping out from the stack and pushing inside the stack. So this stack data structure becomes very handy for implementation of functions, recursive functions. We'll show some examples. Like here, for example, I want to compute the GCD of ab. Now, typically what happens is I call, this GCD is computed, I return, okay, now here, when I call something, I call something. All the say here was, I was here, my program flow was here. I went in, and when I went in, all the local variables and everything here were stored and I had to remember where I'll be returning back. So all those things are stored in the stack. And without a stack data structure, it is very difficult to implement recursion. And for that matter, any function call. So you see here is a function, and so all those return addresses stored before call, this stack was empty. Now after, when it's returning, it is taking out from the top of the stack, and again I come to know where I was. Okay? So similarly, you see here, it's a n choose r ab, that means ncr, okay, what we compute n choose r. If I compute, then, you know, n choose r is factorial, r divided by factorial of n minus r. Or some people write it in this way by factorial of n minus r. So how would I do that? So how can I implement it? So here, ncr has been called, from here, factorial has been called. And then where do I return? I have to come here. Ultimately I have to return here, so I should not lose the path. So what the stack does is when I make the call, first call, then when I make the call, ncr, then the local variables here will be stored on the stack. And again I make another call from here. So local variables are there. I am calling fact as I go in here, the local variables here are stacked up. And then when I return this part, this part, this part will be taken out and passed on to this. So what happens is this part is, as it returns, this part is taken out and I am here, it can again continue. And then it returns, when it returns here, this part will be taken out. This part will be taken out. Okay, this part will be taken out. That is for normal function call, how the stack remembers where I should go back. All right, in the case of recursive calls, what happens? What we have seen is activation record gets pushed into the stack. When a functional call is made. In recursion, a function calls itself. So several function calls are going on with none of the calls are getting back. So all the activation records are collected. So you need not delve into that too much. Let's see, I'll show it by an example of computing factorial. So an activation record is the local variables and the return value what the function should return and where it should return. So with that, say the main function is calling fact three. All right, fact ten. And here is a fact ten. If n equal to zero, return one. Otherwise, n times fact n minus one. So main calls fact. So when it calls, the value is n equal to three. There is no return value, return address is in main. Okay, I'm remembering that. Next again, fact is calling itself. So now fact is calling fact three is calling fact two, and my return address is fact. So you see, it has been stacked up. Next, fact two will call fact one. So that's what the stack is growing, and return is in fact. All right, now next time it will be fact zero. Now the return value. Till now there was no return value. Now the return value is one. Okay, and return address is fact. So as I do that, I return, then I have got a return value, because now I have come to this point. So one into one will be one, and I'm returning to fact. As I return, the stack will contract. And what is the return result? Two times one, that is two, that's a factorial two, and return. I am returning to fact. So I return again. Now I am coming to the last time in the fact with n equal to three that started here, and the result is six. Now I return to main. So at every stage, look at this, I know, I remember from where I started and from where I am returning back, nothing is lost using this stack. So, stack is a very interesting data structure that helps us in many ways, especially in implementing things like recursion and all those. So one assignment that I am leaving to you, do it yourself. Trace the activation record for the following version of fibonacci. Please note down the code include stdio h int f. F is the Fibonacci function a and b. If n is less than two, return n. If it is zero, then return zero. If it's one, return one. Otherwise a is f n minus one. B is f n minus two. I have done it in a different way. F n minus one and f n minus two. So f n minus one has to be solved separately, and f n minus two should be solved separately. Then we'll return a plus b. All right. And then the main will print. So just as a fun, you try to draw the activation record of this version of the function. Please note it down. Take some time and note it. Note down this function. And you see, on this side I have shown how the activation record will look like local variables. You can see n, a and b return value. You have to keep, whether it is in Fibonacci or in main, either in main or in X or Y. Where is X and what is Y? This is X. And this, sorry, there's a problem in this. I am drawing it again. So you see this? This is X. This is X and this is Y. All right. Not, these two are not aligned properly. All right. So either where do I return? And here is the return to the main. Either I return to main or to x or two y. And what is the return value? Draw the activation record of this, and then we'll see how much you could do it. I'm sure you'll be able to do it. And recursion. So today we have learned a new style of programming. That's recursion, and also we discussed in the last class. So recursion is a type of writing functions where the function calls itself, and that makes many functions to be written much more succinctly, much more subtly. And that is a very good software engineering practice. Although as a beginner, if you find difficulty in that, you need not bother too much about it. You have got iteration at your disposal and you can solve most of the problems with iteration. Okay. Practically all the problems you can do. Maybe in some cases it may be a little more difficult to write, but ultimately it will be possible. Okay. So if you find difficulty with recursion, you can set it aside for the time being. But we have to discuss it because that's a very nice way of writing functions. We'll continue with the concept of structures. In the next lecture, a new thing will be introduced that's called structure. Okay, thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Recursion.mp3,"Today, we'll be discussing on a new concept of programming, which is very interesting, but possibly not very much familiar to you. That is known as recursion. You know, repetitions, how they are implemented in C programming. For example, whenever I want to do a particular work, for example, I want to add ten numbers. Then I add the sum with sum plus sum AI with I equal to one. And then I repeat it, I plus plus. And I go on repeating it. And this repetition is done in the form of a for loop or while loop. You know that right? Now, recursion is a different way of doing this. When a function calls itself, that means a function, a particular function will have some inputs and will deliver one output. Now, a function has been. Now, you know, nesting of functions that in order to achieve this objective of taking these inputs and delivering this output, a function could call other functions from there, another function, and then ultimately return to this function, return back here. In that way, it could be done. This was known as nesting. But recursion is a little different. It is that here there is a function which is supposed to be to deliver some output. Now, in order to do this, it is actually repeating itself. That means. Let me give you an example. Suppose I have a machine which can generate one apple. All right? It can generate one apple, produce one apple. Or maybe say apple. Let's say it produces a vending machine which can deliver one coke. All right? One piece of coke. One can of coke, right? So you put in some input, some commands, and it gives you one coke. Now, it has been asked to deliver five cokes. Five cokes. So how can it deliver five cokes? It can deliver only one coke at a time. So, as we know in our knowledge of iteration, so this is some function. Function is delivering coke so it can be repeated. This switch can be pressed. There is a switch. It can be pressed five times. So first one coke comes out. Second coke comes out. So that means this is being repeated five times. That is the conventional one coke. So, that is the conventional way of iterating, repeating the same thing in order to get five cokes. Let us try to do it in another way. Let's assume that this machine can deliver one coke at a time, but it can also clone itself. So let's see how it looks like. So, I need five cokes. So, five. But I can deliver only one. So I saw that. Okay. I can deliver only one coke. All right. I will deliver one coke. But I'll not deliver it till I am ensured that all the five cokes are deliverable. So what it does, it clones itself. Makes another one copy of itself, say. And activates this. With I can deliver one coke. So I ask him to deliver four cokes. Now this one can also deliver only one coke. And finds that okay, I cannot deliver everything. So okay, I keep one coke ready what I can. But I clone myself. And another copy. I activate him this machine and say, please deliver three cokes. But it cannot also deliver three cokes. It can deliver only one. So nothing is being delivered, but only kept noted. So it puts somebody, another, another clone. Please deliver two cokes. I have got one. So it is also not delivering. Because it's not being able to satisfy the request of two cokes. Which was posed to it by this machine. So it now comes to another clone. So asks this clone, please deliver one coke. Now as you know, this machine can deliver one coke. So now it delivers one coke and tells, okay, I have delivered. Now this one. Then, okay. Since it has delivered, it delivers the other cook, which it could do. It also tells its requester, its earlier avtar, the earlier version that okay, I have done my thing. Now you do yours. So what it will do? Remember, each can only deliver one coke at a time. So it will deliver another coke. It passes on to the. Again tells its caller or its generator that deliver another coke. I have delivered. So it delivers the other coke. And ultimately this one also knows that its child has delivered the coke. So ultimately we get five cokes. So you can very easily see that if I had, this is one way in which each of these blocks is the same function. But it is being activated with different requests. And they are waiting till the request can be fulfilled. But in the meanwhile, passing on the request to another one. And as soon as this could fulfill it, it passes it on and then it goes back. In the case of iteration, what would have happened? This would not be done. This same thing. One coke. And again call this and another coke, another coke. Like that. So if I call each of these as functions. Then actually this function and this function. There is no difference between them. Only difference is a value with which it is being called. And this process is successful. Because ultimately there will be a situation when this function or this machine will be able to deliver what it has been asked to one coke. It can deliver. So that will be done. Therefore, we can go back and have everybody else deliver the same thing. This is the principle of recursion. I just used it as a fun example. But let's now come to a little more serious. Look at this. So it is a process by which a function calls itself repeatedly, either directly like x is calling x, or cyclically in a chain, x is calling x calling y. Y is calling x like that, right. Used for repetitive computations. The best thing is, you look at this example. Factorial n. All of us know that factorial five is nothing but five. Four times four times three times two times one. Now you see the same thing I can say. What is this part? Four multiplied by three, multiplied by two multiplied by one. This factorial four. So you see, I am expressing factorial five, factorial function in terms of itself. Five times factorial four and factorial four can again be expressed as four times factorial three. And factorial three can be expressed as three times factorial two. And factorial two can be expressed in terms of factorial one. So 5432. And factorial one is the end. So that is one. So I'm certainly getting the factorial there without any further expansion. So we can write in general, factorial of n is n times factorial of n minus one, and factorial of n minus one will be n minus one into factorial of n minus two. Factorial of n minus two will be n minus two into factorial of n minus three. In that way, it will go on, but it will be successful only if there is a terminating point, which we often call the basis condition. Okay, I hope you have understood this. So two conditions are to be satisfied in order that we can write a recursive formula. One is, it should be possible to express the problem in the recursive form. Just like factorial factorial n is n times factorial n minus one. And also there is another point that is the problem statement must include a stopping condition. What was my stopping condition? In the case of factorial factorial one is one. Okay, so that was the stopping condition. What was the stopping condition in terms of? In the example of delivering the coke, when the machine was asked to deliver only one coke, then it can complete. So that is a stopping condition. And then we go back. Go back. All right. So the stopping factorial n is one if n is equal to zero or n equal to one. Otherwise it is n into factorial n minus one if n is greater than zero. So ultimately it will go on and ultimately it will conclude. Example, factorial one. We have seen that. Another example, greatest common divisor. We can express that in a recursive form. It's very interesting. You can look at it. That greatest common divisor of the same number is itself. That is the key to the logic. Gcd of m and m is m and gcd of m and n is gcd of m minus n and n. Okay? Or the other way. So for example, gcd of 15 and five, I'll say 75 and 1575 and 15 will be Gcd of 60 and 15. GCd of 60 and 15 would be Gcd of 45 and 15. GCd of 40, 515 would be Gcd of 30 and 15. Gcd of 30 and 15 will be gcd of 15 and 15. Now I have got the stopping condition that gcd of the same number will be 15. So my result will be 15, is it clear? So that is a recursive definition of Gcd. So most of the interesting problems can be expressed in the form of in the recursive form, and that helps in writing a very suckant and tight code. Here is another example of recursion Fibonacci series. A series like this. One, then one, then two. Two is what the sum of the previous two elements, one plus one and three. What is three? Three is the sum of the previous two, two and one, then five. What is five? Five is the sum of the previous two. Then eight. What is eight? Eight is the sum of the previous two, five and three. Then 13. What is 1313 is the sum of the previous two, eight and five. Then 21. What is 21? 21 is the sum of the previous 213 and eight. You can see how nice pattern it is. Can you think of how we can write it in a recursive form? How we can express it in a recursive form? If you think a little bit, it will be very easy. It will be something like Fibonacci. Number of n is fibonacci of n minus one plus fibonacci, n minus two. Right? So n 21, this one is the sum of the earlier two Fibonacci sequences. Now, f n minus two will be what will be f n minus three plus f n minus four. Similarly, f n minus one will be f n minus one. F n minus two plus f n minus three. In that way, it will go on. But when will it stop? The stopping condition is that fibonacci of one is one. We'll see that. So if we try to express it in the recursive form, it turns out to be fibonacci of zero is one. That means the first element is one, Fibonacci of one is one. That means second element. Then Fibonacci of n is Fibonacci of n minus one plus Fibonacci of n minus two. So now suppose I give you fibonacci of five. How do you write that? It will be Fibonacci of five will be Fibonacci of four plus fibonacci of three. And fibonacci of three will be Fibonacci of two plus Fibonacci of one. And Fibonacci of one. We know is one. So I know this. And then Fibonacci of two will be fibonacci of one plus fibonacci of zero. I know that this is one, this is one. So I get this. This is done similarly, Fibonacci. Once this is done, I got this number. So what would that be? This will be two and the third one will be two. Then fibonacci of four will be four plus three, two plus three, five. In that it will go on. All right. So if we try to write now, we see how we can write a function, how we can express this fibonacci or this factorial, the recursive expression in the form of a function. Let's see here. I am writing this. You had seen earlier functions written for factorial. So you can see factorial n is if n equal to zero, return one. Otherwise, return n times factorial n minus one. So what will happen? How will this be executed? What will it return? While returning, it will again call this function again. This function will start in the same way, just by replacing n with n minus one. And here it will come out with n minus two. So it will again be called with n minus two, and so on and so forth. It will go on. All right. Now, how is that executed? The function, as I said, is not executed immediately. Just as when I asked that coke machine to deliver five cokes, it did not deliver immediately. It could deliver one coke, held it back, but created another machine to deliver n minus one cokes. And that machine held it back and generated another machine to deliver n minus two cokes. In this way, it went on. They are kept aside on a stack, on a stack, one after another, until the stopping condition is encountered. So it remembered that I have to deliver one. So if you look at this, I don't know whether that will be visible or not. Here. Yeah, here, you see, everybody remembered that, okay, I have to deliver. But they did not deliver. Okay. When the stopping condition was met, after that, this back chain started. Okay. So they are kept aside but not delivered immediately. The function calls are then executed in reverse order. Again, you can see that they are executed in reverse order here. They're executed in the reverse order here. In order to get the solution right, say, calculating factorial four. First, the function calls will be processed. Factorial four is factorial four times factorial three. Then factorial three is three times factorial two. Factorial two is two times factorial one, factorial one is one times factorial zero and factorial zero is one. Therefore, now the actual values will return in the reverse order. One into one, one. So, fact one is complete. So, one into two is two. That goes here. Fact two is two. In that way it goes on. So it goes back in this direction, this direction, this direction, and this direction. Ultimately we get the result from here. Okay, so the actual values return in reverse order. So factorial zero is one, factorial one is one times eleven. Factorial two is, now the reverse order is being done. Two into one, two, three into two, six and four into 6624. In that way it is being computed. All right, so if we look at, so here is a stack. Stack is a data structure. Stack is a way of storing data where we store the data. Just like whatever comes in first obviously goes out last. Because if I put something here, and above that, I put something above that, I put something just like a stack of books, you will have to take out in the other way. This one will come out first. Then this one will come out. Then this one will come out like that. All right, so let's see how it works. Factorial four. So, factor step zero executes. Factorial four. That is, executes. Now return four times factorial three. You see, here is the recursive call. It is calling itself. Return four times factorial three. What is factorial three? Oh, you don't know what is factorial three. Return three times factorial true two. Oh, you don't know what is factorial true two. Okay, then return two into factorial one. Oh, you still do not know what is factorial one. Okay, return one into factorial zero. And so now you know factorial zero is one. So you get one. And now, you could not answer these questions earlier. I have broken it down and gave you an easiest solution. And so now you go back here and you return one into one. Then you go back here, return one into two. Return two. And you go back here, go back here, go back here in that way. This is what is meant by recursion, okay? If we redo it, and while we are doing this, so here is computer implementation of that factorial. If n is less than zero, return one. Return n times factorial n minus one. Okay, so, computes five. So it is again, recursively expressing itself. F four is being expressed in terms of f three. Everything is being expressed. F is being expressed in terms of f three is being expressed in terms of f two. F two is being expressed in terms of f one. F one is being expressed in terms of f zero. And I know what f zero is. So f zero is one. So I go back and I know that now f zero is one. Therefore, f one is one into one. And in this way, I go back in this way. Now, you see, it had expanded in this way. Now it's shrinking one into n is one. So now I know factorial one. So this will shrink. Now I know what is factorial two. That is two. So this will shrink three into two. Six. It is shrinking. Coming here 24 and then here 120. That's how, as if a spring, it got expanded and then it contracted back. This is recursion return. It ultimately returns factorial five to be 120. Another example will be fibonacci number. We'll explain it in the next lecture. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
search as a function.mp3,"We have seen functions in the earlier lecture. And we have also seen. We tried to solve a problem with where there were names of the students in one array and the marks in another array. And we tried to find out. Tried to print out the name of the student who got the highest marks. So for that we had two different arrays. Now, the same thing I can do today. Say I have ten students and each of them have appeared for. This is very bad. Each of them has appeared for four subjects. All right. Or let's say there are five students and each of them has appeared for four subjects. So what would be a convenient way of representing them? One convenient way of representing them would be to have a two dimensional matrix. Two dimensional array where on this side I'll have the role number of the students, which is an integer. And I have got five students. So 1234 and five. Five students. And the marks as the columns, right. So for any problem solving, we'll have to think of how can we represent the data so that our computation is made easy. So that our computation is facilitated. So suppose there are five students. Say role number one. Role number two. Role number three. Role number four. Role number five. And for each of them we have got four columns for the four subjects, right? Suppose the subjects are, say, language, science, mathematics and say history. Four subjects. Right? So how would I read the marks? How would I, first of all store the marks of the students? You can very easily understand now. Now I'm not writing the program. I'm leaving the writing of the program to you. But let's try to understand how it can possibly be solved. So I'll have a function. I can write a function of acquiring data. What will that do? For on this side, I can have an index. I that will talk about the row that I am talking about. That means which student I am talking about. And another index may be j. Or instead of IJ, you can say role and marks. That's also fine. Okay, so keeping I fixed. And then you can fill up the row of the marks of the student. So how would that program segment look like? That program segment will look like for I assigned zero, I less than equal to four. Because there are five students. I plus plus. That is for one row. For j equals zero. J less than equal to three. Because there are four columns. J plus plus scanf. Now you know what to write within the scanf. Okay? So in that way I can read the marks. What I was saying is that instead of this, I can say for. I can be very clear about it. For role equal to zero role less than equal to four, role plus plus, sorry, role plus plus. And for j, similarly, I can make marks. So marks, zero marks less than three marks plus plus, et cetera. In that way I can fill up the table, okay, so now in that way I can fill up the table and say I get the marks as 50, 25, 70, 35, like that, some numbers. Now I can have another function that will find out the total marks of each student. So right now I do not have a space for that. So I can keep that in mind when I'm preparing my table. Then I can have the fifth column for the total marks. Right now I'll pass on. I have read this. So first of all, from my main program, I went to a particular function. I called a particular function which acquired the data and filled up all these, say 70 2015 357-590-8025 610 2030 40 like that, the data has been prepared so quickly, let's see what we did. We entered into a main function, and from the main function I called invoked a function which is acquired data. And what should the type of that function be? Acquired data. Is it returning anything? No. So it should be something like void acquired data d and where is it acquiring the data? In the integer array int say, let's call that array a. And there should be, it's a two dimensional array, so I should have something like this. Just, I am writing clearly int a. If that array was a, that was the parameter. Now, so here that was array a, and here it has been called like acquired data, say my array. And also the size has been specified. The size is suppose globally specified. So I get that array size. Suppose it is defined that role size is five and subject size is four. So I know, but this says subject size plus one. So I needed one more. So I can go here, and from there I returned here, and then I can call another find total of my array. Then what will you do? Essentially, I come to this, and what does that function do, that piece of function that is finding out the total of each student. So that will again be a for loop like the one that we had done earlier. And I'll add keep I to be fixed and add this and write the total here. Now I could have kept it here, or I can have another array total. Let's do that. Suppose I am not having, I'm just having the marks here, and the total array is not here, but a separate array altogether. All right, so I have another array which is total, so I can have the sum of each of them being passed to this. So in that case, when I am calling, when I am calling find total, then I am passing on this array as well as the total array, two arrays, because I want to put the sum on the total array, okay? With that I can find the sum of this, sum of this, some of this, some of this, some of this. And then I can make another function where it finds the max or whatever I want to do so accordingly. The point is that for each of the activities I can make small, small functions, one is for acquiring data, one is for finding the total, one is for finding the maximum number or maybe some other things. Also sorting and all those I can do, I can find out the failure list, another function, so I can have a complete set of small, small functions, each independently done, say acquiring data, finding total, finding max, all these, and they are communicating through a main program. And the main program, my data is one array. So let me draw the data using red. So here I have got my array which was called my array array which had the size five and four, and I had another array total, which is a one dimensional array. How many? Five students. So the main function is invoking from different points for different tasks, these functions, and this function is working on this array, shared array. This function is working on this array and generating the total. Maybe this function is doing something else so that these arrays are being shared by the main function and the small functions. That is how using functions, I can divide a task into smaller subtasks and can do it very nicely. Now with this, now let us move to another problem, one, a version of which we had encountered earlier, that is searching an array. When we have got an array. For example here, when we found, say, suppose I found the total. Here I found the total, and from there I find out which one is the maximum. Or is it that if there is any student whose total is less than 100. Okay, I want to test that. So I have to search this array. Similarly, I can search if there is any student who has got in science more than 90. I can search that along this array. All right, I find if there is any, if 40 is the pass mark, if there is any student who has not passed in maths, I find here there is a failure case. So for that I need to do a search. So search is very fundamental. Search is absolutely fundamental to computation. And so first, we have already seen linear search, but I once again have a journey through that. Okay, so we know that in a search we are given a key, which we are searching for a particular key that we want to find out if the key is present in the array, then we have to say that the key is present and also the position where the key is present. All right. Now we will consider two cases. One is that the array is unsorted. What do I mean by unsorted? By unsorted, I mean that the elements are not in any particular order. For example, think of this array where the elements are 5329 817. Six. Now this array is not in any increasing order nor in some decreasing order. It is decreasing here, decreasing here. Again, increased here, decreased here, again, increased here, decreased here. On the other hand, if the array was something like this, say 2356, sorry, 235568 917, then this array is sorted in an increasing order that as I go from top to down, it is in an increasing order. It is sorted in increasing order. It could be sorted in the decreasing order also. Like say for example, I start with 17, then nine, then eight, then six, then five, then three, then two. So this is, as we go down, the numbers are decreasing. So these are ordered or sorted. And this is unsorted. This is also sorted but in a different order. So I may have to search from an array that is either unsorted or sorted. So first let us think of dealing with unsorted arrays. All right? And we will look into the linear search algorithm for doing that. And if the elements are sorted, we have got a more efficient search algorithm called the binary search. So linear search we have already seen in an earlier lecture. So the basic idea is we start at the beginning of the array. So if we come here, if we come here, sorry, we start, say I want to search this. I start at the beginning of that. I start here and I have got a key. A key is there, say key is eight. So I start from the top, look for the availability of, look for the element matching the key. Five is not matching eight. Then I go on increasing this index and go on comparing till I find either. If eight is not there, I'll come to the end of the array. All the elements have been checked. I have not found the match. Or when I get the match, I'll say that, okay, at this position I have got the key matching. All right. So we'll start at the beginning of the array and inspect every element to see if it matches the key. Now if I want to do it in this way, we often talk about time complexity. It's a measure. I'm not going into the formal way of the measure, the measure of how long an algorithm takes to run. So as you can understand, if there are n elements in the array. Then the best case would be. Let's. You will find out what it will be. Say I start with this. It may be, suppose the key was five. Suppose the key was five. In that case, that's the best case. With one mat, one comparison, I find it. How many comparisons, how many inspections? I needed only one. So that is the best case. The worst case could be if my key was six. If my key was six, then I'd have to inspect every element. And since there are seven elements here, I had to carry out seven comparisons, seven inspections till I found the match. Right. So the best case would be first element, one inspection, one search operation. And the worst case would be no match found, either the last element or not at all found even after that. In that case, I need n search operations. So the best case is one. The worst case is if the size of the array is n, then n. So the average would be n plus one by two search operations. N plus one by two. That is a cost. How much time? That gives a measure of the time the algorithm will take to run. So now we are trying to write it. We had explained this algorithm also earlier, but now that we have done functions, let us write a function for linear search. Why am I writing the function? Say again? If I go to this case now, I may like to say my task is to find out whether any student who has got more than 80. All right, so I'll need to write a function. I'll have to search this in a linear way, in a sequential way, one after another. And for that, I have to write a function. So how will that function look like? Let's see, what are the things I need? I have got an array, so I need to know which array I'll be working with, and that is this array, a. And what is the size of the array? N, whatever that is. Seven, maybe. In our case, the example that I was showing was seven. After I compare seven elements, if I do not find the key, then I am unsuccessful in finding the searches, not yielding any result. The other thing is key, the element, for example, eight, which I am finding out in this array of numbers, right? Say something like this. I am trying to find out eight. So now let's look at the algorithm. Int pos, equal to zero, pause means position. So initially, I am in this position. That is, this array is a. So a zero. While pause is less than size. It is right now zero. It is less than size. That means the pause has not exceeded the last element. That means I have not yet checked the last element, that is why this is said. And this pause, the element a pause. A pause. Pause is, the index is five. And suppose my key is eight. If a pause is not equal to key, then I'll increment pause. I'll check for the next element. Now, look at this. There's an and here. If either of these conditions fail, that means if I have not found it, fine, but I have exceeded the key, exceeded the array size, I mean, limit, then I'll stop. Or if I have found the key, eight here, although I have not reached the end, I'll stop. Okay, so that is the condition. Then I go on increasing pause. If pause is less than n, that means when I come out of this while loop, when any of these conditions are not satisfied. So if pause is less than n, that means actually it should have been, pause is less than size. Okay, if I have come, if still pause is, let's, it should be pause is less than size. If pause is less than size, that means I have not come to the end of the array. Then obviously why did I come out? Because this condition was false. This condition was false means what? I have already found the key, right? Then I'll return the position. So pause increments from zero to one to two, to three, then to four. When I do that, the size was five. I have not exceeded five. It's still less than five, but I have come out. I have come out because I found this. So at pause position four, I am getting the key, so pause is returned. Otherwise, if this is not true, then I'll return minus one, minus one. If it is returned, that means that I have not found the key. Okay, so this is the look of the linear search function. Very simple. Now, so the key appears in. If the key appears within this limit, then I'll return the pointer pos, otherwise, I'll return the key. So here is an example. Say this is the array x twelve minus 378-6765 et cetera. I want to trace the following calls. I call search. So if you go up the linear search, let me call. This is linear search. It should be written down as linear search. I am calling with the array x. All right, the size of the array, eight, and the key is six. Okay, here, what will happen? Size of the array is eight. So I'll start from here. Twelve, no, minus three, no, my key is six. Right. I increment pause from here to here. No, it's not matching. Pause is not the key. Apos is not the key. Here. Apost is the key. So I come out with 01234. Pause value is four. Here. What will happen for this? The same array, x size eight, but my key is five. You can see that I'll go up to this, and after that I'll increment pause plus plus, so it will be more than eight. And so the size is eight, so I'll not be able to, I'll say that I have not got the key. All right, so this one will return four and this one will return minus one. That is how the linear search algorithm works. Now, let's stop here for today. Next, we'll look at another more efficient search, but that demands something more from us, that the array must be sorted. In that case, we can apply the binary search algorithm to make it more efficient. Okay, so today what we saw is how we can write small, small functions to solve a big problem after I break down that big problem into smaller parts. And also, we found how we can, the concept of linear search, which we learned earlier, how we can write a function for that's.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
search trees.mp3,"You. So, as our final example of a user defined data structure, we will look at binary search trees. So we are looking at a situation where we need to maintain dynamic data in a sorted manner. Remember that one of the byproducts of sorting is that we can use binary search to efficiently search for a value. But binary search can be used if we can sort data once and for all and keep it in sorted order. If the data is changing dynamically, then in order to exploit binary search, we'll have to keep resorting the data, which is not efficient. So supposing we have a sequence of items and items are periodically being inserted and deleted. Now, as we saw with heaps, for instance, if we try to maintain a sorted list and then keep track of inserts, then each insert or delete in this case would take order end time and that would also be expensive. However, it turns out that we can move to a tree like structure, or a tree structure like in a priority queue. We move to a heap and then do insert and delete also efficiently alongside searching. So the data structure we have in mind is called a binary search tree. So in a binary search tree we keep exactly one copy of every value. So it's like a set. We don't keep duplicates and the values are organized as follows. For every node, all values which are smaller than the current node's value are to the left, and all values that are bigger than the current node value are to the right. So here is an example of a binary search tree. So you can check, for instance, that to the left of the root five we have all values one, two and four which are smaller than five. And to the right of five we have the values eight and nine which are bigger. Now this is a recursive property. So if you go down, for instance, if you look at the node label two, then below it it has values one and four. Since one is smaller than two, one is to the left of two, and since four is bigger than two, four is to the right of two. Similarly, if you look at the node eight, it has only one value below it, namely nine, and therefore it has no left child, but nine is in the right subtree of eight. So we can maintain a binary search tree using nodes exactly like we did for our user defined lists. Except in a list we had a value and a next pointer. In a binary search tree we have two values below each node, potentially a left child and a right child. So each node now consists of three items, the value being stored, the left child and the right child. So if you look at the same example that we had before on the right, then the root node five will have a pointer to the nodes with two and eight. The node two will have a pointer to the nodes one and four. These are now what are called leaf nodes, so they have no children. So their left and right pointers will be none, indicating there is nothing in that direction. Similarly, eight has got none as its left pointer because it has no left child, and the right pointer points to nine. And the node with nine again has two none pointers because it's a leaf node. Now it will turn out that we will want to expand this representation in order to exploit it better for recursive presentations. So what we will do is that we will not just terminate the tree with a value and two pointers, none. You will actually add a layer of empty nodes with all fields none. With this, the empty tree will be a single empty node, and a leaf node that is not none will have a value, and both its children will be empty nodes. So it won't directly have none as its left and right pointers. It'll actually have children which are empty. So this makes it easier to write recursive functions. And if we don't do this, then it's a bit harder to directly implement recursive functions. So, just to understand how our tree structure changes, this is the structure that we had before the same example. So here, notice that in the leaf nodes, the leaf nodes have a value, and both the child pointers, left and right, are directly none. So we want to change this. What we want to do is we want to insert below this an empty node. Everywhere where we see a none, we want to insert an extra empty node. So this of course blows up the tree a little bit, but then this cost is not that much as you can calculate. So if we do this, then we get a new tree which looks like this. So below every leaf node, wherever we normally had a nun pointer, indicating that the path has ended, we will explicitly add one extra node which has all three fields none. And it will turn out that this is very useful to clean up our programming later on. So this is the representation that we'll use for a binary search tree. Each node has three pointers, and at the leaves we have an extra layer of empty nodes with all three values. None, none, none. So here is the basic class tree. So as before, we have an init function which takes an initial value which is by default none. So the init function works as follows. So we first set up the value to be the init value, which could be none. If there is a value, then we create an tree with one node, in which case we have to create these empty nodes. So notice that if we go back and we don't give a value, so maybe it's better to look at this case. If we don't give a value, then we end up with a tree which just says none, none, none. So this is our empty tree. So the initial value is none. We get this tree. If the initial value is not none, then we get a tree in which we put the value b, and then we make the left and the right pointers both point to this none. So this is a tree that will contain exactly one value. So depending on whether the init value is none or not none, we end up either a tree with three nodes, with two dummy nodes below, or a single empty node denoting the empty tree. So given this as before, we have the function is empty, which basically checks if the value is none. So if I start looking at the tree and the very first node says none, then that tree is empty. Otherwise it's not empty. So let us first look at a way to systematically explore the values in a tree. So these are called traversals. And one traversal, which is very useful for a binary search tree, is an in order traversal. So what an in order traversal does is that it first explores the left side. So it'll first explore this recursively, again using an in order traversal. Then it will display this, and then it'll explore the right. So if you see the code, you can see that if the tree is not empty, you first do an inordered traversal of the left subtree. Then you pick up the value at the current node, and then you do an inordered traversal of the right subtree, and this produces a list of values. So if we execute this step by step, so five, if we reach it says first do an inordered traversal to the left. So we come down to two. This is again not a trivial tree. So again we have to do an inordered traversal. So we go to its left. And now when we have one, an in order traversal of one consists of its left child, which is empty one, and then its right child is empty, so this produces one. Now I come back and I list out the node two. And now I do an inordered traversal of its right. So I've got one, two, four. So this completes the inordered traversal of the left subtree of five. Now I list out five itself, and then I do an inordered traversal of eight and nine. Since eight has no left child, the next value that comes out is eight itself and then nine. So what you can see is that since we print out the values on the left child before the current value, and the values of the right child after the current value with respect to the current value, all these values are sorted, because that's how a search tree is organized. And since this is recursively done at every level down, the final output of an inordered traversal of a search tree is always a sorted list. So this is one way to ensure that the tree that you have constructed is sorted. You do an inordered sub traversal that the tree you have constructed is a search tree. You do an inordered traversal and ensure that the output that you get from this traversal is a sorted list. So as we mentioned at the beginning of this lecture, one of the main reasons to construct a search tree is to be able to do something like binary search, and this is with dynamic data. So we will also have insert and delete as operations. But the main fundamental operation is find. So like in binary search, we start at the root. So imagine that this is the middle of a list or an array. For example, we look at this element. If we have found it, it's fine. If we have not found it, then we need to look in the appropriate subtree. Since the search tree is organized with the left value smaller and the right value is bigger, we go left if the value we are searching for is smaller than the current node, and we go right if it is larger than the current node. So this is very much a generalization of binary search in the tree. So here is the code. It's very straightforward. We want to find a value v. And remember this is this python syntax. So we always have self as the first parameter to our function. So if the current node is empty, we can't find it, so we return false. If we do find v, then we return true, and if we don't find v, then if it is so, this is not t should be self. If it is smaller than this current value, then we go left and search for it. Otherwise we go right and search for. So this is exactly binary search, and it's a very simple recursive thing which exactly follows the structure of a search tree. It will be useful later on to be able to find the smallest and largest values in a search tree. So notice that as we keep going left we go smaller and smaller. So where is the minimum value in a tree? It is along the smaller leftmost path. So if I have to go down the leftmost path and if I can't go any further, then I find it. So we will always apply this function only when the tree is non empty. So let's assume that we are looking for the minimum value in a non empty tree. Well, we find the leftmost part. So if I cannot go further left, then I have found it. So in this case, if I reach one, since I can't go further left, one is the minimum value. Otherwise, if I can go left, then I will go one more step. So if we start this, for instance, at five, it will say that five has a left sub tree. So the minimum value below five is the minimum value below its left child. So we go to three. Now we say that the minimum value below three is the minimum value below its left child. So we go to one. Then we say that the minimum value is the minimum value at one because there is no left child, and therefore we get the answer one. And it is indeed true that anything below that is only on the right and that is two. So dually, one can find the maximum value by following a rightmost path, right. So if the right is none, then we return the current value. Otherwise we recursively look for the maximum value to our right. So in this case we start at five, we go down to seven, then we go down to nine. And since there is no further right path from nine, nine must be the maximum value in this tree. We will come back later on and see why we need this minimum and maximum value. But anyway, it's a useful thing to be able to find, and it's very easy to do. So again, using the structure of the binary search. So one of the things we said is that we need to be able to dynamically add and remove elements from the tree. So the first function that we look for is insert. So how do we insert an element in the tree? Well, it's quite easy. We look for it. If we don't find it, then the place where our search concludes is exactly where it should have been. So we insert it at that point. So for example, supposing we try to insert 21 in this tree. Well, we look at 52 and we go left, then we go left, then we come to 16 again and we go right. Then we come to 21 28 and we find that we have exhausted this path and there is no possible 21 in the street. But had we found 21, it should be to the left or 28. So we insert it there. So we look for where we should find it, and if we don't find it, we insert it in the appropriate place. Similarly, we can start and look for 65, so 65 is bigger than 52, so we go right, then it's smaller than 74, so we go left, but there's nothing to the left of 74. So we put it to the left of 74. Now insert will not put in a value that is already there because we have no duplicate. So if now we try to insert 91, then we go right from 52, we go right from 74, and now we find that 91 is already present in the tree. So insert 91 has no effect on this tree. So this is a very simple modification of the find algorithm. So we keep searching, and if we reach the leaf node then we come to an empty node. So if we find that we have reached an empty node, then we do the equivalent of creating a new node. Here we set this value to be v and we create a new frontier below by adding two empty nodes in the left and right rather than just having none. On the other hand, if we find the value in the tree, we do nothing. And if we don't find the value, then we just use the search tree property and try to insert either on the left or on the right as appropriate. How about delete? So delete is a little bit more complicated than insert. So basically whenever we find v in the tree and there can only be one v, remember this is not like deleting from the list that we had before where we were removing the first copy of v in a search tree, we have only one copy of every value, if at all. So if we find v, we must delete it. So we search for v as usual. Now if the node that we are searching for is a leaf, then we are done, we just delete it and nothing happens. If it has only one child, then we can promote child. If it has two children, we have a whole, we have a node which we have to remove value, but we have values on both sides below it. And now we will use this maximum function, max, val or min valve in order to do the work. So let us just see how this works through some examples. So supposing we first delete 65, then we first search for 65, we find it. Since it is a leaf, then we are, in this case the first case, we just have to remove this leaf and we are done. Now we try to delete 74. So we find 74 and we find that it has only one child. So if it has only one child and we move this out, then we can just effectively short circuit this link and move this whole thing up and make 52 point to 91 directly. So we are in this second case. This is what it means to promote the child. So the deleted node has only one child. We can bypass the child and directly connect the parent of the deleted node to the one child of the deleted node. So this will result in 91 moving up there. Now, finally, we have the difficult case, which is we want to delete a node which is in the middle of the tree, in this case, 37. So we come to 37 and we want to remove this. Now, if we remove this, there will be a vacancy. Now what do we fill the vacancy in and how do we adjust the shape of it? So we look to the left and find the maximum value. Remember that everything to the left is smaller than 37 and everything to the right is bigger than 37. So among the left nodes, we take the biggest one and move it there. Then everything to the left will remain smaller than that node. We could also do it the other way and take the smallest value from the right. But we won't do that. We will stick to taking the maximum value from the left. So we go to the left and find the maximum value is 28. So basically we have taken this 28 and moved it up there. Now we should not have two copies of 28. So we need to remove this 28. So how do we do that? Well, within this subtree, we delete 28. Now, this looks like a problem, because in order to delete a node, we are again deleting a node. But remember that the way that the maximum value was defined, it is along the rightmost path. So the rightmost path will either end in a leaf or it will end in a node like this, which has only one child. And we know that when we have a leaf or only one child, we are in the first two cases, which we can handle without doing this maximum value delete. So we can just walk down, remove the 28 and promote the 21. So this is exactly how delete works. So we can now look at the function. So if there is no value b, then we just return. The easy cases are when we don't find v at the current thing. So if it is less than the current value, then we go to the left and delete. If it is bigger than the current value, we go to the right and delete. So the hard work comes when we actually find v at the current value. So if this is a leaf, now, we haven't shown how to write this function. But if this is a leaf, this means that it has left and right child both as empty nodes. If this is a leaf, then we will make it empty. We will see how we do this in a minute. I'll just show you the code for this. So if this is a leaf, we delete it, right? This is the first case, the simple case, this is a leaf, we just delete it and we make this node empty. If on the other hand it has only one child. So actually in this case, if the left is empty, then we just promote the right, and if its left is not empty, then we will copy the maximum value from the left and delete the maximum value on the left. So we need to just see these two functions here. Make empty and copyright. So make empty just says convert this into an empty node. An empty node is one which all three fields are none. So we'll just say self dot value is none, self dot left is none, self dot right is none. So if it had an empty node hanging off it, those empty nodes are now disconnected from the tree. So this is this make empty function. And now the copyright function just takes everything from the right and moves it up. So it takes the right value and makes it the current value, the left value, right left and makes it the left. So we just take basically this node and copy these values one by one here. So we copied right dot value to the current value, right left to the current, left, right to the current. So how much time do all these take? Well, if you examine the thing carefully, you would realize that in every case we are just walking down one path, searching for the value, and along that path either we find it or we go down to the end and then we stop. So the complexity of every operation is actually determined by the height of the tree. If we have a balanced tree. A balanced tree is one where you can define that each time we come to a node, the left and the right child roughly have the same size. If we have a balanced tree, then it's not difficult to see that we have height, logarithmic and n. This is like a heap. A heap is an example of a balanced tree. A search tree will not be as nicely structured as a heap, because we will have some holes, but we will have logarithmic height. In general, we will not explain how to balance a tree in this particular course. You can look it up. You can look for a topic called aVL trees, which is one variety of balanced trees, which are balanced by rotating subtrees. So it is possible, while doing insert and delete to maintain balance at every node and ensure that all these operations are logarithmic. So let's just look at the code directly and execute it, and convince ourselves that all the things that we wrote here actually work as intended. So here we have a python code for the class tree that we showed in the lectures. So we have just added a comment about how the empty node is organized and the leaves are organized. So there is the constructor which sets up either an empty node or a leaf node with two empty children. Then we have is empty and is leaf. We check whether the current value is none, or both the left and right children are empty respectively. Then we have this function make empty, which converts the leaf to an empty node. Copyright copies the right child values to the current node. And then we have the basic recursive function. So we start with find. So find is the one which is equal under binary search. Then insert is like find, and then where it does not find, it tries to insert. And finally we have max value, which we need for delete and delete. Now when we reach the situation where we have found a value that needs to be deleted, if it is the leaf, then we remove the leaf and make it empty. If it is, the left child is empty, then we copy the right child up. Otherwise we delete the maximum from the left and promote that maximum value to the current. Finally, we have this inordered traversal, which generates a sorted list from the tree values. And the Str function just displays the inordinate traversal. So now if we load this, then we can for instance, import this package, set up an empty tree, and then put in some random values. It's important not to put it in sorted order. Otherwise the sorted tree, if we just insert one at a time, it'll just generate one long path. So I'm just trying to put it in some random order. So we insert into the three all these values, and now if we print tv will give me a sorted version of this. So 1234. So I can now insert more values, so I can, for example, insert 17 and verify that now 17 is there between 14 and 18. And I can keep doing this. I can even insert values in between like 4.5, because I've not specified the integers, so it puts it between four and five and so on. And now I can delete, for example, if I delete three, then I find that I have one, two, four. If I delete, for example 14, then I no longer have 14, between seven and 17 and so on. So this implementation definitely works, although we haven't balanced it. So if we don't balance it, then the danger is that if we keep inserting a sorted sequence, so if we keep inserting larger values, it keeps adding on the right side. So the tree actually looks like a long path. So then it becomes like a sorted list and every insert will take order n time. But if we do have rotations built in as we do, we could using an AVL tree, then we can ensure that the tree never grows to height more than login. So all the operations insert, find and delete will always be logarithmic with respect to the number of values currently being maintained.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
selection sort.mp3,"You. So we have seen that searching becomes more efficient if we have a sorted sequence. So for an unsorted array ordered list, a linear scan is required, and this takes order n time. However, if we have a sorted array, we can use binary search and halve the interval. We have to search with each scan and therefore take order log n time. Now sorting also gives us, as a byproduct, some other useful information. For instance, the median value. The median value in a set is the value such that half the values are bigger and half are smaller. So once we have sorted a sequence, the midpoint automatically gives us the median. We can also do things like building frequency tables or checking for duplicates. Essentially, once we sort a sequence, all identical values come together as a block. So first of all, by checking whether there is a block of size two, we can check whether there's a duplicate in our list. And for each block, if we count the size of the block, we can build a frequency table. So let's look at some ways to sort sequences. So forget about arrays and lists for the moment. And let's think of sorting as a physical task to be performed. So suppose you are a teaching assistant for a course, and the teacher or the instructor has finished correcting the exam papers and now wants you to arrange them so that the one with the largest marks, the highest marks, is on top, the one with the second highest marks is below, and so on. So your task is to arrange the answer papers after correction. In descending order of marks, the topmost one should be the highest mark. So here is one natural strategy to do this. So what we can do is repeatedly look for the biggest or the smallest paper. Now in this case, we are going to build up the stack from the bottom. If the highest mark is on the top, then the lowest mark will be at the bottom. So what we do is we scan the entire stack and find the paper with minimum marks. How do we do this? Well, we just keep looking at each paper in turn. Each time we find a paper with a smaller mark than the one we have in our hand, we change it and replace it by the one we have just found at the end of the scan. In our hand, we will have the paper with the minimum marks. So initially we assume that the topmost paper has a minimum marks, and we keep going down and replacing it with any lower mark we find. So after this scan, we take the paper we have in our hand and put it aside and make a second stack where this is the bottom most thing. Now we have n minus one papers. We repeat the process. We look for the minimum mark amongst these n minus one papers and put this second most lowest mark overall on top of the one we just put. So now we have two papers stacked up in order. As we keep doing this, we will build up a stack from bottom to top which has the lowest mark at the bottom and the highest mark on the top. So suppose these are our six papers. So we have papers with marks 74, 32, eightynight, 55, 21 and 64. So if we scan this list from left to right, then we will find that 21 is the lowest mark. So our strategy says pick up the one with the lowest mark and move it to a new sequence or a new stack. So we do that. Now, again we scan from left to right. This time, of course 21 is gone, so we only have five numbers to scan. So we will find that 32 is our next. And then proceeding in this way, at the next step we will pick up 55 and then 64 and then 74 and finally 89. So in this way, by doing six scans on our list of six elements, we have built up a new sequence which has these six elements ordered according to their value. So this particular strategy, which is very natural and intuitive has a name, is called selection sort. Because at each point we select the next element in sorted order and move it to the final sorted list which is in correct order. So in the algorithm that we executed just now, we needed to build up a second list or a second sequence to store the sorted values. So we kept pulling out things from the first sequence and putting it in the second sequence. However, a little bit of thought will tell us that we don't need to do this. So whenever we pull out an element from the list as being the next smallest, we can move it to the beginning where it is supposed to be and exchange it with what is at the beginning. So we can swap the minimum value with the value in the first position. After this we look at the second position onwards and find the second minimum value and swap it to the second position and so on. So if we were to execute this modified algorithm on the same input that we had before, so in our first scan we would start from the left. So the first position is 74 but the minimum is at 21. So now instead of moving 21 to a new list, we will now swap 21 and 74. So 21 comes to the beginning and 74 goes to the position where 21 was. Now we no longer have to worry about anything to do with 21. We only need to look at this slice, if you want to call it that, starting from 32. So we do this and we find the second smallest element. Now the starting element is 32 and the second smallest element also happens to be 32. That is the smallest element in this slice. So we just keep 32 where it is. Now we start the next slice from position two. So the beginning element is 89 but the smallest element is 55. So having finished this scan, we would say 55 should move to the third position and 89 should replace it. So this way we just keep going on. Now we put 64 where 89 is and finally 74 is in the correct place and 89 is also in the correct place. And we have a sorted sequence using selection sort, where instead of making a second sequence, we have just systematically moved the smallest element we have found to the start of the segment or section that we are looking at right now. So here is a very simple python function which implements selection sort. So the main idea about selection sort is that we have the sequence which has n elements to begin with. So the first time we will scan the entire sequence and we will move the smallest element to this point. Then we will scan the sequence from one onwards. Then we will scan the sequence from two onwards. And at each point, in whichever segment we are, we will move the smallest element to the beginning. So we have the starting points of each scan. So the starting point initially starts at zero and then it goes to one, two, up to the length of l minus one. So for the starting values from zero, implicitly this is zero. Remember, zero to the length of l minus one. We first need to find the minimum value. So we assume that the minimum value is at the beginning of the position of the slice. So we set the minimum position to be the starting position. Remember, the starting position is varying from zero to the length of l minus one. So each slice, the starting position, is the first position in the slice we are currently looking at. Then we scan from this position onwards and if we find a strictly smaller value, if l of I is smaller than what we currently believe is the minimum value, we replace the minimum position by the current index. So in this way, after going through this entire thing, we would have found that say this position is the position of the minimum value. Then we need to exchange these two. So we take the start position and the min position and we do this simultaneous swap which we have seen before. We take two values. We exchange them using this pair notation. So let's see how much time this takes. So in each iteration or in each round of this, we are looking at a slice of length k and we are finding the minimum in that and then exchanging it with the beginning. Now, if we have an unsorted sequence of values of length k, we have to look at all them to find the minimum value. Because we have no idea where it is, we can't stop at any point and declare that there are no smaller values beyond this. So to find the minimum in an unsorted segment of length k, it requires one scan of k steps. And now we do this starting with the segment of the entire slice, that is a slice of length n, then a slice of length n minus one, and so on. And so, if we write, as usual, t of n to be the time it takes for an input of size n to be sorted using selection sort, this would be n for the first slice, n plus one for the second slice on, I mean, position one onwards, n minus two for the position two onwards, and so on. And if we add this all up, we have this familiar sum one plus two plus three up to n, which you will hopefully remember, or you can look up, is given by this expression n into n plus one by two. Now, n into n plus one by two. If we expand, it becomes n squared by two plus n by two. Now, this big o notation, which tells us that it is proportional to n squared. When we have expressions like this, which have different terms like n n squared, n cubed, it turns out that you only need to record the highest term. So since n squared is the highest term, n squared grows faster than n. We can simplify this to o n squared. If you want to see why this is so, we should look up any standard algorithms book. It will explain to you how we calculate big o. But for our purposes, it's enough to remember that big o just takes the highest term in the expression that we are looking at. We said that for sorting algorithm like selection sort, which takes order n squared, will not work for very large values, say for lengths larger than about 5000. So let's look at how this thing works. So first, let's just. So this is the same code that we had on the slide. So selection sort scans, slices from zero up to the length of l minus one. So let's start the Python interpreter. And now we load selection sort from this file. Now, notice the way selection sort works. It doesn't actually return a value. What selection sort does is it takes the value that the list that is passed to it, and it sorts it in place. So in order to see anything from this, we have to first give it a name. So let us take a list such as three, seven, two, for example, and say selection sort of l and now if we look at l, it is correctly sorted in ascending order as two, three, seven. Now in general, we can take a longer list. So for instance, we can use this range function and say, give me the list which is created by taking the range, say from 500 to zero with step of minus one. So this is a descending list of length 500. So if I look at l, it's 500 down to one. And now if I say insertion selection sort of l, then it gets sorted as one to 500. Now our claim is that this will stop working effectively around 5000. So let's see, if I make this as 1000 instead of 500 and run selection sort, then you can see there is an appreciable gap. Right. Now, if I do it for, say 2000, then there's a slightly longer gap. If I do it for 5000, then you can see it takes a little bit of time. It takes more than 1 second for sure. So this is just to validate our claim that in Python, if you expect to do something in 1 second in, then you'd better make sure that the number of steps is below about ten to the seven. And since 5000 squared takes you well beyond ten to the seven, you can expect it to take a very long time.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"sets, stacks, queues.mp3","Program. So in the 1970s, Nicholas Worth, the inventor of the programming language Pascal, wrote a very influential book called algorithms plus data structures equals programs. So the title emphasizes the importance of both algorithms and data structures as components of effective programs. So far, we have seen algorithms in some detail. So now let's take a closer look. Look at some specialized data structures. The data structures that we have seen that are built into Python began with arrays and lists, which are just sequences of values. We also saw dictionaries, which are key value pairs and which are very useful for maintaining various types of information. Another built in data type that is available in Python is the set. So a set is like a list, except that you don't have duplicates in Python. One way of writing a set is to write a list with braces like this. So here we have associated with the name colors a list of values red, black, red, and green. Notice that in setting it up we have repeated red, but because this is a set, the duplicate red will be automatically removed. So if we print the name colors, we just get the list black, red, and green. Now, since the empty brace notation is already used for the empty dictionary, if we want to create an empty set, we have to call the set function as follows. So we say colors equal to set with no arguments. Like lists and other data structures, we can test membership using in. So if in the previous list set colors, which had red, black, and green, we asked whether black is in colors by using the word in, then the return value is true. In general, we can convert any list to a set using the set function. We saw that if you give no bra arguments to set, you get an empty set. But if we give a list such as this 13214 with duplicates and assign it to the name numbers, then because it's a set, the duplicate ones will be removed and we'll get a set of numbers. 01234 notice again that the order in which the set is printed need not be the order in which we provided it. This is very much like a dictionary. Sets are optimized for internal storage to make sure there are no duplicates, et cetera. So we should not assume anything about the order of elements in a set. An interesting feature is that a string itself is essentially a list of characters. So if we give a string to a set, then it produces the set function. Then it produces a set which consists of individual letters from this set. So if we give the string banana to the set function, then we get the three individual letters an and b without duplicates in the set. So as you would expect sets support basic operations like their counterpart in mathematics. So suppose we set up the OD numbers to be the set of all OD numbers between one and eleven, and the prime numbers to be the set of all prime numbers from one and eleven between two and eleven using these set function as we saw before. So if we write this vertical bar, then we can get the union of the two sets. So od union prime will be those elements which are either in Od or in prime. And so we get one from the top, two from the bottom, 3579 and eleven. So we get all the elements in both the sets, but without any duplicates. If we ask for the intersection of the two sets, we use ampersand to denote this. We get those which occur in both sets, those sets those numbers which are both Od and prime, in this case 3511 and seven. Notice again that the order in which these numbers are printed may be arbitrary. Set difference asks for those elements that are in Od but not in prime. In other words, od numbers that are not prime. In this particular collection, one and nine are examples of OD numbers that are not prime. And finally, unlike union which collects elements which are in both sets, we can do an exclusive or which takes elements which are exactly in one of the two sets. So if we use this carrot symbol, then we will get one from the first set, nine from the first set, and two from the second set. Because three, five, seven and eleven occur in both sets, so we will not talk much more about sets, but you can use them in various contexts in order to keep track of a collection of values without duplicates. Using these built in operations, let's look at different ways in which we can manipulate sequences. So a list, as we saw, is a sequence in which we can freely insert and delete values all over the place. Now if we impose some discipline on this, we get specialized data structures, one of which is a stack. So a stack is a last in first out list. So we can only remove from a stack the element that we last added to it. So usually this is denoted by giving two operations. When we push an element onto a stack, we add it to the end of the stack, and when we pop a stack, we implicitly get the last value that was added. Now this is easy to implement. Using built in Python list, we can assume that stacks grow to the right, so we push to the right and we pop from the right. So push sx would just be append x to s. So we can use the built in append function that is available for lists to say s append x when we want to push. And it turns out that Python's lists actually have a built in function called pop, which removes the last element and returns it to us. So we just have to say s pop where s is a list and we get exactly the behavior that we expect of our stack. Stacks are typically used to keep track of recursive function calls, where we want to keep going through a sequence of functions and then returning to the last function that was called before this. In particular, when we do backtracking, we have a stack like behavior, because as we add queens and remove them, what we need to do effectively is to push the latest queen onto the stack so that when we backtrack we can pop it and undo the last move. Another disciplined way of using a list is a queue. Unlike a stack which is last in first out, a queue is a first in first out sequence. In other words, we add at one end and we remove at another end. This is exactly like a queue that you see in real life, where you join the queue at the back and when your turn comes you are at the head of the queue and then you get served. So add q will add x to the rear of the queue and remove q will remove the element which is at the head of the queue. Once again, we can use Python lists, and it turns out that it's convenient to assume that a list that represents a queue has its head at the right end, rather the rear at the left, and the head at the right. This is because we can use pop as before. But now when we want to insert into a queue, we can use the insert function that is provided with this. We haven't seen this explicitly, but if you have gone through the documentation, you will find it. So if I have a list l and if I insert with two arguments j and x, what it means is to put the value j before position j. Put the value x before position j. In particular, if I insert at position zero, this has the effect of putting something before every element in the list. So add q q comma x is just the same as q dot insert zero comma x. In other words, push an x to the beginning. So if I have a q at this form which has some values v one, v two, and so on, then this insert function will just put an x at the beginning. And as we said before, the reason we have chosen to use this notation is that we can then use pop to just remove the last element of the list. So queues and stacks can both be easily implemented using built in lists. So, one typical use of a queue is to systematically explore through a search space. So, imagine that we have a rectangular m cross n grid, and we have a knight, a knight as a chess piece, starting at a position sx, comma, sy. In this case, the knight is denoted by this red circle. So, this is our knight. Now, the night move, if you are familiar with chess, is to move two squares up and one square left. So, this is a night move. Similarly, this is a night move. Similarly, this is a night move and so on. So a night move consists of moving two squares in one direction and then one square across. Okay, so these are all the positions that are reachable from this initial position. By the night move, there are eight of them. So our question is that we have this red starting square and we have a green diamond indicating a target square. Can I hop? Using a sequence of night moves from the red square to the green diamond. So, one way to do this is to just keep growing the list of squares one can reach. So, in the first step, we examine these eight squares that we can reach, as we said, using one move from the starting position, and we mark them as squares that are available to us to reach in one step. Now, we can pick one of them, for instance, one at the top left, and explore what we can reach from there. So, if we start in this square, for instance, and now we explore its neighbors, some of its neighbors are outside the grid, so we throw them away. We keep only those neighbors inside the grid, and one of them, notice, brings us back to the place where we started from. Now, we could pick another square. For example, we could pick the square over here. And if we explore that, it will again in turn produce eight neighbors. And some of these neighbors overlap to the yellow neighbors, who are indicated by a joint shading of yellow and green. And in particular, because both of them were originally reached from the starting point. Of course, the starting point is reached from both of them. So the starting point is both colored yellow and green. So, as you can see, in the process of marking these squares, sometimes we mark a square twice. And we have to have a systematic way of making sure that we do this correctly and don't get into a loop. So what we are trying to do is the following. So, in the first step, we are trying to mark all squares reachable in one move from the starting point, sx comma s y. Then we try to mark all squares reachable from x one in one move. Call this x two. Then we will explore all squares reachable from x two. In one move, call this x three and so on. Now, one of the problems is that we saw that since we could reach x two from x one and one move, then the squares that you can reach from x two will include squares in x one. So how do we ensure that we don't keep exploring an already marked square and go around and round in circles? And related to this question is how do we know when to stop? Of course, since we know that we are looking for the target square, if ever we mark the target square, we can stop. On the other hand, it is possible that the target square is not reachable. In this case, we may keep going on exploring without ever realizing that we are fruitlessly going ahead and we are never going to reach the target square. So how do we know when to stop? So a queue is very useful for this. What we do is we maintain at any point a queue of cells which remain to be explored. Initially, the queue contains only the start node, which is sx, comma sy. At each point we remove the head of the queue and we explore its neighbors. But when we explore its neighbors, we mark these neighbors. Some of them may already be marked. So we look at ax ay, the element we remove from the head of the queue, and we look at all the squares reachable at one step. So reachable means I can take one night move and go there. And the result of this night move doesn't take me off the board. So I mark all these squares which are reachable from ax and ay, some of which were already marked, some of which are marked just now. So what I do is I take the ones which I have newly marked and add them to the queue, saying that these have been newly marked. So now I need to also explore these squares for what I can reach from there. So this guarantees that a square which has been reached once will never be reintroduced into the queue. And finally we keep going until the queue is empty. When the queue is empty. There have been no new squares added which are unmarked before they were added. So there is nothing more to explore and we have gone to every square we can possibly visit. So here is some python pseudocode for this. So we are going to explore. From Sxy to TxTy we assume that we have given to us the values m and n, indicating the number of rows and columns in our grid. So what we do is initially we set the marked array to be zero. Remember this list comprehension notation? So it says zero for in range. N gives us a list of n zeros and we do this m times for j n range m. So we get a list consisting of m blocks, each block having n zeros. So this says that initially nothing is marked. Now we set up the thing by saying that we mark the starting node and we insert the starting node into the queue. Now, so long as the queue is not empty, we pop one element from the queue. In this case, sxy will come out. Now there is a function which we have not written, but which will examine all the neighbors that I can reach from ax ay and give me a list of such pairs of nodes I can reach. So for each neighbor nxny, if it is not marked, then I will mark it and I will insert it into the queue. So I pull out an element from the queue to explore, look at all its neighbors. Those which are not marked I mark and put them back in the queue. And finally, in this case, I'm not even going to check whether I have marked tx or ty in the middle. I know that if I have a finite set of squares, at some point this process has to stop. So at the end I will return whether I'll return the value of marked at the target node txty. So if I have reached it, this will return one, which is true. If it is not reached, it will return zero, which is false. So let's look at an example of how this works. So here we have a three by three grid. Remember that the cells are 1012 and naming convention we want to start from the top center square. So this is our source, and this here in the center is our target. So let's erase all these marks and set up this thing as we would expect. So we say that initially the cube that we want to have has the source node, and we mark the source node in the grid. So the marking is indicated by a red mark. So this is how we start. So our first step is to remove this from the cube and explore its neighbors. Now its neighbors are 20 and two, so this means, so we will henceforth remove these brackets because it's more annoying. So we will just grow it like this. So we say that my q consists of two comma zero and two comma two. So this is my q of vertices to be explored. So at each step I will now remove the first element of the q and explore its neighbors. So when I explore the neighbors of 20, I will find one of them is of course where I started from. So I only look at unmarked neighbors. So an unmarked neighbor is one, two. So I will add that back at the end of the queue. Now proceeding, I will take the next element of the queue, which is two two, and look at its neighbors. So two two can go back again to the original thing. And it also has a new thing here, which is 10. So continuing like this, I remove one two, which is this one, and I look at its neighbors. So one of its neighbors is 20, but one of them is zero zero. So I get a new neighbor, zero zero here. Then I continue by taking 10 of the q, so 10 is this one. So it has one new neighbor, unexplored, just that one. So my q now has followed by zero two. Then when I explore zero zero, I get this neighbor at the bottom, which is two one. Now when I remove zero two, which is this one, I find that both its neighbors are explored. So I add nothing. I continue, I do two one. Again, I find both its neighbors explore, they do nothing. So now at this point the queue is empty, and since the q is empty, I stop and I find that my square of interest, namely eleven, was not marked. Therefore, in this case the target is not reachable from the source node. So this is actually an example of breadfast search, which you will study if you look at graphs. But it just illustrates that a queue is a nice way to systematically keep track of how you explore through a search space. So, to summarize, data structures are ways of organizing information that allow efficient processing in certain contexts. So we saw that Python has a built in implementation of lists of sets. Rather, we also saw that we can take take sequences and use them in two structured ways. So a stack is a last in first out list, and we can use this to keep track of recursive computations. And queues are first f in first out lists that are useful for breadth first exploration. You.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sorting Methods.mp3,"So we were discussing about sorting, and in particular we were discussing about one sorting technique, which is a selection sort. So in selection sort, what do we do? We have got an array and of size size. So that means the index is zero to size minus one. So what we do some parts, we assume that some parts are sorted. So first thing that we do is find the smallest element. So if from zero to k is sorted already in the order, then my job is to sort from k to size minus one. So what we do, the step is that we find the smallest element, minimum value, in the list x from k to size minus one. All right, I find the minimum element and then swap that minimum value with the kth position. That means this position, with this position I carry out here, in this position, I bring the minimum value and this goes on. And then increase k. K will be increased to the next position. And in this way I'll be going on. Okay, so the sub problem is, the sub problem is to find the minimum element. So if I go here, as we have seen in this array, my task is to find the minimum position, okay, so where is, say this part is already sorted. I am sitting here and this is my kth position, right? This is my kth position. And I want to find the minimum, where is the minimum value? Okay, where is the m valve minimum value, where. So for that, this is the function, find the minimum location in the array x. And starting from this location, k up to the location size minus one. So I need to know size and need to know k. That's how we are giving the parameters as we had explained in functions. So at every point you look at how the functions are written. That will help you in revising this. Okay, now the body of the function. So x pause, x pause will be the smallest element found so far. So initially I am making pause to be k. So x pause is this point. Now from k plus one, two up to size, I go on checking whether this xj, this position is less than this position. So I find out in this way here, I find the minimum, right, just see if you can understand the code. I find the minimum in between k plus one to size minus one. In between this I am trying to find the minimum. So whenever I get the minimum, I'll be returning that particular position. So this is the position that I'll be returning this position. Okay, so what would be my full algorithm, therefore? So I have got a function, I have got this function, min lock, which will return me the minimum location, okay, now, so it will yield me the location of the smallest element. So now you see the selection sort main sorting function will be this. It takes the array and the size. Okay, so this is my array, x and this is the size. So I'll have to work between zero to size minus one. I have got two intermediate variables, k and m. For k equal to zero to k size minus one. What am I doing? First, I am starting with this, this element that is k equal to zero. And what am I doing? I am finding out from k in the array, x up to size. I am finding the minimum location. So suppose here is the minimum. Then what am I doing here? Temp is going to ak. So this k is going to temp. And this ak is being written by am. This is the minimum is coming here. And then this temp is going here. So here what am I doing is I am swapping x. My array was internally, I called here. There's a small mistake. I can find. It should be xk. All these would be x. All right? Because I'm dealing with x. So xk will get x minimum m because and vice versa. And this y. So what is happening here? Let's see. Suppose my array was something like this, 50 2010 hundred. So I am first, this is my k equal to one. I want to bring the minimum at this position. So what I do from here, I start searching for the minimum. I find ten to be the minimum. Then I swap here in this piece of code. I swap, I bring ten here and 2070 remains. And 50 I take here. And then what do I do? K is incremented. So now k is here. Now I find min lock. If what is the minimum here? Less than this or not? There is none. So fine. Next. So this remains. Next, I increment this. So this is also in position. This is in position because it need not be exchanged. Next, my k is increased here at this step. K plus it has been increased here. I find the minimum in this area. I find this to be the minimum. So what is happening? Ten was in place. 20 was in place. I swap 50 and 70 here. So 50 comes here. I find the minimum. 70 remains here. 100 remains here. Now I change my k and see if there is any minimum left here. The min location is not returning me anything. So therefore I get this to be my sorted array. Okay? So you can see that. So in this way we can, sorry. Here is an example. Now you see here the example you see here. I start with this. So three is the minimum. I can see here. Twelve minus five, six, et cetera. I can see -17 is the minimum. Okay, so I find out -17 here. I swap that. So -17 comes here and three goes to the place of -17 so these two now 1212 and I find the minimum. From twelve onwards I find minus five to be the minimum. So that one will come here. So minus five comes here and twelve is swapped there. Now within this part I find the minimum. Minimum is three. So three will be swapped with twelve and twelve goes there in the place of three, you see now. So I start with six. I start finding the minimum. Six is the minimum. Fine. So it remains. I increase k. So now 142 in this way I go on from here. Who is the minimum? Starting from 140. 212 is the minimum. So twelve and 142 will be swapped. Twelve and 142 has been swapped. Next, 21, 21. Within this 211-42-4521 is the minimum. Therefore I keep it in place. Next is I take 142 and 45. I find that 45 is minimum. I swap that and 142 goes there. Next is 142. That is the sorted array that we get. This is what is known as selection sort. So the philosophy of selection sort is that I am selecting the minimum element among the unsorted elements and placing it in the position, proper position where that minimum element should be. That's why we are selecting and putting it. So that's why it's known as selection sort. So how many steps are needed to sort in things here? If I do this, how many steps am I taking? You see, how many steps am I taking? All through here? If you look at this, how many steps am I taking? If the list size of the list was n, then the total number of steps that are required is proportional to n square. Because for every element, why it is so, let us try to understand this. The reason is that for every position, how many positions are there? One, two, three. Like that there are n positions. Now for every position, for this position, how many comparisons? I need to find out the minimum n minus one comparison, n comparisons for all these. Next I increment it here. So how many do I need? I need for each of these for n, for n such elements. For each of them I need n comparisons. Then n plus. For this I need n minus one comparisons. Then I need n minus two comparisons. Then I need n minus three comparisons in this way, for example, for this there's n one, two, three. So n minus four comparisons I need. In this part I have to compare between these things. So in that way I go on. So for every. So for each of them I need to compare this, right? For n such things I have to do this. N plus n plus n minus one plus n minus two times n. So that will be of the order of n square. If I find the product, right? And number of compare, total number of steps, and number of comparisons is again n into n minus one by two. Like, as I said, n minus one comparisons, plus n minus two comparisons. Last one is one comparison. So if you add this one to n minus one is n into n minus one by two. You know that, and that is of the order of n squared. If I break it up, it will be n square minus n by two. So that is again of the order of n squared. Of the order of. We write it as of the order of n square. All right? Now next we come to another sorting algorithm which is known as insertion Sort. What is the general situation again, just like the selection sort, we have got the smallest element sorted from zero to this point is sorted. The remaining is Unsorted. All right? Now what we do is compare and shift till Xi is larger. Okay, I go on shifting. So what I do is I start with this element and I put this in the proper position. I insert this in the proper position. So I move this in this side or in this side, and I'll come to the proper position of this element. This element is being put. Since it is smaller, the smallest elements are sorted. So I'm taking this and I am putting it in the place where it should belong because I have not seen up to this. Okay, so insert sort is something like this. Let's see if I can show you an example first. So what I am doing is I'm comparing and shifting till Xi is larger. I am continuously shifting the elements in this way. I go on shifting this. Ultimately, Xi will be larger than all these elements. So therefore my sorted position will be up to this. This is larger. Right? So, I'm sorry, I just went the other side, other way down. So let's study this algorithm. This algorithm is void. Why it's void because it's not returning anything. It is taking the array and is sorting this. It's taking this array and it's sorting this. So its type is void. It's taking a list and its size. Now for I equal to one to size. I am taking item to be the list. I. So I have got elements like, say, twelve, 7517, nine. So first I am taking I is one. So I'm taking this element. This is the item for J. Now, I am looking at you see, J equals I minus one and j is greater than zero and list. So I'm not going into this side. I'll have to go in this direction. What does this mean? I start with J, I minus one and go till j is greater than equal to zero and the list is greater than I. All right, so my I is here. That means I'm going till the end of this array on the other side. I'm going on the other side and I shift. What was my j here, j plus one and the list are being swapped. So now it will become 712, 517, nine now. And then in that way, I go on shifting. All right, so now if I come here, I increment I after one item. So I'll come five and five. I'll go on checking what is the proper place of five. So it will be five will be swapped with this twelve, 717, nine. In that way, I'll try to find out for every each of these, its proper position. Okay, so I think we can go for a more popular sort. Let's go to the more popular sort. I think that will be better. Selection sort. You have learned insertion sort is another form. But let's learn the more popular one. That's a bubble sort. Bubble sort, as the name implies, it starts from the bottom and the minimum element is pushed up to the top. How is that done? Just as a bubble floats up from the bottom and goes to the top, the minimum element should be pushed up, or the minimum element should be pushed up to the top. So let's see how it happens. So I first compare between these two elements, then these two elements, and in this way, I go on comparing between each of them and push it up. Okay. In every iteration, the heaviest element drops at the bottom. So what is happening is. So if I go here from the top, I try to find out if this element, if this particular element. I'm sorry, this particular element is heavier than this particular element, then this particular element should go at the top, and this should come down here. All right, next, I compare what's happening. Next, I compare between this. So this was a heavy element. And I find that this is not an heavy element. This is heavier than this. So this may be more, much heavier than this. So this is not pushed out. Okay, it remains. Now, next, I compare between this and every time I'm making the same mistake. Maybe this is a heavier, lighter element. So this lighter element will go up and this heavier element will come down. So it'll be something like this. All right, so in this way, in one direction, ultimately what I'll do, I'll have the heaviest element at the bottom and all the elements here are lighter than this, this element lighter than this element. But these elements are not sorted. So what I'll do, I'll restrict my next iteration within this zone and again start between these elements and see whichever is heavier that will be pushed down. Am I clear? You see, every time I am comparing between these and I am pushing that down, I think it will be clearer in a moment. It every iteration the heaviest element drops at the bottom and this part is done and the bottom moves upwards. So next time onwards my search will be restricted between this zone, this zone to the top and the heaviest will come here. Next time my search will be restricted to this zone. Like that. So the heaviest here, next heaviest here. Next heaviest here, heaviest here. Next heaviest here, next heaviest here. Like that it will go on. So I want to see if I can give an example first. Yeah, so what is happening here is see this was an unsorted array. The heaviest one has been first pushed down. This 89 was the heaviest one. So by piece by piece comparison I have pushed it down. Next time I was restricted to this part of the array, 89 has been pushed down. Let me try to show you that. Say suppose I have got an array like this. 5016 2030 40. So first I compare between these 250 is heavier. So I come here. Next I compare between these 250 and 2050 is heavier. So 20 comes here, 50 comes here. Now 50 and 30, 50 is heavier so 30 50 and then 50 and 40. So I compared this so it becomes 40 50. So in one turn what do I get? Now? I get 16 2030, 40 50. Now it was such that many things were sorted. Only one was in out of order. So that has been done. But suppose this was. Let me just change it. It became too easy. So suppose it is 25. Then after this swap this became 25 and 50. So I have this array. Now I again check between these two. Heavier is in place. I check between these two, no issue heavier in place. I check between these two. So now what will happen? 25 will come here and 30 being heavier will come here and 30. And I need not compare any further because this I know is the heaviest. So what do I have now? 16 2030 not 30, 30 has been swapped. 25 30 I again compare between these two. So there is no change. As soon as I find that there is no interchange, that means all these things are in order. This is the idea of the selection. Sorry, the bubble sort every time the minimum is shifting going to the bottom or I could have done it in the other way that would have justified the name of the bubble sort if I had taken the lowest element and pushed it up. Okay, so quickly, if we look at the algorithm a little bit. So we have got. This is a bubble sort algorithm. Let's see. Now, in order to explain this, I'll need some time, because here we are using some new ideas, star x and star y. I think I'll take it up in a separate lecture and discuss this separately. All right. But just as I had explained, now, the way the bubble sort works, I'll just give you one more example to show how a bubble sort works. And then in the next lecture, I'll show you the algorithm, because that will require some more explanation. Let's say I have got this. 30, 20, 516, two. So what will be happening in the fast iteration, 30 will be compared with 2030 is heavier. So it'll be 2030, 516, two. Now 30 will be compared with five. So what will happen and will be swapped? 3016, 230 will be compared with 16. So what will happen? 20, 516, 32 and 30 is again greater than two. So 20, 516 to 30. So 20, 516 to 30. By that I get this 30 at the bottom. So now I start with again, 20, 516, two. Right, so now I have got 30 is at the bottom. 20, 516, two and 30 is already in proper place. Here I'll swap. So what will happen? 520, 16, two then 20 will and 16. So it will be 516, 22. Then 516, 220, 20 is in the proper place. So 30 and 20 are in proper place. And 516, two I'll have to handle. So what will be there? 516, two, so 516, two. And here I have got 20 and 30 already in the proper place, sorted. So here, five and 16, no change. 16 and two, there'll be some change. So 5216, so 16 is in the proper place. So now between five and two, so my thing will be 16, 2030 are in place. 16, 2030 are in place. And five and two I have to deal with. These are fine. So my pointers are changing. Right, between these two. Now, five is heavier, so it will be two five, five is in the proper place, so two, five in the proper place. 16, proper place, 20, proper place, 30, proper place. So only two. There is no question of swapping. So I get the complete sorted file. Okay, so this is the principle of bubble sort. I'll be explaining the algorithm, the code in the next class. In the meanwhile, you can think of, you can read books and you can try to see, look at this code and the algorithm yourself. I'll discuss it in the next week's lecture. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
standard input and output.mp3,"Till now, all the programs that you have been asked to write in your assignments have actually been just functions. So these are functions which are called from other pieces of python code and return values to them. Now, when you have a standalone python program, it must interact with the user in order to derive inputs and produce outputs. So let's see how Python interacts with its environment. The most basic way of interacting with the environment is to take input from the keyboard and display output to the screen. Traditionally, these modes are called standard input and standard output. So standard input just means take the input from the keyboard or any standard input device like that. And standard output just means display the output directly on the screen. So the basic command in Python to read from the keyboard is input. So if we invoke the function input with no arguments and assign it to a name, then the name user data will get the value that is typed in by the user at the input command. So remember that it reads a line of input. So the way that the user signals that the input is over is by hitting the return button on the keyboard and the entire sequence of characters up to the return, but not including the return, is transmitted as a string to user data. Now of course, if the program is just waiting for you for input, it can be very confusing. So you might want to provide a prompt which is a message to the user telling the user what is expected. So you can provide such a thing by adding a string as an argument to input. So if you put an argument to input like this, then it is a string which is displayed when the user is supposed to input data. Now this string is displayed as it is, so you can make appropriate adaptations to make it a little more user friendly. We will see an example in a minute, but you might want to leave a space or you might want to insert a new line. So basically you use the input command to read one line of input from the user and you can display a message to tell the user what is expected of him. So here is what happens if I just say user data is equal to input. The python program will just wait. And now as a user who doesn't know what is expected, we don't know whether it's processing something or it's waiting for input. Now it turns out that if we type something and press enter, it'll come back. And now if I ask for the contents of the name user data, it will in fact be the string of things that I typed. So providing an input prompt without a message can be confusing for the user. So what we said was we might want to say something like provide an input like this. So now it provides us with a message, but the number that we type, for instance, is stuck to the message, so it's not very readable. So user data is indeed not a number. Now it's a string, as we will see in a minute. But the fact is that we didn't get any space or anything else, so it looks a bit ugly. So what we said is that you can actually, for instance, put a colon and a space so that the message comes like this. And now this is a slightly nicer prompt. And you could also put a new line if you want, which is signaled by this special character backslash n. So now the message comes and then you type on a new line. And in all cases the outcome is the same. User data, the name to which you're reading the input becomes set to the string that is typed in by the user. So if I do it again, and if I type in something else like 993 for example, then user data becomes the string nine nine three. So you can use input with a message and make the message as readable as you can. So as we saw when we were playing with the interpreter, the input that is read by the function input is always a string. So even if you say enter a number and the user types in a number, this is not actually a number. So if you want to use it as a number, you have to use this type conversion. Remember we have these functions, int, str and so on. So we have to use the int function to type convert whatever the user has typed to an integer. Now of course, remember that if the user types some garbage, then you get an error, right? So the user doesn't type something valid, then you will get an error. So what we can do is we can use exception handling to deal with this error. So what we can say is try user data. So this is the code that we had before those two lines. So what we want to say is we will try these lines, but if the user types something which is not a number, then we are going to ask him to type it again and it'll turn out that that type of error in python is called a value error. So you can verify this by going to the python interpreter and checking. So in the python interpreter if we try to apply int to some nonsensical thing, then we get a value error. So what we are trying to say is that if we get a value error, we want to take appropriate action. So we have this try block, and if we see a value error. What we do is we print a message. Now, we are going to see print just after this, but we print a message to the user saying, this is not a number, try again. And the whole thing is enclosed inside a while loop. And this while loop has the condition true. In other words, the condition is never going to become false. This while loop is going to keep on asking for a number. Right? So how do we get out of this? Well, if I come here and I get a value error, it'll go back and the while will execute again. But if there is no error, remember, if there is no error here, then it'll come to the else. So this else is executed if there's no error. And what the else does is it gets us out of this vicious cycle. So in other words, we are in an infinite loop where we keep on trying to get one more piece of data from the user until we get something that we like. And when we get that, we break out of the loop. So this is another kind of idiomatic way to use exceptions in the context of input and output. As we said in the last lecture, input and output is inherently error prone because you are dealing with an uncertain, interacting environment which can do things which you cannot anticipate or control. So you must take appropriate action to make sure that the interaction goes in the direction that you expect. So the other part of interaction is displaying messages, which we call standard output or printing, to the screen. And this is achieved using the print statement, which we have seen occasionally informally, without formally having defined it. So the basic form of the print statement is to give a sequence of values separated by commas. So print xy will display the value of x, then a space, then the value of y. Print Abc will display three values, the values of a, b, and c separated by spaces. Now, the other thing that we can do is directly print a string or a message. So, like we saw in the previous example, we can say, print the string, not a number. Try again. So this will display the string on the screen. Now, you can combine these two things in interesting ways. So, print takes, in general, a sequence of things of arbitrary length separated by commas. So these things could be either messages or names. So we can say things. Supposing we want to print the value of x and y, but we want to indicate to the output which is x, which is y. So instead of saying just print x comma y, which produces two values on the screen with no indication as to which is x and which is y, we could have this more elaborate print statement which prints four things. So the first thing it prints is a message saying the values are x colon. So this will print x colon and leave a space. Then it'll print the value of current value of x. Then it'll print y colon after a space, and then it'll print the current value of y. So we can intersperse messages with values with names to produce meaningful output that is more readable. By default, print appends a new line whenever it is executed. In other words, every print statement we just print the way we have done so far, appears on a new line because the previous print statement implicitly moves the output to a new line. Now if we want to control this, we can use an optional argument called end. So we can provide a string saying this is what should be put at the end of the print statement. By default, the value here is this new line character, so we can replace this by something else. So here is an example. Supposing we write these three statements. So the first statement says print continue on the this is just a string, but set end to a space. The second line says print same line and then it says set end to a full stop and a new line. And then the third statement says print next line. So what we are doing is in the first two statements we are changing the default. So the default would have been to print a new line, but the first statement is not printing a new line. So if we print this, what we see is that the first two statements continue on the same line. Come on a single line because we have disabled the default print new line and we have explicitly put a new line here and this has forced the next one to come on the next line. So if we break this up and see what happens here, we see that in the first statement we had this end which says insert a space. And this is why we get a space between the word the and the first line and the word same coming from the second line. Otherwise the and same would have been fused together as a single word. So end equal to space is effectively separating this print from the next print by a space. The next print statement inserts a full stop and a new line. So implicitly, although the word same line ends without a full stop, we produce a full stop. And after we produce a full stop, it produces a new line. And finally, after this new line, the next line comes on a new line. And of course because here we didn't say anything, if we print after that, we implicitly would print on a new line. The other thing that we might want to control is how the items are separated on a line. We said that if we say print X, comma Y, then x and y will be separated by space by default. So if we do this print x Y, we set x equal to seven, y equal to ten, and we say x is x and y is y and then we want to end with a full stop. So this is what we want. You want to write the string x is then the value of X, and y is then the value of Y and then a full stop. Now, because everything is separated by space, what we find is that we find a space over here. So do you see this? So this is fine. So we get a space here because that is from this comma. We get a space here which is from this comma. We get a space here which is from this comma. And then we get an unwanted space between ten and the full stop. So how do we get rid of this space, the second space? We don't want a full stop to come after a space. So just like we have the optional argument end, we have an optional argument sep which specifies what string should be used to separate. So for example, if we take the earlier thing, we can say don't separate it with anything. Now of course don't separate it with anything, it changes, because then this x is seven will get fused, and this and will get fused. So what we do instead is we put the space explicitly here. Earlier we had no space here at the end, just around the quotes. Now we put spaces where we want them and we say don't put any other spaces. So what this will say is that x is space. I give the space, don't put a space, put the value of x, don't put a space. Now I give a space. So, and Y is give a space then. Now don't put a space here. So these commas don't contribute any space because I've said separator should be empty. And in particular what this means is that this last comma, the comma between the y and the full stop will not generate a space. And in fact, if you execute this, then you will get the output x is seven and Y is ten. And the way it works is that this is the first block, right? So this is everything up to here. Then this is the second block, this is this, then this is the third block, which is this whole thing with the spaces given. And then this is the value of Y. And finally this is the full stop, right? So this is one way to control the output of a print statement. So with the optional arguments end and sep we can control when successive prints continue on the same line, and we can control to some limited extent how these values are separated on a line. But we may actually want to do a lot more. We might want to put a sequence of things so that they all line up. So supposing we want to print out a table using a print statement. We want to make sure that the columns line up. So we might want to say that each item that we want to print like we have printing a sequence of numbers line by line. But the numbers may have different widths, some may be three digits, some may be five digits. We might say print them all to occupy seven characters width. So this is a thing that we might want to do, align text. Now, within this alignment, we might want to align things left or right. So if we have a default with say ten characters, if they are numbers, we might want them right aligned so that the units digit is aligned up. If they are names, we might want them left aligned, so that we can read them from left to right without it looking ragged. And if we are doing things like calculating averages or something, we may not want the entire thing to be displayed. We might want to truncate it to two decimal points, say it is currency or something like that. So these are all more intricate ways of formatting the output. And we will see in the next lecture how to do this. But right now you can use end and sep to do minimal formatting. So to summarize, you can use the input statement with an optional message in order to read from the keyboard. You can print to the screen using a print statement. Now, we mentioned at the beginning that there are some differences between Python two and three. And here is one of the more obvious differences that you will see. If you look at Python two code, which is available from various sources. In Python two, you can say print space and then give what is given as the arguments to print in Python three. So Python three insists on it being called like a function with brackets. In Python two, the brackets are optional. So you will very often see in Python two code something that looks like print x, y without any brackets. This is legal in Python two. This is not legal in Python three. So just be careful about this. And what we saw is that with a limited amount of control, we can make print behave as we want. So we can specify what to put at the end. In particular, we can tell it not to put a new line. So continue printing on the same line, and we can separate the values by something other than the default space, correct?",,,,,,,,,,,,,,,,,,,,,,,,,,,,
string functions.mp3,"So at the last lecture we saw how to read and write text files. And reading and writing text invariably involves processing the strings that we read and write. And so Python has a number of string processing functions that make it easier to modify these contents. So usually you're reading and writing files in order to do something with these files. And to do something with these, you can use the built in string functions, which are quite powerful, among other things. What you can do with these string functions is, for example, search for text, or search and replace it. A typical use of string processing for a file is when we take something like a spreadsheet and export it as text. So there is something called a comma separated value format Csv, where the columns are output separated by commas as text. So now what we can do with the string file is to read such a file line by line, and in each line extract the columns from the text by reading between the commas. So we will see all these in this lecture. So the first example of a string command that we already saw last time is the commands to strip white space, right? So we have r strip, which we used, for example, to remove the trailing white space. The backslash ends in our lines, and we had l strip to remove leading white space, and we had strip which removes it on both directions. So let's see how this works. Let's create a string which has white space before and afterwards. So let's put some spaces, maybe a tab, then the word hello, then two tabs. So we have a string which has white space, and you can see the tabs are indicated by backslash t and blanks. So now if we want to just strip from the right, we say t is equal to s r strip. So remember this strip command strings are immutable, right? So it won't change s, it'll just return a new string. So if I say t is s r strip, it'll strip the white space to the right and give me t. And if I look at t, it has everything up to hello, but not the tab and the space afterwards. Similarly, if I say t is s l strip, it'll remove the ones to the left. And now t will start with hello, but it'll have the white space at the end. And finally, if I say t is s strip, then both sides are gone and I will just get the word that I want. So this is useful because when you ask people to type things in forms, for example, usually they leave some blanks before and after. So if you want everything before the first blank to be lost and the last blank and only keep the text in between. Then you can use a combination of l strip, rstrip, or just strip to extract the actual data that you want from the file. So the next thing that maybe I want to do is to look for text in a string. So there is a basic command called find. So if s is a string and pattern is another string that I'm looking for in s dot find pattern will return the first position in s which pattern occurs, and if pattern doesn't occur, so the position will there obviously be between zero and the length of s minus one. We already wrote some our own implementations of this earlier, so if it doesn't occur, it'll give you minus one. Now sometimes you may not want to search the entire string, so pattern takes an optional pair of arguments, start and end, in which case, instead of looking for the pattern from the entire string, it looks as a slice from start to end with the usual convention that this is the position from start to end minus one. And there is another version of this command called index. And the difference between find and index is what happens when the pattern is not found. In find, when the pattern is not found, you get a minus one. In index, when the pattern is not found, you get a special type of error, in this case a value error. So again, let's just see how these things actually work. So we have a string here s, which contains the words brown fox, gray dog, brown fox. Now if I ask it to look for the first occurrence of the word brown, then it will return the position zero because it's right there at the beginning of the string. If, on the other hand, I don't want this position, but I want it say starting from position five and going till the length of s, for example, then it will say 19 and if you count, you'll find that correct. The second occurrence of brown is at position 19. If, on the other hand, I look for something which is not there, like cat, then find will return minus one. So minus one is the error which not the error, but the indication that the string was not found. Now, difference with index is that if I give index the same thing instead of a minus one, it gives me a value error saying the substring does not occur, right? So this is how find and index work. So the next natural thing after searching is searching and replacing. So if I want to replace something, I give it two strings, what I'm searching for and what I am replacing it with, and it will return a copy of s with each occurrence of the first string replaced by the second string. Now this can be controlled in the following way. Supposing I don't want each occurrence, but I only want, say, the first occurrence or the first three occurrences. So I can give it an optional argument saying how many such occurrences, starting from the beginning, should be replaced. So it says replace at most the first n copies. And notice that like in strip and all that here, because it's changing the string, it's replacing something by something else. It's not that s is going to change because strings are immutable. It's going to return us the transformed string. So let's look at an example once again. Let's use our old example. S is brown fox, gray dog, brown fox. And now supposing I want to replace brown by black. Then I get black fox, gray dog, black fox. If I say I only want one to be replaced, then I get black fox, gray dog, but the second brown is left unchanged. Now you may ask, what happens if I have this pattern? It doesn't neatly split up if I have the different copies of brown overlap. So supposing I have some stupid string like Ababa. And now I say replace all abas by, say, dd. Right? So now the question is, will it find two abas or one Aba? Because there is an ABA starting at position zero. There is also an ABA in the second half of the spring starting at position two. The question is, will it mark both of these and replace them by DD? Well, it doesn't, because it does it sequentially. So it first takes the first ABA, replaces it by DT. At this point, the ABA, the second ABA has been destroyed, so it will not find it. Whereas if I had had, for instance, two copies of this disjoint, then it would have correctly found this and given me DD followed by DT. So there's no problem about overlapping strings. It just does it from left to right, and it makes sure that the overlap string is first written so the second copy will not get transferred. So the next thing that we want to look at is splitting a string. Now, when we take a spreadsheet and write it out as text, usually what happens is that we'll have an output which looks like this. So the first column would be written, followed by a comma, then the second column. So if we had three columns and the first column said six, second column said seven and the third was a string hello. Then when we write it out as text, we will get six, seven, and hello. So actually hello is a bit of a problem because it has double quotes. Let us not use hello. Let us use something simpler. So let's just say that we had three numbers, six, seven and eight, for example. Now what we want to do is we want to extract this information. So we want to extract the individual six, seven and eight that we had as three values. So what we need to do is look for this text between the strings. So we want to split the column into lines, into chunks between the commas. And this is done using the split command. So split takes a string s and takes a character. Or actually it could be any string, and it splits the columns. It gives you a list of values that come by taking the parts between the commas. So up to the first comma is the first thing. So columns is just a name that we have used. It could be any list. So the first item of the list will be up to the first comma, then between the first and second comma, and so on, and then finally after the last comma. So comma in this case is not a very special thing. You can split using any separator string. And again, just like in replace, we could control how many times we replaced here, you can also control how many splits you make. So you can say split according to this string. So notice that this could be any string. So here we are splitting it according to space, but we are saying don't make more than n chunks. So if you have more than n columns or whatever chunks which come like this beyond a certain point, we will just lump it as one remaining string and keep it with us. So again, let's see how this works. Suppose this is our line of text, which I call CSV line. It's a sequence of values separated by commas. Notice it is a string. So now if I say CSv line split using comma as a separator, then I get a list of values. The string six, the string seven, the string eight. Remember, this is exactly like what we said about input. It doesn't get you the values in the form that you want. You then have to convert them using int. Or these are still strings. So it just takes a long string and splits it up into a list of smaller strings. Now here there are three elements. So if I say, for example, position zero, one, two, so if I say I only want you to do it once, then I get the first six. But then seven and eight doesn't get split because it only splits once. Now if I change this to something more fancy, like say hash question mark, right? So now I have a different separator. It's not a single character. But hash question mark. Then I can say split according to hash question mark. And this will give me the same thing. So you can split according to any string. It's just a uniform string. There are more fancy things you can do with regular expressions and all that, but we won't be covering that for now. As long as you have a fixed string which separates your thing, you can split according to that fixed string. So the inverse operation of split would be to join strings. So supposing we have a collection of strings, and I want to combine it into a single string, separate each of them by a given separator. So as an example, supposing we take s, which is some CSv output, and we split it into columns on comma. Then we can take join string and set it to the value comma and then use that to join the columns. Now this is a bit confusing. So, join is a function which is associated with a string. In this case, the string and concerned is a comma. So it says more or less, you're saying comma join columns, which is use comma to join columns. So you've just given it a name here. Join string is equal to comma, and then CSv line is join string, join columns. So what this says is use comma to separate. So if at the end of this I had got like last time, six, seven and eight, then this will now put them back as six, comma, seven, comma, eight into a single string. Here is another example. Here we have a date, 16 a month, zero, eight, and a year 2016, given as strings. And I want to string it together into a date like we normally use with hyphens. So here, instead of giving an intermediate name to the hyphen and then saying hyphen join, I directly use the string itself. Just want to illustrate that you can directly use the joining string itself as a constant string and say use this to join this list of values. So all you need to make sure is that what you have inside the join the argument is a list of strings, and what you apply it to is the string which will be used to join them. So let's just check that this works the way we actually intended to do. So let's directly do the second example. So supposing we say date is 16. Remember, these are all strings. Month is eight, year is 2016. And now I want to say, what is the effect of joining these three things using dash as a separator? And I get so there are many other interesting things you can do with strings. For example, you can manipulate uppercase and lowercase. So if you say capitalize, what it'll do is it'll convert the first letter to uppercase and keep the rest as lowercase. If you say s dot lower, it'll convert all uppercase to lowercase. If you say S upper, it'll convert all lowercase to uppercase, and so on. There are other fancy things like s title. So title will capitalize each word. So this is how it normally appears, say, in the title of a book or a movie. S swap case will invert lowercase to uppercase and uppercase to lowercase, and so on. So there are a whole collection of functions in the string thing which deal with uppercase, lowercase, and how to transform between these. The other thing that you can do with strings is to resize them to fit what you want. So if you want to have a string which is positioned as a column of certain width, then we can say that center it in a block of size n. So what this will do is it will return a new string which is of length n with s centered in it. Now, by centering, what we mean is that on either side they will leave blanks. Now, instead of blanks, you can put anything you want, like stars or minuses. So you can give a character which will be used to fill up the empty space on either side rather than a blank. Now you may not want it centered, you may not want to the left or the right. So you can, for example, left justify it using ljust or r justify it using rjest. And again, you can give an optional character and so on. So we can just check one or two of these just to see how they work. Suppose we take a short string like hello, and now we center it in a large block of, say, 50. So we say s dot center 50. Then this gives us hello with a lot of blank spaces on either side. Now we can replace those blank spaces by anything we want. So say minus sign. Then we get a string of minus signs or hyphens before that. Now we can also say that I want the thing left justified in this not centered. So if I do that, then I will get hello at the beginning and a bunch of minus signs, similarly with rjest and so on. Some of the other types of functions which you find associated with strings are to check properties of strings. Does s consist only of the letters a to z and capital a to capital z? So that is what S dot is. Alpha says. Is it an alphabetic string? If it is true, it means it is. If it is not. It has at least one non alphabetic character. Similarly, is it entirely digits? Is numeric? Will tell us if it's entirely digits. So there is a huge number of string functions, and there's no point going through all of them in this thing. If we need them as we go along, we will use them and explain them. But you can look at that Python documentation. Look under string functions, and you'll find a whole host of useful utilities which allow you to easily manipulate strings. And this is one of the reasons that Python is a popular language, because you can do this kind of easy text processing, so you can use it to quickly transform data from one format to another, and to change the way it looks, or to resize it, and so on. So string functions are an extremely important part of Python's utility as a glue language for transforming things from one format to another.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
String Operations.mp3,"We have looked at arrays and their utility. We have in particular looked at one dimensional array. And today we'll introduce another variety of array, which is two dimensional array. In fact, we can have multidimensional arrays. In general, arrays can be, we can have n dimension. What is happening with this n dimensional arrays for a particular value of n equal to one, we are having this one dimensional array, right where I have got some say one dimensional array of integers. So for n equal to two, we can have two dimensional arrays. That means where there will be a length and there will be a breadth of the array. So that array can be considered of consisting of a number of one dimensional arrays. For example, as I am showing in this diagram, I have got two dimensions. On this dimension I have got four rows. And on this dimension, I'm sorry, this, let me draw it afresh. So on this side I have got four rows and on this side I have got 123456 positions. So these are called columns. These are called columns and these are called rows, right? So here I have got two dimensions. One is the length, that is six or six columns, and the breadth which is four rows, since it's two dimension. So it is a two dimensional array, okay, so a two dimensional array like this can be considered to be consisting of, say in this case four one dimensional arrays arranged one after another. So this is one array, which we learned till now. This is another array. This part is another array. This part is another array. So we have got four different arrays, 1234 different arrays arranged one after another. Okay, so I can have, for n equal to two, I have got rows and columns. So we get two dimensional address, similarly for n equal to three, we can have three dimensional ids like, so I have got one two dimensional array like this. And we can think of another two dimensional array lying here, another two dimensional array lying here. In that way I can have an arrangement of say maybe three or four two dimensional arrays, one after another. That's also an arrangement. Each of these may be four rows and six columns, sorry, maybe like this, four rows and six columns. So this row, this three dimensional will be four rows, six columns and four such two dimensional ladies. This is one two dimensional array. This is another two dimensional, this one two dimensional array. And we have got four such two dimensional addis arranged one after another, right? If I had one more here, if I had one more here, same array, then this would be changed to five. Okay? In that way I can extend my concept of arranging data as we had done for one dimensional array. We are extending it to two dimensions, three dimensions. In that way, it will be difficult to show it on the screen. We can go up to n, so n dimension ladies, which will have different dimensions altogether. But today we'll be just discussing about two dimensional ladies. And the thing is quite general and can be extended to other dimensional ladies also. So we are now talking about two dimensional arrays. You can see the most common example of two dimensional array is a table. Table means an arrangement of data just like this. This arrangement of information is known as a table. Often we see table in other forms also. For example, I can have a table of something like this. Ah, so the first here I put name of the boy, name of a student. Then I stored age of a student, school to which the student goes and address of the student, maybe. And I have got such scope of keeping it for, say, four students, one student number one, student number two, student number three, student number four. And I go on. So this is known as a table because I am organizing them in an organized, in a tabular form. Okay, so this is a table. So what we were looking at now is another table where here I am showing that there are four students, student one, student two, student three, student four for each of the, each of the students have got some marks in the different subjects. Subject one, subject two, subject three, subject four, and subject five. So I can consider that all the marks of student one in the different subjects are stored in a row. This row for the first student, similarly, this row for the second student. Right? Similarly, this row for the third student and this row for the fourth student. Okay, so each row wise I get the information of all students. And column wise, if I look in this direction, what do I get in subject one, what are the different marks and who have got what marks. And most interesting part is the intersection. Say, for example, this element of the array. What will this element tell me? This element is identified by its row and column, which row it is in, and which column it is in. This element is 75. And what is the meaning of this 75? 75 is the student two's submarks of subject two. Okay? It is in whatever we tell you, you can tell that it is a subject two marks of student two. This is the subject three marks of student three. Okay? So in that way I can represent any of these as identified by some row name, row number and column number. Recall that in the case of one dimensional array, when we are talking of one dimensional array, there we had indices index, right? So that index was telling us, say, for example, there are, suppose these are marks again, out of ten. All right. And I wanted to know what is the marks in subject one. So the I value I equal to zero was pointing me to this. Suppose this is marks, I value was showing this. If I take the I value one, then I get the marks of this subject like that. Now in that case, in the case of one, if I wanted to have this element that was identified by I value equal to 01234. But in the case of a two dimensional array, just as we are seeing here, we will be getting to a particular element again in the same way with index. But here, say for example this element, this element here, how do I identify this element? This element will be identified by this row and this column. So my index, while this was for one dimensional array, the index was I. In this case, the index will be I and j. So any pair, ij pair will identify which row and which column. So this particular element is determined by the I value. Again, just because it is c, I am saying that it is starting from zero, one, two, and here 01234. So say this element can be identified by I is equal to eleven, right? For example, this element, this element is identified by, sorry, index value I, j. I'm sorry. Here the index is eleven. So the I, j pair, j pair is eleven. For this I should be one and j should be three. So this pair is identified, identified by one, three whenever I get. So suppose here this array was marks. Similarly, I'll have a name for this two dimensional array and I can access any element by this indices, okay? But in this case, since it is a two dimensional array, I have got two pointers, two bit, two parts of this, the row part and the column part. Okay? So here you can see that the subjects are organized in this way, subject marks are organized in this way. And we can access any of these elements using the proper index, the student number and the subject number. The table here in the table that was shown here are showing how many elements. 12345 into 420 elements, right? So the table contains 20 values, five in each line. And it can be arranged, organized as a matrix, two dimensional matrix consisting of four rows and five columns. Now, c allows us to define such tables by using two dimensional array. What does it mean? The general form is like this type array name, row size, column size, always you compare with. What we learned for one dimensional array is just an extension of that. For example, marks 45. So in this case, which we saw just now, it's an array with, and let's call this, say the name of this array is also marks. And marks has got so let me write here. It is marks and it has got four rows and it has got five columns. So that's how I can describe this array. And then we can go on filling up the values of this array. So array name, row size and column size. So for example, int marks. Similarly, I can have cells of 25 items over twelve months. Maybe say I can have something like. So let's try to see. What this possibly can mean is that suppose I have got a table where there are twelve rows. All right, I'll have twelve rows here and there'll be 25 columns here. All right, that will be 300 items. So I'm not showing that. But say each of these rows may mean, say this is January row, this is a February row, this is a march row, et cetera. And suppose here there are different items, a shop has got different items and in that way it has got 25 different items. And here we write how many units of a particular. This row is shirts. All right, this one says that in the month of February how many shirts have been sold. And maybe this says in the month of, say this is pen in the month of January or in the month of January how many pens have been sold. So in that way this entire matrix or this array can be named as the array cells which will have twelve rows and 25 columns. Similarly, another very important thing to note is this type. This type that we declared also in the case of a one dimensional array is also applicable here because each of these elements in this array will be of the same type. So here sales, I am saying, and I have said sales is float. So the way I wrote it is not correct. I should write it as say how many elements are there. It can be that in the month of January what is the worth of not how many shirts were sold, but shirts worth how many rupees were sold. So it can be here 100.5, say, because each of these elements are floating point numbers. All right? Similarly, matrix can be 100 by 100 matrix where each of the elements will be a double precision number. Okay, so we have got two places, two dimensions that we are specifying here, unlike what we did in the case of a one dimensional array where we did something like int marks, say five. So int marks, five is a one dimensional array with five elements. I can say that these are with five columns of this one dimensional array which is one row. Had there been more rows like this, then immediately I have to identify which row and which column. And if there be two such rows, then this array should be described as int marks. Say here two five. Okay, because there are two rows similar to that of one dimensional array, but we use two indices. Indices is the plural of index index indices, right. So the first one indicates the row and the second one indicates the column. Both the indices should be expressions which evaluate to integer values. And that was the case for one dimensional addis also. So if I have something like marks two five, these values must be integers. I can write expressions will show there later, but those expressions must evaluate to integer values. All right, so examples are xmn zero. So whatever m value is, m has to be an integer. Suppose m here is two and n is one. Then in this array, whose name is x, we have got a number of rows and a number of columns. Which element am I referring to here? I am referring to row 20123. So I'm referring to this row and which column? I am referring to one. So this was 01234. So I'm referring to this column. Therefore I am actually pointing at this particular element. All right, this particular elementary. Similarly, I can do operations like this. What does this mean? Let's try to understand this. This means I am referring to three different two dimensional arrays. One is one is a which has got some rows and columns. And there is another array, this is a, this is b and I have got another array, c. Now I am taking, what is being done here. This means cik. So this c is being designated by an index I, another index k. This one is being done by referred by I and some g, this one by j and k. What is being done here? That for different values of I, j and k I am selecting. This has got a special application, but I'm not going into that. I am looking at taking a particular value from here that is CI and ck. K is pointing here. So this one I am taking and adding that with the product of AI and j. J might be pointing somewhere here I am taking this element and I am taking maybe for b array, j row, I'm sorry, j row, j should be here, j row and k column. So I'm taking another element from here. So I'm taking this element multiplied by this element here and adding that with this element that is taken from c. That's what I am doing. Okay, so this simple example, but this has got far more reaching implication. You will realize that soon. Here you see what we have done here. Why is this example shown here? You see we are specifying the index in the form of an expression. Suppose j was two and here, which one I am referring to a j into two. So that means a six, followed by whatever value of k was, might be 62. That means I am referring to the element of the array a. A is an array whose 6th, 7th row and third column element is being taken. So if this be like this, I am taking the 7th row element and second or third column element, I am taking that value and finding the square root of that. And that is again being put to the corresponding value of that is coming to some other variable name. Actually, this should be, since this is an array, this should have been kept as some other variable name. B might be. All right, so how is a two dimensional array stored in memory? We know that a one dimensional array is stored in a memory in the contiguous memory location. So just for the sake of recalling, if we had, if I have a one dimensional array, say 3547, they were being mapped to the memory, actual memory. Here is the memory location, the different memory locations, and I am storing them here, 3547, in contiguous locations. Okay, but what happens to the case of two dimensional array? For example, if I have the array that I am drawing here with three rows, three rows and two columns. All right, so what is the dimension of this array? A. A is three, two, okay, three rows and two columns. Now suppose it is 175320. Say those are the values. In that case, if I store it in the memory, I can store it. Now I am drawing how it can be stored in the memory. I need 123456 locations in the memory. So I'll have six locations, so I can store them 152730, or I can store them as 175320. Now, what is the difference between these two storages? This one is I am storing them column wise, I'm storing them column wise, and in this case I am storing them row wise, row after row. Right? In C, the compiler stores the arrays row wise, which is often known as in the row major form, and this is the column major form, column major form. But in C, we are doing it in row major form. There is a specific significance of this, because whenever I want to access an element, say a array, I want to find the particular element, say two, three. Which element shall I find out here? For example, here, let's take this case and let me try to find out the element. Say this is a capital a, capital a. I want to find out the element two one. That means I'm actually trying to find out the row number two, row number two, and element number one. So I'm trying to find this one out. Now, where will it be if I do not know? So say this is accidentally, I am coming to the same. Let's say, let's make this one one. That means which one? Row one, column one. So I'm actually trying to find this element three. Now, what is the address of this element? Where is it stored? You can see that three has been stored here. If I store in the column major form. But if I store in the row major form, it is here. So whenever I am trying to find this element out of this memory representation, I'll actually have to fetch it from the memory, right? So therefore, I have to find out the address of this, and for that I need to know where it is stored row wise or column wise, since I know it is row wise. So how should I go about it, since there are two columns. So for the first row, I'll say that if this with my starting address thousand, then the first row will take thousand and thousand. This is starting from thousand two. All right. This is the first row. This is the second row. And this means the second row part and second rows. This is one. What is this element? Five. This is second row and zero 8th element. And this one is second row. And then the next element. So it is one one. So using, knowing that whether it is stored in the row major form or column major form is very essential in order that I can find out the address of the element in a two dimensional array. We'll continue with this further. More explanations are required about this.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
strings.mp3,"We have seen now that Python uses names to remember values. So values are the actual quantities that we manipulate in our program. These are stored in names. Values have types, and essentially the type of a value determines what operations are allowed. So the types that we have seen are the basic numeric types, int and float, and the logical type bool, which takes values, true or false. So for the numeric types we have arithmetic operations, and we also have other operations which are more complicated for the boolean types we have and or not, which allows us to manipulate true and false values. And then we have these comparison operators equal to greater than and so on, which allows us to check the relative values of two different quantities and decide whether they are in some order with each other. The important thing that we said was that in Python the names themselves don't have a fixed type. So we cannot say that I is of type int or x is of type float. Rather, it depends on what value is assigned. And in particular, if a name is used for the first time without assigning a value, then Python will complain. So we don't have to announce names in advance like other programming languages. But whenever we first use a new name, its first use must be in an assignment statement on the left hand side. So before we use a name in an expression on the right hand side, it must be assigned a valid value. Now, numeric types are by no means the only things that are of interest these days in computation. A lot of the computation we do is actually dealing with text. So whenever we prepare a document, for example, using a word processor or some other thing for presentation, then we are actually manipulating text. So we're moving text around, searching for something to replace and so on. Also, when we are manipulating data itself, very often data comes from multiple sources. So we might have tables of values which are typed in by somebody or generated by a device, and we have to import them into a spreadsheet. And then if we want to manipulate them using another program, we might want to export them from a spreadsheet. This is typically done using text files in which the columns of the spreadsheet are stored in a systematic way, separated by, say, commas. So this also involves text processing. And finally, most of us spent our time using a computer, actually working with the Internet. So one of the most common things that we do when we use the Internet is to type queries and look for matching documents or other resources on the Internet. So most of this search query processing currently is done using text. So it matches the text in the query that we give with some information about the documents also implicitly in text, and decides which documents are most relevant to our query. So text processing is an important part of computation in general, and the ease with which you can manipulate text in Python is one of the reasons why it has become a very popular language to program many things, including Internet applications. So Python uses the type string for text, which internally is called STR. So we will use the word string instead of str because it's easier to say. So a string is basically a sequence of characters. Unlike other programming languages, Python does not have a specific character type to distinguish a single character from a string of length one. So there is only one type for text in Python, which is string, and a single character is indistinguishable from a string of length one. So there are not two types of things. It's not that we have single characters, and then a string is a sequence of characters, a string is a sequence of symbols, and one symbol is just a sequence of length one. So the values of this type are written as we would normally do in English, using quotes. So we use quotation marks to demarcate the beginning and the end of a string when we want to write down an explicit value. So we can use any type of quote. So a single quote would denote in this case that the name city is assigned the string chennai. Note that when we write symbols like this, capital c is different from small c and so on. So we see exactly the symbols within this two quotes as the value assigned to the name city. Now we can also use double quotes. And one reason to use double quotes is if you actually need to use a single quote as part of the string. So this is one way to do it. Another way to do it is to actually write a backslash. So if you write a backslash and a quote in the middle of a string, it means that this quote is to be taken as a symbol and not as the end of the string. But a much simpler way to include special things like quotes inside other quotes is to change the quotation. So a single quote can include double quotes, and a double quote can include single quotes without any confusion. So this says that the name title is assigned the value. Hitchhiker's guide to the Galaxy now, what if you wanted to combine both double quotes and single quotes in the string? So Python has a very convenient thing called a triple quote. So you can open three single quotes, and then you can write whatever you want with multiple double quotes and single quotes. So if you want to say that he said his favorite book is within quotes. Hitchhiker's guide to the Galaxy then this value string has both double quotes inside it, and it also has a single quote inside it. So we can't enclose it in double quotes. And we can't enclose it in single quotes because either of them will be ambiguous. Unless of course we use this backslash, as I said before. So if you don't want to use a backslash, you can use a triple quote. Let's see how this works in the Python interpreter. So we can say s equal to Chennai. And if we now ask for the value of s, we see that it's reported with a single quote. If we ask for the type of s, it says that s is of class SDR. So this tells us that internally Python realizes that s is a string. If we said t is equal to, say just the letter x, then the type of t is also a string. So there's no distinction between a single character and multiple characters. Now if we say, let us just shorten it, say title is equal to hitchhikers. Then if you ask for the value of title, it shows it to you with double quotes outside and a single quote inside. So this indicates that this is a single string. And again, the type of title is str. And finally, if I say my quote is equal to and I use three quotes and I use hitchhikers, so I have hitchhikers and double quotes. Hitchhikers itself contains a single quote and I use triple quotes around it, then my quote is correctly shown. Now notice that when it displays my quote, it doesn't show triple quotes, it encloses, it puts another single quote outside and it shows this internal single quote as being highlighted with a backslash. So backslash single quote is Python's way, and many programming languages way of saying that the next character should not be treated as what it stands for, but as it is. So just take the next single quote as a single quote. Don't treat it as the end of a quotation. The other thing that you can do with single quotes is to actually write multiple lines. If I do this first line and then second line and then third line and then close the quote, then my quote is shown as first line with backslash n. So backslash n again is a special character which indicates a new line, then second line, then new line, and then third line. So we said before that Python is very useful for manipulating text. And one of the things that you would like to do is actually to read and say a paragraph of text or multiple lines from a document and not have to worry about the fact that these are multiple lines. Just store it as a text value, as a string. So this is very much possible in Python. You can embed multiple lines of text into a single value. So as we said, the string is a sequence or a list of characters. So how do we get to individual characters in this list? Well, these characters have positions, and in Python, positions in a string start with zero. So if I have n characters in a string, the positions are named zero to n minus one. So supposing we have a string, hello, it has five characters. So the positions in this string will be called 0123 and four. So this is how we label positions. And another convenience in Python is that we can actually label it backwards. So we can say that this is position minus one. Very often you want to say take the last character of a string and do something. So instead of having to remember the length and then go to the end, it's convenient to say take the last character. So take the minus one character. So we actually saw this when we did the GCD. We talked about the last element of a list, say the list of common factors, and we said the minus one element in the list is the last element. So this numbering scheme that we use for lists informally in the GCD example, without formally explaining it, is actually the same numbering scheme that is used for positions in a string. So we have minus one, minus two, minus three, minus four, minus five. So the important thing to remember is that going forwards you start at zero, and coming backwards you start at minus one, because obviously minus zero is the same as zero. So if we use minus zero for the rightmost thing, there would be terrible confusion as to whether we're talking about the first value or the last value. So the forward positions start from zero from the beginning, and the reverse positions start from minus one from the last element. So once we have this, then we can see that we use the square bracket notation to extract individual positions. So s one. So that is, the character at position one is an e, and if I walk backwards, then s minus two is an l. One of the most basic things one can do with strings is to put them together to combine two values into a larger string. And this is called concatenation, putting them one after the other. And the operator that is used for this is plus. So plus, we saw for numeric values, adds them for strings. The same symbol plus doesn't add strings. Obviously, it doesn't make sense to add strings, but it puts them, juxtaposes them. It puts them one after the other. So if we have a string hello as we did before, and we take this, and we take a new string, and we add it to s, then we get a string t, whose value is the part that was in hello plus the part that was added. So plus is just a simple operator which takes two strings and sticks them side by side. So LET's look at an example in the interpreter. So just to emphasize one point, supposing I said s was hello and t was there, then s plus t would be the value hello there. Now, notice that there is no space. So plus literally puts s followed by t. It doesn't introduce any punctuation, any separation, any space. And this is as you would like it. If you want to put a comma or a space, you must do that. So if you said t instead of that was space, hello, space there. T is the string consisting of a blank space followed by there. Now, if I say s plus t, I get a space between hello and there. So this is important to note that plus directly puts things together. It doesn't add any punctuation or any other separation between the two values. So it's as though you have one new string which is composed of many old strings whose boundaries disappear completely. We can get the length of a string using the function len. So len s REturns the length of s. So this is the number of characters. So remember that if the number of characters is n, then the positions are zero to n minus one. So the length of the string s here would be five. The length of the string t here would be five plus 712. There are many other interesting functions that one can use to manipulate strings. You can search and replace things, you can find the first occurrence of something, and so on. And we will see some of these later on when we get into strings and text processing and reading data from files in more detail. A very common thing that we want to do with strings is to extract a part of a string. We might want to extract the beginning, the first word, and things like that. So the most simple way to do this in Python is to take what is called a slice. So a slice is a segment. A segment means I take a long string, which I can think of as a list of characters, and I want the portion from some starting point to some ending point. So this is what Python calls a slice. So if we say s is hello as before, then for a slice we give the starting point and the ending point separated by colons. So we use the square bracket notation exactly as though we were extracting part of a string, but the part that we are extracting is not a single position, but a range of positions from one to four. Now, in Python, we saw that we had this range function which we wrote last time, which said things like, if I want the numbers from one to m, I must write one to m plus one, because the range function in Python stops one position short of the last element of the range. So in the same way a slice stops one position short of the last index in the slice. So if I do this, then remember that hello has positions 01234. So the slice from one to four starts at one, goes to two, goes to three, but does not go to four. So it's only from e to l, the second l. So in general, if I write si j, then it starts at si and ends at sj minus one. There are some shortcuts which are easy to remember and use very often. You want to take the first n characters in a string, then you could omit the zero and just say start from implicitly from zero. So just leave it out, say Colon and j. So this will give us all positions, zero, one up to j minus one. So if I leave out the first position, it's implicitly starting from zero. And similarly, if I leave out the last position, it runs to the end of the string. So if I want everything from I onwards, then I can say si, colon, and this will go up to the position length of s minus one. But if I write it explicitly as a slice, I will only write length of s. So essentially, this is the main reason that Python has this convention that whenever I write something like a range of one to m plus one, then I have this extra plus one here. So the main reason for this plus one is to avoid having to write minus one. So if I had to include the last character, and if I start numbering at zero, then every time I wanted to go to the end of the string, I would have to say length of s minus one. It is much more convenient to just say length of s and implicitly assume that it knows that it should not go to a length of s but like minus one. So this whole confusion, if you would like to call it that in Python, about the fact that all ranges end one short of the right hand side of the range, stems from the fact that you very often want to run from something to the length of it in a list or a sequence or a string. And when you say that, you don't want to have to keep remembering to say minus one. So let's play with this again in the Python interpreter. So if I say s is equal to hello, then we saw that if I do one to four, I get ell. If I say colon, three, then I get hel, that is zero, one, two. If I say two colon, I get llo, that is two, three, four. What if I say one three to one? So this says start at position three and go up to position one minus one, which is zero. So Python doesn't give you an error. It takes all these invalid ranges. Anything where, for example, the starting point to the ending point does not define a valid range and it says this is the empty string. On the other hand, if I say something like go from zero to seven where there is no 7th position in the string here, Python will not give an error. Instead it will just go up to the last position which actually exists in the string below seven. So in general, these range values are treated in a sensible way. If you give values which don't make sense as far as possible, Python tries to do something sensible with the slice definition. Though we have access to individual positions or individual slices or sequences within a string, we cannot take a part of a string and change it as it stands, so we cannot update a string in place. Suppose we want to take our string hello and change it to the string. Help. It would be nice if we could take the third and the fourth position. So remember 012345 so 01234 so it would be nice if we could say make this into a p and make this into an exclamation mark so that I could get help instead of hello. So we would want to write something like change s three, assign the value s three to be the string p. Now unfortunately, Python doesn't allow this, so you cannot update a string in place by changing its parts. In fact, if you try this, you will actually get an error message. Let's see. So here we have the string hello defined as before, and if I now try to say s three is equal to p, then it says this does not support item assignment, which is what you're trying to say. You cannot change parts of a string as it stands. So instead of doing this, instead of trying to take a string and change a part of it as it stands, what you need to do is actually construct a new string, effectively using the notion of slices and concatenation. So here what we want to do is we said we want to take the first part of the string as it is. So these are the first three characters, and then we want to change this to p exclamation one. So what we can say is update s by taking zero, one, two, which is the slice zero to three, and concatenating it with a new string p exclamation mark. So this is how you modify strings in Python. But the important thing is this is a new s. We are not claiming that this s is the same as the old s, so we build a new string from the old string and perhaps store it back in the same name. It's much like when we say j equal to j plus five, we are actually saying that we have created a new value for j and stored it back in j. So here again we are creating a new string and putting it back, but we are not modifying it. Now this distinction between modifying and creating a new value may not seem very important at this moment, but it will become important as we go along. So strings are what are called immutable values. You cannot change them without actually creating a fresh value, whereas lists, as we will see, which are a more general type of sequence, can be changed in place. You can take one part of a list and then replace it by something else. So we will see more about this later. This is a fairly important concept, but remember for now that strings cannot be changed in place. So to summarize, what we have seen is that text values are important for computation, and Python has the type string or str, which is a sequence of characters to denote text values, and there is no distinction for a separate type for a single character. There is no single character type in Python. A single character is just a string of length one. We can extract individual characters by index positions, we can use slices to extract substrings, and we can glue strings together using the concatenation operator plus. But strings are immutable, so we cannot take a string name assigned a value assigned to a string name and update it in place. We can create a new value by manipulating it using slices and concatenation, but we cannot directly update it because strings are immutable.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Structure (Contd.).mp3,"So, in the last lecture we had seen how a structure is defined. Now we'll see more examples of that in the course. So today will be concentrating on how a particular structure can be processed. In order to process a structure, we have to process every field of the structure. We can operate on every field of the structure. So we can see that a structure. How can we access the member of a structure? Say, for example, there is a variable like name. So we can say overall name of the structure is, say, student. All right? And inside student, we have got name, role number, et cetera. Now, I can. So my variable is say, all right, let me say I have defined like this struct student. Then all these. Then the variables are a one, a two, a three. I'm sure you are getting confused a little bit. So let's define it in the proper way as we had done in the last class. Suppose I define struct student care name, ten int role number. All right. Suppose only two fields are there. And I also say that the variable is variables are x one comma, x two. These are two variables of the type of this structure, whose name is student. So what is my variable name? X one. So here I can say x one, x one dot. This is a dot operator which tells about the member. Now, which member? Say, I want to get the role number. X one dot. Role number. Assign seven, 20. All right, so this is how I can get access to a particular member of a particular structure. So I can also similarly write x two dot name, because the member's name is name, right. Name. Three is j. All right, because name has got a ten field character. Okay. I could have written x two dot name, and I could have assigned a string to this. All these are possible. So if this is clear, then we go ahead a little bit. Where variable refers. This variable is referring to is referring to the name of a structure, structure type variable. And member is the referring to the field or the particular member element. Okay. The examples are a one name, a one role number, a three dot, date of birth, et cetera. So now here, let's take the old example that we had seen. That's a complex number, and how we can perform complex number addition. Now, just to refresh your mind, say I have got two complex numbers, x and y, and I want to perform x plus y. Suppose x is a plus ib and y is m plus in. Then x plus y is the real parts are added separately. So it is a plus m plus I. Then the imaginary parts are added separately, b plus n. That we know from our school level knowledge. Now, how can I perform this addition using the concept of a structure? So here you see, in the program, we define a structure called complex. And there are three variables, a, b, and c of this structure. Type of type, complex. All right, now, what are there that components are? One is float. Sorry, I'm sorry. One is real, real part. Another is. I should rename this. This is actually the imaginary part. Okay. It's renamed in this way here in this program. It would have been better if I had written float, real part, float imaginary part. However, now scanf I am reading the two numbers. A is a variable, a's real part is being read, and a's complex part is being read. Note the format statements, because both of them are float. We are putting percentage f. All right. And so I read a. So you see, normally I would have just done scan f, amperous and a. But here I have to do separately. I have to read the real part and the imaginary part. Then the sum is being stored in c. So c is real will be. C is the sum. So its real will be, sorry. Its real part will be the real part of a, plus the real part of b. And the imaginary part, or as it is written here, complex part is the complex part of imaginary part of a, plus the imaginary part of b. Then I am printing. Look at how I am printing it. Printing percentage f, the real part of c, and plus then I put j and then the complex part of c. So what is being done is suppose I've got two numbers, 3.4 plus here I'm using j. I usually use I, I or j, whatever you do. So you write 7.2. That is a. A's real part is this. And b's real part is say 4.6 plus j. 3.8. Now, if I add them, c will be these real parts are being added. So it is 8.0 plus the imaginary part is added. That is eleven. J. Eleven. All right. So what will be printed is eight plus j. Then the complex part, 7.0. So I think this is clear to you. This is not very difficult to understand. Let's move ahead. So you have seen here, if you note here, you have got the structure definition specified. And here are the very variable definitions. And here we are doing the reading and adding them part by part. How am I accessing the members? I'm accessing the members using this dot operator. And whenever I'm reading the member, I'm actually reading the members. I'm not reading the structure as a whole. Now, one thing to note is when I am declaring this structure inside the main, then the scope of these variables, real and complex, et cetera, or this structure as such is its scope, is within the main. So if a structure is defined within a function, then as we exit that function, the life of that particular structure will end at that point. Now, there are some things which we can do in a much more simpler way. You remember that in the case of arrays, we could not compare arrays together. That array, a one is equal to a two, that was not possible. If we had to compare them array, I had to check them element by element. On the other hand, in the case of a structure, a structure variable can be directly assigned to another structure variable of the same type. For example here, if a is a structure, then I can assign another structure, b, to it directly. So all the elements, if they're of course of the same type. So here is one structure. Here is another structure. Now, if I do this operation, that means assignment, then this will be copied here, this will be copied here, this will be copied here, this will be copied here. All right? But if a and b were arrays, in that case, that would not have been possible. That a is an array and b is an array. So the elements, just by assigning a, assign b, I could not assign b elements to a. That's not allowed in the case of an alley. However, that's possible in the case of a structure. Secondly, now here, one important thing is that they must be of the same type, all right? Otherwise, of course, the members and the fields will not match. So a one assigned a two, I can do. All the individual members get assigned two structure variables cannot be compared for equality or inequality. Now this is important. That two structure variables, I cannot compare them. That structure a one, whether that is equal to a two, that will have to do. Compare. I mean, what I said just a couple of minutes back was inadvertent. That's wrong. Structures we cannot compare, we can assign in a shot, but comparison of structures we cannot do as a whole. All right, two structure variables cannot be compared for equality or inequality. Now for that, what we have to do, we can write a simple function, say I can write and you can take it as an assignment that we can write struct comp, struct cmp, where you will take two structures as input and we'll compare them. And how do you compare them? You will do, say, variable a, one dot member one equals to whether, if it is equal to variable a, two dot member one. In that way, if you do, then it's possible. So what we can do here is I have got two structures and there are two variables of the same type, of the same structure type. One is a one and one is a two. And I have got some values here. All right? And say this is member one, member two, member three, member four. Like that. Now, in order to compare, if I want to compare them, what I have to do, I'll have to see if this is a one, a one dot m one is, this is also m one is equal to a two dot m one, and a one dot m two is equal to a two dot m two, and so on and so forth. If I do then return one, that could be my function. That means if all these are matching, then only I'll say that they have been compared to be the same. Otherwise it will return false. So here, other else return false. So you have to write it nicely. You can take it up as an assignment. Arrays of structures. Now, once we know this, we can now make an array of structure. Why is that useful? Let's take one problem. Let's say that I am trying to store the information of a class of students where maybe there are say 40 students and their information about each student has got different components. Name in a particular class, role number and say marks, total marks. So marks is an integer. Let me say role number is also an integer. And name is a character array, something. All right, now that, so this box, this can be also depicted as a box having three fields, name, role number and marks. But I want to have that for all the 40 students. So I'll have 40 such small boxes, each having three fields, one after another. So that can be represented as an array. You know that in an array we can store data of only the same type. So that is not causing any problem here, because each of these boxes are of the type struct students. Therefore, I can very well consider them to be an array of such structures. So if I call this class is this array, then each of these boxes are an element of that array. So if I say class zero, which element am I looking at? This element, right. If I take class zero, dot name, then which field am I looking at? This particular field. If I write class two, dot, role number, which field am I looking at? Class two. So it's an array. Zero, one, two. You know that just in c, any array starts with zero. So zero, one, two. I come over here and which field am I looking at? Roll number. Role number is the second field. In that way, I can access each element of this array either as a structure or as an individual member of that structure. All right, so in such cases, or the same thing could be applicable if I want to represent a library. So in that case, what will happen? A library will consist of books, right? So suppose, suppose it's a small library where I have got a library of 20 books. All right, 20 books. So books is an array of type. What, let me name it different way. So I am saying my library is consisting of 20 books at most. And what is the type of library? When we write any array, we write int a 20, float a 20 like that. So here, what is the type of library? Type of library will be struct book. So, because every element of this library, when I write int a 20, that means I am talking of an array where there are 20 elements and each element is of type int. So when I am talking of this struct book, library, 20, what will that mean? That will mean that here is an array library having 20 such field, 20 such positions, elements. And each element is a structure called book. I have not defined here the structure of book. So I should have done it earlier. Suppose I do here struct book care, name ten, semicolon. That is the name of the book. Care author, ten. The author of the book, int isbn. And I close that. Suppose this is a structure of the book having three fields only it could have been more fields, number of pages, year of publication, et cetera. I'm not showing that. So each of these elements have got three fields here. Name, which is itself an array of ten characters, author, which is itself an array of ten characters and an integer ISBN number. So this is the whole element, the first or one element of the array, library. And library is an array which houses 20 at the most, such individual structures. So if I say library, three, isbn, where am I going? Which one? I am referring to? 0123, library three. And the last element of that, this is the ISBN number because that's the last one. All right? So therefore, using structure allows us to store different types of data together. And again, array of structure is a very powerful facility that has been given to us using which we can store many more things and we get much more flexibility. Let's go here. Once a structure has been defined, like the structure book that was defined, we can declare an array of structures, for example, struct student class 50. So note here that class is an array having 50 elements. So it's something like this here is class with 50 elements, zero to 49. And what is each element? Each of these elements is a structure of type student must have been defined somewhere earlier. Okay. The individual members can be accessed by class, whichever element I want to have, say, for example, struct student. One field is intro number. There's a name, there's marks and character. So this is the student, and I have got three variables, a one, a two, a three. The array element within the structure. And I have defined an array earlier. That is a class of 50, right? So now I've got an array of which every element is a structure like this. And the structures are variables, a one. These are also the student variables. Also, my class is consisting of the same structure. The array element within the structure can be accessed as now, you can very easily guess if a one dot marks two. Now here, this example is telling us something more. Here, this example is showing that any element of a member of this structure student can also be an array that we had defined earlier. This is also an array. Now suppose I have got this student, a one. His name is a role. Number is, say, one. And marks is itself an array where the marks of literature, history, geography, math, science, everything is stored and the date of birth is a character array. All right. Now, so it is say, 0707-2007 so that's a character array. Now, when I am saying a one marks two, that means I am going to this field is the marks field. I am going to the a one structure, a one variable. And I'm taking its structure and coming to the marks field or membership member. And I am coming to the element zero, one, two. This particular element, this particular element I am coming to by this. This you must understand, okay? So I can have an array within a structure. Also, I can have an array of structure. Till now, what we are discussing was what we discussed was an array of structure, right? And here, what we have just now shown you is what we have just now shown you is an example of that. An array can also be a part of a structure. Next lecture, we'll be talking about a new thing that is, that's also very important. Typedef. That is very much useful for. That facilitates us to create new type definitions. And we can write much simpler programs with this. We'll take it up in the next lecture.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Structure with typedef.mp3,"We were discussing about structures, and in particular, we have discussed about the way the structure is formed. And in that context, we have seen that a structure can contain within itself. Some members can be themselves a structure, right? For example, this one member, which can itself be a structure consisting of other members, this is possible, right? So this is a structure struct s, in which there is another struct, say p, which is a member of this, it's possible. Also, some member can be an array. This can be, say, name ten care. That means it's a character array of name ten. Similarly, it could be some member can be int marks 20, like that. It can happen now. So we have seen that we can have arrays within structure. Also, in the last lecture we have talked about arrays of structure. So there is a scope of confusion between these two. That's why I want to make it clearer that there can be an array within a structure as a member, all right? And the other thing is, we can have array of structure, you. So in this case, we have got an array. Every element of that array is a structure of a particular type, right? We know that an array can hold data elements of the same type. So if I have one particular structure defined like, say, student, and it can be an array of students, so there will be, each of them is of the type student, okay? And we have also seen, so these two must be differentiated very clearly. All right? So as you can see that here a structure member can be an array. We saw it in the last class, last lecture, that say, for example, a structure student has got an array care character array name 30. All right? These are part of an array. Now that we know arrays within structure, we have also seen arrays of structure where we can have a number of elements of that particular structure here. So here we have seen that we have got an array class. The array is class, which can hold up to 50 elements. And each element of this class is a structure of type student. So individual members, when I come to say class I, then I am actually accessing a structure, a particular structure in that array. So a particular structure in that array. Now that structure has got number of fields. Therefore, if I have class I dot name, then I'll get a particular name, okay? If that be the field. Or I can say class two dot role number. So here I think this distinction must be very clear that this is an array of structures and we can handle them. Just as here, the index is pointing to the particular element and then by the dot operator, we are going inside that element and looking at that array whereas in the case of an array within a structure, we look at that in a different way. That is, if there be, and then I come to the structure student and suppose there is a variable of variable of name, say a one, as of type student, then I can say a one dot, say name, and I can take a particular character of that. So look at the difference of this. This is one. The other one was class I dot maybe name j. So here I am accessing the particular element from that structure, and here I am coming to the structure and going to that array element within that structure. So this is unusual point of confusion among many students. That's why I was repeating this. Next we will start looking at an important aspect, an important style of writing programs, which is typedef that facilitates our programming with structure. As the name type diff implies, we are defining some type. We know that int is a type, float is a type, data type, care is a type, et cetera. Now, I can also define my own type that I'll be using in my program using this typedef statement typedef command. So we may define a structure, a structured data type, using a typedef command like this. Let's see syntax. The syntax is I say typedef struct member variable, one member variable, two member variable n, and then some tag. Tag is the name of the new data type. Let me illustrate this, differentiating this with the earlier thing. Say earlier we had written something like this struct student then cares name ten int role number like this. So I was defining a structure in this way, and I was later on referring to this structure as struct student, say student one, student two in this way. All right, now what I am trying to do here is I am trying to define a type. Suppose I don't write this, what I am doing instead I am saying type def struct, same thing, care, name ten int role number, and name this type as student. If I do this, then next time when I write this, student, declare this student one and student two, I'll do it in a different way. I can do it much simply as I am writing now in the red. If I just simply write, look inside this red box. If I write student, student one, comma, student two, that is sufficient. Just as compared this with the way we had declared int x, float y. So here int and float were some types. Now here, student one, student two are two variables of type student. Now, this type is not a called type. It is not predefined in c, therefore, but I can use it because I have already using this type diff statement has defined this structure as student. But please differentiate between this and the normal definition of student as we do normally as say struct something. And then I say student. Now this is here. Is it clear? I say struct. We have seen this and I write the members here and then define that structure as the type student. Now this is a definition once for all a particular structure as student. Now this, if I have to use it, then I have to say struct student followed by a one, a two student, one student, two, whatever. But in this case if I do this type dev, I am saved from this problem. So let's have a little look at how we'll go about it. So that is the tag. So here typedef a particular structure, just as here could be care name or int role, just like that. Note that there's semicolon at the end of all these declarations, and ultimately I name this tag semi, save for example here as student. So tag is the name of the new data type. So given that here is an example, again the example of complex number. So we are defining a type called complex. Ignore this underscore here. So typedef something having real part and an imaginary part is known as the data type complex. And then I am saying complex abc, just like intc flow tabc. I can write complex abc because complex has already been defined here because complex has already been defined. So I think this is clear. Right? Next we move to how do we initialize a structure? We saw that we can initialize an array. Similarly, we can initialize a structure as well, say a structure. Variables may be initialized following similar rules. Like an array, the values are provided within the second braces separated by commas. For example, here complex a complex a a is a complex variable 1.0 comma 2.0. What does it imply? It implies that it is a is a structure having two fields and one field is 1.0. Another is 2.0. Similarly, b is another field which is initialized to -3.0 and 4.0, just as we did it. In the case of arrays, we do it for individual structural variables, but we have to put all the values, initial values for all the fields of the array. So this is what happened by this initialization. The other thing, that last thing that we'll be talking about, is parameter passing in a function. How do we pass a structure as a parameter to a function? We have seen how arrays can be passed. Similarly, how can we pass structures to a function like any other variable, just like any other variable, we can pass it. Like for example here you can see that there is a swap between complex variable a and complex variable b. Now a and e are both structures. So I'm just saying, just as we used to write, say void, swap int a int b, just like that. Here I write complex a, complex b, okay, it's also a call by value now. So here is again the typical assignment and the way we carry it out. So here is an example program using typedev. What is being done here is I am defining a type complex typedef struct. There are two parts, real and imaginary. And this data type is known as complex. Now, I am writing a function. Swap them. So I am taking another, I have taken another variable which is of type complex. Temp is of type complex. So when I do assign a to temp, then this temp variable which is of type complex will get, will copy the variables. Say here it was 3.0 and minus two. So this will come here, it will become 3.0 and this will become minus two. So that is temp. Now I copy a to b. So here, sorry, b to a. I'm sorry, not this one. There was some b, and the values of b are copied to a, not here. These are copied here and here. So might be this is changed to five. This is changed to two point -2.5 and then I copy again b to temp, temp to b. So this is again copied back. So member by member the copying is done. Okay, so here we illustrate what we mean by typedef and a function that is using it. So now suppose how can we print a structure print? I am now printing the comp, say here's a function. The main function is calling print x and pin to I. The main function is calling print x and pin to I. So say, for example, my main function is initializing. Now you understand all these things. X to four, x, real part to four, imaginary part to five, right. And y is real part to ten and imaginary part to 15. So now I am calling print x. So it is calling print x. So x is being copied call by value to another local variable a, which is local to this function. Print. So a is holding the complex variable x and printf a dot real, a dot imaginary. So field by field I print them. Then I come back, I print y. Y is copied to a and the same thing happens. Then I call swap. Now, swap was a function that we just now saw where we take temp and we copy it to temp. And then I copy b to a and then temp to a. In that way we carry out the swapping so it is purely call by value. And then I print x and print y after I swap. What will happen in this case? If I go back to this case where I am passing on this a and b, the x and y are being swapped inside that function. But will that be swapped in actuality? You check that yourself. How do we return a structure from a function? Suppose I have done something, but in this earlier case x and y were being swapped inside the function. But when I come back to the main, my xy remains the same. So if we want to return the function, for example, here I carry out a real plus b real. I make it temp. Say here is an example of adding two complex numbers here, complex a and complex b are two variables which have been passed on as parameter here. And I have got a temp as a local function local variable. So temp real is copying a dot real plus b real. So what is happening here I have got structure a with a real part and an imaginary part. So 3.04.2. Another is b, which is 2.5 and maybe 3.6. Now when I am adding two complex numbers, you remember we discussed it in last class. Also, I first add these two. So a real is added to bdl. So I am getting in temp. This is temp where I am getting 5.5 and then imaginary I am getting 7.8. And now I return temp. Now in the main function, if I had written something like, say, x and y were two complex variables, and what I did, I said add x y assigned to some other complex variable z. In that case, that temp, this temp will be assigned to this complex variable z. That's how we can return a structure from a function. So structure facilitates in many ways in this. So direct arithmetic operations are not possible with structure variables. That means I cannot just add a and b when both of them are structures. I have to do the arithmetic operations over its members. Okay, so with that we conclude our discussion on structures and structure is you'll be given assignments on structures, and this will enable you to write different types of, handle different types of data types together. And using the type def you can design your own complex data type which you can utilize further. So please practice using structures. It's not at all difficult. Only a little practice and a little understanding is required. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Structure.mp3,"Earlier we had talked about storage of data in arrays. Now, what we found, what we mentioned in the case of arrays is that in an array we can store data only of a particular type, particular, say an array of integers, or an array of floats, or an array of characters. But we could not mix different types in the same array. For example, we had faced the problem of representing the students database, where we will have the students name as well as the students marks. So we needed something like this. Actually, that is what was desired, that we'll have the names here, and names will be nothing but an array of characters. So here will be some names, ABC and here will be the marks. 56 a. Now, this representation requires two arrays. One is representing the names as one array and representing marks as another array. Now, however, as the diagram is showing here, we are trying to represent them in a unified structure, in the same structure. But that is not possible in the case of an array. Here we have got two different data types. This an array of characters, and this is an integer. All right. For example, similarly, we can see that if I had stored something that, say, for example, I want to store a graph, a graph where at every .123 seconds, for example, this is time in second, and here I am measuring the temperature. And if I have a graph which is something like this, I cannot say that at every point the temperature will also be an integer. Therefore, if I had tried. So suppose here at point number two the temperature is 50.34, at point number three the temperature can be 70.2. So if I had tried to represent that in the form of a 2d array, in that case it was not possible because a 2d array is also an array and therefore is of only one type. We have to declare a 2d array as an array of integer or as an array of characters or array of float. So I cannot represent that in a 2d array where one side, say, for example, one will be that one column will be temperature and another column will be the time, time and temperature. So that was not possible to be done in a two dimensional array because time, while time will be an integer, one, two, three, temperatures can be something different, 50.670.3, et cetera. So an array is not possible. So our question is then, what is the type of data structure? What is the type of arrangement by which I can represent data of different types together? And the answer to that is what we'll be looking at today. That is, structure. Structures in C allows us to represent a combination of different data types. For example, let me give an example of a structure. Say I want to define student data. And student data will consist of the student name, say the department of the student, role number of the student, maybe the CGP of the student, grade point average of the student, et cetera. Now, let us look at, if I want to store them together as a common piece, a student data, then this entire thing, the student data, has got components of different data types. For example, what will be student name, student name, say, for example, amit will be either a string or an array of character department. Somebody can say mechanical engineering, that can also be a character character string, whereas role number 748 will be an integer and CGPA, say 7.8, will be a floating point number. So what we can see that in order to store the student data, we have to have a mixture of different data types. So a structure allows us to do exactly this, where I can consider this student data as a structure. So let me redraw it in a different way. So I draw a box now which is representing the student data. I name it std data. And I have got different fields in this one field. And each field has got some identification. So this field is storing the name. And this field is basically a character array, a type of type character array. So another field is name is department, and its type is also character array, another field. Remember that every time I am using the term field, field of student data. So name department. What else did we have? Role number, which will be of type integer and CGPA, which will be float. Suppose there is no other field. All right, so we call this entire box to be a structure. This is a structure. And what is contained in this structure? There are four fields that define the structure. The four fields are name, department, role number, and CGPA. These four fields are defining a structure. Now, c allows us to define structures of this type, and we'll learn how we can define such things. And let's go ahead a little bit. What is a structure? It's a convenient tool for handling a group of logically related data items. Here, of course, the logically related data items were the different information fields or information component that are related to a particular student. So till now, we saw very simple data structures like array. Now, here, for example, I have got related components, student name, role number and marks, or CgpA, or for example, a real part and complex imaginary part of a complex number. For example, if I had tried this, say, for example, all of you know that a complex number is stored as a plus ib, right? That's a complex number having. So this is x, where x is a complex number, a plus ib. So maybe x is equal to four plus I, three. All of you are aware of that. Now, how do I represent, I know how I can represent an integer. I know how I can represent a floating point number. But now the question is how I can represent such a complex number. Now, obviously, I can immediately think of that. Well, let me have a structure like this, which will have two fields. One is the real part. This is a real part. So I call it the real part. Another part is the imaginary part. And I can store this number simply as four, three. So the imaginary part is three, and the real part is four. So the complex number, instead of being an integer or a float, is essentially a structure. All right, this is another very common and easy use of structures that you can see. So whenever I refer to this variable x, which is of type complex, I'll be referring to this structure. And not neither at four or nor at three, I'll be looking at this whole thing. Okay, so, so it helps us in organizing a complex data in a much more meaningful way. The individual structure elements that I was talking of, which I was mentioning as fields, is also known as members. Now, you will find other names to structures also. So, structures are sometimes called records. And each of these horizontal boxes that we are drawing were fields of that record. Or in terms of, when we refer to it as structure, we call each of those smaller boxes as members of that structure. Okay, so the composition of a structure can be defined as follows. Say a structure. I can put a tag. Now, this is very important. What is the tag that I am putting over here? Say, for example, earlier I was talking of student data. So my tag could be std data as I had written. So I'll have to write struct, std data. And inside that I have got several members. And what were my members? My member was name. My member was role number, department role number, and CGPA. So I had four members of this. Now, each of these were of different types. That is something which is very important to understand. So struct is the required keyword. I must write this word struct so that I can really show that it is what this tag is. Just the name is the name of the structure, like std data. So that is a structure, just as we had done for other variables, we had done, say, int, x, float, y, et cetera. So here also, instead of int or float, I have to say struct. And what the struct is that is defined. So first of all, I have to define the structure, int, and float are defined by default. Any C compiler will understand what int or float is. But if I write struct, then by default the compiler will not understand what the structure is because there can be different structure. One structure for student names, one structure for book details. If I had thought of book detail, I want to store that in a structure. What will the components be? What will the members be? Can you just think of. The members will be, of course, the title of the book, the author of the book, the publisher, year of publication, the ISBN number, etc. So therefore each of these members will again be of different types. So it will be a heterogeneous organization, just as it was with the student data. So we have to write, if I want to define books, for example, I would have to write struct book followed by the definition of the members. So this is equivalent to as if I am drawing a structure and its name is becoming book, and I am defining what are the members of this structure. All right, let's move a little ahead. So member one, member two, et cetera, are individual member declarations. We'll see more examples of this. The individual members can be of different types, and that is the beauty of structure. The individual members can be ordinarily variables, pointers, arrays, or other structures. It can even be other structure. That is very important. It can be some variable. All right, just as name, or it can be an array, say name was a character array, or it can even be a structure. That means I can have a structure within a structure. So it's possible that I'll have something like this, that I have got a structure. One field of the structure is a character array. Another field of the structure can be an integer variable, or another field of the structure can be a structure itself. It can be another structure where there are more members inside. Okay, that's also possible. Okay. So that is the beauty and the flexibility that we get from structures. So the member names within a particular structure must be distinct from one another. We cannot put the same name to two different structures. Once a structure has been defined, individual structure type variables can be declared as we'll see, struct tag, variable, one variable, two variable, n. I think it will be much more clearer if we go through an example. Let's look at this example. A structured definition. First, I start with a structured definition, struct student. And then I put just two parentheses to show that there will be some members defined inside. Now, how do I define the members? I say that name, one member is name, which is an array of character. All right, the next one is role number, which is an integer. So role number is a variable. As I said, that a structure can field, can be variable, or can be array, or can be another structure. So here is an example where you have an array and a variable of type int. Again, total marks can be integer. Date of birth can be character. And the sizes. So date of birth is again of type array, character array, because the date of birth can be, say, ten Jan, et cetera, 2010. So like that, it can be a character array. So this is how a structure is defined. All right, now I am now defining the variables. I have defined the structures here. So I know once the compiler reads this and finds that, well, I have got some character, some definition of some variable called student, I know that that's a structure. And what is the constituent of that structure? This is these fields. Now, this is just a type. Just as we had int, float, et cetera, or care, those were data types. Now, I'm saying that I have got a structure of type this where there are four fields, but the data has not yet been put. This is very important. There are four fields. One field is name. And I say that is an array of 30 characters. And there is a role number, role, which is an int. Total marks is an integer and date of birth is an array. But you see that there is no data already put inside this array. Now we have to name variables. A one, a two, a three are variables of type. Student structure. And what is that? Student structure. This is a structure. So a one will just be a copy of this structure and a one, a variable a 1 may have, if I take this, may have some name like amit here. All right, role number may be 560 and total maybe 700. And date of birth can be something that is one particular instance of this particular structure. This particular structure that has been defined. This part must be very clear to all of you. So I have defined three variables, a one, a two, and a three, each of type. Type. What type? Structured student. So, type is struct student. We have got these fields as its constituents. Okay? So struct student tells us a new data type. And these are the variables of the data type. So it's also possible to write it in a much more compact form, like, say, struct tag. And then, so I write struct student and I declare care name. 40 int. Role. Role int, total marks, care, date of birth, ten. Okay? And then I could have put the variables, a one, a two, a three inside this. Note that here the semicolon is coming here, that is, that's the end of the definition. So here I have done it in a much more compact form compared to the earlier one. In this form, of course, this tag is optional. So what I mean is, say I define, once again, give an example to you, say a complex number. I can write it as struct complex, and members are int need not be always integers, because if I want to store data of type, say data of type 4.5 plus I 7.2, then I want to make float real, float imaginary, all right? And that is the end of the structure. And I can say struct complex x one, comma x two. This is one way of representing structure. What does it mean that I have first defined the structure called complex, which will have these two components, and then I define that x one and x two are two variables of type this complex. Or I could have written it also. Now, if I do it in this way, I have got an advantage that later on I can also, once I define it, I can define some other variables also. Y one, y two over here. Or I can also define it as struct float real part. Let me, in order to that you don't face confusion, let's write real part, float imaginary part, and then I can say x one, comma x two. Note that here I have not written the thing complex. I have not written that I could have written. It would not have affected me in any adverse way. But it's not necessary to write it over here. So if I write this, how will the compiler interpret it always, you should think, when the compiler looks at it, what will it think? What will it possibly do? So the compiler is trying to understand, okay, now there is no ambiguity, because it knows that x one and x two are two variables of type structure. And the structure is defined here itself. I need not give any name, but the advantage of giving a name is, say I give the name complex here. Here I have defined x one and x two. Later on, also say, for example, if I had done in this way, I could have, later on down the line in this program, I could have written struct complex, say y one, z one. It's possible, because I have already defined struct complex. Okay, so there is a choice over here which you can think of. Let's go ahead a little bit. So in this case the tag is optional. So here is an example. We'll conclude this lecture with this example. Substruct student character name 30 int role number int total marks character date of birth ten a one a two, a three. That means a one, a two, and a three are three students. Student information. Three pieces of student information. Or I could have done it in the way. I have just now shown the same thing without giving any tag over here. These are equivalent. Okay, now, next lecture will talk about how do we process a structure? Okay, that will come in the next lecture.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Substitution of .mp3,"We have discussed about passing arrays as parame meters and for passing arrays as parameters. In c to c functions we take recourse to call by reference. Otherwise, for all other parameter passing, we take recourse to call by value. And just to summarize the call by value and call by reference the references in call by value, do we copy the value of the actual parameter to the formal parameter formal argument, and in call by reference we do not copy the value, but we just pass on the address or the pointer and reference to the actual parameter. Okay, so as a result, what happens that if any change to that variable is resulted in the function itself? In the case of call by value, that will not be automatically reflected to the main program, but in the case of call by reference, since there is no other separate copy, that will automatically be reflected. Just to conclude that part, we'll see a number of applications of functions. Just to conclude that, let's have a quick look at one function. There is no array, but just vision of the prototypes that you can see here. Finding the maximum of three integers. So we have the header file here include stdio h. Then here we declared a function prototype. The actual function maximum has been written later. So here you see that, what does this line tell us? This line tells us that maximum is a function and it consists of three integer arguments. Or three integer parameters will come so as if this is a function which has got three input doors and each door is wide enough to accommodate an integer. Okay, so that much is told. And whatever is inside this I am not aware of that. And at this stage I am not aware of that. And the output will also be another integer that is told by this. So here the salient point to see is that here it was sufficient to just specify the types no names have been put in. Now comes the main program that is very simple. Abc are three integers, so they are local to this function. Enter the integers Abc are entered here. So you know what a is, what b is, and what c is. And then you are calling inside. See here inside the printf I can call maximum with the parameters abc. And we come here. And here I have defined here I did not name here I did not name the variables. Here I have defined the names of the variables intex into y in z. So this X-Y-Z. Again property of this maximum. All right, so X-Y-Z here. And the algorithm of the logic is simple. Initially I make max to be x. If y is greater than max, then y is the max, otherwise z is the max, and then I'm returning max. I'm returning max means I am coming here and then that max is being printed and return zero. Now my main function, where is my main? Main is here main has got a type int, so I am returning zero. So int will. If at the end of the main function a zero is returned, I'll assume that the program has successfully completed. Okay, the reason I brought up this example is just to illustrate this case that you need not at the prototype level, you can escape specifying the parameters. So here's the prototype declaration function calling and function definition. You know that, so these are already repeated. I am not going into that. So instead I'll be talking about a new thing here that is hash include. We have talked about hash include. We have used hash include, and we mentioned that hash include is nothing but a preprocessor statement. A preprocessor statement, how say hash include file name. We have seen hash include stdio h, but it can be for that matter any file name. Hash include file name say for example, I can specify the full path say usr in a linux environment home rajanmyfile h I want to include this file. I want to include this file in my what is happening? This file in my program. All right, the content of the corresponding file will be included in the present file before compilation is done, before compilation is done, and the compiler will compile thereafter, considering the content as it is. So it is a preprocessor statement. That is, I put that inside that hash include, that file is included, and then the compilation is done. Okay, now let's look at this hash include example, look at this program segment which is my source program, which is known as Proc C. So this is my source program. This source program has got hash include no stdio h, but it has just said that in hash include myfile h, and then the main program follows. Okay, now this myfile h is nothing but another file which has got hash include stdio h and index. So when I include myfile h, then this particular file will be included. This particular file, that is, this segment will be included here. So consequently, what will happen is when I say in general hash include filename h, it includes the file name file filename h from a specific directory which is known as the include directory. When I say hash include, it takes from the include directory, and in the include directory I have kept myfile h. And consequently when that is included, ultimately the thing that looks like is it will look like this because that hash include I'm sorry, there should not be an inverted comma here, it should be just hash include stdio h followed by intex. So this whole thing whole thing has replaced myfile h. And where was myfile h? Myfile oh was under user USR include filename h. So that's how I can have other files included in my program. Now, another point of critical discussion is macro definition. We have seen the macros like hash define, so that is again a preprocessor directive. We have seen that hash include is a preprocessor command that means even before the compilation is done, that is copied there. On the other hand, you see the preprocessor directive of hash defined string one, string two. That means string one should be replaced by string two. So how does it happen? It replaces string one by string two whenever it occurs, wherever it occurs, wherever it occurs before compilation. So for example, hash defined PI to be 3.15. So wherever it will find this PI, wherever it will find this PI, it will replace that with 3.15. Okay, so here, for example, you see we have got hash include stdio h. Then we define PI to be 3.15 as the hash defined preprocessor command. Now, in my main program I have got float r four times four, r is four and area is another variable. Both are float. Now, area is PI times r times r. R is already initialized. So what will happen is this will be translated to this PI will be replaced. So the body will be float r assigned four and area and area is so r is four and area will be 3.15 times r times r. So even before compilation, this PI is being replaced by the value 3.15 as has been stated in the hash defined command. We can also give hash define with an argument. Till now we have seen hash define PI as a constant. Hash define some constant k to be five, or whatever. Here we can also define some functions. Like you see, hash defined square x is x times x. So wherever square x will appear, that will be replaced by x times x. Okay, say for example here, let's look at this program again. I think you are not being able to read this, so let me go back. Say, let me have, let, if I have, if I have declared say has defined square x is x times x, then in my program, wherever I'll get, say, p is assigned square y. So this will be translated as p assigned y times y. Okay, so this what should be done that has already been told here that square x is this. So this will simply replace it. Okay, so that is the purpose of hash defined here we can see that. Sorry. And so let's look at this example again. Main y is five, printf value is y times y. That means this is what has been generated after the square x has been square. Here it was square x plus three. So that has become y times y plus three. Now, which one is faster to execute? You can think of if I write square x, written as a macro definition, then I am pasting, as if I'm pasting the body of the code inside this, in the main program. Replacing that. So I don't need to call any function. I can write it as a macro definition. And as a result, even before compilation, even before compilation, I can get this look. And so this can be straightaway applied without requiring to call a function. Now, if square x is written as an ordinary function, not like a macro definition, in that case, I have to call a function. And calling a function has got some overheads, which I'm not discussing here. So if it be a very simple thing like this, it's better to make it a macro so that it automatically gets pasted and it becomes faster. However, there is a word of caution. For example, if I had defined square x. Now when I am defining as a macro, I have to ensure that it is correct. Therefore, if I define square x as x times x, now how the macro definition substitution will be carried out. Let's look at this. If there be something like r assigned square of a plus square of 30, so it will be a times a plus 30 times 30, that's how it will happen. Okay, now what about r square of a plus b? It will be simply pasted as a plus b times a plus b. Consequently, the result will be wrong, because during execution, b times a will be done first, and then that will be added with a and with b. So this is not what I intended. Therefore, if I had done this, defined this as like this and like this, this problem would not have occurred. So unless I do that, this a plus b should, will not be. I need to take, if I define it like this, then it becomes this, which is the correct one. But unless I do that, it will lead to a wrong result. Okay? So you must be very careful about it. This is wrong and the macro definition should have been written. As I have shown, square x is x times x. In that case, we would have got the correct result. Now, before moving to anything else, we will now look at some applications of what we have learned. We are now at a position where we have learned all the fundamental tools without the sophistications that are required to write a program. Okay, so suppose I want to solve a problem like this, that I have got five students in the class, and the five students have got five names, of course, and each of them have got some marks, total marks. Right? Now, how do I represent that? And I want to find out which student, I want to print the name of the student who has got the highest marks. All right, is the problem clear? Let me repeat the problem. I have got five students in a class, and I want to find out which student has got the highest marks, and I want to know the name of that student. Okay, how can I solve this problem? This is a simple problem here. What I'll need is first I'll need an array of the names of the students. So first I need an array of the names of the students. So here, five names will be stored, very, very disproportionate array. And let me call this array to be name or names. And on this side I have got another array which holds the marks of the different students corresponding to the role number, maybe 12345. The marks are stored here, somebody got 50, somebody got 55, somebody got 62, somebody 70, somebody 32, same. And their names are ABC, LMPQ, x and Y. Suppose these are names. These are different names. Now, why do I need two arrays? This is the array called marks. Why do I need two arrays? First of all, the arrays should be holding same type of data. So what is the type of data that the array names is holding? It is an array of character or character string. Now, how can I represent these names? I can represent them as an array of strings. Or each of these names is what? Each of these names is a character array. Therefore, if I just look at names, names will look like a two dimensional array. Now, what would be my algorithm? First of all, I'll come to the representation later. What would be my algorithm? First of all, I'll have to go to this marks array, which is simpler. It's an array of integers. Assuming all integer marks are given. Then I'll have to carry out, find out the maximum of this, and you can write a function to find the maximum of an array. Right? So let's try to write the function first. So I've got an array, marks, which has got five elements. All right? So I can call a function max, let's first of all think of this maximum. What will it return me? Say it will find out. Say if I come to this, it will find out which one is the maximum and will return me an index, right? Oh, this is not the maximum. Sorry, this one is the maximum, so it will return me an index 0123. So it will return me an integer. Therefore I can start with like this, that int maximum of I can call an array integer, array int, suppose that is m this, and the main function will call it with marks. And inside this what will happen, you know, initially let me call a value int. This is a local max assigned m zero. So I initialize a variable max with m zero. Now for I assign some index I, so I have to declare I also here I assigned one I less than equal to five, less than equal to four, sorry, less than equal to four. I plus, plus here, if mi is greater than and max, then max is mi and that will go on. Now ultimately, what shall I return from this? Should I return the max? No, I am returning the value of I because where I found the maximum. So for that, now this I is changing. So here I'll also have to make say, so let me just make this I to be zero. Um, let me make this I to be initially I is zero. So I could have done away with this. And wherever I get this max, I'm changing this I wherever I am getting this max, I can say that there is another max index and I'm making max index equals I. So I'm remembering where I found the max and I'll be returning the max index. All right, so my maximum function in this way, what it will do is, sorry. It will find out the maximum, so it will return three. So the first thing is find max. Now I have got an array names. How is that represented? The representation can be as strings or it can be as an array of characters. If I consider this to be an array of characters, then remember that it's a two dimensional array, okay? And in that case I'll take so this three, and I'll come to this three, this and I'll print out this particular element from that array. Okay, so now what about these names? Let's see, names is an array, say PQR or something. So I can have this as an array of characters. So PQR, Lm, whatever it is. And this part is blank. So what is my declaration of names? Names will be, there are five names, five rows. And each row is a character. So it's a character array. Care names. Let me write it here. Care names, five rows. And each row may have three columns, right at best, like this, LMP, LMK, PQR, like that, say, now I have suppose come that maximum index was this rows. So that is three. Now how do I print this PQR name here? If it is kept as a string, I could have straight with percentage s format, but here, how do I do with this here I'll print which row. I'll print. I'm not writing the entire code. Okay, printf. Which row would I print? I'd print the names three, but there are three characters. So names three in a loop I have to print, right. So printf. So how would the printing be done? How do I print one row of an array, a two dimensional channel. So here I come. So I'll print in a loop. Names 303132. Okay, actually this is three should be somewhere here. It's confusing. Three should be somewhere here, say ABC. So three is actually this row. So names I'll be printing 303132. And that I can print in a for loop. So I leave it to you to try to print this in the character format. You can also try it in the string format. So what we have done here is we have seen how the macros are replaced, and we'll see further examples of functions all through in the future lectures where we'll be applying functions and arrays. Consequently,",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Switch Statement (Contd.) and Introduction to Loops.mp3,"So we are looking at a new construct that is switch and case. So here is another example. But this example has got many more things embedded in it. For example, in order to understand this, you have to understand two things that are being introduced here. One is gatecad. This is a construct. We have seen scanf, we have seen printf as input, output statements, right? But gatecad is also another statement, another function. Actually this is given by, since we have not considered function in detail, there's a built in library function or an operation. You can consider that to be an operation. Also that gatecare. And then there is a parenthesis as if we want to have some value here. It means get the character from the user. So where from does the user provide you the character? Whatever the user types that will be captured by this function. And this will get that particular character. That's why it is called get cap. All right, the other thing that we have here is another function, two upper, two upper. And then you can see that there is another parenthesis to upper. What it does is it converts any character variable to its upper. For example, if I type a as a character, say I have got a variable mycad. Now suppose I have declared Mycad to be a character type of variable, and somewhere here I assigned Mycad to be a. Then what does Mycare get? Mycare gets the ASCII value of small a, okay? Now if I say two upper mycare, then what it will do? It will take the ASCII value of small a and will return me the ASCII value of capital A, all right, to the upper A. So this one will be returned. So here you see two upper what? Not my cap, but what we have written, two upper, then get cat character. So what it means is that you will get the character from the keyboard. Suppose it is small a and then that will be converted to capital a. So it becomes capital a, and then that is being fed assigned to choice. Okay, let's look at it, because it gives us the opportunity to look at nesting of functions. Also there are two built in functions which are being used here to get the character and assign it to choice. All right? So you can also have another example. Similarly, we have got two lower get cat something, where if I had given capital a, it will be converted to small a, okay? And then I assign it to something else. Other things also I could do by suppose I get care, my care and my care is assigned a. Sorry, my care has been assigned a. Then I can say again, I can assign not my care say some other mycare. And suppose there was another variable. Mycare. One, two, upper mycare. Mycare. That was also possible. Of course, Mycare. One has to be also declared. That is not declared here. Okay, that was the first part of the thing. Now let's look at this. So we take a choice. So what is a choice? We are taking a choice. And what is a choice? Choice is a character that has been given. If the user gives a lowercase character, then suppose I want your choice between a multiple choice answer scenario. Type in the answer ABC so somebody can type cap a shift a or just a. All right, whatever you type internally, I'll convert it to capital. So through my two upper function. So now I take your choice. Now, based on the choice, I go on checking. Is it r? If so, print red and then break. It's not r. Then let's go and check whether it's green. G. If it is g, then print green and then print green. And for break, you will come and meet here. Okay, it's not green. Also not r, not green. I'll come to this point. Is it blue? Yes. Then I'll print blue. But suppose somebody has printed, typed in, gave the choice as y. All right, y. Then neither it is r nor it is g nor it is b. Then it will come to default and will print invalid choice here. Since that is the last statement and I'm closing the bracket immediately after that, I may not give the break statement here. I am free not to give the break statement here. Okay. Otherwise, now suppose let's look at this break statement. Suppose I do not give the break statement. Suppose this is not there and my choice is r. My choice is small r. So at this point, the small r will be converted to capital r by this statement. Right? By this. So my choice will be capital r. Now I go here and my system will find that it is r, so it will printf red. I'm sorry, why should I printf red? Will be worked on. Let me do it again. My choice was r that was converted to capital r and by this. And then I come to this point and I find that it is r. So my system prints red. Okay, red has been printed. Now, this break statement is not there. If the break statement is not there, then it will not go. To check this condition, it will simply print all these things. Okay, since it has followed this path, unless I force it to break, it will go on following this path. Okay, so I'll have green printed again, which is not what I desired. Right? So let's see ah, so now let's see here. Let's look at this flowchart, the switch statement. If the case is red, let's stick to the example that we're doing. Red. Then I print red, then break. If the break was not there, then I would be following this path again. I mean, this path would be followed. That's why this break is essential. We'll show the requirement of break in a moment. Okay, now let's look what the break statement is used for. The break statement is used to exit from a switch or terminate from a loop. We have just illustrated it for the switch statement. It can be also used for some other purpose. So the break statement causes, a break statement causes a transfer, causes a transfer of control out of the entire switch statement to the first statement following the switch statement. Okay, so I hope you have understood what is meant by the switch statement, how it can be used. We'll see that through a number of examples later we'll see with a number of examples. So we'll see that the break statement can be used for exiting from loop also. We'll see that. But what is a loop? Next we come to see repetition. Till now, what we have seen is branching. But now we are going to look at another important construct, which is repetition. Now, just for a moment, let's go back to our old friend example. That is finding the sum of n numbers. For example. Now, how did you do that? What was the flowchart? The flowchart was something like this. Read n. That is a number of numbers. All right. Then we make sum equals zero. I'm adding ten number, adding n numbers. Then read number. I'm giving a different variable name num. Then I'm adding that to its sum. Sum is assigned sum plus num. Then I'm decrementing n. Now, I look at is n zero? If yes, then I go and print sum. All right, so if there be three, then I first read one. Add it. So n actually shows how many numbers are yet to be added. So print sum, then stop. But if n is not zero, then what I'll do, I'll go and continue this path. This is another form of structure that we see that we have based on some decision. We have got some statement somewhere, and we are going back to that and repeatedly doing this. We are repeatedly doing this. This is known as loop. This is known as repetition or loop. All right. Unlike the earlier case of if, then where we look at the condition, and then we follow either this path or this path, both in the forward direction. Here we are also taking up the backward direction. So this is a very important concept. We'll need it at every step in our programming exercise. Now, there can be different types of loops. We'll discuss that later. But first, let's take, let's look at a counter. Okay? Now, there are three types of loops. Briefly, let me tell you. One is loop is something that is repeatedly executing. There can be counter control repetition where we know that we know beforehand how many times I must repeat. Okay, suppose I know that. Find the sum of n numbers, whatever that be. N. I know that this will have to be repeated n times. All right, n time. But there is another case where we actually go on repeating a particular set of sentences. We go on repeating that until a particular condition occurs. That means some value has become negative or something that say, for example, I am taking the sum, I am adding that, and the sum goes beyond 9999. And if it goes beyond that, I'll stop. That sort of situation is known as sentinel controlled or event controlled repetition. This will come later. But most importantly, we'll look at this counter control repetition where we know how many times we should loop. Okay, how many times we should loop. And for that we need a control variable. We'll see what that is. Okay, so counter control repetition requires name of a control variable or a loop counter. If you recall, when we added n numbers, what was my counter variable? What was my control variable? Or what was the loop counter? How many times will it do? N, the number of numbers. Right? So similarly, I can have another, some other variable. Say I, say I can just draw arbitrary flowchart for you. Say I is an integer initialized to zero. Then I come here, do something, and then I increment I. Let me use what we learned. I increment I, I plus, plus. Then I check I greater than ten. If it is yes. If it is no, sorry. If it is no, I'll again do that. If it is yes, I'll come out. All right, so I'm doing it as long as I is not greater than ten. So this here, what is my control variable? My control variable is I. Or this is a loop counter based on which how many times I'll be carrying it out is determined. Okay, now, we also had an initial value of the control variable. What was the initial value that I did? In this case, the initial value of I was zero. It was initialized to zero. If you have seen the condition that tests for the final value of the control variable, whether the loop should continue or not, what was my condition test in the earlier case it was I greater than ten. Is I greater than ten? If I is greater than ten, then I'll come out. Otherwise I'll go on continuing with the looping and another increment or decrement operation. Here I was zero, so I incremented it until it comes to ten or cos is ten. If you recall, in the earlier example there was n, so I had to read n numbers. After reading one number, I decremented n. So depending on what I want to do, I will have to increment or decrement the control variable. And based on this condition I'll come out. So here is an example. An initialization is done. You can see here a counter has been set to one. It's an integer counter that has been set to one, while counter is less than equal to ten. While this is a statement that you are getting as long as counter is less than equal to ten. So this is one new term you are learning. While counter is less than equal to ten, do this, printf the counter value and then increment the counter and then go on doing it. Now this really does not make any difference. If I had written counter plus plus, that'd be equivalent. Because this is a singleton here. There is no assignment or nothing addition with this value. So it's standing alone. It really does not mean me. Does not matter whether I make it counter plus plus or counter minus minus. So this one is. So here is the condition. Check. Counter is my control variable and increment on decrement operation. Now you are getting this while statement. And now let's try to find the simple english meaning of while we often write something like this, while it is raining, stay home. That means as long as it is raining, stay home. So this is the condition. Condition. As long as the condition is true, do this. Here you see, while the counter is less than ten, as long as this condition is true, do this. If this condition is false, then come here. Don't do this. Okay, that is the meaning or the semantics of while. So while is used for one of the methods by which we can achieve counter control. Repetition. Okay, now counter control this we have seen. So the while statement actually looks like this. While some condition the statements to repeat it can be one statement or it can be multiple statements as is shown here within this block. All right, this entire statement should be. This entire thing should be repeated. Example here. Suppose here is a weight loss program. I mean, as if you are being told to lose weight by following this. While weight is greater than equal to 65, while weight is greater than equal to 65. That means as long as your weight is greater than 65, then printf, go exercise. Okay. Then come back again. Enter your weight, and then read the weight. Now here there is a nice thing. Often we had encountered the scanf and printf independently. Now, look at this statement. Printf interior weight. Scanf, weight. What does this together mean? I have got my screen here. I have got my screen here. And a program is running and it just says, scanf percentage d and w. Say, wait, you don't see anything on the screen. But suppose somebody who is little more helpful to the user writes, printf, enter your weight. All right. Then here on the screen, it is printed, enter your weight. And then since backslash n is there, you are here now, scanf percentage d and w. Now here. Then when you type your weight, say, 65, then that is shown here. You know what data you are supposed to give. So this sort of thing makes it more interactive. All right. So here you see, these two have made the program more interactive. But what does the program do? It checks at every point. First, it checks the weight. If the weight is not greater than 65, it will simply come out here, because this condition is false. Otherwise, it will carry out all these statements, and then it will read the weight again. You see? Again, the weight has been read. And after the weight has been read, it is coming back here and checking it again whether the weight is greater than 65. If by one day's exercise, you have reduced your weight, then obviously you need not exercise more. You can come out. Otherwise you will have to again go and do this. So while is a very important statement, you should understand the meaning of this. And we'll try to do a couple of more exercises and examples on this. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Switch statement.mp3,"In the last lecture, we had discussed about two new operations that is post increment and pre increment. Here you can see that we are calling them as prefix operation because the operator is before the operand. Here you can see also the operator is before the operand. And what is the operator? Operator is incrementation, but that is being denoted as plus plus twice the addition operation or twice the subtraction operation. And in this here we are talking of, we are calling it to be post fixed operation. Here you can see that the operand is coming first and the operators are following. Right. So the operators are following that. So that's why this is known as post fix. Here also you can see the operand to be I, followed by the operator minus minus. Right. So that's why these are called postfix or prefix. The significance of this, as we discussed in the last class, is that a particular variable will be first incremented here. In this case, it will be first incremented and then used in the operation. Here it will be first decremented, then will be used in the operation, while here it will be. First the operation will be done, and then the decrementation will be done. Here. First the operation will be done, then the incrementation will be done. So we can. So that's what we have written here. First increment or decrement, and then use it in the evaluation. And here increment or decrement is done after being used in evaluation. So it will be clearer when we come with some examples. Here was the example that we had shown in the last class. E and m are two variables. M is initialized to one. And when I am saying plus plus m, that means first I increment m, so m will be here. You can see as soon as I do that m will become two, and then that is being assigned to t, so t becomes two. Whereas here you can see that m is one and we have done post increment. So first the assignment operation will be done. That means m was one. Sorry, m was two. Here. Here. After this, I'm doing this. So t will be one. So what will happen is m is one, so that m will be assigned to t, so t becomes one. And after that, m will be incremented. So ultimately m will be two, but t will be one. So if you look at these two, you'll find the difference between this. Okay, let's have a few more examples. Suppose we have got two variables, a and B, whose initial values are ten and 20. They are initialized to ten and 20. Okay, next we carry out. Look at this operation very carefully. It looks a little clumsy here. There are two operators. One is this one, another one is this one. So this is pre increment. So this is equivalent to x is assigned 50 plus, as if I have put a parenthesis, but that is not required. That first a will be incremented and then that will be added to 50. So what result do we expect? A was ten. A was ten. So first that will be incremented, so that will be eleven. And that will be added to 50. And so X will be. X will get the value, 61. All right. That's what will happen in this case. Okay, so a is eleven and x is 61 as we have shown. Now, let's take this again. This is post infament. So what do we expect here? Let's see what will happen in this case. First here, after the operation is done, then a will be incremented. So what will happen? X was 50. Sorry, I'm sorry. A was ten and I am adding 50 and ten. And a that means 50 plus ten, so that becomes 60. And that 60 is being assigned to x. Because the assignment operation is taking precedence over this post increment. So we get x to be 60. But my job is not yet clear. Because after a's participation in this operation, it will be incremented by one. So a was ten. Then a will be made incremented by one, so it will become eleven. So consequently, this is the result, what we will get. Okay, now let's see again here. What do we expect to happen? A is ten, as usual. A is ten and b is 20. What is being said here? A is post increment, but b is pre increment. Pre decrement. So first, b will be decremented, so b will become 19. Decrement means by one. So it will be decremented. It will be 19. It will be added to a, what was a ten. So these two will be added. And what is that? 29. And that 29 will go to x. So x will be 29. And then, my job is not yet clear, not yet over. So this will be incremented and a will be eleven. All right, so this is how the thing will happen. So the result that we get in this case will be b will be 19. Because b has been decremented. X will be 29 and a will be eleven. I hope you have understood the flow. Okay, now, this is another one here. We really don't know what to do because here I am incrementing pre incrementing a, post incrementing a here. Now I'll take this value of a. Now what will happen? Suppose the problem here is. Suppose a is okay, let's take the case here. A to be ten. Now first I'll decrement a. I'll increment a. So a will be eleven, but a was this a is not incremented, so a minus eleven. So eleven minus eleven, will it be zero, and then this will be a will be twelve, or which one will be done first? This is a particular scenario for the same variable. If the post incrementer, post decrementer, given often that is implementation dependent and the compiler does not take it well, so it often results in undefined value. So you should try to avoid this as much as possible. Actually, you should not use this. You can use this pre increment, post increment. But as I said in the last class, I'd strongly suggest that at the initial phase of programming, you avoid using this pre increment, post increment operations. Instead, although it will be a little laborious, you write x assigned x plus one, or X assigned x minus one for pre increment and predecrement. But it's good to know that C allows us with these facilities. Now, here is another one which at the initial phase you should not try to use unless you are very confident we know if condition, then we do something else. Something. So there are three things. If some condition, then, although we don't write the then, then we do some operations, else we do some other operation. Now, the same thing can be written, so we call it a ternary conditional operation. Here we write it in a different way just to save space. I mean the size of the program. What we do here, say grade greater than equal to 60 printf passed. Otherwise printf failed. So this means here this part is the condition part, and this part is the part that will be computed if the condition is true, and this part will be computed if the condition is false. All right, so this is equivalent to writing if grade greater than equal to 60 printf passed, else printf failed. All right, this is equivalent to that. So what is happening here in this example? So the general syntax is, if there is an expression, if there is an expression, there's a condition expression, then we carry out. If that is true, then we carry out expression two. Otherwise, if it is false, then we carry out if it is true, then we carry out this part, this part that is following interrogation mark. And we carry out expression three. That is the expression that is following the colon mark for the else case or if the condition is false. So this is again writing that if then else in a cryptic shorter way. This is known as ternary conditional operator. But again, I'd say that this is a specialty of c. It's good to know that. But initial phase, at the initial phase of programming, I discourage you to use this. So here is an example. What will this be? Can anyone tell me? We are computing the interest on the amount of money you have got in bank. This means here, let's look at this part. This is a ternary operator. If the balance is greater than 5000, then you compute balance times zero two. That means 20% of the balance, or compute 10% of the balance. If somebody has got a balance 6000, then have 20% of that computed and assign it to the interest part. So you see a bigger statement. If balance is greater than 500, then interest equals balance multiplied by zero, two else, interest equal to balance multiplied by zero, one. All these things can be done in one single sentence or one single statement using c. All right? So that is why some people prefer to use such ternary operators. And you will also certainly use it. But when you are very confident about your programming. Now we come to a new construct, that is the switch construct. Now in order to understand that, let's quickly go to the flowchart for a while. Say I draw a flowchart like this. I am evaluating some value here, all right? Or maybe, okay, I get some value from the user here. Okay, I read some value, let me make it clearer. I read some value from the user. All right, something read color. Now here, depending on the color that the user supplies earlier in this decision box, what were you doing? We were either going for true or for false. Now here what we are seeing. If the color is red, then we do something. If the color is blue, we do something. If the color is magenta, we do something. If the color is orange, then we do something. If the color is violet, we do something. Okay, so the same diagram I can draw in a different way. That is, I am reading color and then as if I am coming to a switch box, think of this to be a switchbox where number of switches are there, all right? And number of switches are there. Now, depending on what value of the color is coming. So this may be the red switch, this may be the blue switch, this may be the orange switch, depending on which value is coming. So let the value be v. If v is r, then this switch gets closed and we follow this path. If the v is blue, then this switch gets closed and we follow this path. If v is orange, then this switch gets closed and we follow this path. All right. That's why because of this analogy with switch, this statement is also known as switch statement. This is also very much used for branching. Branching. We have seen with if else type of thing. And here also we'll see another variety of a c construct called switch using which we'll do that. Okay, so let's see here. Now let's look at the construct of this. The syntax of the switch statement is this switch expression, then case expression one, expression two. Let me give an example first. Then it will be better. Okay, I'll come back to this. So here is the total switch structure. It is a multiple selection structure. So I come to this point. Switch if the case is a. If it is the case that the color is red like that. If the case is a, then I take the case a actions and then come out. Otherwise I take the case b actions. If the case be b, then only I'll take the case b action and then come out. Similarly, if there may be different cases. So what we are getting here is an advantage is an example that we are showing here. What we are getting here is using this case construct, multiple branching. We are accommodating in one shot. Let's look at this. I was giving an example with color. Here it is an example with a letter. So I have read some letter from the user. Okay, some letter has been. Now that letter can be anything, a to z, say a to z. So if the case is that the letter is a, look at how it has been written. Case a. Before that switch, what is my variable on which I am switching? Switch on variable letter. In the earlier example it was switch on the variable color. So here we start with switch on the variable letter. And what are the possible switches? I encapsulate that in two braces, just as we do now. Within this, I am taking multiple decisions. Multiple possibilities are there. Multiple possibilities are there. For example, if the letter is a, that means if it is a case that the letter is a, then we put a semicolon. Then I write down print a first letter. So what will be printed? First letter and then there is a break statement. What this break statement does that you execute this and then you come out of this entire switchbox. Come out here. That means join the next statement. If the letter was b, then here it is not written. I am writing case b, printf second letter, backslash n and then break. That means if the case is b, then I'll print this and after that with the break, I'll come out of this. Now, after that, I have not written anything else, but I have written case Z. Only this case Z. All right, printf. Last letter. Last letter as is shown here and then break. Now, if somebody, this letter was p. If this letter was q or some other Alphabet. Sorry, I mean anything small Alphabet or capital Alphabet, x, whatever. In that case, what do I do? This one only tells me what I can do. If the letter is a, or if the letter is z, or in my case, if the letter is b, but if it be something else. Otherwise, then we use this statement called the default statement. If anything is other than what has been specified here, then we will say that it is some other letter and then break. You see here, if the letter is a, then only I entered here and then went out. If the letter is b, then I only entered here. If the letter is c, then I'll come to default. If the letter is c, it's not specified here. I'll come here and I'll escape. I'll do, right. It's an intermediate letter and then come out. Okay, so with this understanding, if we can go back to the earliest slide, then we can see that the flowchart will be something like this. We start, then we evaluate expression. We evaluate expression. Then we come here. It's equivalent to case a. Yes, do something, do something and then break. Otherwise it will come here. It's looking at. I'm just doing this. K is z. If true, then do something and then break, right? Otherwise. So this is true, this is false. This is true, this is false. Otherwise default. I'll come here, do something, and then break. Now all these breaks. All these breaks brings me to the next statement after the case statement. So anything that is here, whenever I encounter a break, this comes brings me here. This also brings me here. This also brings me here. And I continue following the sequential nature of program from here. All right, so here is another nice example. You can look at it. Say here, switch. I'm switching on an expression. What is that? Choice two oper. Now this has got some multiple parameters into this. Let me take it up in the next lecture so that I can devote some time on this. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Trapezoidal Rule and Runge-Kutta Method.mp3,"In this lecture, we'll be looking at another numerical method technique. That is, we'll actually look at two. First, we'll look at integration, how we can integrate a function. There are several methods for doing that. We'll look at only one method. And after that, you can look up for other methods. Next, we'll proceed to see how ordinary differential equation. Can be solved. Using numerical techniques using programming. So, first of all, let's start with integration. Now, all of you know what integration means. Given a particular function. Given a particular function, integration is, say I've got a function like this. And I want to integrate. Suppose this function is f x. And I want to integrate it within the range a and b. So we write that as integral a to b of f x, right? And you also know that this integration actually means the area that is under this curve. All right, this value is the integration. So we will look at how we can solve this problem. The simplest, a very simple method. Is a trapezoidal method, which we'll discuss here. So you can see that. Okay, let me go back to this case. Now, you can see that I can approximate this curve. In a very simplistic case using a trapezoid, right? So I have got a trapezoid here. Let me draw in blue. So the area under this trapezoid. This is red itself. So the area under this trapezoid. Is approximating under this trapezoid is approximating the area under the curve. But that is becoming possible here. Except for this error that's becoming possible here. Because the curve was very much not very skewed in that sense. But if the curve were something like this. That, say it was something like this. And I was trying to integrate it between these ranges. Then if I had fitted a trapeze zoid here. Then the amount of error would be much more. Because I'll be committing errors at these points. Okay, I'm not considering this. I'm over considering these points, et cetera. So the error would be more. So. It's not always the case that a simple trapezoid. One single trapezoid, will solve. But let's start with that and try to understand how we can go ahead with the problem. So, the area under the curve. In this particular curve. As you can see here. This particular curve that has gone through this is a trapezoid. Under the curve is a trapezoid. This part, if I assume it to be a trapezoid. In that case, the integral of f x dx is the area of the trapezoid. And we know that the area of a trapezoid is nothing but half the sum of the parallel sides. That means fa plus fb divided by the height. Now, if I look at it, these are the parallel sides. Then the height is this b minus a, this amount, right. So this is a known result. Therefore, I can say if I can approximate a curve by a single trapezoid in this way, b minus a times fa, fb plus fa by two, or fa plus fb by two. But of course, we'll see that there can be errors due to this approximation. But this is a simple formula which we can quickly compute. It's very easy to write a program for that. You have got a function that will compute the curve. So you call it for a and call it for b, and compute this expression, you will get the integral. Okay, integral. All right, so here is an example. Why is this important? Suppose the vertical distance covered by a rocket from time eight to 30. So my timeline is from 8 seconds to 32nd is given by this formula. All right, so the vertical distance, overall total vertical distance is this. This is a complicated formula. Now, using single segment trapezoidal rule, let's try to find the distance covered. Let's try to find out the distance covered for this. So we know for eight and for 30, if I compute this function, this was my function. So for f eight, my function is yielding this value. And for f 30, the function is yielding this value. We can compute using. You can use your calculator and find it out that you need not do right now. So you can compute the values at these two points, because this is the overall function. And next, so this is the f eight and f 30. So what will be my integral? My integral will therefore be 30 minus eight, b minus a, fa plus fb by two. So that is coming to this value, sorry, that is coming to 11868 meter. The distance covered is this. But however, the exact value, if you compute it, the exact value, if you do a detailed computation, will be one 10 60 1 meter. So there is an error. Obviously there is an error because I have approximated the curve using a trapezoid. Now let's see how great is the error? How big is the error? So we can see that the true error is minus 80. Seven meter, right? That's quite significant. 800 meters. And the absolute relative error, which is the actual error, true value, and the computed value. And divided by the true value, you find that I am getting 7% more than 7% error. Okay. How can you better it? How can you better it? Therefore, so our answer will be. Instead of applying a single. Fitting in a single trapezoid. I can try to fit in more than one trapezoid here. Like something like this. That there's a trapezoid here. I fit in one trapezoid here. I fit in another trapezoid here. And thereby, I can approximate. I can minimize my error to some extent. So here what we are trying to do. Instead of taking eight and 30. And fitting in one trapezoid for the whole thing. Instead of fitting in one trapezoid for the whole thing. What we are trying to do is we are fitting in one trapezoid for eight to 19. Another for 19 to 30. Okay? So now, again, using the same formula we find. Then here is one nine to eight to 19. This is the integrant. Plus the other trapezoid is giving me this. So I am fitting in two trapezoids now. Clear? So, if I do that. Then let's see whether the result is being bettered. So I compute f eight at f 30. And f 19. And compute both of these values. The areas under the curve here and here. And the result is 1126 6 meters. Now, how far is it from the actual? Now, we can see that the true error now has reduced from 807 meters. To 205 meters. So that tells us that if we can extend this procedure. And fit in more and smaller, but more number of trapezoids. My error will come down further still. Taking q from this idea. What is being done is the multiple segment trapezoidal rule. Therefore, is that we divide into equal segments. Say, here is one trapezoid. Here is one. It's not coming here. Let's see. Select on the color. Say, here is one trapezoid. Here is another trapezoid. Here is another trapezoid. And here is another trapezoid. I'm getting four trapezoids here. And trying to formulate this. I can do that in this way. So the integral is this whole thing. Which will be a sum of these trapezoids. Remember, each these lines, these lines. This distance is the same. So I am dividing b minus a by some particular value, n. And that is my h. So this is h. This is h. This is h. Like that. I am going for equidistant points. And drawing the trapezoids from there. So, therefore, if I follow this. As is shown in this way. The trapezoidal rule. Trapezoidal rule. Can be written as integral of a. From a to b is sum of half f n plus f n plus one. That is fa plus fb by two times the particular distance that is there. X one minus a, x two minus x one. Usually you do it in the equidistant mode. Okay, so now, multisegment trapezoidal rule is therefore an integral. I can be broken down. This is simple. From a to a plus h, I can have f x dx a plus h to a plus two H-F-X dx plus a plus n minus two h to a plus n minus one H-F-X dx a plus n minus one h to b. So, all the segments are being added together. Applying this, I get this formula, b by a divided by two n because f n is coming, two is coming n times. So f a plus fb plus two into f a plus h, because that is coming twice, here once and here once. You see here, f a plus h will come. Here a plus h will come, right? Okay, so using this, let's do the example again, the same thing. Using two segment trapezoidal rule, we could find that the error is coming down. We have already seen that the true value of error is coming down. And the absolute relative error has come to 1.85 three. So now let's come to c programming straight away. How can we encode it using a c program you see here? So I am reproducing the result here again. So, integral of f x dx between a and b will be h by two fa plus two f a plus h plus two f a plus two h. Why this two is coming? Because in the first zone, fa and fa plus h. Second zone, f a plus h plus fa plus two h. So each of these intermediate points are coming twice. That is why there is two. And I've got this formula. Now, as a c programmer, your task is very simple. You see here that I have defined ani whatever. I am asking the user for the necessary inputs how many number of subintervals that you want to have. The initial limit a. You are reading the initial limit b. All those things you are reading. Now, the integral computation is done here. What is being done? H is I am finding out the absolute value of b, because b and a, b minus a divided by n. And I am taking the absolute value of that. All right, because it could have gone on the other side also. Now here I'm just computing the sum. What sum? This part, what initially, x is a plus ih sum sum plus f x. So each of them, next time it is becoming two. All those things I am adding here. So here I am in a loop. I am doing a plus, ih initially I is one, so one h two h, like that. I am going on doing that, and ultimately, and I'm computing the sum here, sum plus f x. Now note that f x is a separate function that has been kept somewhere here. And then ultimately I find the sum sum is these things, a plus h, these points. Now, integral is h by two. This part, fa plus fb plus fa plus fb plus twice the sum a plus h a plus two h a plus k h. Like that. That part has been a plus ih has been computed inside this loop. And that I add with two here, and here is my integral. So that is the trapezoidal rule. The program is so simple if you understand the concept. Okay, next we will move to another very important engineering computation that is needed is solving ordinary differential equations. Quickly. Let all of you know what a differential equation is, and we will in particular look at Rungekuta's fourth order method. And here I'll show examples that you can also find in this site of University of South Florida numerical methods. And I've taken the slides from them with the permission. Now you see how to write an ordinary differential equation. Now, an ordinary differential equation, you know, is dy dx F-X-Y. Okay, now, dy dx. So how do I write it? I write it as suppose this is something given dy dx plus two y is 1.3 into e to the power minus x. And what is this part? This is the initial condition. Okay? Now this can be rewritten as by just changing the directions, because I have to bring it to this form. Dy dx is 1.3 e minus x minus two y. So in this case, we'll assume that our fxyfxy, that is a dy dx is 1.3. This thing into e to the power minus x minus two y. This is our function differential equation that we'll have to solve. So, for dy dx, the Rungvekuta fourth order method, I am not going into the derivation of it for paucity of time. And you can always look into this at any website, or you can look at it in any numerical method textbook. So, the Runga Kutta fourth order method takes four terms. And this is the expression. Given this dy dx, my task of solving a differential equation is to find a particular y, right? So what we are trying to do, y I plus one is yi, some particular yi plus one by six followed by a term. And what is that term? K one plus two k two plus two k three plus k four. This whole thing multiplied by h h is again the sampling gap. That is the distance between the individual points that we look at. Now, what is k one? So k one is nothing. But when I am taking for yifx psi y I, that particular function is k one. What is k two? K two is f of. So suppose there is a curve. Now, I have been given the slope. I do not know the curve. So if I know the curve, again the same problem. If I know the curve, then I can find out the value of any particular yi plus one, given any yi. Now given any yi, I am trying to guess the curve, right. I am trying to solve the curve. So xi was here, x I plus half h. I am taking whatever was my h. I am taking half of h. And what is the y part of this function? Yi plus half of k one h. Okay, so because k one was, if I, k one was the function that was giving y given an x, that was giving a y for an x. So I am taking this. What is k three? K three is again, this part is same, x I plus half h. But this part is now becoming much more predictive. So it is half of k two, h, half of k two. That means whatever has been computed here times h and k four is x I plus h. The last one is x I plus h, because I am trying to solve the equation within this zone h. So x I plus h I start with x I and this is x I plus h. All right, times k three h. Okay, here, there is no half. Now this derivation you can look at, but ultimately I multiply it with one by six. So given this runga Kuta formula, let's quickly look at an example that will be a very nice thing to look at. Suppose a ball is at 1200 kelvin and is allowed to cool down in air in an ambient temperature of 300 kelvin. So the ball was heated and it's cooling down. Assuming that the heat is lost only due to radiation. The differential equation for the temperature is given here. This one. All right, where theta zero, we know initial condition is 1200 kelvin. Find the temperature at t 480. So what is my xi? So now if I assume a step size of 240, I want to find out the temperature at 480. So suppose it was up at a particular temperature after 480 seconds. So here is time. It was at 1200. And I have got some radiation formula using which it is coming down. So I want to find out what would the temperature be at 480 seconds. 480 seconds from the starting point where it was 1200 degree kelvin. I want to find out this temperature, that is the yi I want to find out, find out, given the slope of this differential equation. So assuming a step size of h to be 240, half of this, if I take half of this 240, then d theta dt, you can compute that here. If you compute the d theta dt is here. So my formula will be theta I and theta I. K one plus two. K two plus two. K three plus k four divided by six times h. That is the runga kutta formula rk formula. So that is what I want to find out. Right. So now step one, you see, I'm not going into all these calculations, but I'm finding out the value of k one. All right, I am finding out the value of k two using this value of k one. K one is being used here. And I find out the value of k two. Again, the value of k two is being used here. I find out the value of k three. And k three is being used here. I find out the value of k four. I find out those values. All right, manually. Manually. I'm doing that now. So the solution, therefore, the approximate then theta zero was 1200 initial condition. And here I put in the values of this times h. H was 240. So I have taken it at the meetpoint. So I find that the temperature, sorry, the temperature that would be, would be 675.65. That's the approximate temperature at 240. All right, so this will be the value at 240. Next I have to find out at 480. So what would I do? Step two, I have taken at half point, I found out, now my initial value, theta zero is changing. Now I again do the same thing. Find out k one. Find out k two. Find out k three. Find out k four. Now, with this initial condition using the same function, all right, h is again what will be h. H will be again 240. Because I have to find it out at 480, right? At 480 degree temperature. Temperature. So now I find out that using theta one is now 675.65. That is the approximate value that I got earlier. And I compute this, I find out using the same Lungakuta method, that this is the approximate temperature at 480. At 480 seconds would be 594.91 degree kelvin. Okay, this is how we apply runga Kuta method, and it's very useful. So the exact solution of the differential equation is 647.57. If I solve it now, it was, and we got it. How much? 594.91 and 594.91. So it was not very far. Okay, not very far. Around 50 degree kelvin. That is certainly an approximation. So now we have understood. What is Runga Kutta method? Now I want to write a c program for it again. You might find the approach to be mathematically very novel, maybe intricate. You may find some initial difficulty in understanding, but I'm sure you will understand it very fast. But you will see that the encoding it as a c program or as a program is really simple. Now you're learning c. In future, you'll be using Matlab and other things. You will be able to solve it very easily. I am showing you the c solution here on this side. I have kept what we learned till now, right? Y I plus one. That means in our case, the temperature at 480 degree is temperature at 240 degree plus this. And k one is F-X-Y-K two is F-X-I. This one, F-X-I plus half, h plus y I plus half k one, h, et cetera, et cetera, et cetera. So now let's look at the program. We have got. The math function. Everything ready. Now, this function, somehow this function has to be written. Now, this function is here. It's being shown as a very simple function. It can be any function, the differential equation function, the earlier function that we have shown, that log function that you have to write. Okay, so here is an example of a simple function, x minus y by x plus y. Okay, just for illustrative function, whatever is your differential, I mean, sorry, the dy dx, given that will come in this function. So now, you see here, I read how many times the h value, x zero, x one value. All these things I read. Now, the key thing comes here. This is the implementation of the runga Kutta method, so very simple. You see, I am computing k one. K one is f x zero, y zero. So I'm coming to this function, computing x zero. Y zero. Then I'm going back computing k two for x zero plus h by two. H has been read here. Scan fh has been read. Okay, this h has been read. Then y zero plus m one. I'm sorry. Here, it should be k one, k one, and this should be k two. All these m's you read as k. Okay, this is k three. This is k three. This is k two times h. So actually, we are computing this thing straightway. I am computing all these, and then y is assigned y plus kh. Sorry. This whole thing is kh. Here. This will also be k. So this statement will be y will be y plus kh, y plus kh, right? And x x plus h. I am incrementing x and going on. All right, I am doing it for two intervals till I come over here. So I ultimately come to this printf, and I print the value of y for a particular x. That is the Runga kuta. So this is straightway amenable to some c program. And for each of these f's, you are calling the function every time. All right, so this is the Rungekuta method for solving a differential equation. So I'd encourage you to look at other methods of integration, like Simpson's one third rule is a very popular method and differential equation Rungekuta. This is known as Runga kuta, fourth order method, because we are taking more terms here. There are even. But this works very well for most of the engineering problems. So I'll encourage you to write programs on this. And later on henceforth, we'll move to another interesting aspect that is known as recursion, a new style of programming, which we'll take up in the next lecture. Thank you.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
tuples and dictionaries.mp3,"You. So we have seen this kind of a simultaneous assignment where we take three names on the left and assign them to three values on the right, and we enclose these in these round brackets. So this kind of sequence of values with a round bracket is called a tuple. So normally we talk about pairs, triples, quadruples, but in general when it goes to values of k, we call them k tuples. Now in python, tuples are also valid values. You can take a single name and assign it a tuple of values. For instance, we can take a two dimensional point with x coordinates 3.5 and 4.8, and say that point has the value 3.5, comma 4.8, and this is not a list but a tuple, and we will see in a minute what difference is. Similarly, we can say that a date is made up of three parts, a day, a month and a year, and we can enclose this into a three valued or triple. So tuple behaves like a list. So it is a kind of sequence. So like strings and lists, in a tuple you can extract one element of a sequence. So we can say that the zero th value in point is the x coordinate. So this would assign the value 3.5 to the value x to the name x coordinate. Or we can take a slice. We can say that if we want only seven to and 2013, we take date and take the slice from one till the end. Then we will get seven comma 2013. So this behaves very much like a different type of sequence, exactly like strings and lists we have seen so far. But the difference between a tuple and a list is that a tuple is immutable. So tuple behaves more like a string. In this case, we cannot change, for instance, this date to eight by saying date at position one should be replaced by the value eight. This is possible in a list, but not in a tuple. So tuples are immutable sequences, and we will see in a minute why this matters. So let's go back to list. So a list is a sequence of values, and implicitly there are positions associated with the sequence starting at zero and going up to the length of the list minus one. So an alternative way of viewing a list is to say that it maps every position to the value. In this case, the values are integers. We can say that this list l is a map or a function in the mathematical sense from the domain 01234 to the range of integers. And in particular it assigns l zero to be 13, l four to be 72, and so on where we are looking at this as a function value. So the programming program language way of thinking about this is that 01234 are what are called keys. So these are the values with which we have some items associated. So we search for the item associated with one and we get back 46. So we have keys, and the corresponding entries in the list are called values. So a list is one way of associating keys to values. So we can generalize this concept by allowing keys from a different set of things other than just the range of values from zero to n minus one. So the key, for instance, could be a string. So we might want a list in which we index the values by the name of a player. So for instance, you might keep track of the scores in a test match by saying that for each player's name, what is the value associated? So Dhawan score is 84, Pujara score is 16, Kohli's score is 200. We store these all in a more generic list where the list values are not indexed by position, but by some more abstract key, in this case, the name of the player. So this is what Python calls a dictionary. In some other programming languages, this is also called an associative array. So you might see this in the literature. So here is a store of values which are accessed through a key which is not just a position, but some arbitrary index. And Python's rule is that any immutable value can be a key. So this means that you can use strings which are immutable, and here, for instance, you can use tuples, but you can't use lists as we. And the other feature of a dictionary is that like a list, it is mutable. We can take a value with a key and replace it. So we can change Pujara score if we want, by an assignment to 72. And this will just take the current dictionary and replace the value associated with pujara from 16 to 72. So dictionaries can be updated in place and hence are mutable, exactly like lists. So we have to tell Python that some name is a dictionary and it's not a list. So we signify an empty dictionary by curly braces. Remember, we use square brackets for lists. So if you want to initialize that dictionary that we saw earlier, then we would first say test one is the empty dictionary by giving it the braces here. And then we can start assigning values to all the players that we had before, like Dhawan and Pujara and so on. So notice that all these three sequences and types of things that we have have different. So for strings, of course, we use double quotes or single quotes. For lists, we use square brackets, for tuples, we use round brackets, and for dictionaries, we use braces. So there is an unambiguous way of signaling to python what type of a collection we are associating with a name so that we can operate on it with the appropriate operations that are defined for that type of collection. So once again, for a dictionary, the key can be any immutable value. That means your key could be an integer, it could be a float, could be a bool, it could be a string, it could be a tuple. What it cannot be is a list or a dictionary. So we can't have a value indexed by a list itself or by a dictionary. So we can have multiple, just like we have nested lists, where we can have a list containing lists and we have two indices. Take the zero th list and the first position in the zero th list, we can have two levels of keys. So if we want to keep track of scores across multiple test matches, instead of having two dictionaries, we can have one dictionary where the first key is the test match, test one or test two, and the second key is the player. So with the same first key, for example, with the same different first key, for example, test one and test two, we could keep track of two different scores for Dhavan, the score in test one and the score in test two. And you can have more than one player in test two, like we have here, we have both Kohli and Dhavan test. So if you try to display a dictionary in python, it will show it to you in this bracket, in this kind of curly bracket notation, where each entry will be the key followed by the value separated by the colon, and then this will be like a list separated by commas. And if you have multiple keys, then essentially this is one whole entry in this dictionary. It says, for the key test one, I have these values. For the key test two, I have these values, and internally they are again dictionary. So they have their own key value. So let's see how it works. We start with an empty dictionary says score, and now we want to create keys. So supposing we say score test one, one equal to 76. Now, this is going to give us an error because we haven't told it that score test one is supposed to be a dictionary, so it doesn't know that you can further index it with the word. So we have to first tell it that not only is score and empty dictionary, so is score test one, and presumably, since we'll use it, so is score test two. And now we can go back and set Havan's score in the first test to 76, and maybe we can set it in the second test to 57. Maybe we can set Kohli's score in the first test, 200. Now, if you ask it to show us what score looks like, we see that it has an outer dictionary with two keys. Test one, test two, each of which is a nested dictionary. In the nested dictionaries, we have two keys, Davan and Kohli, which score 76 and 200 as the values. And test two has one dictionary. One dictionary entry with Dhavan is the key and 27 is the key. So if we want to process a dictionary, then we would need to run through all the values. And one way to run through value, all the values, is to extract the keys and extract each value by turn. So, there is a function, d keys, which returns a sequence of keys of a dictionary, D. And the typical thing we would do is, for every key in d keys, do something with d square bracket key. So pick up all the keys. So this is like saying, for every position in a list, do something with the value at that position, saying, so something. For every key in a list, do something with the value associated with that key. Now, one thing we have to keep in mind, which I'll show you in a minute, is that d keys is not in any predictable order. So dictionaries are optimized internally to return the value with the key quickly, so it may not preserve the keys in the order in which they're inserted. So we can't predict anything about how d keys will be presented to us. So, one way to do this is to use the sorted function so we can say for k in sorted d keys, process dk, and this will give us the keys in sorted order according to the sort function. So, sorted l is a function we haven't seen so far. Sorted l returns a sorted copy of l. It does not modify l. What we have seen so far is l dot sort, which is a function which takes a list and updates it in place. So, sorted l takes an input list, leaves it unchanged, but returns a sorted version of that list. The other thing to keep in mind is that, though it is tempting to believe that d keys is a list, it is not a list. It's like range and other things. It's just a sequence of values that you can use inside a form. So we must use the list property to actually create a list out of d keys. So let's validate the claim that keys are not kept in any particular order. So let's start with an entry dictionary. And now let us create for each letter an entry which is the same as that l. So we can say for l in abcd, E-F-G-H-I-D-I-D-L is equal to l. So what is this saying? So when you say for l in a string, it goes through each letter in that string. It's going to say d with the key a is the value a, d with the key b is the value b, and so on. So now if I ask you what is da, it will tell me it's a. If I ask you what is di, it will tell me. Now, notice that the keys were inserted in the order abcdef g h. But if I ask for d keys, it produces it in some very random order. So e is first and a is way down and so on. There's no specific order that you can discern from. So this is just to emphasize that the order in which keys are inserted into the dictionary is not going to be the order in which they're presented to you through the keys function. So you should always ensure that if you want to process the keys in a particular order, make sure that you preserve that order. When you extract the keys, you can't assume that the keys will come out in any given order. So another way to run through the values in a dictionary is to use d values. So d keys returns the keys in some order, d values gives you the values in some order. So this is for example like saying for x in l. So you just get the values, you don't get their position. So here you just get the values, you don't get the keys. So if you want to add up all the values, for instance from a dictionary, you can start off by initializing total to zero. And then for each value you can just add it up should be s. So you can pick up each s in test one dot values and add it to the code. So you can test for a key being in a dictionary by using the in operator. Just like lists, when you say x in l for a list, it tells you true. If x belongs to l, the value x belongs to l, it tells you false. Otherwise the same is true of keys. So if I want to add up the scores for individual batsmen, but I don't know if they batted in each test match. So I will say for each of the keys, in this case, Dhawan and poly initialize a dictionary, which I've already set up, not here I would have said that total is a dictionary. So total with keys, Dhawan is zero. Total with key, poly is zero. Now, for each match in our nested dictionary, if Dhawan is entered as a batsman in that match, so if the name Dhavan appears as a key in the score for that match, then and only then do you add score, because if it doesn't appear, it's illegal to access that value. So this will one way to make sure that when you access a value from a dictionary, the key actually exists. You can use the in function. So here is a way of remembering that a dictionary is different from a list. If I start with an empty dictionary, and then I assign a key which has not been seen so far in a dictionary, there is no problem. It's just equivalent to inserting this key in the dictionary with that value. If d zero already existed, it will be updated. So either you update or you insert. So this is in contrast with a list where if you have an empty list and then try to insert at a position which does not exist, you get an index error. So in a dictionary, it flexibly expands to accommodate new keys or updates the key depending on whether the key already exists or not. So, to summarize, a dictionary is a more flexible association of values to keys than you have in a list. The only constraint that Python imposes is that all keys must be immutable values. You can't have keys which are mutable values, so you cannot use dictionaries or lists themselves as keys, but you can have nested dictionaries with multiple levels of. The other thing is that we can use d keys to cycle through all the keys in the dictionary and similarly d values. But the order in which these keys emerge from d keys is not predictable, so we need to sort it or do something else if we want to make sure we process them in a predictable order. So it turns out that you will see that dictionaries are actually something that make Python a really useful language for manipulating information from text files or tables, if you have what I call comma separated value tables taken out of spreadsheets, because then we can use column headings as accumulate values and so on. So you should understand and assimilate dictionaries into your programming skills, because this is what makes Python really a very powerful language for writing scripts to manipulate data.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Types of Software and Compilers.mp3,"In the last class, last lecture, we had discussed about variables and values, and we explained that variables are mapped by the compiler to different memory locations. So whenever we mention about any variable x, y or z, each of them corresponds to a memory location. Okay? Each of them corresponds to a memory location, and each of them corresponds to a memory location. And whenever we assign some value, like, say, 20 to x, that means in a particular memory location, that value is written. So we had done this example once again, we quickly go through it, that x is being assigned 20. So the memory location corresponding to x is getting the value 20, whereas the memory location corresponding to y can be anything. When we assign in this statement the value 15 to y, then 15 is written in the location corresponding to y. When we do y plus three and assign it to x, that means actually we are reading this value of y here, reading the value of y, which is 15, and we are adding three with that, and we are getting 18, and that 18 is written into this location. All right, this may appear to be very simple, but this way of thinking or way of looking at the things will come in very handy, as you will see, during the later phases of programming. Now, here again, when we are, what is being meant by this statement that the value, how will I read it? I'll read it like this, that the value of x, value stored in x, that is 18, will be divided by six, and that result will be stored in Y. All right, so x was 1818, has been divided by six and we get three, and that three is written in Y. Now, here there are a couple of things that, what is this 18? What is this 20? These are values, and whereas these are variables, these are also known as constants. Constants are the values which do not change during the execution of the program. Next, now we can think of the software. Now, you know, any computer system consists of hardware as well as software, right? So we'll have some hardware as well as software. Now, the hardware is consisting of the cpu, the memory, the I O devices. All those things are hardware. And the software is the instructions that this hardware that is executed by this hardware. The instructions that are executed by this hardware constitute the software. Now, software can be of two types. Okay? For example, first one is the application software. Application software is a software that we write. So we can just have an idea of this through this onion type of diagram. At the core, we have got the hardware. The hardware is here, and I am putting two layers around this, and the user is standing somewhere here, and the user is not directly interacting with the hardware. Why? Because the hardware merely understands ones and zeros. And it is very difficult for the user to write in ones and zeros. So the user will write in some high level language. High level language HLL, in which the user writes and the system automatically converts it into a way that is understood by the hardware. And what is that automatic way of converting it? We have seen that is compiler is a software. Compiler is again a software, right. A compiler is a software which converts. So before coming to application software, let me talk about system software. So we know that when the user has written something in high level language that is converted by a program called compiler into the machine level language or high machine level language, right? Which the hardware understands. So the compiler is, let's mark it like this is a part of this layer which is the system software. Similarly, operating system is another very important software that is lying in this layer, internal layer, which enables the user to use the computer in a much more user friendly way and in a much more efficient way. So operating system, compiler, et cetera, are the core very important elements of the entire computer system, without which we would not be able to use the computer in as efficient way as we do it nowadays. Now given this hardware and this layer of operating system and compiler and other system software, now we are in a position to write some programs for our day to day use. For example, a company wants to find out the salary information of the people. They can use some payroll software here. Or for example, you want to design some data analysis software that will take some data and using a particular software will analyze the data statistically and give you some good insights. So all those things the user is writing and they are forming the application software. So most of the time the programmers who are not systems programmers, not the system designers, but just users, they mostly use the application software. Okay? Given this, we come to a very important software we just now mentioned that is an operating system. Now you know that you are aware of the typical operating systems like Windows, Linux or Unix, all right? Nowadays Apple is becoming popular. Mac OS, all these things are operating systems. Now, what is the operating system? The operating system is a layer around the hardware which enables a user to use the software. Use this computer system, I'm sorry, use the system in a much more user friendly way. Now there are different varieties of operating system, single user operating system, multi user operating system, et cetera. Now this operating system also activates another system software that we have talked about. That is a compiler, right? The operating system will call or will activate the software system software called the compiler. When you want to run a high level program. Okay, given this background, let us now move to discussion on programming. We know by now that programming means we have to express our intention of solving a problem by executing a number of steps. And those number of steps, once again, you know that by now we start with the algorithm. And that algorithm can be expressed in different ways like pseudocode or flowchart. And then the programmer actually writes them in a high level language. Some high level language. Now what we are going to discuss now is a particular high level language which is called c. We are taking c just as an example of a high level language because we have to express the logic in the form of some high level language. We are taking c as an example, and as I have mentioned earlier, that the logic, the style and the philosophy remains more or less the same across different programming languages like Java, c plus, plus and others. Of course, c is the simplest to start with. Let's see now we are using the term language. Think of a human language. Any language is constituted of some vocabulary, right? The vocabulary, say for example in English, the vocabulary consists of some words, right? Different words like say bird is a valid word in the english vocabulary. But if I had written rbid, that is possibly not a valid word in the english language vocabulary. All right, now we have got some valid words. Similarly, c will also have some valid words which we'll see through which we can express the basic elements of a c program. Just as english sentence is built using english, valid english words. Otherwise the meaning will not be understood. In the case of c programming language, say c will have its own vocabulary, right? The words valid in c. Now if I had written some word in English that is not some string, some pattern in English like rbid, that unless this has got some special meaning, this will not be. And if this is a part of a sentence, this will not be very clearly understood by anybody. Now when I have written a c program, who is going to understand this? For whom am I writing this c program? I am writing this c program for the compiler. C compiler, all right. I am writing it for the c compiler. And the c compiler is responsible to understand this, okay? And just as we understand an english sentence, open the door, so we understand the meaning of that sentence. We go and execute that, we open the door. Similarly in C, if we write something, unless the compiler understands this, it will not be able to convert it to the machine language, which will be executed by the hardware or the computer, right? So a C program must constitute of valid C words. And we'll see what are the valid words and what are the rules for that? Now, the next thing, if I write a particular sentence, I saw a bird. That is a valid english sentence. Why is it valid? Because it is grammatically correct. And also it is carrying a very clear meaning. It's a meaningful sentence, right? So this is both correct grammatically by grammar, and also it is meaningful. Now suppose I wrote it wrote something like I seize a bird. Now, this is grammatically wrong. Grammatically wrong. However, it conveys some meaning. I understand that the person who wrote this is weak in grammar. He is not very much conversant with the subject verb agreement, but still I can make a meaning out of it. On the other hand, for a compiler, if I write a C sentence, let me call it not sentence, let me call it C statement. Now, a C statement, that means a statement in the language C will consist of some valid words in C, and also it will have to follow some grammatical rules of C. Unfortunately here, although it is grammatically wrong, I could understand the meaning of this. But a C statement, if it is grammatically wrong, grammatically, according to the grammar of C, okay, if it is not in tune with the grammar of C, then it's grammatically wrong. And since this c sentence will be interpreted not by a human being, but by a machine, a machine, a computer, however smart it may look like, is basically not as intelligent as human beings. So that as of now, so whatever we can make out the meaning out of it, a compiler, a C program will not, the compiler will not be able to make out. Correspondingly, the correct machine language cannot be generated. Therefore, if there is something that is grammatically wrong according to C grammar, that will be indicated, marked by the compiler, as a syntax error. All right, so unless we write something in the correct syntax, there is always a chance of, there is always a chance it will obviously lead to a syntax error and the compiler will not produce the corresponding machine code. All right, so we are now supposed to learn what is. Therefore, we need to know what are the valid words in C, what are the correct grammatical structures in C. Now, if we learn both these, we learn the c language. Similarly, if you want to learn any other language, computer language, you have to exactly know these things. What are the valid words in that language, and what is the correct grammatical structure in that language? So given this, we will start looking at c programs. Even before that, we once again recapitulate whatever we are expressing. We are expressing them using some variables, constant constants, right? And the variables have got, we have shown X-Y-Z et, cetera, et cetera. Variables. So each of these variables, which are nothing but memory locations, are being given some names, right? So we have to give some names of the variables. All right. There are some rules for naming them. Just as in English, we start a proper noun with a capital letter. Ravana. All right. Sita. We write them with a capital letter. This is the rule of English. However, if you write in any indian language, say, you write anything, amar. Okay. You write that there is no question of any capital letter here, but it's a property of English. It's a rule of English that the capital first letter of a proper noun must start with a capital letter. Similarly, for naming the variables in C, there are some rules. So here we have seen X-Y-Z et cetera. These are the variables. So there are some rules for naming the variables. We'll come back to this again. But first of all, any string of alphabets, say, let me introduce one word, alphanumeric. Alpha numeric means what alphabets? And what are the english alphabets? Abc up to z. Small letter. AbC, up to z. That's Alphabet and numerals. We know zero to nine. All right. 0123. Up to nine. Now, an alphanumeric means a union of both these, either Alphabet or numeral. So a variable name in C can consist of any alphanumeric character. Now. So it can be, say, apple is a valid variable name in C. Again, if I start with small a, this is also a valid variable name in C. But although these two are same, since I have put in different characters, one capital, one small, these two will be treated as two separate variable names. All right? Similarly, I can write, say, apple, one, two, that's also a valid variable name. Now, there are some special characters, like underscore, that is allowed. Like I could have written something like this, Apple underscore, one, two, that's also a valid variable name. However, I cannot start a variable name with a digit or a number. For example, one, two, apple is not a variable valid variable name. Other special characters, like, say, apple percentage is not a valid variable name. So these are some of the rules. So what are the rules of naming a c variable? It can consist of any alphanumeric character, any length, but it must start with an Alphabet. And only some specific special characters like the underscore is allowed. Others are not. Okay, so this is not allowed. But say Apple Bob 34. This is a valid name. Okay, so here I can use as again, apple b, small o, small b. This is also a valid name. So in general, what is the rule? I can have a string of alphanumeric character starting with an Alphabet and having no special characters except for this underscore. All right, so with that, that's how we'll name the variables. And each variable, I again repeat, you know that a variable essentially consists of memory locations. A variable is nothing but a memory location, and we are putting the name to that particular memory location. So if Apple be this memory location, maybe Apple is another memory location. Now which variable will go to which memory location is decided by the compiler? So might be Bob is another one. All right, Bob. Bob is another one. All right, so these are separate memory locations. So variables. And naming of variables is a fundamental step in writing a C program, because whatever we write, we have to write them through variables. Now quickly, once again, we look at this, that whenever we are writing, suppose again, I'm writing. Now, suppose there are three numbers, ABC or, okay, I want to find the average of that. So I can write it in the form of say and say average. You can see that average is a valid, valid name in the case of a variable. So I can say avg is a plus b plus c, whole thing divided by three. Now this one I can call to be a C sentence, or I am saying sentence, just so that you can have an analogy with our English. But we will call it C statement, all right? And this C statement consists of several things. We'll come to the other things, but you can see that it is consisting of 1234 variables and one constant. That is three. All right? And there are some special parentheses and all these are also valid symbols in C, okay? And these are operators. So we'll see how a C statement is constituted. But whenever we write a C statement, it will consist of a number of variables. Now coming to a C program, a C program consists of a set of, let me call it a number of, maybe one, but at least one number of functions. What are functions? There is a significance of this term functions. But for the time being, let us simply try to visualize it in this way that I am trying to build a machine which will do something. What will it do? Say, for example, it's a machine that will take, say, two or three numbers, A-B-C and will produce the average. Now this is a machine, all right? It does something, takes some input and gives some output. Now this entire machine can be built up with smaller submachines, all right? And one machine, each of these submachines can do some specific task. For example, if I take a complicated, say, paper rolling machine, then there are so many things to be done in order to roll out or prepare papers. So similarly, there can be different submachines which are doing different functions. So each of them, each of these submachines are carrying out different functions. Are carrying out different functions. All right, this is doing one, this is doing another, and all these three together is doing something. Now, as I said in a special case, just like for a simple case of average, I may not need many sub modules because I can very well take a, b and c here, a, b and c. And simply in this machine I can write a program like avg is equal to a plus b plus c divided by three, and that will be the output, right? So here I don't need any submachines because it's a simple problem, but nevertheless I need at least one function. That is, what is this task is being done. So any C program will require at least one function, and in many cases we'll see it will require more number of functions. We'll come to this in the next lecture. Bye.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Use of Logical Operaotrs in Branching.mp3,"In the last lecture, we had an idea of what control structures are. Control structures are, are some language structures by which we can change the flow of control, which normally is sequential. That means one executed after another. Now, in a language, just as we had statements, arithmetic expressions, logical expressions, all those were statements in our language, c language, you also have some control statements for achieving the control structures. What they do, as I have said, allow different sets of instructions to be executed depending on the outcome of a logical test. So if we go back to the flowchart, we are coming in a sequential flow. At this point, we encounter decision point, and at this decision point, we carry out some logical test. For example, is x greater than zero, yes or no? If it be yes, there will be some flow, and if it be no, there will be some other flow. All right? Not necessarily backward. It can go somewhere else, et cetera. All right, so based on a logical test, that means this test, which will result in a logical value. And what are the logical values? Logical values are either zero or one, either true or false. Okay, so, so whether true or false, this is called branching. So again, whenever I am coming to a decision box and from there, I am branching out either in this direction or in some other direction. All right, so this is a branching branch point. Okay, so that is the change of the control flow. Some applications may also require that a set of instructions be executed repeatedly. They will be going on. They will be executing as in the case of reading the numbers, three numbers, I'll be repeating, reading a number, adding that with sum, decrementing count, checking whether count is equal to zero, and then again go back and read the number, and this flow will continue. Okay, based on some condition, how long? In the earlier example, how long were we doing that? Based on what condition? The condition was whether the count is zero or not. As long as the count is not zero, we are going on doing this. Okay, so this is also known as looping. Doing the thing repeatedly. This is also known as looping. So, branching. Or if we go back to the earlier one, then it's called a loop. Now, how do we specify the conditions? By now, I am sure you have guessed how we do that. We specify the conditions using relational operators. Or there are four relational operators. We have seen less than, less than, equal to, greater than, greater than, equal to. I had said not equal to also, but not equal to can also be seen as the negation of the equality operator. The equality operator is this double equal to sign and not equal to is exclamation mark followed by equal to so, using this relational operators, we'll get, using one single, any of these, one single relational operator, we'll get one logical expression. One logical expression. And using logical operators and connectives, we'll be able to connect a number of logical operations, logical expressions, okay? And logical, another logical expression. In that way, we can carry out, we can generate the condition using this. Okay, now, two logical operators we have seen and, and, or another unary negation operator we did not discuss earlier, but we are doing it now. That is, this means not. All right. For example, suppose x is five, and at some point I compute x greater than five. The result of this logical expression will be false. Right? This is false. But if I take the negative of this, then this false will be negated, and the negation of that will be taken. So that will be one true. That means, what is the meaning of this? Is it the case, I can read it in this way. Is it the case that x is greater than five is false, is not true? Yes, that statement is true. I can state it in another way. Is it the case that x is not greater than five? Yes, that is the case. Again, I tell the first one. That's more complicated. Is it the case that the statement x greater than five is not true? That statement is true. That it is not true is true. So that is not means whatever logical expression I have after this, that will be negated. So it is equivalent to not of the logical expression. So if this logical expression, if this logical expression leads to this logical expression only is one, then not of that will invert it and make it zero. Or if this logical expression was zero, then this not of this will make it one. Okay, so this is the unary negation operation. All right, let's say some examples count less than equal to zero. This is a logical expression. It will be either true or false. Maths plus physics. That means here, math is the marks obtained by a student in maths plus physics plus chemistry, divided by three is greater than equal to 60. That means the average of these three marks is greater than equal to 60. Either the person, the sex of that person is male. Sorry. And let's look at this. It's using a logical connective. The person. This will be true. If the person is a male and his age is greater than or equal to 21. So for a female of age 22, this will be false. For a male age 20, it will be false. A male age 25, it will be true. Here again, another one with this connective marks is greater than 80 and marks is less than 90. Sorry. Marks is greater than equal to 80 and marks is less than 90. That means what? Anything starting from 80 to 89, if the marks is between this, then this will be true. Okay. It another one with an or operator balance is greater than 5000 or the number of transactions is greater than 25. So in a bank situation, for example, you are making a lot of transactions. What is a transaction? When you deposit a money, that's a transaction. When we withdraw a money, that is also a transaction. So there are different transactions. So what we are saying here, either I have got rs5000 greater than rs5000 in my balance or I have done more than 25 transactions. If any one of them true, suppose you have got rs6000 in your balance and number of transactions is 26, then also this is true. If the balance is 6000 and number of transactions you have done is only 20, then also it is true. Okay, we have already explained the role of or operator earlier. Okay, now this, if the grade of the student is a, if a student has got grade a, what will be the value of this logical expression? True or false? If the student has actually got the a grade. All right, so this one, this part will be true, but my actual logical expression is this one, which is a negation of that. So it will be false because the person has got grade a. What does it mean? It means that is it the case that the student has not got grade a. Okay, here is another little more complicated. X greater than 20 and y less than 16. Now, the way we should evaluate this is, I'll evaluate each of them separately. Suppose x is greater than 20. Suppose 21, so this is true and y is 15, so this is true. So both these together is true. Then I take this one with this and so the result will become false. Okay, let me clear it again. Suppose x is 21, so this part is true. Then I compute this. Y is 17. This part is false. Therefore, these two are connected by this amps. And that means logic. I'm sorry, very sorry. It's not ampere sand double. And that means and operator by logical. And so these two will result in through the logical and it will result in zero. But my actual expression is a negation of that. So the result will be one. Okay, clear. Okay, so that is how we carry out, these are the examples of evaluation of logical expressions and logical expressions. So, each of them, each of these logical expressions can serve as a condition in our control structure, in this loop, in this diamond box decision box where we test, or let's call it the test box, in that any of these sort of logical expressions can reside, and the result of that can be either zero or nonzero, false or true. Okay. Accordingly, we'll branch out in either this direction or in some other direction. Okay, so zero indicates false and nonzero indicates true. Typically, the true is represented by the value one in most of the machines. Okay, this is something that we have already said. The decision symbol in the flowchart indicates the decision to be made. It contains an expression that can be true or false. Test the condition and follow the appropriate path. That's how we'll do is a single entry, single exit structure. That means in this diamond box, we'll enter through any one point, and we'll exit from only one point, either this or this, simultaneously. We cannot come out of this because a thing cannot be true or false at the same time. Therefore, any one exit will take the general syntax. Syntax means what? Syntax means the grammar. The exact grammatical structure that we should write is if condition. Then I carry out some operations you have seen in an earlier lecture when we were comparing two numbers, x and y, and would be printing x is large. If x is greater than y, then what did we write? We wrote something like this. We wrote, if x is greater than equal to y, print f what we printed y. X is greater than equal to y. X is large or not. In this form, we wrote down that x is large here. All right, so if this condition is true, then I'll be doing this print operation. Okay, x is large, then backslash n. I'm not being able to write very clearly here, so I try again. If x is greater than y or greater than equal to y. So this is the condition. You see this? If there's a reserved word in C, then the condition. If the condition is true, then this is followed by a statement. Now, if it be a single statement, I don't need to give this curly bracket, but just, I am giving it just to keep the parity here. I write printf x is large, then backslash n. Right? And we end this statement. Okay, so if this condition is true, then this statement will be executed. That is my syntax. Otherwise, some other statement will be executed. Now this is something which takes some time to settle down, so we will explain it repeatedly to some extent. If there is a single statement in the block, these braces can be omitted. I'm sorry? These braces can be omitted. Okay, now let's come to this structure. If statement. First of all, we are looking at the first and very important control statement in C. That is the if statement. Okay? If some condition. So we come here. The structure is we carry out some test. On some condition, grade is greater than equal to 60. If it is true, then we do something. Here, I print past. Otherwise, I write something else. So this is a selection structure. What is it selecting? It is selecting. Which path should I go? All right. Now you see here we are coming through this path. Here I carried out a test. If this test is true, I do this, do this, execute this statement and come back and continue. Not come back and then continue this path. If this statement is not true, that means if this test fails, then I'll not select this path. I'll continue in the path in which I was going, right? So that's why this is often known as the selection structure. So, a decision can be made on any expression. Here, you see, only thing that we are trying to do is test whether some condition is true or false. Now, if the result of an expression is zero, then we take it to be false. And if it be nonzero, then we'll take it to be true. If I evaluate something to be true, like say for example, if x was five, and I carry out x, is x equal to five, this logical expression will evaluate to true. That means one. That means it is nonzero. If I had written x less than five, then it would have resulted in false. It would be zero. Now, suppose I simply do something different. I write in this decision box, I'm coming like this, and inside the decision box, I write and x was six. Say I do not write a logical expression. Here I write an arithmetic expression x. Or let me x was five, I carry out some expression, x plus five. What will the result of this expression be? It will be ten. That is, it is nonzero. Then also it will be taken as true. Although we do not need it all the time, you need not bother about it. But in general, a decision can be made on any expression. Typically and most conveniently, we will be using logical expressions. But if I carry out an arithmetic expression, something like a times b plus c minus d, then also this will give me a value. And this value, if zero means it is false and not zero, then it will be taken as true. Nonzero will be taken as true. However, this is just a matter of detail. You need not get too much bothered about it. Right now, we will try to keep as much as possible relational expressions or logical expressions inside this test blocks. So here, if grade is greater than equal to 60, print past ten. That means this is the equivalent of this structure that we have shown here, this flowchart can be simply written as this statement. I think all of you will be able to read it. Now, if has been given in a different color because this is what we have introduced here. This if is the use of if the selection structure followed by a condition. If the condition is true, then this statement will be executed. If the condition is false, then this statement will not be executed. Will bypass this statement. Now, please remember this. When I write if some condition sum statements, these statements will be executed. Only if this condition is true, I write it in a different way. Now, say, for example, I have got a number of statements. Some statements are there. And then here there is an if statement. If condition, then some statements. Here, maybe more than one statements are in a brace. Now, if the condition and after that there are other statements. Now, if the condition is true, then only these statements will be executed. Let's name these statements to be a. Then this block a will be executed. This block will be executed. If this condition is false, then this block a will be bypassed and on false, I'll come here and come to say this block b. So if the condition is false, then the block b will be executed. If the condition is true, then this block a will be executed. All right, now suppose. Let me explain it in a little different way. I am drawing another diagram now. Here is some block of statements. Let's call the block of statements to be a. And then I have one statement. If condition. Whatever the condition is, then within parenthesis, there is a block of statements b, and then there is a block of statements c. So the flow of sequence, I mean the flow will be that first a will be executed. Then if the condition is true, then if the condition is true, then b will be executed. After that, what will happen after that again will come here and C will be executed. Now, if the condition were false, condition was false, I would have computed a. After that, what would have computed condition would be checked. B will not be evaluated, not be executed, because condition is false. After that, c will be executed. So please note that in this structure, I am executing c either way. Now, the choice of whether b is being done or not is dependent on the condition. Okay, so this gives you an idea of. You see here. If the condition is false, then also this part will be executed. Okay, so here we'll conclude today with this example. Small example program. Let's try to understand each line of them. We start with include stdio h. I hope you have not forgotten that any c program must have a main program. Main function. And here is the main function. Inside the body of the main function. What is being done? I have declared. What is being done here? I have declared three variables, a, b and c. Then what am I doing here? Observe this line. Scanf percentage d, percentage d, percentage d, and a and b and c. So I'm reading three variables, abc. Okay, now what am I doing here? I am evaluating an if condition. If a is greater than equal to b and a is greater than c. So you understand that if a is a number, b is a number, c is a number, a is greater than b, and a is also greater than c. That means a is the largest number. So then I print this. I print this only if this condition is true. Otherwise I'll do something else. Now, suppose a is greater than b. Suppose a is 20, b is ten and c is five. So this one will be true. Then the largest number is a that we printed. Next statement will come to is another if statement. What is being done here? If b is greater than equal to a and b is greater than equal to c, b is not greater than equal to a. Therefore, this does not evaluate to be true. Therefore this statement does not execute. Okay, next I come to this statement. I am flowing this, I am following this flow, but only branch that I took is, if this condition was true, then I printed this in this particular case of data. In this case of data, for some other case, it will be different. Now, if c is greater than a, not true. So this is false. This will not be executed. So the only thing that will be printed is the largest number is a. Now, if for example, a was ten, b was 20 and c was five, then what would have happened? Let's see here. A is greater than equal to b. I try to test this, fail. So this will not be executed. So I come here, right? And then I test this. B is greater than a, right? And b is greater than c. That's also right. So this condition passes. So then I execute this, I print larger number is b. I print that, and then I come to the next statement. What happens in this statement? C is greater than equal to a. No, false. So the only thing that is printed is the largest number is b. All right, so we stop here. We'll continue our explanations in the next lecture. Farther, we'll have, we'll need to discuss it and also try it a little bit more. Because from this point onwards, our logic and logical constructs have started becoming just a little more complicated. But it's very interesting and it's very easy to understand if you just try to think about it logically. Thank you very much.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Use of Pointer in Function Context Bubble Sort.mp3,"So we were discussing about bubble sort and we had looked at some notion of pointers. So we have now got the preliminary idea about pointers. Now let us on this segment we have seen this part of the code. All right, this part of the code we have seen, this part we have seen. Right, this side there's the bubble sort function. On this side we have got a function which is swapping two variables. All right, I want to swap x and y. So this swap function is taking x and y. So we have seen earlier, ah, that in the normal case, if we, if we swap in a function, suppose I have got a void swap x, y. Then we had shown, and we used another variable, int temp. This was also int. This was also int, right? So we had seen that whatever swapping I am doing here, that is not being reflected in the main function that we saw. Now what we are doing here, let's see here. I am writing void swap. Instead of writing x and y, I am writing int star x comma int star. Sorry, this should have space here, although not necessary. But int star y, that means what, what I am passing here is my swap function. Here is my swap function, and it has got two input parameters. A function has got always one output. There can be a number of input parameters. Earlier it was x and y. So some variables, x and y were having the actual parameters being copied into them. But now I have not used x and y. Instead I am using pointer to x and pointer to y. So what is being sent here now is, let me do it afresh, it's faster. Void swap, instar x int star y. And that means now I am in my main function. Here is my main function, or the calling function, not necessarily the main function. In this case it was called from bubble sort. So the calling function, I should not say main, it should be the calling function. The calling function has got two variables, x and y. Now when I am calling this function, void swap, it is here, void swap, it's already written here. So I am actually having the function here, the swap function. I am not passing the values of x and y. To be more natural, let's make this actual parameters are a and b, a and b. So somehow I am calling here swap in my calling function, I am calling swap a comma b. If I had done this, then this value of a and the value of b would have been copied there. But instead, what I am doing now, I'll not write this. Instead I'll write in star a and instar b. So I can say here I am passing star a, comma star b. That means what? I am passing the pointers. I'll do it again. Let's look at this. Say here I am passing the address. So again, let me do it in a nicer way. So here is the calling function, and the calling function has got the variables a and b. And inside the calling function I am saying swap. What should I pass on? Instead of saying a and b, I am saying and a comma and b. And you know what is and a and b? And a means the address of a and b means address of b. Right? So I am actually passing the addresses of a and b. So the address of a was say thousand. And this was maybe thousand, 502 addresses. Now, here is my called function void swap int. Now, a and b have been declared int star x, comma int star y. So what is happening? Whatever I am doing here, what is being passed here? And a is being passed and here and b is being passed. That means this address and this address are being passed. Thousand and 1500 are being passed. And also I know here that what I am getting are the pointers to the variables that are to be swapped. It was not int x or int to I. Let's go back to this once again. So here you see I am calling xj and xj plus one in my bubble sort algorithm. In my bubble sort algorithm, I had the array and j was here. And j plus one was here. This was already failed something. And I am comparing. So here is my I. So I'll work in this zone and I'm looking at two elements, j and j plus one. And I want to swap them. So what I am doing is I am passing on the address of this here. So suppose this address was thousand and this address was 1002. So this is being passed here. So this is thousand. And this is what is happening here. Temp is a local variable. See, temp is not a pointer. Temp is a local variable. Suppose here the point was this was 50 and this was two. So temp is getting the content of x, right? So thousands, content, thousands. Content was 50, content of the pointer content of x. All right, so the 50 is being copied here. And then what is happening? Content of y is coming to content of x. So content of y is coming to content of x. So this is becoming two. This is being swapped and it's becoming two. And temp is coming as the content of y. So this is becoming 50. So what is happening? All the changes were reflected here in the main body of the data. All right, so that is how we could really reflect the change onto the calling function. So stated in another way, it would be like this, that say I have got a data here and here is my calling function, and here is my called function. Now there is some variable that is being used by the calling function, say a. That means this a is somewhere here. This a has been referred here. So let me, it's not proper to show it here again. Now the calling function is using the variable a somewhere here. All right. So when this variable is being used as a parameter to this called function, instead of sending the variable, say some other function, I call and in that I pass on the address of that variable a. So that address, whatever this address is, this is thousand that is being passed on to this called function. So the call function on the other hand, knows that its input parameter is, say call function is f is int. What I am getting is int star x. That means what I'm accepting that the call function is accepting is nothing but a pointer to an integer variable. Now, so the pointer to the integer variables 1000 comes up. And here, suppose it does something with the content. Now here, when I take this, say star x, that means x is a pointer. X is a pointer to an integer. And when I take star x aesthetics x, that means is the content of this. And suppose I do it, star x plus one, that means the content of this address, same address, x was 1000 and the content of that thousand is being added. So here it was 50. So that is being added where it's being added here. So this is becoming changing to 51. So this, if you recall, we had talked about two things when the functions are called. We said that usually c always calls by value, except for the case of arrays. But here is an example where I can also say this has been called by value of the pointer. So in this case it is an example call by value of the pointer. That means what I have copied is only the pointer. Therefore, the change that is being reflected is being reflected in the main program. So in that way there is also a call by reference. So in that way we can reflect the change of the function. So if you ever face the crisis that, well, I am writing a function, but I know a function can only return one value, but I have got multiple values to return. This is a nice way in which you can do it. Okay, so this is, this, we have a new concept. We have learned the use of pointers, the notion of pointers and how it can be used in the context of just learning another language. That's a bubble sort. Okay, so the bubble sort, once again we revise. Let's go to the next one and we'll come back. So the main program is taking a main function, is reading an array. All right, this array is being read x. I is an integer. I is an integer. Now for I zero to less than twelve, there were twelve elements here. Print the array. Then it's calling bubble sort. Sorry, when it's calling bubble sort, it's calling bubble sort. With the array being passed and the size of the array being passed here. Now we go to bubble sort. That means I go to the earlier slide. So what I had seen earlier. So there we go and call the bubble sort. And the bubble sort in turn calls the swap. Ultimately that swapping is done inside the bubble sort. And then we print the ultimate data. All right, so what will be the time complexity? We have seen the time complexity in terms of the Big O notation at times. So what is the worst case? If you think of, let's once again recaptulate, think of the algorithm that was something like this. First I had this size n. So initially the number of comparisons were one. Then worst case two. I first compare between these two, then I compare between these two. Then I compare between these two. Now depending on the comparison, I may or may not exchange. All right, may not show up, but I have to do n minus one comparisons. So first I do n minus one comparisons. And if the along with that I have done the swapping. So the first position is now filled up with the largest element. Then again I have to start from here, compare again twice, thrice. In that way I go on comparing the second time. And by now this number of comparisons is n minus two. So the second one will also be filled up with the heaviest element. And in that way I'll go on. Ultimately, last time is one. So the overall, if I add them, the number of comparisons is this and that is of the order of n square because it breaks down to n square minus n, et cetera. Right. And what is the best case? What will be the best case? Best case is if you don't have to do any swap, it's already sorted, but still you do not know that it is sorted. You'll have to compare them anyway and therefore the best case will be the same. All right, best case will be the same. Can we make the best case with n minus one comparisons? Only that we can think of later. But now with this, let's move to. So all these searching and sortings we are doing was using arrays. Now just a word of caution about some common pitfalls with arrays in C is that often we can exceed the array bound without really noting of that. For example, array size has been declared to be ten. That means my indices are from zero to nine, right? So if I write a for loop like this, then it will, and I try to initialize it. So it will initialize to 10, then one, then two, then three, till it is less than equal to ten. So the 10th element is here that will also be put to zero, but that may be destroying some other memory location. Therefore, that check is not there and c does not support array declarations with very variable expressions. So quickly. If we summarize, what we learned here is we are not talking about this in this course, but what we have learned here is searching. We have seen and we have seen two very efficient methods of searching. One is the linear search is simple. Another better method is binary search. But binary search is effective when the array is already sorted. We have learnt about how to sort an array. We have particularly looked at two sorting algorithms. One is selection sort. Another is the bubble sort. And while discussing about bubble sort, we have also looked at very interesting way of communicating between a function and a caller function and the called function. When I have to communicate or pass on return more than one variable to the calling function, there we are using the pointers. So we introduced the concept of pointers. Pointers are nothing but the addresses of the variables. So instead of passing on the value, I am passing on the address, and whatever I am doing, I am doing on the address. Okay, so that is another important thing that we have covered in this lecture. Next, I think we will go to some other concepts of arrays itself. Now just to mention that there are two different, two more here. We have seen that the complexity of these algorithms are of order of n squared, both for selection sort and for bubble sort. But can we have it better? We have got two very nice sorting algorithms. One is known as the quicksort, another is known as the mud sort. Okay, quicksort and march sort, which reduces the complexity of sorting and are very popular algorithms. But we are not discussing it in this course. For those of you interested can learn it later. Next, we'll be moving in the next lecture to discuss about how arrays can handle, I mean, strings can be handled as arrays. That we'll do in a separate lecture. So up to this for now and we'll continue in the next lecture. Bye.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
user defined lists.mp3,"You. So now that we have seen the basics about how to define classes and objects, let's define an interesting data structure. Suppose we want to implement our own version of a list. So a list is basically a sequence of nodes, and each node in the sequence stores a value and points to the next node. So in order to go through the list, we have to start at the beginning and walk following these pointers till we reach the last pointer, which points to nothing. So if we have a list of the form v one, v two, v three, v four in Python notation, then this is how we would imagine it is actually represented. There are four nodes. The list l itself, which we have set up, points to the first node in the list. V one points to v two, v two points to v three, and v three points to v four. The final node points to nothing, and that indicates we have reached the end of the list. So in this representation, what would the empty list look like? Well, it's natural to assume that the empty list will consist of a single node which has both the value and the next node pointer set to none. Whereas for instance, a singleton would be a single node in which we have the value v one and the next set to none. So this is the convention that we shall follow for our representation of a list. So notice that unless we have an empty list with a single node, none, none, no other node in a list can have value none. So this is something that we will implicitly assume and use that checking for the value none will tell us it's an empty list and we will never find a none in the middle of the list. So we distinguish between a singleton and an empty list purely based on the value. Both of them consist of a single node. Now the reason that we have to do this is because actually Python doesn't allow us to create an empty list if we say something like l is equal to none, and we want this to denote the empty list. The problem is that none doesn't have a type as far as Python's value system concerned. So once we have none, we can't apply the object functions we are going to create for this list type. So we need to create something which is empty of the correct type. So we need to create at least one node, and that's why we need to use this kind of a representation in order to denote an empty list. So here is the basic class that we are going to use. So it's a class node. So inside each node we have two attributes, value and next, as we said, and remember that self is always used with every function to denote the object under consideration. We will use this default scheme that if we don't say anything, we create an empty list. So the init value, so this should be in it value. So the initial value is by default none, unless I provide you an initial value, in which case you create a list with that value. And because of our assumption about empty list, all we need to do to check whether a list is empty is to check whether the value at the initial node is none or not. So we just take the list we are pointing to and look at the very first value, which will be self dot value, and ask whether it's none. If it is none, it's empty. If it's not none, it's not empty. So here is a typical thing. So we say l one is equal to node. This creates an empty list because it's not provided any value. So the default initial value is going to be none. If I say l two is equal to node five, this will create a node with the value five. So it'll create the singleton list that we would normally write in Python like this. So if I ask whether l one is empty, the answer will be true. If I ask whether l two is empty, the answer will be false because self dot value is not. Now, now once we have a list, what we would like to do is manipulate it. So the first thing that we might want to do is add a value at the end of the list. So if the list is already empty, then we have a single node which has value none, and we want to make it a singleton node, a singleton list with value v. So we want to go from this to this. So remember that in a singleton node we just have, instead of none, we have the value b over here. So that's all we need to do. We need to just replace the none by b. If we are at the last element of the list, and we know that we are at the last element of the list because the next value is none, then what we need to do is create a new value. So we walk to the end of the list, right, and then we reach none. So now we create a new element here with the value v and we make this element point to it. So we create a new element, the node v, and set the next field of the last node to point to the new node. And if this is not the last value, then, well, we can just recursively say to the rest of the list. Treat this as a new list starting at the next element. Take the next element and recursively append b to that. So this gives us a very simple recursive definition of append. So we take append and we want to append b to this list. So if it is empty, then we just set the value to b. So this just converts the single node with value none to the single node with value b. Otherwise, if we are at the last node that is self dot next is none, then we create a new node with the value v, and we set our next pointer to create new node. Remember, when we create a new node, the new node automatically is created by our init function with the next none. So we would now create a new node which looks like v and none, and we will set our next pointer to point to it. And the final thing is that if it is not none, then we have something else after us. So we go to that next element self dot next, and with respect to that next element, we reapply the append function with the value b. So this is the recursive call. So we have been abundantly careful in making sure that this is parsable. So we have put this bracket saying that we take the object self dot next and apply append to that. Actually Python will do this correctly, so we need not actually put the bracket, so we can just write self next append b. And Python will correctly bracket this as self next append. So this dot is taken from the right. Now, instead of recursively going to the end of the list, we can also scan the end of the list till the end iteratively. So we can write a loop which keeps traversing these pointers until we reach a node whose next is none. So if the list is empty as before, we replace the value none by v. Otherwise we scan the list till we reach the last element. And then once we reach the last element, as in the earlier case, we create a new node and make the last element point to it. So this gives us an append which is iterative. So we call it append, ie, just to indicate that it's iterative. So the first part is the same. If the current list is empty, then we just set the value to be b and we return. Otherwise we now want to walk down the list. So we set up a temporary pointer to point to the current node that we are at, and so long as the next is none, we keep shifting temp to the next value. So we just write a loop which says while temp next is not none, just keep going from temp to temp next. So just keep shifting temp. Finally, when we come out of this loop at this point, we know that temp next is none. So this is the condition under which we exit the loop. So we have reached the node. Temp is now pointing to the last node in the current list. At this point, we do exactly what we did in the recursive case. We create a new node with the value v, and we make this last node point to this new node. So we reset next of temp from none to the new node. So what if we don't want to append, but we want to insert? Now, it looks normally that insert should be easier than append, but actually insert is a bit tricky. So, by insert, we mean that we want to put a value at the beginning. So we want to put a node here which has v and make this point here. So this is what we want to do. Now, the problem with this really is that after we create a new node, we cannot make this point here and this point here. There's no problem in making the new node point to b one. But if we reassign the value of l or inside an object, if we reassign the value of self, then this creates a completely different object. So, we saw this when we were looking at how parameters are passed and mutable values are passed. We said that if we pass a mutable value to a function, so long as we don't reassign that thing, any mutation inside the function will be reflected outside the function. But if we reassign to the function, to the list or dictionary inside the function, we get a new copy, and then after that, any change we make is off. So, same way, if we reassign l or self to point to a new node, then we will lose the connection between the parameter we pass to the function and the parameter we get back. So we must be careful not to make l point to this thing. So we cannot change where l points to. So how do we get around this problem? We have created a new node. We want to make l point to it, but we are not allowed to do so, because if we do so, then python will disconnect the new l from the old l. So there is a very simple trick. What we do is we don't change the identity of the node. We change what it contains. So we know now that v one is the old first node and v is the new first node. But we can't make l point to the new first node, so we exchange the values. So what we do is we replace v one by v and v by v one. So now the values are swapped and we also have to do a similar thing for what is pointing where. So l is now pointing to v as the first node. But now we have bypassed v one, which is a mistake. So we must now make the first node point to the new node and the new node point to the old second node. So by doing this kind of plumbing, what we have ensured is that the new list looks like we have inserted a v before the v one, but actually we have inserted a new node in between v and v two. And we have just changed the links to make it appear as though the new node is second and not first. So here is the code for insert. So as usual, if you have an empty list, insert is easy, we just have to change none to v. So insert and append both behave the same way with an empty list. We go from the empty list to the list v. Doesn't matter whether you're inserting or appending otherwise. We create this new node and then we do this swapping of values between the current node that self is pointing to, that is the head of the list and the new node. So we exchange the values, we set self dot value to new node value and simultaneously new node value to self dot value using this python simultaneous assignment. And similarly we take self dot next, which is pointing to the next node, and make it point to the new node. And the new node instead should point to what we were pointing to earlier. So new node next is self dot next. So this is how we insert. And insert, as we saw, is a little bit more complicated than append because of having to handle the initial way in which l points to the list or self points to the list. What if we want to delete a node? So how do we specify to delete a node? Well, we specify it by value, but let's just suppose you want to delete, say the second node in this list. Now how would we delete it? Well, again, just as we did insert, we would do some replumping or reconnection. So we take the node that we want to delete and we just make the link that points to v two, bypass it. So we take the link from v one and make it directly point to v three. So in essence, all the delete requires us to do is to reassign the pointer from before the deleted node to the pointer after the deleted node. It actually does not physically remove that object from memory, but it just makes it inaccessible from the link array. So we provide a value v and we want to remove the first occurrence of v. So we scan the list for the first v. Now notice that in this plumbing procedure we need to be at v one in order to make it point to v three. So if we want to delete the next node, then we are in good shape because we can take the next dot next and assign it to the current next. So we should look one step ahead. If we are already at v two, then we have gone past v one and we can't go back to v one easily the way we have set up our list, because it only goes forwards. We can't go back to v one and change it. So what we will actually do, do is we will scan by looking at the next value. So if the self dot next value is v, that is the next node is to be deleted. Then we bypass it by saying the current nodes next is not the next node that we had, but the next nodes next. So self dot next is reassigned to self dot next bypass the next node. So as before, like with insert, the only thing we have to be careful about is if we have to delete actually the first value in the list. So if we want to delete the first value in the list exactly like we had with insert, the natural thing would be to now say that l should point to the second value in the list, but we cannot point l there because if we reassign the node that l points to, then it'll create a new object and it'll break the connection between the parameter we pass and the thing we get back. So we use the same trick. What we do is we copy v two, the value v two from the next node. So we just copy this value from here to here, and then we delete v two. So we wanted to delete the first node. We are not allowed to delete the first node because we can't change what l points to. So instead we take the value in the second node, which was v two, copy it here, and then pretend we deleted v two by making the first node point to the third node. So here is a part of the delete function. So first of all, if we were looking for v, right? And then we don't find it. Sorry. In this code it's called x. So this is deleting value x if you want. If we say that the list is empty, then obviously we can't delete it, because delete says if there is a value of a node with value x, then delete it. So if it is empty, we do nothing. Otherwise, if the self dot value is x. The first node is to be deleted. Then if there's only one node, then we are going from x to empty. This is easy, right? So if there is no next node, if we have only a singleton, then we just set the value to pin none and we are done. So this is the easy case. But if it is not the first node, I mean, it is the first node and this is not also the only node in the list, then what we do is we do what we said before, we copy the next value. We pretend that we are deleting the second node. So we copy the second value into the first value and we delete the next node by bypassing. So this is that bypass. So this is part of the function, this is the tricky part, which is how do you delete the first value if it is only one value, make it none. If not, bypass the second node by copying the second node to the first node. And if this is not the case, then we just walk down and find the first x to delete. So we start as this is like our iterative append, we start pointing to cell and so long as we have not reached the end of the list, if we find the next value is x, then we bypass it, right? And if we reach the end of the list and we haven't found it, we do nothing, we just have to return. In this case it's not like append, where when we reach the end of the list, we have to append here. If we don't find an x by the time we reach the end of the list, then there's nothing to be done. So just for completeness, here is the full function. So this was the first slide we saw, which is the case on the value to be deleted in the first node. And this is the second case when we walk down the list looking for the first x to delete. So just like append can be done both iteratively and recursively, we can also delete recursively, which is if it is the first node, we handle it as a special way by moving the second value to the first and bypassing it as we did before. Otherwise we just point to the next node and ask the next node, the list starting at the next node, what is normally called the tail of the list to delete v from itself. So the only thing that we have to remember in this is that if we reach the end of the list and we delete the last element. So supposing it turns out the value v to be deleted is here. So we come here and then we delete it. What we'll end up with is finding a value none being because when we delete it from here, it's as though we take a singleton element v and delete v from a singleton and we'll create none num. So this is the base case, right? So if we are recursively deleting as we go, whenever we delete from the last node, it's as though we are deleting from a singleton list with value v and we are not allowed to create a value none at the end. So we have to just be checked when we create the next thing. If we delete the next value and its value becomes none, then we should remove that item from the list. So this is the only tricky thing that when we do a recursive delete, we have to be careful. After we delete, we have to check what has happened. So this part is the earlier part, and now this is the recursive part. The recursive part is fairly straightforward. So this is the first part is when you delete the first element from a list. For the recursive part, we check if self dot next is equal to none, then we delete recursively. That's fine. So this is a delete call. Now, after the delete is completed, we check whether the next value has actually become none. Have we actually ended up at the last node and deleted the last node? If so, then we remove it. So this we can either write self dot next is equal to self dot next, or we could even just write self dot next is equal to none, which is probably a cleaner way of saying this, because it can only happen at the last node. So we make this node the last node. Remember, if the next node is none, its next nodes also be none. So this has the same effect, self next must be none. So we can also directly assign self dot next equal to none, and it would basically make this node the last node. So the only thing that to remember about recursive delete is when we reach the end of the list and we have deleted this list, this becomes none. Then we should terminate the list here and remove this node from. Finally, let's write a function to print out a list so that we can keep track of what's going on. So we will print out a list by just constructing a python list out of it and then using str on the python list. So we want to create a python list from the values in our list. So we first initialize our list that we are going to produce for the empty list. If our list, the node itself has nothing, then we return the string value of the empty list. Otherwise we walk down the list and we keep adding each value using the append function, right? So we keep appending each value that we have stored in each node, building up a python list in this process. And finally we return whatever is a string value of that list. So let's look at some python code and see how this actually works. So here we have code which exactly reflects what we did in the slides. We have chosen to use the recursive versions for both append and delete. So we start with this initial initialization, which sets the initial value to be none by default or otherwise. V as the argument provided then is empty just checks whether self dot value is none. We had written more compact form in the slide by saying just return self dot value equal to equal to none. But we have expanded it out as an if statement here. Now this is the append function. So append just checks if the current node is empty, then it puts it here, otherwise it creates a new node. If we have reached the last node, it creates a new node and makes the last node point to the new node. Otherwise it recursively appends. Then we have this insert function here. So this insert function again, if it is empty, then it just creates a singleton list. Otherwise it creates a new node and exchanges the first node and the new node, right? So this particular thing here is the place where we create this swap the pointer so that what self points to doesn't change, but rather we create a reordering of the new node and the first node. So the new node becomes the second node and the first node now has the value that we just added. And finally we can come down to the recursive delete. So the recursive deletes again says that if the list is empty, then we do nothing. Otherwise, if the first value is to be deleted, then we have to be careful and we make sure we delete the second value by actually copying the second node into the first. And finally, if that is not the case, then this we recursively delete. But then when we finish the delete, we have to delete a spurious empty node at the end of the list in case we have accidentally created it. So these two lines here just make sure that we don't leave a spurious empty node at the end of the list. And finally we have this str function which creates the python list from our values and eventually returns a string representation of that list. So if we now run this by importing, then we could say, for instance, that l is a list with value zero. And if we say print l, then we will get this representation zero to l. We could for instance, put this in a loop and say for I in range one, say eleven, l dot append I. And then if we at this point print l, then we get zero to ten as before. Now we say l dot delete four for instance, and we print l. Then four is gone and so on. If we say l dot insert twelve and print l, then twelve at the beginning. So you can check that this works. Notice that we are getting this empty bracket. This is a return value. So when we wrote this return, we wrote with the empty argument, and then we get this empty tuple. You can just write a return with nothing and then it won't display this fun any return value. But what is actually important is that the internal representation of our list is correctly changing with the functions that we have written. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Variables and Memory.mp3,"In the earlier lecture, we had seen that we start with an algorithm, and we start with an algorithm and convert that algorithm into some sort of high level program, some high level program. We convert it to some high level program, and that high level program is fed to a compiler. And the compiler prepares the machine level program. Okay? Now this machine level program is fed is stored in the memory of the computer, and from this memory stored in the memory of the computer. Now, from the memory, the CPU CPU executes it and we get the desired result. So that is the overall flow of the whole thing. Right. Now we will now come back to some of the statements that we used in the earlier example programs. We'll come back to that. Say we had statements like sum is equal to sum plus number one, right? Yesterday we encountered such statements. Sum equal to sum plus number one. Now also say, for example, max assigned number two. Max assigned number. Now the question is, what are these things? Max number. All right. Or for example, if I write area is assigned 5.2. What is this area and what is this 5.2. Now this is some very fundamental concept that we'll be discussing today. These are known as the variables, and these are known as the values. Now, we must be very clear. Before we start translating or writing a program in any high level language, it is imperative to know very clearly what is a variable and what is a value. So, today's lecture will be devoted to explaining the difference between variables and values, and what is the significance of these variables. Now, let us look at this diagram. The memory can be considered to be a number of racks in a book rack sort of thing. Or you can think of a number of drawers in a chest of dryers. Essentially, these are specific places. These are specific places, as is being shown here. All right, now, each of these place is known as a memory location. All right, block pointing to the corrective. Now, here you can see that each of these locations have been marked with. Each of these locations have been marked with a particular address. So these are the addresses. All right. These are the addresses and each address of every memory location. So think of a scenario that in a locality there are a number of houses. Each of this house is a location. So this is a location. Right? Now I want to reach a particular house. That means a particular location. How can I identify where I should go? For that, we need some address. So similarly, in the case of memory, for every location, there is an address. So here we are showing 123-45-6789 actually, there are more locations which have not been shown. So we are showing n locations. N number of locations, n locations are being shown and each of these have got some address. There is a peculiarity here. The reason of that will be clear later. Let's, for the time being, accept that we are starting our journey with the number zero. So the first address is address zero. And so the nth address will be address n minus one because the second address will be address one. So the nth address will be n minus one. Now recall that we had the scenario that we had a high level program, high level program, or if you remember, we call it also the source code. And from the source code the compiler converts them into a machine code, machine language. Right now in my high level source code, I have a statement like sum equals 25, say now when I say that sum is equal to 25, the compiler will look at this and will assign these variable. Now this sum is a variable. Variable means what? It's a variable because it can be loaded with different values. A variable can have different values. For example, here I am making sum equal to 25. After a while I can make sum equal to 37. Therefore, sum is a variable and it can have different values, right? So say in a program, in a program I have got here, sum equals to 25, x equal to 56, and sum equals to sum plus x, something of that sort. So here, how many variables do we see? And how many values do we see? We find that sum is a variable and x is a variable. And these variables have been repeated here. And what are the, how many values do we see? 25 is a value, 56 is another value. Okay? Now when the compiler takes the high level program and it looks at, the compiler looks at all the variables and assigns, assigns, or allocates distinct locations to each variable. For the sake of simplicity, let's say that it assigns distinct locations to each variable. All right? Sometimes advanced compilers also share locations, but that is not our concern right now. Therefore, let's come back to the slide once again. You can see if I have a number of variables, then every variable is mapped to a particular memory address. For example here, if I write sum equals 56, x equal to 27, and y is equal to 3.5, the compiler will look at this piece of program, this piece of program, and will allocate, and we'll allocate some location to each of these variables. Maybe sum can be allocated here. X is allocated here, y is allocated here. Therefore, sum can be identified now by the computer, the cpu, when it will run the program, it can look at whenever sum appears in the program, the compiler will convert it to the corresponding address of sum. Sum has got the address three. X has got the address six, and y has got the address seven. All right? Therefore, this thing is converted to a scenario where I am actually writing 56 into address three. So as if 56 is being written here, I'll explain it later. X is being written, 27 is being written here, and 3.5 is being written here. All right? Because while the computer executes the program, it will take the data from the memory location only and the memory locations. It no longer understands whatever name you gave to this particular variable, whether it is sum or any other name, but it is identified uniquely by the address that the compiler has given it. All right? The compiler can, depending on the availability of the memory locations, allocate different addresses to different variables. Once that is done, there is a table, for example, there is a table like this, a record that is kept that you can think of, that we have got the variables here, the variable and the address. So some table of that sort is prepared. Sum is address three, x is address 27, et cetera. So, sorry, x is address five is address five, and y is address seven. Now, the CPU, whenever it, so the program in the machine language is converted in terms of these addresses. In terms of these addresses, okay, in terms of these addresses, these variables will no longer appear in the machine language. All right, so now let us look at this in a little more detail. Now, suppose, look at this instruction. There's a program. Now, one thing to mention here is typically a program consists of a sequence of instructions that we know that one instruction after another will be executed. So this is usually done in a sequence where is an exception from that sequence. We had seen in the flowcharts that whenever there is a loop, I am repeating an instruction time and again. We have seen, when we are trying to find the maximum of n numbers or average of n numbers, we are repeating some instructions time and again. In that case, we go back to the earlier instruction. Otherwise, one instruction is executed after another, right? So as time passes, we have got some instruction here not doing any meaningful computation, say, just to illustrate, x equals ten. Now, here is another point. What does this equal mean? All right, this is something that we should understand. In our school, we often do say x equal to y. That means x. The value of x is equal to the value of y. So if x is five, then y is five, right? But here, this symbol, whenever we are using now is, this symbol actually means assignment. Now, this is something which you should understand, and this is fundamental to any programming language that we use. When I write x here, I am writing x, this symbol y. I'll read it as x is assigned y. What does it mean? X is getting the value of y. Now, so often it is. Therefore, in order to avoid this confusion, we write it in this way that the value of y is assigned to x. Now, here is something to really understand. What is x? X, is it a value? No, x is a variable. Therefore x is a memory location. The compiler has allocated some memory location with a specific address. So this x is nothing but a memory location with some distinct address. Is it readable? Memory location with some distinct address that is x. And y is also a memory location with distinct address. But this assignment means it is getting the value that is in y. So let's think of like this, that here is a memory location, that is x. So X when I'm writing x, that means that it is actually the address of X that has been address of this memory location. Okay? And Y is also a memory location. And when I am writing Y, this variable name Y, just for ease of our understanding, otherwise I would have to write the address here. And the address in a computer system, in a machine language, will be a string of binary bits, I mean bits, bit string. So that will be really complicated. So for the sake of understanding, we are just writing x and Y. But you must understand that this x or this y means the address, the address. Address of X. All right, and who has allocated the address of x or the address of Y? The compiler. Okay, now when I am doing assignment, this x is assigned the value of Y. Suppose Y had five. All right? The value was five. Now this five is then written over here, and this also becomes five. This is the meaning of assignment. It is not exactly meaning equal to y. Essentially, after this, what happened is the value of x is actually equal to the value of Y. But this sign typically means assignment. Okay? In order to show this equality, we have got other symbols. We'll come across that later. Okay, so now let us move to this. So here we are executing an instruction, one instruction after another. So here in the first instruction, we find that x has been assigned the value ten. It's not. Once again, let me come here. This is, this means x is assigned the value of y. If I write this x assigned ten, this means x has been assigned ten. That means x is assigned the value ten, because here I had some value in Y, whatever it is, and that was being transferred to x. But here it is not. This side, the right hand side, is no longer a variable, but a value right the right hand side is a value. Therefore, x is a memory location. For this example. For this example, x is a memory location which is having the value ten after execution of this instruction. This will be the situation in the memory. This will be the situation in the memory after the execution of this instruction. Right? So now here, now you'll understand as I assign ten to x, and this is the same memory location, this is the memory location for x, the same memory location. See how the picture is changing here? That memory location x is getting the value ten. On this side, I am showing the memory location allocated to the variable x. Okay, so ten. Next step, I assign 20. So this location gets 20. So this ten that was there in the same location, ten was there. Ten is being overwritten by 20 here. So when this is being executed, then this ten is being overwritten and 20 is being written. So I'm getting here 20. Now x has got 20. What is x? Now x is 20. Now I do another arithmetic operation here. How do you explain this? X assigned x plus one. Let's go back one moment to this. X was, there's x, it was 20. And I have come across an instruction which says x equal to x plus one. What does it mean? It means assign to x what? X plus one. That means after computation of this expression, whatever value you get, whatever value you get after computation of the expression will be assigned to x. So how will it be done? Right. Now, what is the value of x? 20. So the cpu will have doing some addition operation, will read this value 20 here, and some incrementation by one so that these two will be added. The value from the location x will be taken. It will be added with one or incremented with one. So here I'll be getting after addition, I'll be getting 21. Now, this assignment means whatever value you get after computation will be assigned to this. Why this? Because on the left hand side, I have got the same location x. So this will be changed to 21. Now, suppose if instead I had the situation like this, x at 20, and I write y assigned x plus one, what does it mean? It means that this y is another memory location. And what is being told over here, you take x, take the content of x, and so you will take 20 and have one added. Add them, you will get 21 and assign it to y. In that case, you see the picture, the content of the memory location. The value of the memory location x remains unchanged, and another location gets the value 21 right. Unlike the earlier case, when we had written x assigned x plus one, when I do that. Then in this case, this value will be overwritten. This 20 will be overwritten, but in this case, it is not being overwritten. It is remaining. All right, now let's go back to the slide here. So when I, therefore, you, now you understand x was 20 assigned 20. Then next step, x is assigned x plus one. So it becomes 21, the same location. X is becoming 21. Now, I am doing x assigned x multiplied by five. So again, what I'm doing, I'm again doing the same thing, x assigned x times five. So I had x and x was 21. Here I took that value, and this time, instead of adding the cpu, is doing some multiplication and with this constant value, five and is getting the value 105. Now, this 105 is again written back to x. So it is going over there and it will override this 21, and we'll write 10 five. Clear. Therefore, here we'll have the result as 10 five. I hope you have been able to understand the difference between the variables and values here and the variables, the fact that variables are nothing but memory locations. So I'll continue with this in the next class. So quickly, let's have a look at this. Say, let's see. Let's revise here another situation, another program segment. A part of the program. X is assigned 20. Y is assigned 15. Next step, Y is assigned 15. X is assigned Y plus three. Y is assigned X plus X divided by six. Now, obviously, since there are two variables in this program, there will be two memory locations assigned. Two memory locations assigned. Now, here in the first instruction, X is being assigned 20. Therefore, this location has got 20 written in it. What is there in Y? I don't know. Anything. Sorry. Anything that, anything that was earlier, from the beginning was remaining, that is there. I don't care. Next step, I am writing 15 to Y. I am assigning, sorry. I am assigning 15 to Y. Therefore, now X remains as it is 20 and Y becomes 15. Right. Now what am I doing in the third step, I am doing X assigned Y plus three, just as I had explained in the last slide just now that I'll be actually taking the content of Y. Content of Y. Whatever Y was, it was 15 or something. I take it and add something to this and store it back to X. All right, that's what I am doing. Right. So here you see? Sorry. Next. Yeah. So X assigned Y plus three. So Y was 15. So that is taken. Three is added to that. The result is 18. And where is that loaded? That is loaded into X. So it becomes 18. And what happens to Y. Y is not disturbed. Because here. At this point. At this. Sorry. At this point, Y has just been read. At this. At this point, Y has just been read. It has not been written into. Y has been just read. I read from this location. I did not disturb it. I disturbed X. So I added three and made it 18. Here what I am doing. I am now disturbing Y. How? I am reading the value of x, dividing it by six. So 18 divided by six will be three. I am writing that to Y. Therefore, now I am disturbing Y and Y has got a new value. So now my result. Now, if I had written here, print x and Y, then my result would be 18 and three. Right? So that is how the variables are handled by a program. And I tried to explain to you the difference between variables and values. So you please look at the pseudocode of the examples that we did in the last lecture and see what are the variables and what are the values. And try to draw a diagram as I have done today, just to have a clearer conception for that. So.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Variables and Variable Types in C.mp3,"So we were looking at a sample C program, and as we had discussed in the last lecture, we have a structure, as is shown here. You can see that there is a main function here, a main function is there, and that main function is covered by two parentheses. Now we can see that we start with a header file that includes stdio h, and stdio h stands for standard I o. That means whenever we'll get some instructions to carry out input or output that will be in reference to or with respect to the standard input that is a keyboard. That means the data will be taken from the keyboard, and if anything is to be printed, it will be printed on the screen. So that is a default thing for any C program we have to put in stdio h, include hash, include this is known as this read as hash, include stdio h. Unless you want to take the file, don't want to take it from the keyboard, or do not want to print on the screen. Next thing is that the main function, which, as I said in the last class, that there must be a main function, and the main function will have a place for the parameters. You can see here for the parameters here, which may or may not be empty. The third point is the structure, the overall boundary of the main function. Or for that matter, for any function, there should be a boundary specified, and that boundary is specified by these two curly brackets. Next we come to the statement, as I had said, that just like any other language, c also has got some words which are understood by the compiler. Printf is one such word, which is a statement for printing the sentence that is given within these double quotes. Okay, you can see the double quotes here. So what will it print? It will print our first look at the C program here. As is shown here, that will be printed, okay, printf within quote here, there is a quote, end quote, and here is a start quote. Our first look at the C program. In addition, there is, I'm sorry, let me go up. We can see two special symbols, which are these backslash ends. Right? Let me just clear it up here. You can see this backslash n, something of this sort. This means go to a new line or end of line. Now suppose, let's see, suppose I had something like this. I had printed something, all right, I had printed something. There's a screen. I had printed a brown fox. Now, after I printed, that means the computer printed, you can see where my pen is. My pen is lying here, right? My pen is here. Now if I say backslash n, this is no red as backslash backslash n. That means my pen will come to the beginning of the new line. And here I'll write our first c program. And by default my pen is here. But since I have given another backslash n, the pen will come here. So next time if I again start with a backslash n, it will come to the new line. And if I do not give a backslash n, it will continue from here. You will understand this more. When we look at more number of programs, it will be much more clear to you. Okay, so this is a structure of a very simple sip program. We'll see more of this. Now here is another program again. Now it is easier to understand. You have got an include stdio h, which has to be there. For any c program, there will be a main function, as is being shown here, and there are parentheses between these two. The program should be written. This is a boundary of the main function. Now here there are some more new things which are being shown to you in the form of example. So you see the first line is intabc. What is meant by that is that I'll be using in this program three variables, a, b and c, and each of them is of type integer. Now you are already acquainted with the term variables, but you are probably not acquainted with the term type of a variable. So quickly let's go to that. We have got variables, variables, and the variables can be of different type. Also, constants can be of different types, can be of different type. For example, the variables can be of type integer. For example, 717, all these things, 256, 1009. All these are integers. Another type of variable can be real numbers which are say 10.56.325 fractional numbers, right? These are real. This is also known as in C as floating point numbers. Now integers, are these reals or float floating point numbers. Are these. Similarly, I can have characters like say X-Y-P whatever. These are different characters, or maybe, and is a character, okay, so each of any of these alphanumerics and all those can be characters. Now, so we know what is an integer? What is a real, what is a floating point? What is a floating point? What is a character? Now, a variable is of type integer. What does it mean? As you know, a variable is nothing but a memory location, right? It means, and suppose this variable, I say variable a is of type integer. So there is a memory location corresponding to a. And this memory location can only hold values which are integers. So 57 I can store here. But if I try to store 57.5 here, it will not store 57.5 because it has been told to be an integer. Similarly, if I say variable b is of type floating point, in short, I am writing float. That means this variable b can store a floating point number. So 57.5 can be stored here. Even if I try to store in b, 57. In b, if I store 57, just 57, then that will be stored as 57.0. All right? Similarly, there can be types of characters. Now, depending on the type of the variable, the compiler assigns different sizes of memory for the different variables. For example, in standard C compilers, and it's a convention that for an integer, two memory locations are allocated. Now, how big this will be, say, sometimes each of these memory locations can be 16 bits. In that case I am using 216 bits. That means 32 bits to store an integer, whereas for a real number, now this is a convention. Four locations are used for storing a real number. All right, so 64 bits. 1616. 1616. So that will be for real numbers, okay? Now, so depending on what I write, how I define the type of the variable, when I say ABC, I also say what type of variable it is. Is it an integer, is it a real or what it is. Now if you come here, you will see that here I have written float and I did not write floating point number. Now in C, in order to specify a variable to be real, we declare that to be float, say P. Q. That means semicolon. That means p and q are two variables which are of type, floating point number, right? And if I write int abc, that means a, b, and c are three variables which are of type floating integer, type int. So we do not write integer, we just write in c int. Okay? Now obviously then for p, how many bytes, depending on how many bits will be given, how many memory locations will be given? For p, maybe four. Q, it will be four, but for ABC it will be only two. All right? Now let us therefore go back to the program here. Here we find int aBC. Now this statement, this is called a type declaration, all right? This is known as a type declaration, okay? This is the first statement. So I have declared the variables. Now, in C program, before a variable is used, it should be declared about its type, okay? The other thing is, you can see this. So here you can see a has been assigned ten. B has been assigned 20. That means what? That means in the memory location, a corresponding to a memory location corresponding to a, ten has been written, and to the memory location corresponding to b, 20 has been written. All right? And this statement, c assigned a plus b. I had explained in another lecture that that means this data, this value ten and this value 20 will be taken out from the left hand side. From the corresponding memory locations they will be added and the result will be 30. All right, the result will be 30 and that 30 will be written into the location C. So this will be 30. Okay, this much is clear. Now, what about this line? I know that a printf statement just tells me that I have to print whatever is there in the quote. So how will the print look like? Please note the sum of percentage d, and percentage d is percentage d. This is equivalent to writing this. The sum of dash and dash is dash. There are three gaps. One here, one here, and one here. Now, how will these gaps be filled? Filled, they will be filled by the values of a, b and c, respectively. Each of these dashes will be filled up by the respective values of ABC. Now this percentage D is a format statement. It's saying that this gap can be filled by a digit or by an integer. This gap can be filled only with an integer. Now here Ia is an integer. Therefore, this gap will be filled with the integer value ten and percentage d, and is being printed as it is because it is within this double quote. And dash. This dash will be filled with another digit. This will be filled with another digit. And what is that digit? The second space, b and b is 20. So it will be 20 is what is a plus is c. And what is the value of c? C. The value of c is 30. So this is what will be printed. All right, so this is how we print a sentence where I have got some places for different variables, and these places will be filled up by the values of the variables whose names are being specified here. I repeat, these gaps will be filled by the values of the variables whose names or whose identifiers are being specified here. And the type of this variable and the specification of this dash should match. Okay, so now it's. So it will be printed. Sum of ten and 20 is 30. Now coming to the third sample program. Now, this is a little more complicated. And this is trying to find out the largest of three numbers. That means what we had done in our flowchart exercise, finding the max of three numbers. Now that was discussed using flowcharts and pseudocode. And here we are discussing that using a program, a c program. How is that idea translated into c program? Again? Let's start with. Even before that, I'd like to point out something again. Let's revise the structure of the program. We start with a header stdio h. Now we put in a comment. What is this? We saw in the last class, it's a comment. This comment is just telling us the compiler has got nothing to do with it. It's just telling us that this program finds the largest of three numbers. Then, as usual, we have got a main function which must be there. And there should be a parenthesis which is delineating the boundary of this program. And also we have seen this. I am using three variables, a, b and c, and I have put in the type of that. The next new thing that is coming up is here, scanf. This is an input statement for reading three variables from the keyboard. Now, recall that I said that for every language there is a vocabulary. There is a set of words that the language understands. So in C, in an earlier one, we have seen, in an earlier program, we have seen the statement printf. Right? We had seen the program printf. So printf is a particular word. Now we now encounter another word. Int is also another word. Int is another word which is specific to c. And the meaning of this, every word will have a meaning. So this means that whatever follows are variable names of type integer. Whatever follows this word int are variable names of type integer. Okay, next new word that we are getting is scanf, just like we had seen printf earlier. All right, printf is a word that tells us that something is being printed here. Scanf is a word that tells that whatever is inside this parenthesis. Inside this parenthesis is an input statement. Let us study this a little bit here. Here again, you will see that there is a percentage d, percentage d, percentage three, percentage ds within quote. And you know that percentage d means it's a specifier for an integer. Some integer will be read. Scanf means, say, assume it is reading. So therefore it's something like this. I am creating as if three places, because corresponding to each percentage d, percentage d, percentage d, percentage d, within the quote, I am creating three spaces and followed by that. Let's go back to this. I'm sorry. Here. There should be no comma. All right, I'm just giving three percentage ds. So let me go back here. So it should be within the quote here is scanf, within quote, percentage d, blank, percentage d, blank percentage d. And the quote is closed, comma. That means, as if just to understand, I am creating three spaces, each of which are ready to accept an integer. And where will those be stored? Here I am writing. And a and B, and C. Now here, I'll request you to just forget about this ampere sand sign. Forget about this for the time being. This, we'll explain a little later. Just assume that a, b, and c. But before that, for any read statement, we'll have to put an ampere sand before the variable names. There is a reason for that. What is the meaning of this sentence? The meaning of this sentence is that there are three places which are ready to hold three variables which will come to the locations. ABC. When I am reading as if I am reading from the user, three variables. Abc. Okay, now why I put that ampere stand, we'll explain a little later. So, three spaces have been created. And what are these spaces? These spaces are nothing but these three memory locations which three memory locations whose names have been specified here. All right, so this is something that you have to be a little careful and practice a little bit. It will be very easy later on. So within the quote, I specify the format specifier that it is integer, in this case, percentage d. And these are the variable names. All right, now let's go back to anything that is new here. Now, a new word we are encountering here. If is a conditional statement. You need not bother about it. If you recall, in the flowchart, we had a thing called diamond, right? Where we are taking some decisions based on some conditions. Yes and no. Right, we are doing that here. We are looking at some condition here. If a is greater than b and a is also greater than c. If that is yes, then I am printing that a is the largest number. Try to apply simple logic here. If is a conditional word. Condition is a conditional word. And this entire statement, starting from if to this semicolon, is one statement, and where I check the condition whether a is greater than b and a is greater than c. If that is so, that is if the diamond comes out with that yes, then I am printing that the largest number is a. Otherwise, that means if the answer to this is no, otherwise I am again checking again. If again I am checking another condition. I am checking another condition here. What am I checking? Is b greater than c? Yes. If yes, then I am printing the largest number is b. Otherwise, this is yes. Otherwise, if it is no, then I am printing the largest number is c. So we are encountering some new words. If and else, if means if in the result of this diamond box is yes, then this statement will be executed. Otherwise, that means if the answer to this diamond box is no, then this part will be executed. This part will be executed. Now, here again, the second block I am checking if b is greater than c. Again, if this is true for this condition, this will be executed when this condition is true. Or yes, if it is false, then this statement will be executed. So it is a little more complicated program, but a very useful example. All right, so we see there are comments we have already mentioned. Now we are coming to another program. This is using what we earlier had said, that a big machine can be divided into submachines. So a big program, this one is not a big program, but any program can be broken down into different functions. Here is the main function. This one is main. Let me draw it a little nicely. Here we have got a main function, and inside there is another function whose name is my function. I'm sorry. All right, now let's look at this. Now, first here there is another new thing we are introducing and that you should understand. That is, define PI to be. Define PI to be 3.1,415,926. That means this, wherever in this program this PI will appear, there we will replace it with this value, 3.1,415,926. But inside the program, I'll not write PI, I'm just defining it once for all. And this means I'm replacing PI by this value. You, before the compilation is done. Okay, so this is again a preprocessor statement. We'll continue with this example in the next lecture. Bye.",,,,,,,,,,,,,,,,,,,,,,,,,,,,
